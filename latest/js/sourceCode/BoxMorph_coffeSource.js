// Generated by CoffeeScript 1.7.1
window.BoxMorph_coffeSource = '# BoxMorph ////////////////////////////////////////////////////////////\n\n# I can have an optionally rounded border\n\nclass BoxMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  cornerRadius: null\n\n  constructor: (@cornerRadius = 4) ->\n    super()\n\n  isTransparentAt: (aPoint) ->\n    # first quickly check if the point is even\n    # within the bounding box\n    if !@boundsContainPoint aPoint\n      return true\n \n    thisMorphPosition = @position()\n    radius = Math.max @cornerRadius, 0\n \n    relativePoint = new Point aPoint.x - thisMorphPosition.x, aPoint.y - thisMorphPosition.y\n\n    # top left corner\n    if relativePoint.x < radius and relativePoint.y < radius\n      if relativePoint.distanceTo(new Point radius,radius) > radius\n        return true\n\n    # top right corner\n    else if relativePoint.x > @width() - radius and relativePoint.y < radius\n      if relativePoint.distanceTo(new Point @width() - radius,radius) > radius\n        return true\n\n    # bottom left corner\n    else if relativePoint.x < radius and relativePoint.y > @height() - radius\n      if relativePoint.distanceTo(new Point radius, @height() - radius) > radius\n        return true\n\n    # bottom right corner\n    else if relativePoint.x > @width() - radius and relativePoint.y > @height() - radius\n      if relativePoint.distanceTo(new Point @width() - radius, @height() - radius) > radius\n        return true\n\n\n    return false\n  \n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle) ->\n\n    if @preliminaryCheckNothingToDraw false, clippingRectangle, aContext\n      return\n\n    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return null\n\n      aContext.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      aContext.clipToRectangle al,at,w,h\n\n      aContext.globalAlpha = @alpha\n\n      aContext.scale pixelRatio, pixelRatio\n      morphPosition = @position()\n      aContext.translate morphPosition.x, morphPosition.y\n      aContext.fillStyle = @color.toString()\n      \n      aContext.beginPath()\n      @outlinePath aContext, Math.max @cornerRadius, 0\n      aContext.closePath()\n      aContext.fill()\n\n      aContext.restore()\n\n      # paintHighlight is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio (i.e. after the restore)\n      @paintHighlight aContext, al, at, w, h\n\n  \n  outlinePath: (context, radius) ->\n    offset = radius\n    w = @width()\n    h = @height()\n    # top left:\n    context.arc offset, offset, radius, degreesToRadians(-180), degreesToRadians(-90), false\n    # top right:\n    context.arc w - offset, offset, radius, degreesToRadians(-90), degreesToRadians(-0), false\n    # bottom right:\n    context.arc w - offset, h - offset, radius, degreesToRadians(0), degreesToRadians(90), false\n    # bottom left:\n    context.arc offset, h - offset, radius, degreesToRadians(90), degreesToRadians(180), false\n\n  cornerRadiusPopout: (menuItem)->\n    @prompt menuItem.parent.title + "\\ncorner\\nradius:",\n      @,\n      "setCornerRadius",\n      @cornerRadius.toString(),\n      null,\n      0,\n      100,\n      true\n\n  insetPosition: ->\n    return @position().add(@cornerRadius - Math.round(@cornerRadius/Math.sqrt(2)))\n\n  insetSpaceExtent: ->\n    return @extent().subtract(2*(@cornerRadius - Math.round(@cornerRadius/Math.sqrt(2))))\n\n  extentBasedOnInsetExtent: (insetMorph) ->\n    return insetMorph.extent().add(2*(@cornerRadius - Math.round(@cornerRadius/Math.sqrt(2))))\n\n  # there is another method almost equal to this\n  # todo refactor\n  choiceOfMorphToBePicked: (ignored, morphPickingUp) ->\n    # this is what happens when "each" is\n    # selected: we attach the selected morph\n    debugger\n    morphPickingUp.addInset @\n    if @ instanceof ScrollFrameMorph\n      @adjustContentsBounds()\n      @adjustScrollBars()\n  \n  # there is another method almost equal to this\n  # todo refactor\n  pickInset: ->\n    choices = world.plausibleTargetAndDestinationMorphs @\n\n    # my direct parent might be in the\n    # options which is silly, leave that one out\n    choicesExcludingParent = []\n    choices.forEach (each) =>\n      if each != @parent\n        choicesExcludingParent.push each\n\n    if choicesExcludingParent.length > 0\n      menu = new MenuMorph false, @, true, true, "choose Morph to put as inset:"\n      choicesExcludingParent.forEach (each) =>\n        menu.addItem each.toString().slice(0, 50), true, each, "choiceOfMorphToBePicked"\n    else\n      # the ideal would be to not show the\n      # "attach" menu entry at all but for the\n      # time being it\'s quite costly to\n      # find the eligible morphs to attach\n      # to, so for now let\'s just calculate\n      # this list if the user invokes the\n      # command, and if there are no good\n      # morphs then show some kind of message.\n      menu = new MenuMorph false, @, true, true, "no morphs to pick"\n    menu.popUpAtHand @firstContainerMenu()\n\n\n  # BoxMorph menus:\n  developersMenu: ->\n    menu = super()\n    menu.addLine()\n\n    menu.addItem "corner radius...", true, @, "cornerRadiusPopout", "set the corner\'s\\nradius"\n    menu.addItem "pick inset...", true, @, "pickInset", "put a morph as inset"\n    menu\n  \n  \n  setCornerRadius: (radiusOrMorphGivingRadius, morphGivingRadius) ->\n    if morphGivingRadius?.getValue?\n      radius = morphGivingRadius.getValue()\n    else\n      radius = radiusOrMorphGivingRadius\n\n    # for context menu demo purposes\n    if typeof radius is "number"\n      @cornerRadius = Math.max radius, 0\n    else\n      newRadius = parseFloat radius\n      if !isNaN newRadius\n        @cornerRadius = Math.max newRadius, 0\n    @layoutInset()\n    @changed()\n  \n  colorSetters: ->\n    # for context menu demo purposes\n    ["color"]\n  \n  numericalSetters: ->\n    # for context menu demo purposes\n    list = super()\n    list.push "setCornerRadius"\n    list\n';
