// Generated by CoffeeScript 1.7.1
window.CircleBoxMorph_coffeSource = '# CircleBoxMorph //////////////////////////////////////////////////////\n\n# I can be used for sliders\n\nclass CircleBoxMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  orientation: null\n  autoOrient: true\n\n  constructor: (@orientation = "vertical") ->\n    super()\n    @silentRawSetExtent new Point 20, 100\n\n  \n  autoOrientation: ->\n    if @height() > @width()\n      @orientation = "vertical"\n    else\n      @orientation = "horizontal"\n\n\n  calculateKeyPoints: ->\n    @autoOrientation()  if @autoOrient\n    if @orientation is "vertical"\n      radius = @width() / 2\n      x = @center().x\n      center1 = new Point(x, @top() + radius).round()\n      center2 = new Point(x, @bottom() - radius).round()\n      rect = @topLeft().add(\n        new Point(0, radius)).corner(@bottomRight().subtract(new Point(0, radius)))\n    else\n      radius = @height() / 2\n      y = @center().y\n      center1 = new Point(@left() + radius, y).round()\n      center2 = new Point(@right() - radius, y).round()\n      rect = @topLeft().add(\n        new Point(radius, 0)).corner(@bottomRight().subtract(new Point(radius, 0)))\n    return [radius,center1,center2,rect]\n\n  isTransparentAt: (aPoint) ->\n    # first quickly check if the point is even\n    # within the bounding box\n    if !@boundsContainPoint aPoint\n      return true\n\n    [radius,center1,center2,rect] = @calculateKeyPoints()\n\n    if center1.distanceTo(aPoint) < radius or\n    center2.distanceTo(aPoint) < radius or\n    rect.containsPoint aPoint\n      return false\n\n    return true\n  \n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle) ->\n\n    if @preliminaryCheckNothingToDraw false, clippingRectangle, aContext\n      return\n\n    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return null\n\n      aContext.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      aContext.clipToRectangle al,at,w,h\n\n      aContext.globalAlpha = @alpha\n\n      aContext.scale pixelRatio, pixelRatio\n      morphPosition = @position()\n      aContext.translate morphPosition.x, morphPosition.y\n\n      [radius,center1,center2,rect] = @calculateKeyPoints()\n\n      # the centers of two circles\n      points = [center1.toLocalCoordinatesOf(@), center2.toLocalCoordinatesOf(@)]\n\n      aContext.fillStyle = @color.toString()\n      aContext.beginPath()\n\n      # the two circles (one at each end)\n      aContext.arc points[0].x, points[0].y, radius, 0, 2 * Math.PI, false\n      aContext.arc points[1].x, points[1].y, radius, 0, 2 * Math.PI, false\n      # the rectangle\n      rect = rect.floor()\n      rect = rect.toLocalCoordinatesOf @\n      aContext.moveTo rect.origin.x, rect.origin.y\n      aContext.lineTo rect.origin.x + rect.width(), rect.origin.y\n      aContext.lineTo rect.origin.x + rect.width(), rect.origin.y + rect.height()\n      aContext.lineTo rect.origin.x, rect.origin.y + rect.height()\n\n      aContext.closePath()\n      aContext.fill()\n\n      aContext.restore()\n\n      # paintHighlight is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio (i.e. after the restore)\n      @paintHighlight aContext, al, at, w, h\n\n  \n  # CircleBoxMorph menu:\n  developersMenu: ->\n    menu = super()\n    menu.addLine()\n    # todo Dan Ingalls did show a neat demo where the\n    # boxmorph was automatically changing the orientation\n    # when resized, following the main direction.\n    if @orientation is "vertical"\n      menu.addItem "make horizontal", true, @, "toggleOrientation", "toggle the\\norientation"\n    else\n      menu.addItem "make vertical", true, @, "toggleOrientation", "toggle the\\norientation"\n    menu\n  \n  toggleOrientation: ->\n    center = @center()\n    if @orientation is "vertical"\n      @orientation = "horizontal"\n    else\n      @orientation = "vertical"\n    @silentRawSetExtent new Point @height(), @width()\n    @fullRawMoveCenterTo center\n    @changed()\n';
