// Generated by CoffeeScript 1.7.1
window.LinearLayoutSpec_coffeSource = '# LinearLayoutSpec\n\n# this comment below is needed to figure out dependencies between classes\n\n# This is a port of the LayoutSpec class from\n# Cuis Smalltalk (version 4.2-1766)\n# Cuis is by Juan Vuletich\n\n# LinearLayoutSpecs are the basis for the layout mechanism.\n# Any Morph can be given a LinearLayoutSpec, but in order to honor it,\n# its owner must be a LinearLayoutMorph.\n\n# A LinearLayoutSpec specifies how a morph wants to be laid out.\n# It can specify either a fixed width or a fraction of some\n# available owner width. Same goes for height. If a fraction\n# is specified, a minimum extent is also possible.\n\n\n# Alternatives:\n#  - proportionalWidth notNil, fixedWidth notNil ->    Use fraction of available space, take fixedWidth as minimum desired width\n#  - proportionalWidth isNil, fixedWidth isNil   ->    Use current morph width\n#  - proportionalWidth isNil, fixedWidth notNil    ->    Use fixedWidth\n#  - proportionalWidth notNil, fixedWidth isNil    ->    NOT VALID\n\n#Same goes for proportionalHeight and fixedHeight\n\nclass LinearLayoutSpec\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  morph: null\n  minorDirectionFloat: 0.5 # equivalent to "#center"\n  fixedWidth: 0\n  fixedHeight: 0\n  proportionalWidth: 1.0\n  proportionalHeight: 1.0\n  category: \'Morphic-Layouts\'\n\n\n  # Just some reasonable defaults, use all available space\n  constructor: ->\n\n  @newWithFixedExtent: (aPoint) ->\n    @newWithFixedWidthFixedHeight(aPoint.x, aPoint.y)\n\n  @newWithFixedHeight: (aNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.setFixedHeight aNumber\n   return linearLinearLayoutSpec\n\n  @newWithFixedWidth: (aNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.setFixedWidth aNumber\n   return linearLinearLayoutSpec\n\n  @newWithFixedWidthFixedHeight: (aNumber, otherNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.setFixedWidth aNumber\n   linearLinearLayoutSpec.setFixedHeight otherNumber\n   return linearLinearLayoutSpec\n\n  @newWithFixedWidthFixedHeightMinorDirectionFloat: (aNumber, otherNumber, aSymbolOrNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.setFixedWidth aNumber\n   linearLinearLayoutSpec.setFixedHeight otherNumber\n   linearLinearLayoutSpec.setMinorDirectionFloat aSymbolOrNumber\n   return linearLinearLayoutSpec\n\n  @newWithFixedWidthProportionalHeight: (aNumber, otherNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.setFixedWidth aNumber\n   linearLinearLayoutSpec.setProportionalHeight otherNumber\n   return linearLinearLayoutSpec\n\n  @newWithFixedWidthProportionalHeightMinorDirectionFloat: (aNumber, otherNumber, aSymbolOrNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.setFixedWidth aNumber\n   linearLinearLayoutSpec.setProportionalHeight otherNumber\n   linearLinearLayoutSpec.setMinorDirectionFloat aSymbolOrNumber\n   return linearLinearLayoutSpec\n\n  @newWithKeepMorphExtent: ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.useMorphWidth\n   linearLinearLayoutSpec.useMorphHeight\n   return linearLinearLayoutSpec\n\n  @newWithMorphHeightFixedWidth: (aNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.setFixedWidth aNumber\n   linearLinearLayoutSpec.useMorphHeight\n   return linearLinearLayoutSpec\n\n  @newWithMorphHeightProportionalWidth: (aNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.setProportionalWidth aNumber\n   linearLinearLayoutSpec.useMorphHeight()\n   return linearLinearLayoutSpec\n\n  @newWithMorphWidthFixedHeight: (aNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.useMorphWidth()\n   linearLinearLayoutSpec.setFixedHeight aNumber\n   return linearLinearLayoutSpec\n\n  @newWithMorphWidthProportionalHeight: (aNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.useMorphWidth()\n   linearLinearLayoutSpec.setProportionalHeight aNumber\n   return linearLinearLayoutSpec\n\n  # Will use all available width\n  @newWithProportionalHeight: (aNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.setProportionalHeight aNumber\n   return linearLinearLayoutSpec\n\n  # Will use all available height\n  @newWithProportionalWidth: (aNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.setProportionalWidth aNumber\n   return linearLinearLayoutSpec\n\n  @newWithProportionalWidthFixedHeight: (aNumber, otherNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.setProportionalWidth aNumber\n   linearLinearLayoutSpec.setFixedHeight otherNumber\n   return linearLinearLayoutSpec\n\n  @newWithProportionalWidthFixedHeightMinorDirectionFloat: (aNumber, otherNumber, aSymbolOrNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.setProportionalWidth aNumber\n   linearLinearLayoutSpec.setFixedHeight otherNumber\n   linearLinearLayoutSpec.setMinorDirectionFloat aSymbolOrNumber\n   return linearLinearLayoutSpec\n\n  @newWithProportionalWidthProportionalHeight: (aNumber, otherNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.setProportionalWidth aNumber\n   linearLinearLayoutSpec.setProportionalHeight otherNumber\n   return linearLinearLayoutSpec\n\n  @newWithProportionalWidthProportionalHeightMinorDirectionFloat: (aNumber, otherNumber, aSymbolOrNumber) ->\n   linearLinearLayoutSpec = new @()\n   linearLinearLayoutSpec.setProportionalWidth aNumber\n   linearLinearLayoutSpec.setProportionalHeight otherNumber\n   linearLinearLayoutSpec.setMinorDirectionFloat aSymbolOrNumber\n   return linearLinearLayoutSpec\n\n  # Use all available space\n  @newWithUseAll: ->\n   return new @()\n\n  setFixedHeight: (aNumber) ->\n   # aNumber is taken as the fixed height to use.\n   # No proportional part.\n   @fixedHeight = aNumber\n   @proportionalHeight = null\n\n  setFixedOrMorphHeight: (aNumber) ->\n    # aNumber is taken as the fixed height to use.\n    # No proportional part.\n    if @fixedHeight?\n      @fixedHeight = aNumber\n    else\n      @morph.rawSetHeight aNumber\n    @proportionalHeight = null\n\n  setFixedOrMorphWidth: (aNumber) ->\n    # aNumber is taken as the fixed width to use.\n    # No proportional part.\n    if @fixedWidth?\n      @fixedWidth = aNumber\n    else\n      @morph.rawSetWidth aNumber\n    @proportionalWidth = null\n\n  setFixedWidth: (aNumber) ->\n    # aNumber is taken as the fixed width to use.\n    # No proportional part.\n    @fixedWidth = aNumber\n    @proportionalWidth = null\n\n  setMinorDirectionFloat: (howMuchFloat) ->\n    # This sets how float is done in the secondary direction.\n    # For instance, if the owning morph is set in a row,\n    # the row will control horizontal layout. But if there\n    # is unused vertical space, it will be used according to\n    # this parameter. For instance, #top sets the owning morph\n    # at the top. Same for #bottom and #center. If the owner is\n    # contained in a column, #left, #center or #right should be\n    # used. Alternatively, any number between 0.0 and 1.0 can be\n    # used.\n    #  self new minorDirectionFloat: #center\n    #  self new minorDirectionFloat: 0.9\n\n    switch howMuchFloat\n      when "#top" then @minorDirectionFloat = 0.0\n      when "#left" then @minorDirectionFloat = 0.0\n      when "#center" then @minorDirectionFloat = 0.5\n      when "#right" then @minorDirectionFloat = 1.0\n      when "#bottom" then @minorDirectionFloat = 1.0\n      else @minorDirectionFloat = howMuchFloat\n\n  setProportionalHeight: (aNumber) ->\n   @setProportionalHeightMinimum(aNumber, 0.0)\n\n  setProportionalHeightMinimum: (aNumberOrNil, otherNumberOrNil) ->\n    # Alternatives: same as in #proportionalWidth:minimum:\n    # see comment there\n    @proportionalHeight = aNumberOrNil\n    @fixedHeight = otherNumberOrNil\n\n  setProportionalWidth: (aNumber) ->\n    return @setProportionalWidthMinimum aNumber, 0\n\n  setProportionalWidthMinimum: (aNumberOrNil, otherNumberOrNil) ->\n    # Alternatives:\n    #  - proportionalWidth notNil, fixedWidth notNil ->    Use fraction of available space, take fixedWidth as minimum desired width\n    #  - proportionalWidth isNil, fixedWidth isNil   ->    Use current morph width\n    #  - proportionalWidth isNil, fixedWidth notNil  ->    Use fixedWidth\n    #  - proportionalWidth notNil, fixedWidth isNil  ->    NOT VALID\n    @proportionalWidth = aNumberOrNil\n    @fixedWidth = otherNumberOrNil\n\n  setProportionalHeight: (aNumberOrNil) ->\n   # Alternatives: same as in #proportionalWidth:minimum:, see comment there\n   @proportionalHeight = aNumberOrNil\n\n  setProportionalWidth: (aNumberOrNil) ->\n    # Alternatives:\n    #  - proportionalWidth notNil, fixedWidth notNil ->    Use fraction of available space, take fixedWidth as minimum desired width\n    #  - proportionalWidth isNil, fixedWidth isNil   ->    Use current morph width\n    #  - proportionalWidth isNil, fixedWidth notNil  ->    Use fixedWidth\n    #  - proportionalWidth notNil, fixedWidth isNil  ->    NOT VALID"\n    @proportionalWidth = aNumberOrNil\n\n  useMorphHeight: ->\n    # Do not attempt to layout height. Use current morph height if at all possible\n    @fixedHeight = null\n    @proportionalHeight = null\n\n  useMorphWidth: ->\n    # Do not attempt to layout width. Use current morph width if at all possible\n    @fixedWidth = null\n    @proportionalWidth = null\n\n  getFixedHeight: ->\n    # If proportional is zero, answer stored fixed extent,\n    # or actual morph extent if undefined. (no proportional extent is computed)\n    # Otherwise, we do proportional layout, and the stored extent is\n    # a minimum extent, so we don\'t  really a fixed extent.\n    if @proportionalHeight?\n      return 0\n    if not @fixedHeight?\n      return @morph.height()\n\n  getFixedWidth: ->\n    # If proportional is zero, answer stored fixed extent,\n    # or actual morph extent if undefined. (no proportional extent is computed)\n    # Otherwise, we do proportional layout, and the stored extent is\n    # a minimum extent, so we don\'t  really a fixed extent.\n    if @proportionalWidth?\n      return 0\n    if not @fixedWidth?\n      return @morph.width()\n\n  heightFor: (availableSpace) ->\n    # If proportional is zero, answer stored fixed extent,\n    # or actual morph extent if undefined.\n    # Otherwise, we do proportional layout, and the stored\n    # extent is a minimum extent.\n    # If there is no minimum extent, it should be set to zero.\n\n    if @proportionalHeight?\n      return Math.max( @fixedHeight, Math.round(@proportionalHeight * availableSpace) )\n    return @getFixedHeight()\n\n  getFixedHeight: ->\n    if not @fixedHeight?\n      return 0\n    else\n      @fixedHeight\n\n  getFixedWidth: ->\n    if not @fixedWidth?\n      return 0\n    else\n      @fixedWidth\n\n  getProportionalHeight: ->\n    if not @proportionalHeight?\n      return 0\n    else\n      @proportionalHeight\n\n  getProportionalWidth: ->\n    if not @proportionalWidth?\n      return 0\n    else\n      @proportionalWidth\n\n  widthFor: (availableSpace) ->\n    # If proportional is zero, answer stored fixed extent,\n    # or actual morph extent if undefined.\n    # Otherwise, we do proportional layout, and the\n    # stored extent is a minimum extent.\n    # If there is no minimum extent, it should be set to zero.\n    if @proportionalWidth?\n      return Math.max( @fixedWidth, Math.round(@proportionalWidth * availableSpace) )\n    return @getFixedWidth()\n\n  isProportionalHeight: ->\n    return @proportionalHeight?\n\n  isProportionalWidth: ->\n    return @proportionalWidth?';
