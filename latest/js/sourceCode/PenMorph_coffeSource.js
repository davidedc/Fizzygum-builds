// Generated by CoffeeScript 1.7.1
window.PenMorph_coffeSource = '# PenMorph ////////////////////////////////////////////////////////////\n\n# I am a simple LOGO-wise turtle. Note that this morph\'s graphical\n# representation is ONLY the turtle, not the graphics that come\n# out of it. The graphics generated by the pan are located in the\n# canvas it was attached to when the graphics happened.\n#\n# example code to run:\n#   this.sierpinski(400,40);\n\nclass PenMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n  \n  heading: 0\n  penSize: null\n  isWarped: false # internal optimization\n  isDown: true\n  wantsRedraw: false # internal optimization\n  penPoint: \'tip\' # or \'center\'\n  \n  constructor: ->\n    @penSize = WorldMorph.preferencesAndSettings.handleSize * 4\n    super()\n    @rawSetExtent new Point @penSize, @penSize\n    # todo we need to change the size two times, for getting the right size\n    # of the arrow and of the line. Probably should make the two distinct\n    @penSize = 1\n    #alert @morphMethod() # works\n    # doesn\'t work cause coffeescript doesn\'t support static inheritance\n    #alert @morphStaticMethod()\n\n    # no need to call  because @rawSetExtent does it.\n    # (should it?)\n    #\n\n\n  @staticVariable: 1\n  @staticFunction: -> 3.14\n\n  imBeingAddedTo: (newParentMorph) ->\n    if !(newParentMorph instanceof HandMorph or newParentMorph instanceof CanvasMorph)\n      @inform "a pen will only\\nwork on a canvas..."\n\n    \n  # PenMorph updating - optimized for warping, i.e atomic recursion\n  changed: ->\n    if @isWarped is false\n      w = @root()\n      # unless we are the main desktop, then if the morph has no parent\n      # don\'t add the broken rect since the morph is not visible\n      if w instanceof WorldMorph and (@ instanceof WorldMorph or @parent?)\n        w.broken.push @clippedThroughBounds().spread()\n      @parent.childChanged @  if @parent\n  \n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle) ->\n\n    if @preliminaryCheckNothingToDraw false, clippingRectangle, aContext\n      return\n\n    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return null\n\n      aContext.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      aContext.clipToRectangle al,at,w,h\n\n      aContext.globalAlpha = @alpha\n\n      aContext.scale pixelRatio, pixelRatio\n      morphPosition = @position()\n      aContext.translate morphPosition.x, morphPosition.y\n\n      direction = @heading\n      if @isWarped\n        @wantsRedraw = true\n        return\n      len = @width() / 2\n      start = @center().subtract(@position())\n\n      if @penPoint is "tip"\n        dest = start.distanceAngle(len * 0.75, direction - 180)\n        left = start.distanceAngle(len, direction + 195)\n        right = start.distanceAngle(len, direction - 195)\n      else # \'middle\'\n        dest = start.distanceAngle(len * 0.75, direction)\n        left = start.distanceAngle(len * 0.33, direction + 230)\n        right = start.distanceAngle(len * 0.33, direction - 230)\n\n      aContext.fillStyle = @color.toString()\n      aContext.beginPath()\n\n      aContext.moveTo start.x, start.y\n      aContext.lineTo left.x, left.y\n      aContext.lineTo dest.x, dest.y\n      aContext.lineTo right.x, right.y\n\n      aContext.closePath()\n      aContext.strokeStyle = "white"\n      aContext.lineWidth = 3\n      aContext.stroke()\n      aContext.strokeStyle = "black"\n      aContext.lineWidth = 1\n      aContext.stroke()\n      aContext.fill()\n      @wantsRedraw = false\n\n      aContext.restore()\n\n      # paintHighlight is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio (i.e. after the restore)\n      @paintHighlight aContext, al, at, w, h\n\n  \n  \n  # PenMorph access:\n  setHeading: (degrees) ->\n    @heading = parseFloat(degrees) % 360\n    @changed()\n  \n  \n  # PenMorph drawing:\n  drawLine: (start, dest) ->\n\n    if !@parent.backBuffer?\n      return\n\n    context = @parent.backBuffer.getContext "2d"\n\n    from = start.subtract @parent.position()\n    to = dest.subtract @parent.position()\n    if @isDown\n      context.lineWidth = @penSize\n      context.strokeStyle = @color.toString()\n      context.lineCap = "round"\n      context.lineJoin = "round"\n      context.beginPath()\n      context.moveTo from.x, from.y\n      context.lineTo to.x, to.y\n      context.stroke()\n      @parent.changed()\n      # unless we are the main desktop, then if the morph has no parent\n      # don\'t add the broken rect since the morph is not visible\n      if @isWarped is false and (@ instanceof WorldMorph or @parent?)\n        world.broken.push start.rectangle(dest).expandBy(Math.max(@penSize / 2, 1)).intersect(@parent.clippedThroughBounds()).spread()\n  \n  \n  # PenMorph turtle ops:\n  turn: (degrees) ->\n    @setHeading @heading + parseFloat degrees\n  \n  forward: (steps) ->\n    start = @center()\n    dist = parseFloat steps\n    if dist >= 0\n      dest = @position().distanceAngle dist, @heading\n    else\n      dest = @position().distanceAngle(Math.abs(dist), (@heading - 180))\n    @fullRawMoveTo dest.round()\n    @drawLine start, @center()\n  \n  down: ->\n    @isDown = true\n  \n  up: ->\n    @isDown = false\n  \n  clear: ->\n    \n    @parent.changed()\n  \n  \n  # PenMorph optimization for atomic recursion:\n  startWarp: ->\n    @wantsRedraw = false\n    @isWarped = true\n  \n  endWarp: ->\n    @isWarped = false\n    if @wantsRedraw\n      \n      @wantsRedraw = false\n    @parent.changed()\n  \n  warp: (fun) ->\n    @startWarp()\n    fun.call @\n    @endWarp()\n  \n  warpOp: (selector, argsArray) ->\n    @startWarp()\n    @[selector].apply @, argsArray\n    @endWarp()\n  \n  \n  # PenMorph demo ops:\n  # try these with WARP eg.: this.warp(function () {tree(12, 120, 20)})\n  warpSierpinski: (length, min) ->\n    @warpOp "sierpinski", [length, min]\n  \n  sierpinski: (length, min) ->\n    if length > min\n      for i in [0...3]\n        @sierpinski length * 0.5, min\n        @turn 120\n        @forward length\n  \n  warpTree: (level, length, angle) ->\n    @warpOp "tree", [level, length, angle]\n  \n  tree: (level, length, angle) ->\n    if level > 0\n      @penSize = level\n      @forward length\n      @turn angle\n      @tree level - 1, length * 0.75, angle\n      @turn angle * -2\n      @tree level - 1, length * 0.75, angle\n      @turn angle\n      @forward -length\n';
