// Generated by CoffeeScript 1.7.1
window.SpeechBubbleMorph_coffeSource = '# SpeechBubbleMorph ///////////////////////////////////////////////////\n\n#\n#	I am a comic-style speech bubble that can display either a string,\n#	a Morph, a Canvas or a toString() representation of anything else.\n#	If I am invoked using popUp() I behave like a tool tip.\n#\n\nclass SpeechBubbleMorph extends BoxMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  isPointingRight: true # orientation of text\n  contents: null\n  padding: null # additional vertical pixels\n  isThought: null # draw "think" bubble\n  isClickable: false\n  morphInvokingThis: null\n\n  constructor: (\n    @contents="",\n    @morphInvokingThis,\n    @color = (new Color 230, 230, 230),\n    cornerRadius,\n    @padding = 0,\n    @isThought = false) ->\n      # console.log "bubble super"\n      super(cornerRadius or 6)\n      # console.log @color\n  \n  @createBubbleHelpIfHandStillOnMorph: (contents, morphInvokingThis) ->\n    # console.log "bubble createBubbleHelpIfHandStillOnMorph"\n    # let\'s check that the item that the\n    # bubble is about is still actually there\n    # and the mouse is still over it, otherwise\n    # do nothing.\n    if morphInvokingThis.root() == world and morphInvokingThis.boundsContainPoint world.hand.position()\n      theBubble = new @ localize(contents), morphInvokingThis, null, null\n      theBubble.popUp theBubble.morphInvokingThis.rightCenter().add new Point -8, 0\n\n  @createInAWhileIfHandStillContainedInMorph: (morphInvokingThis, contents, delay = 500) ->\n    # console.log "bubble createInAWhileIfHandStillContainedInMorph"\n    if AutomatorRecorderAndPlayer.animationsPacingControl and\n     AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE\n        @createBubbleHelpIfHandStillOnMorph contents, morphInvokingThis\n    else\n      setTimeout (=>\n        @createBubbleHelpIfHandStillOnMorph contents, morphInvokingThis\n        )\n        , delay\n  \n  # SpeechBubbleMorph invoking:\n  popUp: (pos, isClickable) ->\n    # console.log "bubble popup"\n    @fullRawMoveTo pos.subtract new Point 0, @height()\n    @fullRawMoveWithin world\n\n    @buildAndConnectChildren()\n\n    world.add @\n    @addFullShadow()\n    @fullChanged()\n    world.hand.destroyTemporaries()\n    world.hand.temporaries.push @\n    if isClickable\n      @mouseEnter = ->\n        @destroy()\n    else\n      @isClickable = false\n    \n  buildAndConnectChildren: ->\n    # console.log "bubble buildAndConnectChildren"\n    # re-build my contents\n    if @contentsMorph\n      @contentsMorph = @contentsMorph.destroy()\n    if @contents instanceof Morph\n      @contentsMorph = @contents\n    else if isString @contents\n      @contentsMorph = new TextMorph(\n        @contents,\n        WorldMorph.preferencesAndSettings.bubbleHelpFontSize,\n        null,\n        false,\n        true,\n        "center")\n    else if @contents instanceof HTMLCanvasElement\n      @contentsMorph = new Morph()\n      @contentsMorph.silentRawSetWidth @contents.width\n      @contentsMorph.silentRawSetHeight @contents.height\n      @contentsMorph.backBuffer = @contents\n      @contentsMorph.backBufferContext = @contentsMorph.backBuffer.getContext "2d"\n    else\n      @contentsMorph = new TextMorph(\n        @contents.toString(),\n        WorldMorph.preferencesAndSettings.bubbleHelpFontSize,\n        null,\n        false,\n        true,\n        "center")\n    @add @contentsMorph\n\n    # adjust my layout\n    @silentRawSetWidth @contentsMorph.width() + ((if @padding then @padding * 2 else @cornerRadius * 2))\n    @silentRawSetHeight @contentsMorph.height() + @cornerRadius + @padding * 2 + 2\n\n    # draw my outline\n    #super()\n\n    # position my contents\n    @contentsMorph.fullRawMoveTo @position().add(\n      new Point(@padding or @cornerRadius, @padding + 1))\n\n\n  outlinePath: (context, radius) ->\n    # console.log "bubble outlinePath"\n    circle = (x, y, r) ->\n      context.moveTo x + r, y\n      context.arc x, y, r, degreesToRadians(0), degreesToRadians(360)\n    offset = radius\n    w = @width()\n    h = @height()\n\n    # top left:\n    context.arc offset, offset, radius, degreesToRadians(-180), degreesToRadians(-90), false\n\n    # top right:\n    context.arc w - offset, offset, radius, degreesToRadians(-90), degreesToRadians(-0), false\n\n    # bottom right:\n    context.arc w - offset, h - offset - radius, radius, degreesToRadians(0), degreesToRadians(90), false\n    unless @isThought # draw speech bubble hook\n      if @isPointingRight\n        context.lineTo offset + radius, h - offset\n        context.lineTo radius / 2, h\n      else # pointing left\n        context.lineTo w - (radius / 2), h\n        context.lineTo w - (offset + radius), h - offset\n\n    # bottom left:\n    context.arc offset, h - offset - radius, radius, degreesToRadians(90), degreesToRadians(180), false\n\n    if @isThought\n      # close large bubble:\n      context.lineTo 0, offset\n\n      # draw thought bubbles:\n      if @isPointingRight\n\n        # tip bubble:\n        rad = radius / 4\n        circle rad, h - rad, rad\n\n        # middle bubble:\n        rad = radius / 3.2\n        circle rad * 2, h - rad, rad\n\n        # top bubble:\n        rad = radius / 2.8\n        circle rad * 3, h - rad, rad\n      else # pointing left\n        # tip bubble:\n        rad = radius / 4\n        circle w - (rad), h - rad, rad\n\n        # middle bubble:\n        rad = radius / 3.2\n        circle w - (rad * 2), h - rad, rad\n\n        # top bubble:\n        rad = radius / 2.8\n        circle w - (rad * 3), h - rad, rad\n\n';
