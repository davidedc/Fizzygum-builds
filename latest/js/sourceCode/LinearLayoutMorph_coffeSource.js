// Generated by CoffeeScript 1.7.1
window.LinearLayoutMorph_coffeSource = '# LinearLayoutMorph\n\n# this comment below is needed to figure out dependencies between classes\n# REQUIRES Color\n# REQUIRES Point\n# REQUIRES Rectangle\n# REQUIRES LinearLayoutAdjustingMorph\n\n# This is a port of the\n# LayoutMorph Cuis Smalltalk classe (version 4.2-1766)\n# Cuis is by Juan Vuletich\n\n# A Layout that arranges its children in a single column or a single row.\n# I.e. a row or column of widgets, does layout by placing\n# them either (respectively) horizontally or vertically.\n\n# Submorphs might have a linearLinearLayoutSpec property\n# specifying a LinearLayoutSpec.\n# If some don\'t, then, for a column, the column\n# width is taken as the width, and any morph height\n# is kept. Same for rows: submorph width would be\n# maintained, and submorph height would be made\n# equal to row height.\n\nclass LinearLayoutMorph extends LayoutMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  instanceVariableNames: \'direction separation float\'\n  classVariableNames: \'\'\n  poolDictionaries: \'\'\n\n  direction: ""\n  float: 0 # equivalent to #left, or #top\n  separation: null # contains a Point\n\n  constructor: ->\n    super()\n    @separation = new Point 0,0\n  \n  @newColumn: ->\n    newLinearLayoutMorph =  new @()\n    newLinearLayoutMorph.beColumn()\n    return newLinearLayoutMorph\n\n  @newRow: ->\n    #debugger\n    newLinearLayoutMorph =  new @()\n    newLinearLayoutMorph.beRow()\n    return newLinearLayoutMorph\n\n  beColumn: ->\n    @direction = "#vertical"\n    @setFloat "#center"\n\n  beRow: ->\n    @direction = "#horizontal"\n    @setFloat= "#left"\n\n  defaultColor: ->\n    return Color.transparent()\n\n  # This sets how extra space is used when doing layout.\n  # For example, a column might have extra , un-needed\n  # vertical space. #top means widgets are set close\n  # to the top, and extra space is at bottom. Conversely,\n  # #bottom means widgets are set close to the bottom,\n  # and extra space is at top. Valid values include\n  # #left and #right (for rows) and #center. Alternatively,\n  # any number between 0.0 and 1.0 might be used.\n  #   self new float: #center\n  #   self new float: 0.9\n  setFloat: (howMuchFloat) ->\n    switch howMuchFloat\n      when "#top" then @float = 0.0\n      when "#left" then @float = 0.0\n      when "#center" then @float = 0.5\n      when "#right" then @float = 1.0\n      when "#bottom" then @float = 1.0\n      else @float = howMuchFloat\n\n  setSeparation: (@separation) ->\n\n  xSeparation: ->\n    return @separation.x\n\n  ySeparation: ->\n    return @separation.y\n\n  # Compute a new layout based on the given layout bounds\n  layoutSubmorphs: ->\n    console.log "layoutSubmorphs in LinearLayoutMorph"\n    #debugger\n    super()\n    if @children.length == 0\n      @layoutNeeded = false\n      return @\n\n    @layoutSubmorphsWithinBounds @boundingBox(), @direction\n\n    @layoutNeeded = false\n\n  # Compute a new layout based on the given layout bounds.\n  horizontalErrorForMorphIfContainerHasWith: (tryingWidth, morph, intendedMorphWidth) ->\n\n\n  # Compute a new layout based on the given layout bounds.\n  # Note that the layout doesn\'t look at all at the current size\n  # of the morphs inside the layout. It rather sets them based\n  # on the bounds of the layout.\n  layoutSubmorphsWithinBounds: (boundsForLayout, direction) ->\n    debugger\n    #| xSep ySep usableWidth sumOfFixed normalizationFactor availableForPropWidth widths l usableHeight boundsTop boundsRight t |\n    xSep = @xSeparation()\n    ySep = @ySeparation()\n\n    if direction == "#horizontal"\n      separationInMainDirection = xSep\n      separationInMinorDirection = ySep\n      minorDirectionStart = boundsForLayout.top()\n      mainDirectionEnd = boundsForLayout.right()\n      mainDirectionStart = boundsForLayout.left()\n\n      mainDirectionBoundsExtent = boundsForLayout.width()\n      minorDirectionBoundsExtent = boundsForLayout.height()\n      fixedMainDirectionVarName = "fixedWidth"\n      getFixedMainDirectionVarName = "getFixedWidth"\n      mainDirectionForVarName = "widthFor"\n      minorDirectionForVarName = "heightFor"\n    else if direction == "#vertical"\n      separationInMainDirection = ySep\n      separationInMinorDirection = xSep\n      minorDirectionStart = boundsForLayout.left()\n      mainDirectionEnd = boundsForLayout.bottom()\n      mainDirectionStart = boundsForLayout.top()\n\n      mainDirectionBoundsExtent = boundsForLayout.height()\n      minorDirectionBoundsExtent = boundsForLayout.width()\n      fixedMainDirectionVarName = "fixedHeight"\n      getFixedMainDirectionVarName = "getFixedHeight"\n      mainDirectionForVarName = "heightFor"\n      minorDirectionForVarName = "widthFor"\n\n    # there might be submorphs that don\'t have a layout.\n    # for example, currently, the HandleMorph can be attached\n    # to the LinearLayoutMorph without a linearLinearLayoutSpec.\n    # just skip those. The HandleMorph does its own\n    # layouting.\n    childrenWithLinearLayoutSpec = @children.filter (child) ->\n      child.linearLinearLayoutSpec?\n\n    # first off let\'s see how much space we have to\n    # put the morphs in.\n    # Which is same as the current extent of the layout\n    # minus any gaps between the morphs.\n    # TODO you have to correct on that you have to count only the\n    # morph that have a layout spec here\n    usableMainDirectionSpace = mainDirectionBoundsExtent - ((childrenWithLinearLayoutSpec.length + 1) * separationInMainDirection)\n    \n\n    # next, we take away from the available space the space\n    # required by the fixed size morphs.\n    sumOfFixed = 0\n\n\n    childrenWithLinearLayoutSpec.forEach (child) =>\n      if child.linearLinearLayoutSpec[fixedMainDirectionVarName]?\n        sumOfFixed += child.linearLinearLayoutSpec[getFixedMainDirectionVarName]()\n    \n    # what\'s left now is the space we have available for all the\n    # proportional-size morphs\n    availableForPropMainDirection = usableMainDirectionSpace - sumOfFixed\n    # if the sum of the proportional sizes is > 1.0 then\n    # we distribute the space by normalising to the total sum\n    # If it\'s < 1.0 then we don\'t normalise to 1, so there might be\n    # some further space left.\n    normalizationFactor = @proportionalMainDirectionNormalizationFactor()\n    availableForPropMainDirection = availableForPropMainDirection * normalizationFactor\n    # Distribute the space to the proportional morphs, put all the\n    # spaces in an array\n    # TODO again you should skip the morphs without a\n    # linearspec\n    mainDirectionSizesOfMorphs = []\n    sumOfMainDirections = 0\n    childrenWithLinearLayoutSpec.forEach (child) =>\n      mainDirectionSizeForThisMorph = child.linearLinearLayoutSpec[mainDirectionForVarName] availableForPropMainDirection\n      sumOfMainDirections += mainDirectionSizeForThisMorph\n      mainDirectionSizesOfMorphs.push mainDirectionSizeForThisMorph\n    startingSpaceInMainDirection = ((usableMainDirectionSpace - sumOfMainDirections) * @float + Math.max(separationInMainDirection, 0)) +  mainDirectionStart\n    mainDirectionCursor = startingSpaceInMainDirection\n\n    usableMinorDirection = minorDirectionBoundsExtent - Math.max 2*separationInMinorDirection, 0\n    \n    for i in [childrenWithLinearLayoutSpec.length-1 .. 0]\n      m = childrenWithLinearLayoutSpec[i]\n      # major direction\n      mainDirectionSizeForThisMorph = mainDirectionSizesOfMorphs[i]\n      # minor direction\n      lls = m.linearLinearLayoutSpec\n      h = Math.min(usableMinorDirection, lls[minorDirectionForVarName](usableMinorDirection))\n      t = (usableMinorDirection - h) * lls.minorDirectionFloat + separationInMinorDirection + minorDirectionStart\n\n      # Set bounds and adjust major direction for next step\n      # self flag: #jmvVer2.\n      # should extent be set in m\'s coordinate system? what if its scale is not 1?\n      switch direction\n        when "#horizontal"\n          newExtent = new Point Math.min(mainDirectionSizeForThisMorph,mainDirectionBoundsExtent), h\n          m.fullRawMoveTo new Point mainDirectionCursor, t\n        when "#vertical"\n          newExtent = new Point h, Math.min mainDirectionSizeForThisMorph, mainDirectionBoundsExtent\n          m.fullRawMoveTo new Point t, mainDirectionCursor\n\n      m.rawSetExtent newExtent\n\n      if mainDirectionSizeForThisMorph > 0\n        # move on the cursor along the main direction\n        mainDirectionCursor = Math.min mainDirectionCursor + mainDirectionSizeForThisMorph + separationInMainDirection, mainDirectionEnd\n\n\n  # So the user can adjust layout\n  addAdjusterMorph: ->\n    thickness = 4\n    adjuster = new LinearLayoutAdjustingMorph()\n\n    if @direction == "#horizontal"\n      @addMorphFixedWidth adjuster, thickness\n\n    if @direction == "#vertical"\n      @addMorphFixedHeight adjuster, thickness\n\n    adjuster\n\n  #"Add a submorph, at the bottom or right, with aLinearLayoutSpec"\n  addMorphWithLinearLayoutSpec: (aMorph, aLinearLayoutSpec) ->\n    aMorph.linearLinearLayoutSpec = aLinearLayoutSpec\n    @add aMorph\n\n\n  # if the sum of the proportional sizes is > 1.0 then\n  # we normalise for that, i.e. the space is distributed\n  # according to the size proportional to the sum > 1.0\n  #\n  # if the sum of the proportional sizes < 1.0\n  # then we DON\'T normalise on that sum, meaning that there\n  # might be space left in the layout. For example if you\n  # add only one morph with proportional size of 0.5\n  # then it will be half of the layout\'s size even if there are\n  # no other morphs.\n  proportionalMainDirectionNormalizationFactor: ->\n    sumOfProportional = 0\n    @children.forEach (child) =>\n      if child.linearLinearLayoutSpec?\n        sumOfProportional += switch @direction\n          when "#horizontal"\n            child.linearLinearLayoutSpec.getProportionalWidth()\n          when "#vertical"\n            child.linearLinearLayoutSpec.getProportionalHeight()\n\n    return 1.0 / Math.max sumOfProportional, 1.0\n\n\n  adjustByAt: (aLayoutAdjustMorph, aPoint) ->\n    # | delta l lls r rs lNewWidth rNewWidth i lCurrentWidth rCurrentWidth doNotResizeBelow |\n\n    i = @children.indexOf aLayoutAdjustMorph\n\n    l = @children[i + 1]\n    r = @children[i - 1]\n\n    lls = l.linearLinearLayoutSpec\n\n    if @direction == "#horizontal"      \n      doNotResizeBelow =  @minPaneWidthForReframe()\n      lSize = l.width()\n      rSize = r.width()\n      delta = aPoint.x - aLayoutAdjustMorph.position().x\n      checkProportionalSizeVarName = "isProportionalWidth"\n      setProportionalSizeVarName = "setProportionalWidth"\n      getProportionalSizeVarName = "getProportionalWidth"\n      setFixedSizeVarName = "setFixedOrMorphWidth"\n    else\n      doNotResizeBelow =  @minPaneHeightForReframe()\n      lSize = l.height()\n      rSize = r.height()\n      delta = aPoint.y - aLayoutAdjustMorph.position().y\n      checkProportionalSizeVarName = "isProportionalHeight"\n      setProportionalSizeVarName = "setProportionalHeight"\n      getProportionalSizeVarName = "getProportionalHeight"\n      setFixedSizeVarName = "setFixedOrMorphHeight"\n\n    lCurrentWidth = Math.max lSize, 1 # avoid division by zero\n\n    rs = r.linearLinearLayoutSpec\n    rCurrentWidth = Math.max rSize, 1 # avoid division by zero\n\n    delta = Math.max delta, doNotResizeBelow - lCurrentWidth\n    delta = Math.min delta, rCurrentWidth - doNotResizeBelow\n    if delta == 0 then return @\n    lNewWidth = lCurrentWidth + delta\n    rNewWidth = rCurrentWidth - delta\n    if lls[checkProportionalSizeVarName]() and rs[checkProportionalSizeVarName]()\n      # If both proportional, update them\n      lls[setProportionalSizeVarName] 1.0 * lNewWidth / lCurrentWidth * lls[getProportionalSizeVarName]()\n      rs[setProportionalSizeVarName] 1.0 * rNewWidth / rCurrentWidth * rs[getProportionalSizeVarName]()\n    else\n      # If at least one is fixed, update only the fixed\n      if !lls[checkProportionalSizeVarName]()\n          lls[setFixedSizeVarName] lNewWidth\n      if !rs[checkProportionalSizeVarName]()\n          rs[setFixedSizeVarName] rNewWidth\n    @layoutSubmorphs()\n\n\n  #####################\n  # convenience methods\n  #####################\n\n  addAdjusterAndMorphFixedWidth: (aMorph,aNumber) ->\n    @addAdjusterAndMorphLinearLayoutSpec aMorph, LinearLayoutSpec.newWithFixedWidth aNumber\n\n  addAdjusterAndMorphFixedHeight: (aMorph,aNumber) ->\n    @addAdjusterAndMorphLinearLayoutSpec aMorph, LinearLayoutSpec.newWithFixedHeight aNumber\n\n  addAdjusterAndMorphLinearLayoutSpec: (aMorph, aLinearLayoutSpec) ->\n    #Add a submorph, at the bottom or right, with aLinearLayoutSpec"\n    adj = @addAdjusterMorph()\n    @addMorphWithLinearLayoutSpec aMorph, aLinearLayoutSpec\n\n  addAdjusterAndMorphProportionalHeight: (aMorph, aNumber) ->\n    @addAdjusterAndMorphLinearLayoutSpec aMorph, LinearLayoutSpec.newWithProportionalHeight aNumber\n\n  addAdjusterAndMorphProportionalWidth: (aMorph, aNumber) ->\n    @addAdjusterAndMorphLinearLayoutSpec aMorph, LinearLayoutSpec.newWithProportionalWidth aNumber\n\n  addMorphFixedHeight: (aMorph, aNumber) ->\n    @addMorphWithLinearLayoutSpec aMorph, LinearLayoutSpec.newWithFixedHeight aNumber\n\n  addMorphFixedWidth: (aMorph, aNumber) ->\n    @addMorphWithLinearLayoutSpec aMorph, LinearLayoutSpec.newWithFixedWidth aNumber\n\n  addMorphWithLinearLayoutSpec: (aMorph, aLinearLayoutSpec) ->\n    # Add a submorph, at the bottom or right, with aLinearLayoutSpec\n    aMorph.linearLinearLayoutSpec = aLinearLayoutSpec\n    @add aMorph\n\n  addMorphProportionalHeight: (aMorph, aNumber) ->\n    @addMorphWithLinearLayoutSpec aMorph, LinearLayoutSpec.newWithProportionalHeight aNumber\n\n  addMorphProportionalWidth: (aMorph, aNumber) ->\n    @addMorphWithLinearLayoutSpec aMorph, LinearLayoutSpec.newWithProportionalWidth aNumber\n\n  addMorphUseAll: (aMorph) ->\n    @addMorphWithLinearLayoutSpec aMorph, LinearLayoutSpec.useAll()\n\n  addMorphs: (morphs) ->\n    morphs.forEach (morph) =>\n      @addMorphProportionalWidth morph, 1\n\n  addMorphsWidthProportionalTo: (morphs, widths) ->\n    morphs.forEach (morph) =>\n      @addMorphProportionalWidth morph, widths\n\n  # unclear how to translate this one for the time being\n  is: (aSymbol) ->\n    return aSymbol == "#LinearLayoutMorph" # or [ super is: aSymbol ]\n\n\n  @testSet1: ->\n    @testScenario1 "#horizontal"\n    @testScenario2 "#horizontal"\n    @testScenario3 "#horizontal"\n    @testScenario4 "#horizontal"\n    @testScenario5 "#horizontal"\n    @testScenario6 "#horizontal"\n\n  @testSet2: ->\n    @testScenario1 "#vertical"\n    @testScenario2 "#vertical"\n    @testScenario3 "#vertical"\n    @testScenario4 "#vertical"\n    @testScenario5 "#vertical"\n    @testScenario6 "#vertical"\n\n\n  @testScenario1: (direction = "#horizontal")->\n    rect1 = new RectangleMorph new Point(20,20), new Color(255,0,0)\n    rect2 = new RectangleMorph new Point(20,20), new Color(0,255,0)\n    \n    if direction == "#horizontal"\n      line = LinearLayoutMorph.newRow()\n      line.addMorphProportionalWidth rect1, 2\n      line.addMorphProportionalWidth rect2, 1\n    else\n      line = LinearLayoutMorph.newColumn()\n      line.addMorphProportionalHeight rect1, 2\n      line.addMorphProportionalHeight rect2, 1\n\n    line.layoutSubmorphs()\n    line.fullRawMoveTo new Point 10, 10\n    line.fullRawMoveWithin world\n    world.add line\n    line.changed()\n\n    # attach a HandleMorph to it so that\n    # we can check how it resizes\n    new HandleMorph line\n\n\n  @testScenario2: (direction = "#horizontal")->\n    rect3 = new RectangleMorph new Point(20,20), new Color(255,0,0)\n    rect4 = new RectangleMorph new Point(20,20), new Color(0,255,0)\n\n    if direction == "#horizontal"      \n      line = LinearLayoutMorph.newRow()\n      line.addMorphFixedWidth rect3, 10\n      line.addMorphProportionalWidth rect4, 1\n    else\n      line = LinearLayoutMorph.newColumn()\n      line.addMorphFixedHeight rect3, 10\n      line.addMorphProportionalHeight rect4, 1\n\n    line.layoutSubmorphs()\n    line.fullRawMoveTo new Point 110, 10\n    line.fullRawMoveWithin world\n    world.add line\n    line.changed()\n\n    # attach a HandleMorph to it so that\n    # we can check how it resizes\n    new HandleMorph line\n\n  @testScenario3: (direction = "#horizontal")->\n    rect5 = new RectangleMorph new Point(20,20), new Color(255,0,0)\n    rect6 = new RectangleMorph new Point(20,20), new Color(0,255,0)\n    rect7 = new RectangleMorph new Point(20,20), new Color(0,0,255)\n\n    if direction == "#horizontal"      \n      line = LinearLayoutMorph.newRow()\n      line.addMorphProportionalWidth rect6, 2 # green\n      line.addAdjusterAndMorphProportionalWidth rect7, 1 # blue\n      line.addMorphProportionalWidth rect5, 3 # red\n      #line.addMorphFixedWidth rect5, 10 # red\n    else\n      line = LinearLayoutMorph.newColumn()\n      line.addMorphProportionalHeight rect6, 2 # green\n      line.addAdjusterAndMorphProportionalHeight rect7, 1 # blue\n      line.addMorphProportionalHeight rect5, 3 # red\n      #line.addMorphFixedHeight rect5, 10 # red\n\n    #line.addMorphProportionalWidth rect7, 1\n    line.layoutSubmorphs()\n    line.fullRawMoveTo new Point 210,10\n    line.fullRawMoveWithin world\n    world.add line\n    line.changed()\n\n    # attach a HandleMorph to it so that\n    # we can check how it resizes\n    new HandleMorph line\n\n  @testScenario4: (direction = "#horizontal")->\n    # //////////////////////////////////////////////////\n    # note how the vertical spacing in the horizontal layout\n    # is different. the vertical size is not adjusted considering\n    # all other morphs. A proportional of 1.1 is proportional to the\n    # container, not to the other layouts.\n    # Equivalent smalltalk code:\n    # | pane rect1 rect2 |\n    # pane _ LinearLayoutMorph newRow separation: 5. "3"\n    # pane addMorph: (StringMorph contents: \'3\').\n    # \n    # rect1 := BorderedRectMorph new color: (Color lightOrange).\n    # pane addMorph: rect1 \n    #          linearLinearLayoutSpec: (LinearLayoutSpec  fixedWidth: 20 proportionalHeight: 1.1 minorDirectionFloat: #center).\n    # rect2 := BorderedRectMorph new color: (Color cyan);\n    #   linearLinearLayoutSpec: (LinearLayoutSpec  fixedWidth: 20 proportionalHeight: 0.5 minorDirectionFloat: #center).\n    # pane addMorph: rect2.\n    # pane\n    #   color: Color lightGreen;\n    #   openInWorld;\n    #   morphPosition: 520 @ 50;\n    #   morphExtent: 180 @ 100\n    # //////////////////////////////////////////////////\n\n    rect5 = new RectangleMorph new Point(20,20), new Color(255,0,0)\n    rect6 = new RectangleMorph new Point(20,20), new Color(0,255,0)\n    rect7 = new RectangleMorph new Point(20,20), new Color(0,0,255)\n\n    if direction == "#horizontal"\n      line = LinearLayoutMorph.newRow()\n      line.addMorphProportionalWidth rect6, 0.5 # green\n      line.addMorphFixedWidth rect5, 20 # red\n      line.addMorphProportionalWidth rect7, 1.0 # blue\n    else\n      line = LinearLayoutMorph.newColumn()\n      line.addMorphProportionalHeight rect6, 0.5 # green\n      line.addMorphFixedHeight rect5, 20 # red\n      line.addMorphProportionalHeight rect7, 1.0 # blue\n \n    line.layoutSubmorphs()\n    line.fullRawMoveTo new Point 310, 10\n    line.fullRawMoveWithin world\n    world.add line\n    line.changed()\n\n    # attach a HandleMorph to it so that\n    # we can check how it resizes\n    new HandleMorph line\n\n  @testScenario5: (direction = "#horizontal")->\n    rect5 = new RectangleMorph new Point(20,20), new Color(255,0,0)\n    rect6 = new RectangleMorph new Point(20,20), new Color(0,255,0)\n    rect7 = new RectangleMorph new Point(20,20), new Color(0,0,255)\n\n    if direction == "#horizontal"\n      line = LinearLayoutMorph.newRow()\n      line.addMorphProportionalWidth rect6, 0.5 # green\n      line.addMorphProportionalWidth rect7, 1.0 # blue\n      line.addAdjusterAndMorphFixedWidth rect5, 20 # red\n    else\n      line = LinearLayoutMorph.newColumn()\n      line.addMorphProportionalHeight rect6, 0.5 # green\n      line.addMorphProportionalHeight rect7, 1.0 # blue\n      line.addAdjusterAndMorphFixedHeight rect5, 20 # red\n\n    line.layoutSubmorphs()\n    line.fullRawMoveTo new Point 410, 10\n    line.fullRawMoveWithin world\n    world.add line\n    line.changed()\n\n    # attach a HandleMorph to it so that\n    # we can check how it resizes\n    new HandleMorph line\n\n  @testScenario6: (direction = "#horizontal")->\n    rect5 = new RectangleMorph new Point(20,20), new Color(255,0,0)\n    rect6 = new RectangleMorph new Point(20,20), new Color(0,255,0)\n\n    if direction == "#horizontal"\n      line = LinearLayoutMorph.newRow()\n      line.addMorphProportionalWidth rect6, 0.5 # green\n      line.addMorphFixedWidth rect5, 20 # red\n    else\n      line = LinearLayoutMorph.newColumn()\n      line.addMorphProportionalHeight rect6, 0.5 # green\n      line.addMorphFixedHeight rect5, 20 # red\n\n    line.layoutSubmorphs()\n    line.fullRawMoveTo new Point 510, 10\n    line.fullRawMoveWithin world\n    world.add line\n    line.changed()\n\n    # attach a HandleMorph to it so that\n    # we can check how it resizes\n    new HandleMorph line\n';
