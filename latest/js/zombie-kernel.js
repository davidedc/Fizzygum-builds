// Generated by CoffeeScript 1.7.1
var Arg, Args, BasicCalculatedVal, BlinkerMorph, BouncerMorph, BoxMorph, CaretMorph, CircleBoxMorph, Color, ColorPaletteMorph, ColorPickerMorph, ContainerMixin, ControllerMixin, FrameMorph, GrayPaletteMorph, GroundVal, HandMorph, HandleMorph, HashCalculator, InspectorMorph, LayoutAdjustingMorph, LayoutMorph, LayoutSpec, ListMorph, MenuItemMorph, MenuMorph, MixedClassKeywords, Morph, MorphicNode, MorphsListMorph, MouseSensorMorph, Mousetrap, PenMorph, Point, Point2, PreferencesAndSettings, ProfilerData, ProfilingDataCollector, ReactiveValuesTests, ReactiveValuesTestsRectangleMorph, Rectangle, RectangleMorph, ScrollFrameMorph, ShadowMorph, SliderButtonMorph, SliderMorph, SpeechBubbleMorph, StringFieldMorph, StringMorph, SystemInfo, SystemTestsCommand, SystemTestsCommandCheckNumberOfItemsInMenu, SystemTestsCommandCheckStringsOfItemsInMenuOrderImportant, SystemTestsCommandCheckStringsOfItemsInMenuOrderUnimportant, SystemTestsCommandCopy, SystemTestsCommandDoNothing, SystemTestsCommandKeyDown, SystemTestsCommandKeyPress, SystemTestsCommandKeyUp, SystemTestsCommandLeftOrRightClickOnMenuItem, SystemTestsCommandMouseDown, SystemTestsCommandMouseMove, SystemTestsCommandMouseUp, SystemTestsCommandOpenContextMenu, SystemTestsCommandPaste, SystemTestsCommandResetWorld, SystemTestsCommandScreenshot, SystemTestsCommandShowComment, SystemTestsCommandTurnOffAlignmentOfMorphIDsMechanism, SystemTestsCommandTurnOffAnimationsPacingControl, SystemTestsCommandTurnOffHidingOfMorphsContentExtractInLabels, SystemTestsCommandTurnOffHidingOfMorphsGeometryInfoInLabels, SystemTestsCommandTurnOffHidingOfMorphsNumberIDInLabels, SystemTestsCommandTurnOnAlignmentOfMorphIDsMechanism, SystemTestsCommandTurnOnAnimationsPacingControl, SystemTestsCommandTurnOnHidingOfMorphsContentExtractInLabels, SystemTestsCommandTurnOnHidingOfMorphsGeometryInfoInLabels, SystemTestsCommandTurnOnHidingOfMorphsNumberIDInLabels, SystemTestsControlPanelUpdater, SystemTestsRecorderAndPlayer, SystemTestsReferenceImage, SystemTestsSystemInfo, TextMorph, TriggerMorph, WorkspaceMorph, WorldMorph, arrayShallowCopy, arrayShallowCopyAndReverse, contains, degrees, detect, fontHeight, getBlurredShadowSupport, getDocumentPositionOf, getMinimumFontHeight, hashCode, i, isFunction, isNil, isObject, isString, localize, morphicVersion, newCanvas, noOperation, nop, radians, sizeOf, _KEYCODE_MAP, _MAP, _REVERSE_MAP, _SHIFT_MAP, _SPECIAL_ALIASES, _addEvent, _bindMultiple, _bindSequence, _bindSingle, _callbacks, _characterFromEvent, _directMap, _eventModifiers, _fireCallback, _getMatches, _getReverseMap, _handleCharacter, _handleKey, _ignoreNextKeyup, _isModifier, _modifiersMatch, _pickBestAction, _resetSequenceTimer, _resetSequences, _resetTimer, _sequenceLevels, _sequenceType,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

ProfilerData = (function() {
  function ProfilerData() {}

  ProfilerData.reactiveValues_valueRecalculations = 0;

  ProfilerData.reactiveValues_signatureCalculations = 0;

  ProfilerData.reactiveValues_signatureComparison = 0;

  ProfilerData.reactiveValues_argumentInvalidations = 0;

  ProfilerData.reactiveValues_valueInvalidations = 0;

  ProfilerData.reactiveValues_parentValuesRechecks = 0;

  ProfilerData.reactiveValues_createdGroundVals = 0;

  ProfilerData.reactiveValues_createdBasicCalculatedValues = 0;

  ProfilerData.resetReactiveValuesCounts = function() {
    this.reactiveValues_valueRecalculations = 0;
    this.reactiveValues_signatureCalculations = 0;
    this.reactiveValues_signatureComparison = 0;
    this.reactiveValues_argumentInvalidations = 0;
    this.reactiveValues_valueInvalidations = 0;
    this.reactiveValues_parentValuesRechecks = 0;
    this.reactiveValues_createdGroundVals = 0;
    return this.reactiveValues_createdBasicCalculatedValues = 0;
  };

  ProfilerData.coffeeScriptSourceOfThisClass = 'class ProfilerData\n  \n  @reactiveValues_valueRecalculations: 0\n  @reactiveValues_signatureCalculations: 0\n  @reactiveValues_signatureComparison: 0\n  @reactiveValues_argumentInvalidations: 0\n  @reactiveValues_valueInvalidations: 0\n  @reactiveValues_parentValuesRechecks: 0\n  @reactiveValues_createdGroundVals: 0\n  @reactiveValues_createdBasicCalculatedValues: 0\n\n  @resetReactiveValuesCounts: ->\n    @reactiveValues_valueRecalculations = 0\n    @reactiveValues_signatureCalculations = 0\n    @reactiveValues_signatureComparison = 0\n    @reactiveValues_argumentInvalidations = 0\n    @reactiveValues_valueInvalidations = 0\n    @reactiveValues_parentValuesRechecks = 0\n    @reactiveValues_createdGroundVals = 0\n    @reactiveValues_createdBasicCalculatedValues = 0\n\n';

  return ProfilerData;

})();

Arg = (function() {
  Arg.prototype.valWrappedByThisArg = null;

  Arg.prototype.maybeChangedSinceLastCalculation = true;

  Arg.prototype.directlyCalculatedFromParent = false;

  Arg.prototype.fromChild = false;

  Arg.prototype.fromLocal = false;

  Arg.prototype.directlyOrIndirectlyCalculatedFromParent = false;

  Arg.prototype.morphContainingThisArg = null;

  Arg.prototype.args = null;

  Arg.prototype.markedForRemoval = false;

  Arg.signatureAtLastCalculation = "";

  Arg.id = "";

  function Arg(valWrappedByThisArg, valContainingThisArg) {
    this.valWrappedByThisArg = valWrappedByThisArg;
    this.valContainingThisArg = valContainingThisArg;
    this.morphContainingThisArg = this.valContainingThisArg.ownerMorph;
    this.args = this.valContainingThisArg.args;
    this.id = this.valWrappedByThisArg.id;
    this.args.argById[this.id] = this;
  }

  Arg.prototype.fetchVal = function() {
    return this.valWrappedByThisArg.fetchVal();
  };

  Arg.prototype.getSignatureOrCustomSignatureOfWrappedVal = function() {
    var theValSignature;
    if (this.args.customSignatureMethod != null) {
      theValSignature = this.args.customSignatureMethod(valWrappedByThisArg);
    } else {
      theValSignature = this.valWrappedByThisArg.lastCalculatedValContent.signature;
      if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
        console.log("fetching default signature of argument: " + this.id + " : " + theValSignature);
      }
    }
    theValSignature = theValSignature + this.markedForRemoval;
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      console.log("calculated signature of argument: " + this.id + " : " + theValSignature);
    }
    return theValSignature;
  };

  Arg.prototype.semanticallyChangedSinceLastValCalculation = function() {
    if (this.getSignatureOrCustomSignatureOfWrappedVal() !== this.signatureAtLastCalculation) {
      return true;
    } else {
      return false;
    }
  };

  Arg.prototype.checkBasedOnSignature = function() {
    var signatureOfArgUsedInLastCalculation;
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      console.log("checking signature of argument: " + this.id);
    }
    signatureOfArgUsedInLastCalculation = this.signatureAtLastCalculation;
    if (signatureOfArgUsedInLastCalculation === void 0) {
      if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
        console.log("argument: " + this.id + " is undefined, breaking and returning ");
      }
      this["break"]();
      return void 0;
    }
    if (this.valWrappedByThisArg.lastCalculatedValContentMaybeOutdated) {
      if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
        console.log("argument: " + this.id + " is broken on its own anyways, breaking this arg");
      }
      return this["break"]();
    } else {
      if (this.semanticallyChangedSinceLastValCalculation()) {
        if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
          console.log("argument: " + this.id + " has equal signature to one used for last calculation, healing");
        }
        return this.heal();
      } else {
        if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
          console.log("argument: " + this.id + " has different signature to one used for last calculation, breaking");
        }
        return this["break"]();
      }
    }
  };

  Arg.prototype.updateSignature = function() {
    var newSig, oldSig, signatureChanged;
    oldSig = this.signatureAtLastCalculation;
    newSig = this.getSignatureOrCustomSignatureOfWrappedVal();
    signatureChanged = false;
    if (newSig !== oldSig) {
      signatureChanged = true;
    }
    this.signatureAtLastCalculation = newSig;
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      if (signatureChanged) {
        console.log("checked signature of argument: " + this.id + " and it changed was: " + oldSig + " now is: " + newSig);
      } else {
        console.log("checked signature of argument: " + this.id + " and it didn't change was: " + oldSig + " now is: " + newSig);
      }
    }
    return signatureChanged;
  };

  Arg.prototype.updateSignatureAndHeal = function() {
    var signatureChanged;
    signatureChanged = this.updateSignature();
    this.heal();
    return signatureChanged;
  };

  Arg.prototype.heal = function() {
    this.maybeChangedSinceLastCalculation = false;
    delete this.args.argsMaybeChangedSinceLastCalculationById[this.id];
    this.args.countOfDamaged--;
    if (!this.valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal) {
      return this.valContainingThisArg.checkAndPropagateChangeBasedOnArgChange();
    }
  };

  Arg.prototype["break"] = function() {
    this.maybeChangedSinceLastCalculation = true;
    this.args.argsMaybeChangedSinceLastCalculationById[this.id] = true;
    this.args.countOfDamaged++;
    if (!this.valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal) {
      return this.valContainingThisArg.checkAndPropagateChangeBasedOnArgChange();
    }
  };

  Arg.prototype.markForRemoval = function() {
    this.markedForRemoval = true;
    this.turnIntoArgNotDirectlyNorIndirectlyDependingOnParent();
    return this.morphContainingThisArg.argMightHaveChanged(valWrappedByThisArg);
  };

  Arg.prototype.unmarkForRemoval = function() {
    return this.markedForRemoval = false;
  };

  Arg.prototype.removeArgIfMarkedForRemoval = function() {
    if (this.markedForRemoval) {
      this.removeFromArgs();
      return true;
    } else {
      return false;
    }
  };

  Arg.prototype.removeFromArgs = function() {
    delete this.args.argById[this.id];
    if (this.args.argsMaybeChangedSinceLastCalculationById[this.id] != null) {
      delete this.args.argsMaybeChangedSinceLastCalculationById[this.id];
      return this.args.countOfDamaged--;
    }
  };

  Arg.prototype.disconnectChildArg = function() {
    this.fromChild = false;
    delete this.args.childrenArgByName[this.valContainingThisArg.valName];
    this.args.childrenArgByNameCount[this.valContainingThisArg.valName]--;
    return this.markForRemoval();
  };

  Arg.prototype.disconnectParentArg = function() {
    this.directlyCalculatedFromParent = false;
    this.directlyOrIndirectlyCalculatedFromParent = true;
    delete this.args.parentArgByName[this.valContainingThisArg.valName];
    return this.markForRemoval();
  };

  Arg.prototype.turnIntoArgDirectlyOrIndirectlyDependingOnParent = function() {
    var cv, k, v, _i, _j, _len, _len1, _ref, _results;
    this.args.calculatedDirectlyOfIndirectlyFromParentById[this.valWrappedByThisArg.id] = true;
    if (this.args.calculatedDirectlyOfIndirectlyFromParentById[this.valWrappedByThisArg.id] == null) {
      this.args.calculatedDirectlyOfIndirectlyFromParentByIdCount++;
    }
    this.valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal = true;
    this.directlyOrIndirectlyCalculatedFromParent = true;
    _ref = this.valContainingThisArg.localValsAffectedByChangeOfThisVal;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cv = _ref[_i];
      cv.stainValCalculatedFromParent(this.valContainingThisArg);
    }
    if (this.ownerMorph.parent != null) {
      v = this.morphContainingThisArg.parent.morphValsDependingOnChildrenVals[this.valName];
      _results = [];
      for (_j = 0, _len1 = v.length; _j < _len1; _j++) {
        k = v[_j];
        _results.push(k.stainValCalculatedFromParent(this.valContainingThisArg));
      }
      return _results;
    }
  };

  Arg.prototype.turnIntoArgNotDirectlyNorIndirectlyDependingOnParent = function() {
    var cv, k, v, _i, _j, _len, _len1, _ref, _results;
    if (this.args.calculatedDirectlyOfIndirectlyFromParentById[this.valWrappedByThisArg.id] != null) {
      this.args.calculatedDirectlyOfIndirectlyFromParentByIdCount--;
    }
    delete this.args.calculatedDirectlyOfIndirectlyFromParentById[this.valWrappedByThisArg.id];
    this.directlyOrIndirectlyCalculatedFromParent = false;
    if (this.args.calculatedDirectlyOfIndirectlyFromParentByIdCount > 0) {
      this.valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal = false;
      _ref = this.valContainingThisArg.localValsAffectedByChangeOfThisVal;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        cv = _ref[_i];
        cv.unstainValCalculatedFromParent(this.valContainingThisArg);
      }
      if (this.valContainingThisArg.ownerMorph.parent != null) {
        v = this.morphContainingThisArg.parent.morphValsDependingOnChildrenVals[this.valContainingThisArg.valName];
        _results = [];
        for (_j = 0, _len1 = v.length; _j < _len1; _j++) {
          k = v[_j];
          _results.push(k.unstainValCalculatedFromParent(this.valContainingThisArg));
        }
        return _results;
      }
    }
  };

  Arg.coffeeScriptSourceOfThisClass = '# an Arg wraps a Val that is an input to the\n# calculation of the current Val.\n# an Arg for example contains the signature that\n# the input val had when the Val was calculated.\n# The signature could be a custom signature that is\n# only relevant to this Val. So it contains several\n# pieces of information about each input val, that are\n# specific to the context of this Val (hence, we\n# can\'t put it in the input arg val, we need to\n# put this Arg which lives in the context of this\n# Val).\n\n# REQUIRES ProfilerData\n\nclass Arg\n  valWrappedByThisArg: null\n  maybeChangedSinceLastCalculation: true\n  \n  # an argument can either be\n  #  1. connected to a parent\n  #  2. connected to a child\n  #  3. connected to a local value\n  # and this is determined when the\n  # value that depends on this argument is created.\n  # (the parent/child is dynamic, but the nature of\n  # the argument is decided early)\n  directlyCalculatedFromParent: false\n  fromChild: false\n  fromLocal: false\n\n  # this flag tracks whether this argument\n  # directly or indirectly depends on a parent\n  # value. So if @directlyCalculatedFromParent is true\n  # then this is true as well. But this could be true\n  # even is @directlyCalculatedFromParent is false,\n  # because you could have an argument which\n  # is connected to a value in a child BUT\n  # that value might directly or indirectly\n  # depend on a parent value at some stage.\n  directlyOrIndirectlyCalculatedFromParent: false\n  \n  morphContainingThisArg: null\n  args: null\n  markedForRemoval: false\n  # we keep the vals of the args we\n  # used to calculate the last val. This is so\n  # we can keep an eye on how the args\n  # change. If they change back to the original\n  # vals we used then we can propagate this\n  # "OK our last calculation actually holds"\n  # information WITHOUT triggering a recalculation.\n  @signatureAtLastCalculation: ""\n  @id: ""\n\n  constructor: (@valWrappedByThisArg, @valContainingThisArg) ->\n    @morphContainingThisArg = @valContainingThisArg.ownerMorph\n    @args = @valContainingThisArg.args\n    @id = @valWrappedByThisArg.id\n    @args.argById[@id] = @\n\n  fetchVal: () ->\n    @valWrappedByThisArg.fetchVal()\n\n  ################################################\n  #  signature checking / calculation\n  ################################################\n\n  # we give the opportunity to specify a custom signature\n  # for args, in case we have a signature that\n  # is more efficient considering the type of\n  # calculation that we are going to do\n  getSignatureOrCustomSignatureOfWrappedVal: () ->\n    if @args.customSignatureMethod?\n      theValSignature = @args.customSignatureMethod valWrappedByThisArg\n    else\n      theValSignature = @valWrappedByThisArg.lastCalculatedValContent.signature\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "fetching default signature of argument: " + @id + " : " + theValSignature\n    theValSignature = theValSignature + @markedForRemoval\n\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "calculated signature of argument: " + @id + " : " + theValSignature\n\n    return theValSignature\n\n  semanticallyChangedSinceLastValCalculation: () ->\n    if @getSignatureOrCustomSignatureOfWrappedVal() != @signatureAtLastCalculation\n      return true\n    else\n      return false\n\n  # an Argument of this value has notified its change\n  # but we want to check, based on either its default\n  # signature or a custom signature, wether its\n  # value changed from when we calculated this value\n  # the last time. Following this check, we might\n  # "heal"/break the value and potentially\n  # propagate the change\n  checkBasedOnSignature: () ->\n\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "checking signature of argument: " + @id\n\n    # the unique identifier of a val is given by\n    # its name as a string and the id of the Morph it\n    # belongs to. For localVals this is ever so slightly\n    # inneficient as you could always index them through\n    # an integer, which would be faster, but probably\n    # the improvement would be "in the noise".\n    signatureOfArgUsedInLastCalculation =\n      @signatureAtLastCalculation\n    # this is the case where a child has been added:\n    # the arg wasn\'t there before\n    if signatureOfArgUsedInLastCalculation == undefined\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "argument: " + @id + " is undefined, breaking and returning "\n      @break()\n      return undefined\n\n    # if the arg which has maybe changed doesn\'t know\n    # its val then we just mark the arg as broken\n    # and we do nothing else\n    if @valWrappedByThisArg.lastCalculatedValContentMaybeOutdated\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "argument: " + @id + " is broken on its own anyways, breaking this arg"\n      @break()\n    else\n      # if the val that asserts change claims that its val\n      # is actually correct then we proceed to check its\n      # signature to check whether it changed since the\n      # last time we calculated our val.\n      # We let the user provide her own signature calculation\n      # method for args: this is because for the purpose of\n      # the calculation of this val, there might be a better\n      # notion of equivalency of the args that lets us be\n      # more tolerant of changes (which means less invalidation which\n      # means less recalculations which means fewer invalidations further\n      # on). An example of such "wider" equivalency is for the HSV color\n      # values if we need to convert them to RGB. Every HSV value\n      # with V set to zero is equivalent in this respect because it\n      # always means black.\n      if @semanticallyChangedSinceLastValCalculation()\n        # argsMaybeChangedSinceLastCalculation is an object, we add\n        # a property to it for each dirty arg, so we delete\n        # such property when we verify it\'s actually healthy.\n        if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n          console.log "argument: " + @id + " has equal signature to one used for last calculation, healing"\n        @heal()\n      else\n        if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n          console.log "argument: " + @id + " has different signature to one used for last calculation, breaking"\n        @break()\n\n\n  updateSignature: () ->\n    oldSig = @signatureAtLastCalculation\n    newSig = @getSignatureOrCustomSignatureOfWrappedVal()\n    signatureChanged = false\n    if newSig != oldSig\n        signatureChanged = true\n    @signatureAtLastCalculation = newSig\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      if signatureChanged\n      	console.log "checked signature of argument: " + @id + " and it changed was: " + oldSig + " now is: " + newSig\n      else\n      	console.log "checked signature of argument: " + @id + " and it didn\'t change was: " + oldSig + " now is: " + newSig\n    return signatureChanged\n\n  updateSignatureAndHeal: () ->\n    signatureChanged = @updateSignature()\n    @heal()\n    return signatureChanged\n\n\n  ################################################\n  #  breaking / healing\n  ################################################\n\n  heal: () ->\n    @maybeChangedSinceLastCalculation = false\n    delete @args.argsMaybeChangedSinceLastCalculationById[@id]\n    @args.countOfDamaged--\n    # check implications of argument being healed: it\n    # might be that this means that the value heals as\n    # well and propagates healing\n    if !@valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal\n      @valContainingThisArg.checkAndPropagateChangeBasedOnArgChange()\n\n  break: () ->\n    @maybeChangedSinceLastCalculation = true\n    @args.argsMaybeChangedSinceLastCalculationById[@id] = true\n    @args.countOfDamaged++\n    # check implications of argument being broken: it\n    # might be that this means that the value breaks as\n    # well and propagates damage\n    if !@valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal\n      @valContainingThisArg.checkAndPropagateChangeBasedOnArgChange()\n\n\n  ################################################\n  #  removal\n  ################################################\n\n  # we don\'t completely destroy the argument\n  # (lieke removeFromArgs does)\n  # for the simple reason that we do need to\n  # remember its signature when the value\n  # was last calculated.\n  markForRemoval: () ->\n    @markedForRemoval = true\n    @turnIntoArgNotDirectlyNorIndirectlyDependingOnParent()\n    @morphContainingThisArg.argMightHaveChanged(valWrappedByThisArg)\n\n  unmarkForRemoval: () ->\n    @markedForRemoval = false\n\n  removeArgIfMarkedForRemoval: () ->\n    if @markedForRemoval\n      @removeFromArgs()\n      return true\n    else\n      return false\n\n  removeFromArgs: () ->\n    #@turnIntoArgNotDirectlyNorIndirectlyDependingOnParent()\n    delete @args.argById[@id]\n    if @args.argsMaybeChangedSinceLastCalculationById[@id]?\n      delete @args.argsMaybeChangedSinceLastCalculationById[@id]\n      @args.countOfDamaged--\n\n\n\n  ################################################\n  #  disconnection\n  ################################################\n\n  disconnectChildArg: () ->\n    @fromChild = false\n    delete @args.childrenArgByName[@valContainingThisArg.valName]\n    @args.childrenArgByNameCount[@valContainingThisArg.valName]--\n    @markForRemoval()\n\n  disconnectParentArg: () ->\n    @directlyCalculatedFromParent = false\n    @directlyOrIndirectlyCalculatedFromParent = true\n    delete @args.parentArgByName[@valContainingThisArg.valName]\n    @markForRemoval()\n\n  ################################################\n  #  (un)turning into argument\n  #  directly or indirectly depending on parent\n  ################################################\n\n  turnIntoArgDirectlyOrIndirectlyDependingOnParent: () ->\n    @args.calculatedDirectlyOfIndirectlyFromParentById[@valWrappedByThisArg.id] = true\n    if !@args.calculatedDirectlyOfIndirectlyFromParentById[@valWrappedByThisArg.id]?\n        @args.calculatedDirectlyOfIndirectlyFromParentByIdCount++\n    @valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal = true\n    @directlyOrIndirectlyCalculatedFromParent = true\n\n    for cv in @valContainingThisArg.localValsAffectedByChangeOfThisVal\n      cv.stainValCalculatedFromParent @valContainingThisArg\n    if @ownerMorph.parent?\n      v = @morphContainingThisArg.parent.morphValsDependingOnChildrenVals[@valName]\n      for k in v\n        k.stainValCalculatedFromParent @valContainingThisArg\n\n\n\n  turnIntoArgNotDirectlyNorIndirectlyDependingOnParent: () ->\n    # note that we might turn also an Argument that we know\n    # directly depends on a parent. The reason is that\n    # we might be removing the parent, in which case\n    # this morph might cease to depend on parent values.\n    # we need to find out by doing the full works here.\n\n    # this changes @directlyOrIndirectlyDependsOnAParentVal if there are no\n    # more args depending on parent vals\n    if @args.calculatedDirectlyOfIndirectlyFromParentById[@valWrappedByThisArg.id]?\n        @args.calculatedDirectlyOfIndirectlyFromParentByIdCount--\n    delete @args.calculatedDirectlyOfIndirectlyFromParentById[@valWrappedByThisArg.id]\n    @directlyOrIndirectlyCalculatedFromParent = false\n\n    if @args.calculatedDirectlyOfIndirectlyFromParentByIdCount > 0\n      @valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal = false\n\n      # this means that the arg that has unstained itself\n      # was the last and only reason why this val was stained\n      # so we proceed to unstain ourselves\n      for cv in @valContainingThisArg.localValsAffectedByChangeOfThisVal\n        cv.unstainValCalculatedFromParent @valContainingThisArg\n      if @valContainingThisArg.ownerMorph.parent?\n        v = @morphContainingThisArg.parent.morphValsDependingOnChildrenVals[@valContainingThisArg.valName]\n        for k in v\n          k.unstainValCalculatedFromParent @valContainingThisArg';

  return Arg;

})();

Args = (function() {
  Args.prototype.argById = null;

  Args.prototype.parentArgByName = null;

  Args.prototype.childrenArgByName = null;

  Args.prototype.childrenArgByNameCount = null;

  Args.prototype.localArgByName = null;

  Args.prototype.calculatedDirectlyOfIndirectlyFromParentById = null;

  Args.prototype.calculatedDirectlyOfIndirectlyFromParentByIdCount = 0;

  Args.prototype.countOfDamaged = 0;

  Args.prototype.morphContainingTheseArgs = null;

  Args.prototype.argsMaybeChangedSinceLastCalculationById = null;

  function Args(valContainingTheseArgs) {
    this.valContainingTheseArgs = valContainingTheseArgs;
    this.argById = {};
    this.parentArgByName = {};
    this.childrenArgByName = {};
    this.childrenArgByNameCount = {};
    this.localArgByName = {};
    this.calculatedDirectlyOfIndirectlyFromParentById = {};
    this.argsMaybeChangedSinceLastCalculationById = {};
    this.morphContainingTheseArgs = this.valContainingTheseArgs.ownerMorph;
  }

  Args.prototype.healAll = function() {
    var eachArg, _results;
    _results = [];
    for (eachArg in argsMaybeChangedSinceLastCalculationById) {
      _results.push(eachArg.heal());
    }
    return _results;
  };

  Args.prototype.getByVal = function(theVal) {
    return this.getById(theVal.id);
  };

  Args.prototype.setup_AddAllLocalArgVals = function(localInputVals) {
    var each, newArg, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = localInputVals.length; _i < _len; _i++) {
      each = localInputVals[_i];
      each.localValsAffectedByChangeOfThisVal.push(this.valContainingTheseArgs);
      newArg = new Arg(localInputVals, this.valContainingTheseArgs);
      newArg.fromLocal = true;
      _results.push(this.localArgByName[localInputVals.valueName] = newArg);
    }
    return _results;
  };

  Args.prototype.setup_AddAllParentArgNames = function(parentArgsNames) {
    var eachVar, _base, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = parentArgsNames.length; _i < _len; _i++) {
      eachVar = parentArgsNames[_i];
      if ((_base = this.morphContainingTheseArgs.morphValsDirectlyDependingOnParentVals)[eachVar] == null) {
        _base[eachVar] = {};
      }
      _results.push(this.morphContainingTheseArgs.morphValsDirectlyDependingOnParentVals[eachVar][this.valContainingTheseArgs.valName] = this.valContainingTheseArgs);
    }
    return _results;
  };

  Args.prototype.setup_AddAllChildrenArgNames = function(childrenArgsNames) {
    var eachVar, _base, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = childrenArgsNames.length; _i < _len; _i++) {
      eachVar = childrenArgsNames[_i];
      if ((_base = this.morphContainingTheseArgs.morphValsDependingOnChildrenVals)[eachVar] == null) {
        _base[eachVar] = {};
      }
      _results.push(this.morphContainingTheseArgs.morphValsDependingOnChildrenVals[eachVar][this.valContainingTheseArgs.valName] = this.valContainingTheseArgs);
    }
    return _results;
  };

  Args.prototype.tryToReconnectDisconnectedArgFirst = function(parentOrChildVal) {
    var existingArg;
    existingArg = this.argById[parentOrChildVal.id];
    if (existingArg != null) {
      existingArg.markedForRemoval = false;
      existingArg.valContainingThisArg.argMightHaveChanged(parentOrChildVal);
      return existingArg;
    }
    return null;
  };

  Args.prototype.connectToChildVal = function(valDependingOnChildrenVal, childVal) {
    var argumentToBeConnected, _base, _base1, _name, _name1;
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      console.log("connecting " + valDependingOnChildrenVal.valName + " in morph " + valDependingOnChildrenVal.ownerMorph.uniqueIDString() + " to receive input from " + childVal.valName + " in morph " + childVal.ownerMorph.uniqueIDString());
    }
    argumentToBeConnected = this.tryToReconnectDisconnectedArgFirst(childVal);
    if (argumentToBeConnected == null) {
      argumentToBeConnected = new Arg(childVal, valDependingOnChildrenVal);
    }
    argumentToBeConnected.fromChild = true;
    if ((_base = this.childrenArgByName)[_name = childVal.valName] == null) {
      _base[_name] = {};
    }
    this.childrenArgByName[childVal.valName][childVal.id] = argumentToBeConnected;
    if ((_base1 = this.childrenArgByNameCount)[_name1 = childVal.valName] == null) {
      _base1[_name1] = 0;
    }
    this.childrenArgByNameCount[childVal.valName]++;
    if (childVal.directlyOrIndirectlyDependsOnAParentVal) {
      this.valContainingTheseArgs.stainValCalculatedFromParent(childVal);
    }
    return argumentToBeConnected.args.argFromChildMightHaveChanged(childVal);
  };

  Args.prototype.connectToParentVal = function(valDependingOnParentVal, parentVal) {
    var argumentToBeConnected;
    argumentToBeConnected = this.tryToReconnectDisconnectedArgFirst(childVal);
    if (argumentToBeConnected == null) {
      argumentToBeConnected = new Arg(childVal, valDependingOnParentVal);
    }
    argumentToBeConnected.directlyCalculatedFromParent = true;
    return argumentToBeConnected.turnIntoArgDirectlyOrIndirectlyDependingOnParent();
  };

  Args.prototype.argFromChildMightHaveChanged = function(childValThatMightHaveChanged) {
    var arg;
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      console.log("marking child value " + childValThatMightHaveChanged.valName + " in morph " + childValThatMightHaveChanged.ownerMorph.uniqueIDString() + " as \"might have changed\" ");
    }
    arg = this.argById[childValThatMightHaveChanged.id];
    if ((arg == null) || this.holdOffFromPropagatingChanges) {
      return;
    }
    if (arg.markedForRemoval) {
      return;
    }
    if (arg.maybeChangedSinceLastCalculation && childValThatMightHaveChanged.ownerMorph.parent === this.morphContainingTheseArgs) {
      arg.checkBasedOnSignature();
    } else if (arg.maybeChangedSinceLastCalculation && childValThatMightHaveChanged.ownerMorph.parent !== this.morphContainingTheseArgs) {
      arg["break"]();
    } else if (!arg.maybeChangedSinceLastCalculation && childValThatMightHaveChanged.ownerMorph.parent === this.morphContainingTheseArgs) {
      add(the(data(structures && mark(it(as(dirty && signature(void 0)))))));
    } else if (!arg.maybeChangedSinceLastCalculation && childValThatMightHaveChanged.ownerMorph.parent !== this.morphContainingTheseArgs) {
      this(should(never(happen)));
    }
    if (!this.valContainingTheseArgs.directlyOrIndirectlyDependsOnAParentVal) {
      return this.valContainingTheseArgs.checkAndPropagateChangeBasedOnArgChange();
    }
  };

  Args.prototype.fetchAllArgsDirectlyOrIndirectlyCalculatedFromParent = function() {
    var argCalculatedFromParent, idNotUsed, oneOrMoreArgsHaveActuallyChanged, _ref;
    oneOrMoreArgsHaveActuallyChanged = false;
    _ref = this.calculatedDirectlyOfIndirectlyFromParentById;
    for (idNotUsed in _ref) {
      argCalculatedFromParent = _ref[idNotUsed];
      if (argCalculatedFromParent.removeArgIfMarkedForRemoval()) {
        continue;
      }
      argCalculatedFromParent.fetchVal();
      oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged || argCalculatedFromParent.updateSignatureAndHeal();
    }
    return oneOrMoreArgsHaveActuallyChanged;
  };

  Args.prototype.fetchAllRemainingArgsNeedingRecalculation = function() {
    var maybeModifiedArg, maybeModifiedArgId, oneOrMoreArgsHaveActuallyChanged;
    this.holdOffFromPropagatingChanges = true;
    oneOrMoreArgsHaveActuallyChanged = false;
    for (maybeModifiedArgId in this.argsMaybeChangedSinceLastCalculationById) {
      maybeModifiedArg = this.argById[maybeModifiedArgId];
      if (maybeModifiedArg.removeArgIfMarkedForRemoval()) {
        continue;
      }
      if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
        console.log("fetching potentially changed input: " + maybeModifiedArg.id);
      }
      debugger;
      maybeModifiedArg.fetchVal();
      oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged || maybeModifiedArg.updateSignature();
    }
    return oneOrMoreArgsHaveActuallyChanged;
    this.args.healAll();
    return this.holdOffFromPropagatingChanges = false;
  };

  Args.coffeeScriptSourceOfThisClass = '# Args are the input based on which a val is calculated\n# There are several pieces of "aggregate" information that\n# we keep about args considered together e.g. whether\n# any of them has changed since the last calculation of the\n# Val, or which ones directly or indirectly depend on a Parent\n# Val.\n\n# REQUIRES ProfilerData\n\nclass Args\n  # some accessors gere to get to the\n  # actual arguments. You can get to all\n  # of them by Id of the Value\n  # or, in the care of an argument connected\n  # to a parent morph, by the value name\n  # (since there is only one Arg connected\n  # to the parent for each value name, which is\n  # not the case for children Args as\n  # onviously you may have many children and hence\n  # many arguments)\n  argById: null\n  parentArgByName: null\n  childrenArgByName: null\n  # we want to group together all children\n  # values under the same name\n  # so we keep this count separate\n  # rather than counting navigating the keys\n  childrenArgByNameCount: null\n  localArgByName: null\n  calculatedDirectlyOfIndirectlyFromParentById: null\n  calculatedDirectlyOfIndirectlyFromParentByIdCount: 0\n\n  countOfDamaged: 0\n  morphContainingTheseArgs: null\n\n  # just some flags to keep track of which\n  # args might have changed. Again, we might\n  # not know for sure because we don\'t necessarily\n  # recalculate them\n  argsMaybeChangedSinceLastCalculationById: null\n\n  constructor: (@valContainingTheseArgs) ->\n    @argById = {}\n    @parentArgByName = {}\n    @childrenArgByName = {}\n    @childrenArgByNameCount = {}\n    @localArgByName = {}\n    @calculatedDirectlyOfIndirectlyFromParentById = {}\n    @argsMaybeChangedSinceLastCalculationById = {}\n\n    @morphContainingTheseArgs = @valContainingTheseArgs.ownerMorph\n\n\n  ################################################\n  #  breaking / healing\n  ################################################\n\n  healAll: () ->\n    for eachArg of argsMaybeChangedSinceLastCalculationById\n      eachArg.heal()\n\n\n  ################################################\n  #  accessors\n  ################################################\n\n  getByVal: (theVal) ->\n    return @getById theVal.id\n\n  ################################################\n  #  setup methods - these are called in the\n  #  constructors of each value to prepare\n  #  for the arguments.\n  ################################################\n\n  # for local arguments, you can\n  # actually create the arguments as they are static\n  setup_AddAllLocalArgVals: (localInputVals) ->\n    for each in localInputVals\n      # connecting arguments that come from local values is\n      # easier because those links are static, they are done\n      # at construction time once and for all\n      each.localValsAffectedByChangeOfThisVal.push @valContainingTheseArgs\n      newArg = new Arg localInputVals, @valContainingTheseArgs\n      newArg.fromLocal = true\n      @localArgByName[localInputVals.valueName] = newArg\n\n  # you can\'t create the actual arguments yet as these\n  # arguments will be connected dynamically. we just prepare\n  # some a structure in the morph so we\'ll be able\n  # to connect the actual values in the morph\'s\n  # childAdded and childRemoved methods\n  setup_AddAllParentArgNames: (parentArgsNames) ->\n    # ORIGINAL CODE:\n    #for each var in parentArgsNames\n    #  if !@ownerMorph.morphValsDirectlyDependingOnParentVals[each]?\n    #    @ownerMorph.morphValsDirectlyDependingOnParentVals[each] = {}\n    #  @ownerMorph.morphValsDirectlyDependingOnParentVals[each][@valName] = @\n\n    for eachVar in parentArgsNames\n      @morphContainingTheseArgs.morphValsDirectlyDependingOnParentVals[eachVar]?= {}\n      @morphContainingTheseArgs.morphValsDirectlyDependingOnParentVals[eachVar][@valContainingTheseArgs.valName] = @valContainingTheseArgs\n\n  # you can\'t create the actual arguments yet as these\n  # arguments will be connected dynamically. we just prepare\n  # some a structure in the morph so we\'ll be able\n  # to connect the actual values in the morph\'s\n  # childAdded and childRemoved methods\n  setup_AddAllChildrenArgNames: (childrenArgsNames) ->\n    #debugger\n    for eachVar in childrenArgsNames\n      @morphContainingTheseArgs.morphValsDependingOnChildrenVals[eachVar] ?= {}\n      @morphContainingTheseArgs.morphValsDependingOnChildrenVals[eachVar][@valContainingTheseArgs.valName] = @valContainingTheseArgs\n\n  ################################################\n  #  argument connenction methods\n  #  these are called when Morphs are moved\n  #  around so we need to connect/disconnect\n  #  the arguments of each value to/from the\n  #  (new) parent/children\n  ################################################\n\n  # check whether you are reconnecting\n  # an arg that was temporarily\n  # disconnected\n  tryToReconnectDisconnectedArgFirst: (parentOrChildVal) ->\n    existingArg = @argById[parentOrChildVal.id]\n    if existingArg?\n      existingArg.markedForRemoval = false\n      existingArg.valContainingThisArg.argMightHaveChanged(parentOrChildVal)\n      return existingArg\n    return null\n\n\n  # connects a val depending on a children val to a child val.\n  # This is called by childAdded on the new parent of the childMorph\n  # that has just been added\n  connectToChildVal: (valDependingOnChildrenVal, childVal) ->\n\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "connecting " + valDependingOnChildrenVal.valName + " in morph "+ valDependingOnChildrenVal.ownerMorph.uniqueIDString() + " to receive input from " + childVal.valName + " in morph "+ childVal.ownerMorph.uniqueIDString()\n\n    # check whether you are reconnecting\n    # an arg that was temporarily\n    # disconnected\n    #if @morphContainingTheseArgs.constructor.name == "RectangleMorph"\n    #  debugger\n    argumentToBeConnected = @tryToReconnectDisconnectedArgFirst childVal\n    argumentToBeConnected ?= new Arg childVal, valDependingOnChildrenVal\n    argumentToBeConnected.fromChild = true\n    @childrenArgByName[childVal.valName] ?= {}\n    @childrenArgByName[childVal.valName][childVal.id] = argumentToBeConnected\n    @childrenArgByNameCount[childVal.valName]?= 0\n    @childrenArgByNameCount[childVal.valName]++\n    if childVal.directlyOrIndirectlyDependsOnAParentVal\n      @valContainingTheseArgs.stainValCalculatedFromParent(childVal)\n    argumentToBeConnected.args.argFromChildMightHaveChanged childVal\n\n  # connects a val depending on a parent val to a parent val.\n  # This is called by childAdded on the childMorph that has just\n  # been added\n  connectToParentVal: (valDependingOnParentVal, parentVal) ->\n    # check whether you are reconnecting\n    # an arg that was temporarily\n    # disconnected\n    argumentToBeConnected = @tryToReconnectDisconnectedArgFirst childVal\n    argumentToBeConnected ?= new Arg childVal, valDependingOnParentVal\n    argumentToBeConnected.directlyCalculatedFromParent = true\n    argumentToBeConnected.turnIntoArgDirectlyOrIndirectlyDependingOnParent()\n\n  ################################################\n  #  handling update of argument coming from\n  #  other values\n  ################################################\n\n  argFromChildMightHaveChanged: (childValThatMightHaveChanged) ->\n\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "marking child value " + childValThatMightHaveChanged.valName + " in morph "+ childValThatMightHaveChanged.ownerMorph.uniqueIDString() + " as \"might have changed\" "\n\n\n    arg = @argById[childValThatMightHaveChanged.id]\n    if  !arg?  or  @holdOffFromPropagatingChanges then return\n    if arg.markedForRemoval then return\n    # the unique identifier of a val is given by\n    # its name as a string and the id of the Morph it belongs to\n    if arg.maybeChangedSinceLastCalculation and childValThatMightHaveChanged.ownerMorph.parent == @morphContainingTheseArgs\n      arg.checkBasedOnSignature()\n    else if arg.maybeChangedSinceLastCalculation and childValThatMightHaveChanged.ownerMorph.parent != @morphContainingTheseArgs\n      # argsMaybeChangedSinceLastCalculation contains kid and kid not child anymore\n      arg.break()\n    else if !arg.maybeChangedSinceLastCalculation and childValThatMightHaveChanged.ownerMorph.parent == @morphContainingTheseArgs\n      # argsMaybeChangedSinceLastCalculation not contains kid and kid is now child\n      # ???\n      add the data structures and mark it as dirty and signature undefined\n    else if !arg.maybeChangedSinceLastCalculation and childValThatMightHaveChanged.ownerMorph.parent != @morphContainingTheseArgs\n      # argsMaybeChangedSinceLastCalculation not contains kid and not child\n      # ???\n      this should never happen\n    if !@valContainingTheseArgs.directlyOrIndirectlyDependsOnAParentVal\n      @valContainingTheseArgs.checkAndPropagateChangeBasedOnArgChange()\n\n  ################################################\n  #  fetching correct arguments values\n  ################################################\n\n  # all @calculatedDirectlyOfIndirectlyFromParentById\n  # always need\n  # to be fetched (maybe recalculated)\n  # regardless of their dirty val\n  # we then update the signature and heal them.\n  # Note that some children args can be in this set\n  # as children args can maybe depend directly\n  # or indirectly from parent vals.\n  fetchAllArgsDirectlyOrIndirectlyCalculatedFromParent: ->\n    oneOrMoreArgsHaveActuallyChanged = false\n    for idNotUsed, argCalculatedFromParent of @calculatedDirectlyOfIndirectlyFromParentById\n      # check that the child/parent arg we are going to fetch\n      # is still a in a child/parent relationship with\n      # this morph. If not, this check will remove the\n      # arg and just move on\n      if argCalculatedFromParent.removeArgIfMarkedForRemoval()\n        continue\n      # note here that since in @argValsById we keep the\n      # reference to the Val object, which is the one\n      # we pass to the "functionToRecalculate", we\n      # don\'t need to put the fetched val anywhere.\n      argCalculatedFromParent.fetchVal()\n      # updateSignatureAndHeal returns true if\n      # the argument has actually changed since last\n      # recalculation\n      oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged or argCalculatedFromParent.updateSignatureAndHeal()\n    return oneOrMoreArgsHaveActuallyChanged\n\n  fetchAllRemainingArgsNeedingRecalculation: ->\n    @holdOffFromPropagatingChanges = true\n\n    oneOrMoreArgsHaveActuallyChanged = false\n    for maybeModifiedArgId of @argsMaybeChangedSinceLastCalculationById\n      maybeModifiedArg = @argById[maybeModifiedArgId]\n      # check that the child arg we are going to fetch\n      # is still a in a child relationship with\n      # this morph. If not, this check will remove the\n      # arg and just move on.\n      if maybeModifiedArg.removeArgIfMarkedForRemoval()\n        continue\n      # note here that since in @argValsById we keep the\n      # reference to the Val object, which is the one\n      # we pass to the "functionToRecalculate", we\n      # don\'t need to put the fetched val anywhere.\n\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "fetching potentially changed input: " + maybeModifiedArg.id\n\n      debugger\n      maybeModifiedArg.fetchVal()\n      # the argument has actually changed since last\n      # recalculation\n      oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged or maybeModifiedArg.updateSignature()\n    return oneOrMoreArgsHaveActuallyChanged\n\n    # since we calculated all the damaged args,\n    # heal them all\n    @args.healAll()\n    @holdOffFromPropagatingChanges = false  ';

  return Args;

})();

GroundVal = (function() {
  GroundVal.prototype.directlyOrIndirectlyDependsOnAParentVal = false;

  GroundVal.prototype.lastCalculatedValContent = null;

  GroundVal.prototype.lastCalculatedValContentMaybeOutdated = false;

  GroundVal.prototype.localValsAffectedByChangeOfThisVal = null;

  GroundVal.prototype.args = null;

  function GroundVal(valName, lastCalculatedValContent, ownerMorph) {
    var contentOfLastCalculatedVal;
    this.valName = valName;
    this.lastCalculatedValContent = lastCalculatedValContent;
    this.ownerMorph = ownerMorph;
    if (this.constructor.name === "GroundVal" && WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      ProfilerData.reactiveValues_createdGroundVals++;
      if (this.lastCalculatedValContent == null) {
        contentOfLastCalculatedVal = null;
      } else {
        contentOfLastCalculatedVal = this.lastCalculatedValContent;
      }
      console.log("building GroundVal named " + this.valName + " in morph " + this.ownerMorph.uniqueIDString() + " with content: " + contentOfLastCalculatedVal);
    }
    this.addMyselfToMorphsValsList(valName);
    this.id = this.valName + this.ownerMorph.uniqueIDString();
    this.localValsAffectedByChangeOfThisVal = [];
  }

  GroundVal.prototype.checkAndPropagateChangeBasedOnArgChange = function() {
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      console.log("checking if " + this.valName + " in morph " + this.ownerMorph.uniqueIDString() + " has any damaged inputs...");
    }
    if (this.args.countOfDamaged > 0) {
      if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
        console.log("... " + this.valName + " in morph " + this.ownerMorph.uniqueIDString() + " has some damaged inputs but it's already broken so nothing to do");
      }
      if (this.lastCalculatedValContentMaybeOutdated === false) {
        if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
          console.log("... " + this.valName + " in morph " + this.ownerMorph.uniqueIDString() + " has some damaged inputs and wasn't damaged so need to propagate damage");
        }
        this.lastCalculatedValContentMaybeOutdated = true;
        return this.notifyDependentParentOrLocalValsOfPotentialChange();
      }
    } else {
      if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
        console.log("... " + this.valName + " in morph " + this.ownerMorph.uniqueIDString() + " has NO damaged inputs");
      }
      return this.heal();
    }
  };

  GroundVal.prototype.heal = function() {
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      console.log("... now healing " + this.id);
    }
    if (this.lastCalculatedValContentMaybeOutdated) {
      if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
        console.log("... " + this.id + "'s last calculated value was marked as broken, notifying dep values of this being healed");
      }
      this.lastCalculatedValContentMaybeOutdated = false;
      return this.notifyDependentParentOrLocalValsOfPotentialChange();
    }
  };

  GroundVal.prototype.addMyselfToMorphsValsList = function(valName) {
    return this.ownerMorph.allValsInMorphByName[valName] = this;
  };

  GroundVal.prototype.stainValCalculatedFromParent = function(stainingArgVal) {
    var stainingArg;
    stainingArg = this.args.getByVal(stainingArgVal);
    return stainingArg.turnIntoArgDirectlyOrIndirectlyDependingOnParent();
  };

  GroundVal.prototype.unstainValCalculatedFromParent = function(unstainedArgVal) {
    var unstainedArg;
    unstainedArg = this.args.getByVal(unstainedArgVal);
    return stainingArg.turnIntoArgNotDirectlyNorIndirectlyDependingOnParent();
  };

  GroundVal.prototype.setVal = function(newVal) {
    this.signature = newVal.signature;
    if (this.lastCalculatedValContent === newVal) {

    } else {
      this.lastCalculatedValContent = newVal;
      return this.notifyDependentParentOrLocalValsOfPotentialChange();
    }
  };

  GroundVal.prototype.notifyDependentParentOrLocalValsOfPotentialChange = function() {
    var cv, k, v, _i, _len, _ref, _results;
    _ref = this.localValsAffectedByChangeOfThisVal;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cv = _ref[_i];
      cv.argMightHaveChanged(this);
    }
    if (this.ownerMorph.parent != null) {
      v = this.ownerMorph.parent.morphValsDependingOnChildrenVals[this.valName];
      _results = [];
      for (k in v) {
        _results.push(k.argMightHaveChanged(this));
      }
      return _results;
    }
  };

  GroundVal.prototype.fetchVal = function() {
    return this.lastCalculatedValContent;
  };

  GroundVal.coffeeScriptSourceOfThisClass = '# just a draft, it\'s not meant to compile or work\n# just yet, we are just assembling things\n\n# a GroundVal holds a val that is not\n# calculated from anything: it\'s actually\n# changeable as is. It doesn\'t react to the\n# change of any other Val.\n\n# REQUIRES ProfilerData\n\nclass GroundVal\n  \n  directlyOrIndirectlyDependsOnAParentVal: false\n\n  # we use "lastCalculatedValContent" here just as a matter of\n  # uniformity. The cached val of a GroundVal\n  # is always up to date, it\'s always good for use.\n  lastCalculatedValContent: null\n\n  # always false for GroundVals, because there is never\n  # a recalculation to be done here, the val is always\n  # exactly known\n  lastCalculatedValContentMaybeOutdated: false\n  # these vals are affected by change of this\n  # val\n  localValsAffectedByChangeOfThisVal: null\n\n  args: null\n\n  constructor: (@valName, @lastCalculatedValContent, @ownerMorph) ->\n\n    # stuff to do only if we are building GroundVal and not\n    # any of its subclasses\n    if @constructor.name == "GroundVal" and\n        WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n\n      ProfilerData.reactiveValues_createdGroundVals++\n\n      if !@lastCalculatedValContent?\n        contentOfLastCalculatedVal = null\n      else\n        contentOfLastCalculatedVal = @lastCalculatedValContent\n\n      console.log "building GroundVal named " + @valName + " in morph "+ @ownerMorph.uniqueIDString() + " with content: " + contentOfLastCalculatedVal\n\n    @addMyselfToMorphsValsList valName\n    @id = @valName + @ownerMorph.uniqueIDString()\n    @localValsAffectedByChangeOfThisVal = []\n\n\n  checkAndPropagateChangeBasedOnArgChange: () ->\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "checking if " + @valName + " in morph "+ @ownerMorph.uniqueIDString() + " has any damaged inputs..."\n\n    # we can check these with a counter, DON\'T do\n    # something like Object.keys(obj).length because it\'s\n    # unnecessary overhead.\n    # Note here that there is no propagation in case:\n    #  a) there is a change but we already notified our\n    #     change to the connected vals\n    #  b) there is no change and we never notified\n    #     any change to the connected vals\n    if @args.countOfDamaged > 0\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "... " + @valName  + " in morph "+ @ownerMorph.uniqueIDString() + " has some damaged inputs but it\'s already broken so nothing to do"\n      if @lastCalculatedValContentMaybeOutdated == false\n        if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n          console.log "... " + @valName  + " in morph "+ @ownerMorph.uniqueIDString() + " has some damaged inputs and wasn\'t damaged so need to propagate damage"\n        @lastCalculatedValContentMaybeOutdated = true\n        @notifyDependentParentOrLocalValsOfPotentialChange()\n    else # there are NO damanged args\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "... " + @valName  + " in morph "+ @ownerMorph.uniqueIDString() + " has NO damaged inputs"\n      @heal()\n\n\n  heal: ->\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "... now healing " + @id\n\n    if @lastCalculatedValContentMaybeOutdated\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "... " + @id + "\'s last calculated value was marked as broken, notifying dep values of this being healed"\n      @lastCalculatedValContentMaybeOutdated = false\n      @notifyDependentParentOrLocalValsOfPotentialChange()\n\n\n  addMyselfToMorphsValsList: (valName) ->\n    @ownerMorph.allValsInMorphByName[valName] = @\n\n  stainValCalculatedFromParent: (stainingArgVal) ->\n    # note that staining argument here could\n    # be a child argument, as it might directly or\n    # indirectly depend on\n    # a value which is in a parent\n    stainingArg = @args.getByVal stainingArgVal\n    # this might recursively stain other values\n    # depending on this value\n    stainingArg.turnIntoArgDirectlyOrIndirectlyDependingOnParent()\n\n  unstainValCalculatedFromParent: (unstainedArgVal) ->\n    # note that argument here could\n    # be a child argument, as it might directly or\n    # indirectly depend on\n    # a value which is in a parent\n    unstainedArg = @args.getByVal unstainedArgVal\n    # this might recursively un-stain other values\n    # depending on this value\n    stainingArg.turnIntoArgNotDirectlyNorIndirectlyDependingOnParent()\n\n\n  # this is the only type of val that we\n  # can actually change directly.\n  # All other typed of vals are calculated\n  # from other vals.\n  setVal: (newVal) ->\n    @signature = newVal.signature\n\n    # comparison needs to be smarter?\n    # does this need to have multiple version for basic vals\n    # like integers and strings?\n    if @lastCalculatedValContent == newVal\n      return\n    else\n      @lastCalculatedValContent = newVal\n      @notifyDependentParentOrLocalValsOfPotentialChange()\n  \n  # note that parents never notify children\n  # of any change, because we don\'t want this\n  # operation to take long as there might be hundreds\n  # of children directly/indirectly under this morph.\n  notifyDependentParentOrLocalValsOfPotentialChange: ->\n    for cv in @localValsAffectedByChangeOfThisVal\n      cv.argMightHaveChanged @\n    if @ownerMorph.parent?\n      v = @ownerMorph.parent.morphValsDependingOnChildrenVals[@valName]\n      for k of v\n        #k.argFromChildMightHaveChanged @\n        k.argMightHaveChanged @\n\n  # no logic for recalculation needed\n  # fetchVal is an apt name because it doesn\'t necessarily\n  # recalculate the val (although it might need to) and it\n  # doesn\'t just look it up either. It\'s some sort of retrieval.\n  fetchVal: ->\n    return @lastCalculatedValContent\n\n';

  return GroundVal;

})();

BasicCalculatedVal = (function(_super) {
  __extends(BasicCalculatedVal, _super);

  BasicCalculatedVal.prototype.lastCalculatedValContentMaybeOutdated = true;

  BasicCalculatedVal.prototype.lastCalculatedValContent = void 0;

  BasicCalculatedVal.prototype.holdOffFromPropagatingChanges = false;

  function BasicCalculatedVal(valName, functionToRecalculate, localInputVals, parentArgsNames, childrenArgsNames, ownerMorph) {
    var collectionOfChildrenValuesNames, eachName, _i, _len;
    this.valName = valName;
    this.functionToRecalculate = functionToRecalculate;
    this.localInputVals = localInputVals;
    this.ownerMorph = ownerMorph;
    BasicCalculatedVal.__super__.constructor.call(this, this.valName, null, this.ownerMorph);
    ProfilerData.reactiveValues_createdBasicCalculatedValues++;
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      collectionOfChildrenValuesNames = "";
      for (_i = 0, _len = childrenArgsNames.length; _i < _len; _i++) {
        eachName = childrenArgsNames[_i];
        collectionOfChildrenValuesNames = collectionOfChildrenValuesNames + ", " + eachName;
      }
      console.log("building BasicCalculatedVal named " + this.valName + " in morph " + this.ownerMorph.uniqueIDString() + " depending on children variables: " + collectionOfChildrenValuesNames);
    }
    this.args = new Args(this);
    this.args.setup_AddAllLocalArgVals(this.localInputVals);
    this.args.setup_AddAllParentArgNames(parentArgsNames);
    this.args.setup_AddAllChildrenArgNames(childrenArgsNames);
  }

  BasicCalculatedVal.prototype.propagateChangeOfThisValIfNeeded = function(newValContent) {
    debugger;
    if (newValContent.signature === this.lastCalculatedValContent.signature) {
      return this.heal();
    } else {
      if (this.lastCalculatedValContentMaybeOutdated === false) {
        return notifyDependentParentOrLocalValsOfPotentialChange();
      }
    }
  };

  BasicCalculatedVal.prototype.fetchVal = function() {
    var newValContent, oneOrMoreArgsHaveActuallyChanged;
    if (this.lastCalculatedValContentMaybeOutdated === false) {
      return this.lastCalculatedValContent;
    }
    oneOrMoreArgsHaveActuallyChanged = false;
    oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged || this.args.fetchAllArgsDirectlyOrIndirectlyCalculatedFromParent();
    oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged || this.args.fetchAllRemainingArgsNeedingRecalculation();
    if (oneOrMoreArgsHaveActuallyChanged) {
      newValContent = this.functionToRecalculate(this.args.argById, this.args.localArgByName, this.args.parentArgByName, this.args.childrenArgByName, this.args.childrenArgByNameCount);
      this.signature = newValContent.signature;
      this.lastCalculatedValContent = newValContent;
      if (!this.directlyOrIndirectlyDependsOnAParentVal) {
        this.propagateChangeOfThisValIfNeeded(newValContent);
      }
    }
    return this.lastCalculatedValContent;
  };

  BasicCalculatedVal.coffeeScriptSourceOfThisClass = '# just a draft, it\'s not meant to compile or work\n# just yet, we are just assembling things\n\n# REQUIRES ProfilerData\n\nclass BasicCalculatedVal extends GroundVal\n  # sometimes we know that the cached val\n  # might be out of date but we don\'t want to\n  # trigger a recalculation to actually check.\n  # This is what this flag tracks.\n  # Note that this flag has no meaning if this Val\n  # is @directlyOrIndirectlyDependsOnAParentVal, as in that case\n  # we always have to fetch the val rather than\n  # hope to have a good cached version.\n  lastCalculatedValContentMaybeOutdated: true\n  lastCalculatedValContent: undefined\n  # this is needed because during the recalculation step\n  # we don\'t want to process the notifications that\n  # we receive about our args changing, that\n  # would be messy and wasteful.\n  holdOffFromPropagatingChanges: false\n\n  # this val might be referenced by parent Morph or\n  # children Morphs dynamically so they way to find this\n  # val might be through the name as a string\n  constructor: (@valName, @functionToRecalculate, @localInputVals, parentArgsNames, childrenArgsNames, @ownerMorph) ->\n    super(@valName, null, @ownerMorph)\n\n    ProfilerData.reactiveValues_createdBasicCalculatedValues++\n\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      collectionOfChildrenValuesNames = ""\n      for eachName in childrenArgsNames\n        collectionOfChildrenValuesNames = collectionOfChildrenValuesNames + ", " + eachName\n      console.log "building BasicCalculatedVal named " + @valName + " in morph "+ @ownerMorph.uniqueIDString() + " depending on children variables: " + collectionOfChildrenValuesNames\n    \n    # we don\'t mark immediately this value as\n    # depending on parent, the reason is that there might be\n    # no parent morph to this one, so in some circumstances\n    # this value\'s content can actually just be treated as\n    # a normal value that doesn\'t need to automatically\n    # fetch values for some of its arguments, and which\n    # notification of changes can actually be believed.\n    # As soon as a parent Morph is added, then this doesn\'t\n    # hold true anymore - this Value stops notifying the\n    # other dependent values of changes because it doesn\'t\n    # get the changes from the parent values itself...\n    #@directlyOrIndirectlyDependsOnAParentVal = true\n\n    @args = new Args(@)\n    @args.setup_AddAllLocalArgVals @localInputVals\n    @args.setup_AddAllParentArgNames parentArgsNames\n    @args.setup_AddAllChildrenArgNames childrenArgsNames\n\n\n  # Given that this Val if a pure function depending\n  # on some args, we want to know at all times\n  # whether the args change. If the don\'t, then we\n  # know that there is no need to recalculate the present\n  # val. So this method is used by all the args\n  # of this val to notify whether they have changed\n  # or not.\n  # It\'s important to note that this method can be\n  # called for two reasons:\n  # 1) an arg has just been recalculated. Hence\n  #    we know exactly its val\n  # 2) an arg has just maybe changed because\n  #    he knows that one of HIS args has changed\n  #    but since we want to minimise recalculations we\n  #    don\'t know what the new val is, just that\n  #    maybe it has changed. \n  # There is one exception: all args\n  # that depend on a parent val (directly or indirectly)\n  # never notify anybody. This is because if a parent had\n  # to notify all the directlty or indirectly connected\n  # vals, in general it could be\n  # very expensive, as for example there could be 50\n  # children to notify (and they might to notify other\n  # connected vals). What happens instead is that when\n  # this val is calculated, all args that depend on\n  # a parent (directly or indirectly) are\n  # always re-fetched, we just\n  # can\'t trust them to have notified us of their change...\n  # this method never triggers a recalculation!\n  # we could receive this because\n  #   - a recalculation has happened down the line\n  #     and we know the actual val of the\n  #     changed arg\n  #   - some invalidation has happened down the line\n  #     and hence the arg *might* have changed\n  #     but we don\'t know the actual val.\n  # We just need to keep track of which args might\n  # need recalculation and which ones are surely the\n  # same as the version we used for our last calculation.\n  #argMightHaveChanged: (changedArgVal) ->\n  #\n  #  if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n  #    console.log "marking argument " + changedArgVal.valName + " connected to morph " + changedArgVal.ownerMorph.uniqueIDString() + " as \"might have changed\" "\n  #\n  #  changedArg = @args.argById[changedArgVal.id]\n  #  if changedArg.markedForRemoval or @holdOffFromPropagatingChanges then return\n  #  changedArg.checkBasedOnSignature()\n  #  if !@directlyOrIndirectlyDependsOnAParentVal\n  #    @checkAndPropagateChangeBasedOnArgChange()\n\n\n\n  propagateChangeOfThisValIfNeeded: (newValContent) ->\n    debugger\n    if newValContent.signature == @lastCalculatedValContent.signature\n      @heal()\n    else # newValContent.signature != @lastCalculatedValContent.signature\n      if @lastCalculatedValContentMaybeOutdated == false\n        notifyDependentParentOrLocalValsOfPotentialChange()\n        # note that @lastCalculatedValContentMaybeOutdated\n        # remains false because we are sure of this value\n        # as we just calculated\n\n  # this method is called either by the user/system\n  # because it\'s time to get the val, or it\'s\n  # called by another val which is being asked to\n  # return its val recursively.\n  # this method could trigger a recalculation of some\n  # args, and of this val itself (obviously\n  # this whole apparatus is to minimise recalculations).\n  # Even if this\n  # particular function *might* be cheap to compute,\n  # the "dirty" parameters of its input might not be cheap\n  # to calculate.\n  # fetchVal is an apt name because it doesn\'t necessarily\n  # recalculate the val (although it might need to) and it\n  # doesn\'t just look it up either. It\'s some sort of retrieval.\n  fetchVal: () ->\n    if @lastCalculatedValContentMaybeOutdated is false\n      return @lastCalculatedValContent\n    \n    oneOrMoreArgsHaveActuallyChanged = false\n    oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged or @args.fetchAllArgsDirectlyOrIndirectlyCalculatedFromParent()\n    oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged or @args.fetchAllRemainingArgsNeedingRecalculation()\n\n    if oneOrMoreArgsHaveActuallyChanged      \n      # functionToRecalculate must always return\n      # an object with a calculated default signature\n      # in the .signature property\n      newValContent =\n        @functionToRecalculate @args.argById,\n          @args.localArgByName,\n          @args.parentArgByName,\n          @args.childrenArgByName,\n          @args.childrenArgByNameCount\n\n      @signature = newValContent.signature\n      @lastCalculatedValContent = newValContent\n      if !@directlyOrIndirectlyDependsOnAParentVal\n        @propagateChangeOfThisValIfNeeded newValContent\n    return @lastCalculatedValContent\n      \n    \n';

  return BasicCalculatedVal;

})(GroundVal);

MixedClassKeywords = ['onceAddedClassProperties', 'included'];

arrayShallowCopy = function(anArray) {
  return anArray.concat();
};

arrayShallowCopyAndReverse = function(anArray) {
  return anArray.concat().reverse();
};

hashCode = function(stringToBeHashed) {
  var char, hash, i, _i, _ref;
  hash = 0;
  if (stringToBeHashed.length === 0) {
    return hash;
  }
  for (i = _i = 0, _ref = stringToBeHashed.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    char = stringToBeHashed.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return hash;
};

nop = function() {
  return function() {
    return null;
  };
};

noOperation = function() {
  return null;
};

isFunction = function(functionToCheck) {
  return typeof functionToCheck === "function";
};

localize = function(string) {
  return string;
};

isNil = function(thing) {
  return thing === undefined || thing === null;
};

contains = function(list, element) {
  return list.some(function(any) {
    return any === element;
  });
};

detect = function(list, predicate) {
  var element, _i, _len;
  for (_i = 0, _len = list.length; _i < _len; _i++) {
    element = list[_i];
    if (predicate.call(null, element)) {
      return element;
    }
  }
  return null;
};

sizeOf = function(object) {
  var key, size;
  size = 0;
  key = void 0;
  for (key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      size += 1;
    }
  }
  return size;
};

isString = function(target) {
  return typeof target === "string" || target instanceof String;
};

isObject = function(target) {
  return (target != null) && (typeof target === "object" || target instanceof Object);
};

radians = function(degrees) {
  return degrees * Math.PI / 180;
};

degrees = function(radians) {
  return radians * 180 / Math.PI;
};

fontHeight = function(height) {
  var minHeight;
  minHeight = Math.max(height, WorldMorph.preferencesAndSettings.minimumFontHeight);
  return minHeight * 1.2;
};

newCanvas = function(extentPoint) {
  var canvas, ext;
  ext = extentPoint || {
    x: 0,
    y: 0
  };
  canvas = document.createElement("canvas");
  canvas.width = ext.x;
  canvas.height = ext.y;
  return canvas;
};

getMinimumFontHeight = function() {
  var canvas, ctx, data, maxX, size, str, x, y, _i, _j;
  str = "I";
  size = 50;
  canvas = document.createElement("canvas");
  canvas.width = size;
  canvas.height = size;
  ctx = canvas.getContext("2d");
  ctx.font = "1px serif";
  maxX = ctx.measureText(str).width;
  ctx.fillStyle = "black";
  ctx.textBaseline = "bottom";
  ctx.fillText(str, 0, size);
  for (y = _i = 0; 0 <= size ? _i < size : _i > size; y = 0 <= size ? ++_i : --_i) {
    for (x = _j = 0; 0 <= maxX ? _j < maxX : _j > maxX; x = 0 <= maxX ? ++_j : --_j) {
      data = ctx.getImageData(x, y, 1, 1);
      if (data.data[3] !== 0) {
        return size - y + 1;
      }
    }
  }
  return 0;
};

getBlurredShadowSupport = function() {
  var ctx, source, target;
  source = document.createElement("canvas");
  source.width = 10;
  source.height = 10;
  ctx = source.getContext("2d");
  ctx.fillStyle = "rgb(255, 0, 0)";
  ctx.beginPath();
  ctx.arc(5, 5, 5, 0, Math.PI * 2, true);
  ctx.closePath();
  ctx.fill();
  target = document.createElement("canvas");
  target.width = 10;
  target.height = 10;
  ctx = target.getContext("2d");
  ctx.shadowBlur = 10;
  ctx.shadowColor = "rgba(0, 0, 255, 1)";
  ctx.drawImage(source, 0, 0);
  if (ctx.getImageData(0, 0, 1, 1).data[3]) {
    return true;
  } else {
    return false;
  }
};

getDocumentPositionOf = function(aDOMelement) {
  var offsetParent, pos;
  if (aDOMelement === null) {
    return {
      x: 0,
      y: 0
    };
  }
  pos = {
    x: aDOMelement.offsetLeft,
    y: aDOMelement.offsetTop
  };
  offsetParent = aDOMelement.offsetParent;
  while (offsetParent != null) {
    pos.x += offsetParent.offsetLeft;
    pos.y += offsetParent.offsetTop;
    if (offsetParent !== document.body && offsetParent !== document.documentElement) {
      pos.x -= offsetParent.scrollLeft;
      pos.y -= offsetParent.scrollTop;
    }
    offsetParent = offsetParent.offsetParent;
  }
  return pos;
};

MorphicNode = (function() {
  MorphicNode.prototype.parent = null;

  MorphicNode.prototype.children = null;

  function MorphicNode(parent, children) {
    this.parent = parent != null ? parent : null;
    this.children = children != null ? children : [];
  }

  MorphicNode.prototype.toString = function() {
    return "a MorphicNode" + "[" + this.children.length + "]";
  };

  MorphicNode.prototype.childrenTopToBottom = function() {
    return arrayShallowCopyAndReverse(this.children);
  };

  MorphicNode.prototype.addChild = function(aMorphicNode) {
    this.children.push(aMorphicNode);
    aMorphicNode.parent = this;
    return this.connectValuesToAddedChild(aMorphicNode);
  };

  MorphicNode.prototype.addChildFirst = function(aMorphicNode) {
    this.children.splice(0, null, aMorphicNode);
    return aMorphicNode.parent = this;
  };

  MorphicNode.prototype.removeChild = function(aMorphicNode) {
    var idx;
    idx = this.children.indexOf(aMorphicNode);
    if (idx !== -1) {
      this.children.splice(idx, 1);
    }
    aMorphicNode.parent = null;
    return this.disconnectValuesFromRemovedChild(aMorphicNode);
  };

  MorphicNode.prototype.root = function() {
    if (this.parent != null) {
      return this.parent.root();
    }
    return this;
  };

  MorphicNode.prototype.depth = function() {
    if (!this.parent) {
      return 0;
    }
    return this.parent.depth() + 1;
  };

  MorphicNode.prototype.allChildrenBottomToTop = function() {
    var result;
    result = [this];
    this.children.forEach(function(child) {
      return result = result.concat(child.allChildrenBottomToTop());
    });
    return result;
  };

  MorphicNode.prototype.allChildrenTopToBottom = function() {
    var arrayToReturn, morph, morphNumber, _i, _ref;
    if (this.children.length === 0) {
      return [this];
    }
    arrayToReturn = [];
    for (morphNumber = _i = _ref = this.children.length - 1; _i >= 0; morphNumber = _i += -1) {
      morph = this.children[morphNumber];
      arrayToReturn = arrayToReturn.concat(morph.allChildrenTopToBottom);
    }
    return arrayToReturn.push(this);
  };

  MorphicNode.prototype.forAllChildrenBottomToTop = function(aFunction) {
    aFunction.call(null, this);
    if (this.children.length) {
      return this.children.forEach(function(child) {
        return child.forAllChildrenBottomToTop(aFunction);
      });
    }
  };

  MorphicNode.prototype.allLeafsBottomToTop = function() {
    if (this.children.length === 0) {
      return [this];
    }
    this.children.forEach(function(child) {
      var result;
      return result = result.concat(child.allLeafsBottomToTop());
    });
    return result;
  };

  MorphicNode.prototype.allParentsBottomToTop = function() {
    var someParents;
    if (this.parent != null) {
      someParents = this.parent.allParentsBottomToTop();
      someParents.push(this);
      return someParents;
    } else {
      return [this];
    }
  };

  MorphicNode.prototype.allParentsTopToBottom = function() {
    return this.allParentsBottomToTop().reverse();
  };

  MorphicNode.prototype.allParentsBottomToTopSuchThat = function(predicate) {
    var result;
    result = [];
    if (this.parent != null) {
      result = this.parent.allParentsBottomToTopSuchThat(predicate);
    }
    if (predicate.call(null, this)) {
      result.push(this);
    }
    return result;
  };

  MorphicNode.prototype.allParentsTopToBottomSuchThat = function(predicate) {
    var collected;
    collected = [];
    if (predicate.call(null, this)) {
      collected = [this];
    }
    if (this.parent != null) {
      collected = collected.concat(this.parent.allParentsTopToBottomSuchThat(predicate));
    }
    return collected;
  };

  MorphicNode.prototype.containedInParentsOf = function(morph) {
    var examinedMorph;
    if (morph == null) {
      console.log("failed to find morph in test: " + window.world.systemTestsRecorderAndPlayer.name);
      console.log("trying to find item with text label: " + window.world.systemTestsRecorderAndPlayer.testCommandsSequence[window.world.systemTestsRecorderAndPlayer.indexOfTestCommandBeingPlayedFromSequence].textLabelOfClickedItem);
      console.log("...you can likely fix the test by correcting the label above in the test");
      debugger;
    }
    if (morph === this) {
      return true;
    }
    examinedMorph = morph;
    while (examinedMorph.parent != null) {
      examinedMorph = examinedMorph.parent;
      if (examinedMorph === this) {
        return true;
      }
    }
    return false;
  };

  MorphicNode.prototype.siblings = function() {
    var index, siblings;
    if (!this.parent) {
      return [];
    }
    siblings = arrayShallowCopy(this.parent.children);
    index = siblings.indexOf(this);
    siblings.splice(index, 1);
    return siblings;
  };

  MorphicNode.prototype.howManySiblingsBeforeMeSuchThat = function(predicate) {
    var eachSibling, theCount, _i, _len, _ref;
    theCount = 0;
    _ref = this.parent.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      eachSibling = _ref[_i];
      if (eachSibling === this) {
        return theCount;
      }
      if (predicate.call(null, eachSibling)) {
        theCount++;
      }
    }
    return theCount;
  };

  MorphicNode.prototype.nthChildSuchThat = function(n, predicate) {
    var eachChild, theCount, _i, _len, _ref;
    theCount = 0;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      eachChild = _ref[_i];
      if (predicate.call(null, eachChild)) {
        theCount++;
        if (theCount === n) {
          return eachChild;
        }
      }
    }
    return null;
  };

  MorphicNode.prototype.parentThatIsA = function(constructor) {
    if (this instanceof constructor) {
      return this;
    }
    if (!this.parent) {
      return null;
    }
    return this.parent.parentThatIsA(constructor);
  };

  MorphicNode.prototype.parentThatIsAnyOf = function(constructors) {
    constructors.forEach((function(_this) {
      return function(each) {
        if (_this.constructor === each) {
          return _this;
        }
      };
    })(this));
    if (!this.parent) {
      return null;
    }
    return this.parent.parentThatIsAnyOf(constructors);
  };

  MorphicNode.prototype.topMorphSuchThat = function(predicate) {
    var foundMorph, morph, morphNumber, _i, _ref;
    if (this.children.length === 0) {
      if (predicate.call(null, this)) {
        return this;
      } else {
        return null;
      }
    }
    for (morphNumber = _i = _ref = this.children.length - 1; _i >= 0; morphNumber = _i += -1) {
      morph = this.children[morphNumber];
      foundMorph = morph.topMorphSuchThat(predicate);
      if (foundMorph != null) {
        return foundMorph;
      }
    }
    if (predicate.call(null, this)) {
      return this;
    } else {
      return null;
    }
    return null;
  };

  MorphicNode.prototype.topmostChildSuchThat = function(predicate) {
    var morph, morphNumber, _i, _ref;
    for (morphNumber = _i = _ref = this.children.length - 1; _i >= 0; morphNumber = _i += -1) {
      morph = this.children[morphNumber];
      if (predicate.call(null, morph)) {
        return morph;
      }
    }
    return null;
  };

  MorphicNode.prototype.collectAllChildrenBottomToTopSuchThat = function(predicate) {
    var collected;
    collected = [];
    if (predicate.call(null, this)) {
      collected = [this];
    }
    this.children.forEach(function(child) {
      return collected = collected.concat(child.collectAllChildrenBottomToTopSuchThat(predicate));
    });
    return collected;
  };

  MorphicNode.coffeeScriptSourceOfThisClass = '# Morphic node class only cares about the\n# parent/child connection between\n# morphs. It\'s good to connect/disconnect\n# morphs and to find parents or children\n# who satisfy particular properties.\n# OUT OF SCOPE:\n# It\'s important to note that this layer\n# knows nothing about visibility, targets,\n# image buffers, dirty rectangles, events.\n# Please no invokations to changed or fullChanged\n# or updateRendering in here, and no\n# touching of any of the out-of-scope properties\n# mentioned.\n\nclass MorphicNode\n\n  parent: null\n  # "children" is an ordered list of the immediate\n  # children of this node. First child is at the\n  # back relative to other children, last child is at the\n  # top.\n  # This makes intuitive sense if you think for example\n  # at a textMorph being added to a box morph: it is\n  # added to the children list of the box morph, at the end,\n  # and it\'s painted on top (otherwise it wouldn\'t be visible).\n  # Note that when you add a morph A to a morph B, it doesn\'t\n  # mean that A is cointained in B. The two potentially might\n  # not even overlap.\n  # The shadow is added as the first child, and it\'s\n  # actually a special child that gets drawn before the\n  # others.\n  children: null\n\n  constructor: (@parent = null, @children = []) ->\n  \n  \n  # MorphicNode string representation: e.g. \'a MorphicNode[3]\'\n  toString: ->\n    "a MorphicNode" + "[" + @children.length + "]"\n\n  # currently unused in ZK\n  childrenTopToBottom: ->\n    arrayShallowCopyAndReverse(@children)  \n  \n  # MorphicNode accessing:\n  addChild: (aMorphicNode) ->\n    @children.push aMorphicNode\n    aMorphicNode.parent = @\n    @connectValuesToAddedChild aMorphicNode\n  \n  addChildFirst: (aMorphicNode) ->\n    @children.splice 0, null, aMorphicNode\n    aMorphicNode.parent = @\n  \n  removeChild: (aMorphicNode) ->\n    idx = @children.indexOf(aMorphicNode)\n    @children.splice idx, 1  if idx isnt -1\n    aMorphicNode.parent = null\n    @disconnectValuesFromRemovedChild aMorphicNode\n  \n  \n  # MorphicNode functions:\n  root: ->\n    return @parent.root() if @parent?\n    @\n  \n  # currently unused\n  depth: ->\n    return 0  unless @parent\n    @parent.depth() + 1\n  \n  # Returns all the internal AND terminal nodes in the subtree starting\n  # at this node - including this node.\n  # Remember that the @children property already sorts morphs\n  # from bottom to top\n\n  allChildrenBottomToTop: ->\n    result = [@] # includes myself\n    @children.forEach (child) ->\n      result = result.concat(child.allChildrenBottomToTop())\n    result\n\n  # the easiest way here would be to just return\n  #   arrayShallowCopyAndReverse(@allChildrenBottomToTop())\n  # but that\'s slower.\n  # So we do the proper visit here instead.\n  allChildrenTopToBottom: ->\n    # base case - I am a leaf child, so I just\n    # return an array with myself\n    # note that I return an array rather than the\n    # element cause this method is always expected\n    # to return an array.\n    if @children.length == 0\n      return [@]\n\n    # if I have some children instead, then let\'s create\n    # an empty array where we\'ll concatenate the\n    # others.\n    arrayToReturn = []\n\n    # if I have children, then start from the top\n    # one (i.e. the last in the array) towards the bottom\n    # one and concatenate their respective\n    # top-to-bottom lists\n    for morphNumber in [@children.length-1..0] by -1\n      morph = @children[morphNumber]\n      arrayToReturn = arrayToReturn.concat morph.allChildrenTopToBottom\n\n    # ok, last we add ourselves to the bottom\n    # of the list since this node is at the bottom of all of\n    # its children...\n    arrayToReturn.push @\n\n\n  # A shorthand to run a function on all the internal/terminal nodes in the subtree\n  # starting at this node - including this node.\n  # Note that the function first runs on this node (which is the bottom-est morph)\n  # and the proceeds by visiting the "bottom" child (first one in array)\n  # and then all its children and then the second - bottomest child etc.\n  # Also note that there is a more elegant implementation where\n  # we just use @allChildrenBottomToTop() but that would mean to create\n  # all the intermediary arrays with also all the unneeded node elements,\n  # there is not need.\n  forAllChildrenBottomToTop: (aFunction) ->\n    aFunction.call null, @\n    if @children.length\n      @children.forEach (child) ->\n        child.forAllChildrenBottomToTop aFunction\n  \n  # not used in ZK so far\n  allLeafsBottomToTop: ->\n    if @children.length == 0\n      return [@]\n    @children.forEach (child) ->\n      result = result.concat(child.allLeafsBottomToTop())\n    return result\n\n  # Return all "parent" nodes from the root up to this node (including both)\n  allParentsBottomToTop: ->\n    if @parent?\n      someParents = @parent.allParentsBottomToTop()\n      someParents.push @\n      return someParents\n    else\n      return [@]\n  \n  # Return all "parent" nodes from this node up to the root (including both)\n  # Implementation commented-out below works but it\'s probably\n  # slower than the one given, because concat is slower than pushing just\n  # an array element, since concat does a shallow copy of both parts of\n  # the array...\n  #   allParentsTopToBottom: ->\n  #    # includes myself\n  #    result = [@]\n  #    if @parent?\n  #      result = result.concat(@parent.allParentsTopToBottom())\n  #    result\n\n  allParentsTopToBottom: ->\n    return @allParentsBottomToTop().reverse()\n\n  # this should be quicker than allParentsTopToBottomSuchThat\n  # cause there are no concats making shallow copies.\n  allParentsBottomToTopSuchThat: (predicate) ->\n    result = []\n    if @parent?\n      result = @parent.allParentsBottomToTopSuchThat(predicate)\n    if predicate.call(null, @)\n      result.push @\n    result\n\n  allParentsTopToBottomSuchThat: (predicate) ->\n    collected = []\n    if predicate.call(null, @)\n      collected = [@] # include myself\n    if @parent?\n      collected = collected.concat(@parent.allParentsTopToBottomSuchThat(predicate))\n    return collected\n\n  # quicker version that doesn\'t need us\n  # to create any intermediate arrays\n  # but rather just loops up the chain\n  # and lets us return as soon as\n  # we find a match\n  containedInParentsOf: (morph) ->\n    if !morph?\n      # this happens when in a test, you select\n      # a menu entry that doesn\'t exist.\n      # so it\'s a good thing that we block the test\n      # and let the user navigate through the world\n      # to find the state of affairs that caused\n      # the problem.\n      console.log "failed to find morph in test: " + window.world.systemTestsRecorderAndPlayer.name\n      console.log "trying to find item with text label: " +  window.world.systemTestsRecorderAndPlayer.testCommandsSequence[window.world.systemTestsRecorderAndPlayer.indexOfTestCommandBeingPlayedFromSequence].textLabelOfClickedItem\n      console.log "...you can likely fix the test by correcting the label above in the test"\n      debugger\n    # test the morph itself\n    if morph is @\n      return true\n    examinedMorph = morph\n    while examinedMorph.parent?\n      examinedMorph = examinedMorph.parent\n      if examinedMorph is @\n        return true\n    return false\n\n  # The direct children of the parent of this node. (current node not included)\n  # never used in ZK\n  # There is an alternative solution here below, in comment,\n  # but I believe to be slower because it requires applying a function to\n  # all the children. My version below just required an array copy, then\n  # finding an element and splicing it out. I didn\'t test it so I don\'t\n  # even know whether it works, but gut feeling...\n  #  siblings: ->\n  #    return []  unless @parent\n  #    @parent.children.filter (child) =>\n  #      child isnt @\n  siblings: ->\n    return []  unless @parent\n    siblings = arrayShallowCopy @parent.children\n    # now remove myself\n    index = siblings.indexOf(@)\n    siblings.splice(index, 1)\n    return siblings\n\n  # find how many siblings before me\n  # satisfy a property\n  # This is used when figuring out\n  # how many buttons before a particular button\n  # are labeled in the same way,\n  # in the test system.\n  # (so that we can say: automatically\n  # click on the nth button labelled "X")\n  howManySiblingsBeforeMeSuchThat: (predicate) ->\n    theCount = 0\n    for eachSibling in @parent.children\n      if eachSibling == @\n        return theCount\n      if predicate.call(null, eachSibling)\n        theCount++\n    return theCount\n\n  # find the nth child satisfying\n  # a property.\n  # This is used when finding\n  # the nth buttons of a menu\n  # having a particular label.\n  # (so that we can say: automatically\n  # click on the nth button labelled "X")\n  nthChildSuchThat: (n, predicate) ->\n    theCount = 0\n    for eachChild in @children\n      if predicate.call(null, eachChild)\n        theCount++\n        if theCount is n\n          return eachChild\n    return null\n  \n  # returns the first parent (going up from this node) that is of a particular class\n  # (includes this particular node)\n  # This is a subcase of "parentThatIsAnyOf".\n  parentThatIsA: (constructor) ->\n    # including myself\n    return @ if @ instanceof constructor\n    return null  unless @parent\n    @parent.parentThatIsA constructor\n  \n  # returns the first parent (going up from this node) that belongs to a set\n  # of classes. (includes this particular node).\n  parentThatIsAnyOf: (constructors) ->\n    # including myself\n    constructors.forEach (each) =>\n      if @constructor is each\n        return @\n    #\n    return null  unless @parent\n    @parent.parentThatIsAnyOf constructors\n\n  # There is a simpler implementation that is also\n  # slower where you first collect all the children\n  # from top to bottom and then do the test on each\n  # But this more efficient - we don\'t need to\n  # create that entire list to start with, we just\n  # navigate through the children arrays.\n  topMorphSuchThat: (predicate) ->\n    # base case - I am a leaf child, so I just test\n    # the predicate on myself and return myself\n    # if I satisfy, else I return null\n    if @children.length == 0\n      if predicate.call(null, @)\n        return @\n      else\n        return null\n    # if I have children, then start to test from\n    # the top one (the last one in the array)\n    # and proceed to test "towards the back" i.e.\n    # testing elements of the array towards 0\n    # If you find any morph satifies, the search is\n    # over.\n    for morphNumber in [@children.length-1..0] by -1\n      morph = @children[morphNumber]\n      foundMorph = morph.topMorphSuchThat(predicate)\n      if foundMorph?\n        return foundMorph\n    # now that all children are tested, test myself\n    if predicate.call(null, @)\n      return @\n    else\n      return null\n    # ok none of my children nor me test positive,\n    # so return null.\n    return null\n\n  topmostChildSuchThat: (predicate) ->\n    # start to test from\n    # the top one (the last one in the array)\n    # and proceed to test "towards the back" i.e.\n    # testing elements of the array towards 0\n    # If you find any child that satifies, the search is\n    # over.\n    for morphNumber in [@children.length-1..0] by -1\n      morph = @children[morphNumber]\n      if predicate.call(null, morph)\n        return morph\n    # ok none of my children test positive,\n    # so return null.\n    return null\n\n  collectAllChildrenBottomToTopSuchThat: (predicate) ->\n    collected = []\n    if predicate.call(null, @)\n      collected = [@] # include myself\n    @children.forEach (child) ->\n      collected = collected.concat(child.collectAllChildrenBottomToTopSuchThat(predicate))\n    return collected';

  return MorphicNode;

})();

Morph = (function(_super) {
  __extends(Morph, _super);

  Morph.instancesCounter = 0;

  Morph.lastBuiltInstanceNumericID = 0;

  Morph.prototype.instanceNumericID = 0;

  Morph.prototype.propertyUpTheChain = [1, 2, 3];

  Morph.prototype.morphMethod = function() {
    return 3.14;
  };

  Morph.morphStaticMethod = function() {
    return 3.14;
  };

  Morph.prototype.isMorph = true;

  Morph.prototype.bounds = null;

  Morph.prototype.color = null;

  Morph.prototype.texture = null;

  Morph.prototype.cachedTexture = null;

  Morph.prototype.lastTime = null;

  Morph.prototype.alpha = 1;

  Morph.prototype.isMinimised = false;

  Morph.prototype.isVisible = true;

  Morph.prototype.isDraggable = false;

  Morph.prototype.isTemplate = false;

  Morph.prototype.acceptsDrops = false;

  Morph.prototype.noticesTransparentClick = false;

  Morph.prototype.fps = 0;

  Morph.prototype.customContextMenu = null;

  Morph.prototype.trackChanges = true;

  Morph.prototype.shadowBlur = 10;

  Morph.prototype.image = null;

  Morph.prototype.onNextStep = null;

  Morph.prototype.allValsInMorphByName = null;

  Morph.prototype.morphValsDependingOnChildrenVals = null;

  Morph.prototype.morphValsDirectlyDependingOnParentVals = null;

  Morph.augmentWith = function(obj) {
    var key, value, _ref;
    for (key in obj) {
      value = obj[key];
      if (__indexOf.call(MixedClassKeywords, key) < 0) {
        this[key] = value;
      }
    }
    if ((_ref = obj.onceAddedClassProperties) != null) {
      _ref.apply(this);
    }
    return this;
  };

  Morph.addInstanceProperties = function(obj) {
    var key, value, _ref;
    for (key in obj) {
      value = obj[key];
      if (__indexOf.call(MixedClassKeywords, key) < 0) {
        this.prototype[key] = value;
      }
    }
    if ((_ref = obj.included) != null) {
      _ref.apply(this);
    }
    return this;
  };

  Morph.prototype.connectValuesToAddedChild = function(theChild) {
    var childVal, morphValsDependingOnChildrenVals, morphValsDirectlyDependingOnParentVals, nameOfChildrenVar, nameOfParentVar, parentVal, valDependingOnChildrenVal, valDependingOnParentVal, valNameNotUsed, _ref, _ref1, _results;
    _ref = this.morphValsDependingOnChildrenVals;
    for (nameOfChildrenVar in _ref) {
      morphValsDependingOnChildrenVals = _ref[nameOfChildrenVar];
      childVal = theChild.allValsInMorphByName[nameOfChildrenVar];
      if (childVal != null) {
        for (valNameNotUsed in morphValsDependingOnChildrenVals) {
          valDependingOnChildrenVal = morphValsDependingOnChildrenVals[valNameNotUsed];
          valDependingOnChildrenVal.args.connectToChildVal(valDependingOnChildrenVal, childVal);
        }
      }
    }
    _ref1 = theChild.morphValsDirectlyDependingOnParentVals;
    _results = [];
    for (nameOfParentVar in _ref1) {
      morphValsDirectlyDependingOnParentVals = _ref1[nameOfParentVar];
      parentVal = this.allValsInMorphByName[nameOfParentVar];
      if (parentVal != null) {
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (valNameNotUsed in morphValsDirectlyDependingOnParentVals) {
            valDependingOnParentVal = morphValsDirectlyDependingOnParentVals[valNameNotUsed];
            _results1.push(valDependingOnParentVal.args.connectToParentVal(valDependingOnParentVal, parentVal));
          }
          return _results1;
        })());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Morph.prototype.disconnectValuesFromRemovedChild = function(theChild) {
    var childArg, morphValsDependingOnChildrenVals, morphValsDirectlyDependingOnParentVals, nameOfChildrenVar, nameOfParentVar, parentArg, valDependingOnChildrenVal, valDependingOnParentVal, valNameNotUsed, _ref, _ref1, _results;
    _ref = this.morphValsDependingOnChildrenVals;
    for (nameOfChildrenVar in _ref) {
      morphValsDependingOnChildrenVals = _ref[nameOfChildrenVar];
      for (valNameNotUsed in morphValsDependingOnChildrenVals) {
        valDependingOnChildrenVal = morphValsDependingOnChildrenVals[valNameNotUsed];
        childArg = valDependingOnChildrenVal.args.argById[theChild.id];
        if (childArg != null) {
          childArg.disconnectChildArg();
        }
      }
    }
    _ref1 = theChild.morphValsDirectlyDependingOnParentVals;
    _results = [];
    for (nameOfParentVar in _ref1) {
      morphValsDirectlyDependingOnParentVals = _ref1[nameOfParentVar];
      _results.push((function() {
        var _results1;
        _results1 = [];
        for (valNameNotUsed in morphValsDirectlyDependingOnParentVals) {
          valDependingOnParentVal = morphValsDirectlyDependingOnParentVals[valNameNotUsed];
          parentArg = valDependingOnParentVal.args.parentArgByName[nameOfParentVar];
          if (parentArg != null) {
            _results1.push(parentArg.disconnectParentArg());
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  Morph.prototype.uniqueIDString = function() {
    return this.morphClassString() + "#" + this.instanceNumericID;
  };

  Morph.prototype.morphClassString = function() {
    return this.constructor.name || this.constructor.toString().split(" ")[1].split("(")[0];
  };

  Morph.morphFromUniqueIDString = function(theUniqueID) {
    var result;
    result = world.topMorphSuchThat((function(_this) {
      return function(m) {
        return m.uniqueIDString() === theUniqueID;
      };
    })(this));
    if (result == null) {
      alert("theUniqueID " + theUniqueID + " not found!");
    }
    return result;
  };

  Morph.prototype.assignUniqueID = function() {
    this.constructor.instancesCounter++;
    this.constructor.lastBuiltInstanceNumericID++;
    return this.instanceNumericID = this.constructor.lastBuiltInstanceNumericID;
  };

  Morph.roundNumericIDsToNextThousand = function() {
    console.log("@roundNumericIDsToNextThousand");
    if (this.lastBuiltInstanceNumericID % 1000 === 0) {
      this.lastBuiltInstanceNumericID++;
    }
    return this.lastBuiltInstanceNumericID = 1000 * Math.ceil(this.lastBuiltInstanceNumericID / 1000);
  };

  function Morph() {
    Morph.__super__.constructor.call(this);
    this.assignUniqueID();
    this.bounds = new Rectangle(0, 0, 50, 40);
    this.color = this.color || new Color(80, 80, 80);
    this.lastTime = Date.now();
    this.allValsInMorphByName = {};
    this.morphValsDependingOnChildrenVals = {};
    this.morphValsDirectlyDependingOnParentVals = {};
  }

  Morph.prototype.toString = function() {
    var firstPart;
    firstPart = "a ";
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.IDLE && SystemTestsRecorderAndPlayer.hidingOfMorphsNumberIDInLabels) {
      firstPart = firstPart + this.morphClassString();
    } else {
      firstPart = firstPart + this.uniqueIDString();
    }
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.IDLE && SystemTestsRecorderAndPlayer.hidingOfMorphsGeometryInfoInLabels) {
      return firstPart;
    } else {
      return firstPart + " " + this.bounds;
    }
  };

  Morph.prototype.toStringWithoutGeometry = function() {
    return "a " + this.uniqueIDString();
  };

  Morph.prototype.destroy = function() {
    this.visible = false;
    if (this.parent != null) {
      this.fullChanged();
      this.parent.removeChild(this);
    }
    return null;
  };

  Morph.prototype.destroyAll = function() {
    while (this.children.length !== 0) {
      this.children[0].destroy();
    }
    return null;
  };

  Morph.prototype.runChildrensStepFunction = function() {
    var elapsed, nxt, timeRemainingToWaitedFrame;
    if (!this.step) {
      return null;
    }
    elapsed = WorldMorph.currentTime - this.lastTime;
    if (this.fps > 0) {
      timeRemainingToWaitedFrame = (1000 / this.fps) - elapsed;
    } else {
      timeRemainingToWaitedFrame = 0;
    }
    if (timeRemainingToWaitedFrame < 1) {
      this.lastTime = WorldMorph.currentTime;
      if (this.onNextStep) {
        nxt = this.onNextStep;
        this.onNextStep = null;
        nxt.call(this);
      }
      this.step();
      return this.children.forEach(function(child) {
        return child.runChildrensStepFunction();
      });
    }
  };

  Morph.prototype.nextSteps = function(arrayOfFunctions) {
    var lst, nxt;
    lst = arrayOfFunctions || [];
    nxt = lst.shift();
    if (nxt) {
      return this.onNextStep = (function(_this) {
        return function() {
          nxt.call(_this);
          return _this.nextSteps(lst);
        };
      })(this);
    }
  };

  Morph.prototype.step = noOperation;

  Morph.prototype.left = function() {
    return this.bounds.left();
  };

  Morph.prototype.right = function() {
    return this.bounds.right();
  };

  Morph.prototype.top = function() {
    return this.bounds.top();
  };

  Morph.prototype.bottom = function() {
    return this.bounds.bottom();
  };

  Morph.prototype.center = function() {
    return this.bounds.center();
  };

  Morph.prototype.bottomCenter = function() {
    return this.bounds.bottomCenter();
  };

  Morph.prototype.bottomLeft = function() {
    return this.bounds.bottomLeft();
  };

  Morph.prototype.bottomRight = function() {
    return this.bounds.bottomRight();
  };

  Morph.prototype.boundingBox = function() {
    return this.bounds;
  };

  Morph.prototype.corners = function() {
    return this.bounds.corners();
  };

  Morph.prototype.leftCenter = function() {
    return this.bounds.leftCenter();
  };

  Morph.prototype.rightCenter = function() {
    return this.bounds.rightCenter();
  };

  Morph.prototype.topCenter = function() {
    return this.bounds.topCenter();
  };

  Morph.prototype.topLeft = function() {
    return this.bounds.topLeft();
  };

  Morph.prototype.topRight = function() {
    return this.bounds.topRight();
  };

  Morph.prototype.position = function() {
    return this.bounds.origin;
  };

  Morph.prototype.extent = function() {
    return this.bounds.extent();
  };

  Morph.prototype.width = function() {
    return this.bounds.width();
  };

  Morph.prototype.height = function() {
    return this.bounds.height();
  };

  Morph.prototype.plausibleTargetAndDestinationMorphs = function(theMorph) {
    var result;
    result = [];
    if (!this.isMinimised && this.isVisible && !theMorph.containedInParentsOf(this) && this.bounds.intersects(theMorph.bounds)) {
      result = [this];
    }
    this.children.forEach(function(child) {
      return result = result.concat(child.plausibleTargetAndDestinationMorphs(theMorph));
    });
    return result;
  };

  Morph.prototype.boundsIncludingChildren = function() {
    var result;
    result = this.bounds;
    this.children.forEach(function(child) {
      if (!child.isMinimised && child.isVisible) {
        return result = result.merge(child.boundsIncludingChildren());
      }
    });
    return result;
  };

  Morph.prototype.boundsIncludingChildrenNoShadow = function() {
    var result;
    result = this.bounds;
    this.children.forEach(function(child) {
      if ((!(child instanceof ShadowMorph)) && (!child.isMinimised) && child.isVisible) {
        return result = result.merge(child.boundsIncludingChildrenNoShadow());
      }
    });
    return result;
  };

  Morph.prototype.visibleBounds = function() {
    var frames, visible;
    visible = this.bounds;
    frames = this.allParentsTopToBottomSuchThat(function(p) {
      return p instanceof FrameMorph;
    });
    frames.forEach(function(f) {
      return visible = visible.intersect(f.bounds);
    });
    return visible;
  };

  Morph.prototype.moveBy = function(delta) {
    this.changed();
    this.bounds = this.bounds.translateBy(delta);
    this.children.forEach(function(child) {
      return child.moveBy(delta);
    });
    return this.changed();
  };

  Morph.prototype.silentMoveBy = function(delta) {
    this.bounds = this.bounds.translateBy(delta);
    return this.children.forEach(function(child) {
      return child.silentMoveBy(delta);
    });
  };

  Morph.prototype.setPosition = function(aPoint) {
    var delta;
    delta = aPoint.subtract(this.topLeft());
    if ((delta.x !== 0) || (delta.y !== 0)) {
      return this.moveBy(delta);
    }
  };

  Morph.prototype.silentSetPosition = function(aPoint) {
    var delta;
    delta = aPoint.subtract(this.topLeft());
    if ((delta.x !== 0) || (delta.y !== 0)) {
      return this.silentMoveBy(delta);
    }
  };

  Morph.prototype.setLeft = function(x) {
    return this.setPosition(new Point(x, this.top()));
  };

  Morph.prototype.setRight = function(x) {
    return this.setPosition(new Point(x - this.width(), this.top()));
  };

  Morph.prototype.setTop = function(y) {
    return this.setPosition(new Point(this.left(), y));
  };

  Morph.prototype.setBottom = function(y) {
    return this.setPosition(new Point(this.left(), y - this.height()));
  };

  Morph.prototype.setCenter = function(aPoint) {
    return this.setPosition(aPoint.subtract(this.extent().floorDivideBy(2)));
  };

  Morph.prototype.setFullCenter = function(aPoint) {
    return this.setPosition(aPoint.subtract(this.boundsIncludingChildren().extent().floorDivideBy(2)));
  };

  Morph.prototype.keepWithin = function(aMorph) {
    var bottomOff, leftOff, rightOff, topOff;
    leftOff = this.boundsIncludingChildren().left() - aMorph.left();
    if (leftOff < 0) {
      this.moveBy(new Point(-leftOff, 0));
    }
    rightOff = this.boundsIncludingChildren().right() - aMorph.right();
    if (rightOff > 0) {
      this.moveBy(new Point(-rightOff, 0));
    }
    topOff = this.boundsIncludingChildren().top() - aMorph.top();
    if (topOff < 0) {
      this.moveBy(new Point(0, -topOff));
    }
    bottomOff = this.boundsIncludingChildren().bottom() - aMorph.bottom();
    if (bottomOff > 0) {
      return this.moveBy(new Point(0, -bottomOff));
    }
  };

  Morph.prototype.layoutSubmorphs = function() {
    return null;
  };

  Morph.prototype.setExtent = function(aPoint) {
    if (!aPoint.eq(this.extent())) {
      this.changed();
      this.silentSetExtent(aPoint);
      this.changed();
      this.updateRendering();
      return this.layoutSubmorphs();
    }
  };

  Morph.prototype.silentSetExtent = function(aPoint) {
    var ext, newHeight, newWidth;
    ext = aPoint.round();
    newWidth = Math.max(ext.x, 0);
    newHeight = Math.max(ext.y, 0);
    return this.bounds.corner = new Point(this.bounds.origin.x + newWidth, this.bounds.origin.y + newHeight);
  };

  Morph.prototype.setWidth = function(width) {
    return this.setExtent(new Point(width || 0, this.height()));
  };

  Morph.prototype.silentSetWidth = function(width) {
    var w;
    w = Math.max(Math.round(width || 0), 0);
    return this.bounds.corner = new Point(this.bounds.origin.x + w, this.bounds.corner.y);
  };

  Morph.prototype.setHeight = function(height) {
    return this.setExtent(new Point(this.width(), height || 0));
  };

  Morph.prototype.silentSetHeight = function(height) {
    var h;
    h = Math.max(Math.round(height || 0), 0);
    return this.bounds.corner = new Point(this.bounds.corner.x, this.bounds.origin.y + h);
  };

  Morph.prototype.setColor = function(aColorOrAMorphGivingAColor) {
    var aColor;
    if (aColorOrAMorphGivingAColor.getColor != null) {
      aColor = aColorOrAMorphGivingAColor.getColor();
    } else {
      aColor = aColorOrAMorphGivingAColor;
    }
    if (aColor) {
      if (!this.color.eq(aColor)) {
        this.color = aColor;
        this.changed();
        return this.updateRendering();
      }
    }
  };

  Morph.prototype.updateRendering = function() {
    var context;
    this.image = newCanvas(this.extent().scaleBy(pixelRatio));
    context = this.image.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    context.fillStyle = this.color.toString();
    context.fillRect(0, 0, this.width(), this.height());
    if (this.cachedTexture) {
      this.drawCachedTexture();
    } else {
      if (this.texture) {
        this.drawTexture(this.texture);
      }
    }
    return this.changed();
  };

  Morph.prototype.drawTexture = function(url) {
    this.cachedTexture = new Image();
    this.cachedTexture.onload = (function(_this) {
      return function() {
        return _this.drawCachedTexture();
      };
    })(this);
    return this.cachedTexture.src = this.texture = url;
  };

  Morph.prototype.drawCachedTexture = function() {
    var bg, cols, context, lines, x, y, _i, _j;
    bg = this.cachedTexture;
    cols = Math.floor(this.image.width / bg.width);
    lines = Math.floor(this.image.height / bg.height);
    context = this.image.getContext("2d");
    for (y = _i = 0; 0 <= lines ? _i <= lines : _i >= lines; y = 0 <= lines ? ++_i : --_i) {
      for (x = _j = 0; 0 <= cols ? _j <= cols : _j >= cols; x = 0 <= cols ? ++_j : --_j) {
        context.drawImage(bg, Math.round(x * bg.width), Math.round(y * bg.height));
      }
    }
    return this.changed();
  };

  Morph.prototype.blit = function(aCanvas, clippingRectangle) {
    var al, area, at, context, delta, h, randomB, randomG, randomR, sl, src, st, w;
    if (this.isMinimised || !this.isVisible || (this.image == null)) {
      return null;
    }
    area = clippingRectangle.intersect(this.bounds).round();
    if (area.isNotEmpty()) {
      delta = this.position().neg();
      src = area.copy().translateBy(delta).round();
      context = aCanvas.getContext("2d");
      context.globalAlpha = this.alpha;
      sl = src.left() * pixelRatio;
      st = src.top() * pixelRatio;
      al = area.left() * pixelRatio;
      at = area.top() * pixelRatio;
      w = Math.min(src.width() * pixelRatio, this.image.width - sl);
      h = Math.min(src.height() * pixelRatio, this.image.height - st);
      if (w < 1 || h < 1) {
        return null;
      }
      context.drawImage(this.image, Math.round(sl), Math.round(st), Math.round(w), Math.round(h), Math.round(al), Math.round(at), Math.round(w), Math.round(h));
      if (world.showRedraws) {
        randomR = Math.round(Math.random() * 255);
        randomG = Math.round(Math.random() * 255);
        randomB = Math.round(Math.random() * 255);
        context.globalAlpha = 0.5;
        context.fillStyle = "rgb(" + randomR + "," + randomG + "," + randomB + ")";
        return context.fillRect(Math.round(al), Math.round(at), Math.round(w), Math.round(h));
      }
    }
  };

  Morph.prototype.recursivelyBlit = function(aCanvas, clippingRectangle) {
    if (clippingRectangle == null) {
      clippingRectangle = this.boundsIncludingChildren();
    }
    if (this.isMinimised || !this.isVisible) {
      return null;
    }
    this.blit(aCanvas, clippingRectangle);
    return this.children.forEach(function(child) {
      return child.recursivelyBlit(aCanvas, clippingRectangle);
    });
  };

  Morph.prototype.hide = function() {
    this.isVisible = false;
    this.changed();
    return this.children.forEach(function(child) {
      return child.hide();
    });
  };

  Morph.prototype.show = function() {
    this.isVisible = true;
    this.changed();
    return this.children.forEach(function(child) {
      return child.show();
    });
  };

  Morph.prototype.minimise = function() {
    this.isMinimised = true;
    this.changed();
    return this.children.forEach(function(child) {
      return child.minimise();
    });
  };

  Morph.prototype.unminimise = function() {
    this.isMinimised = false;
    this.changed();
    return this.children.forEach(function(child) {
      return child.unminimise();
    });
  };

  Morph.prototype.toggleVisibility = function() {
    this.isMinimised = !this.isMinimised;
    this.changed();
    return this.children.forEach(function(child) {
      return child.toggleVisibility();
    });
  };

  Morph.prototype.fullImage = function() {
    var boundsIncludingChildren, ctx, img;
    boundsIncludingChildren = this.boundsIncludingChildren();
    img = newCanvas(boundsIncludingChildren.extent().scaleBy(pixelRatio));
    ctx = img.getContext("2d");
    ctx.translate(-boundsIncludingChildren.origin.x * pixelRatio, -boundsIncludingChildren.origin.y * pixelRatio);
    this.recursivelyBlit(img, boundsIncludingChildren);
    return img;
  };

  Morph.prototype.fullImageData = function() {
    return this.fullImage().toDataURL("image/png");
  };

  Morph.prototype.fullImageHashCode = function() {
    return hashCode(this.fullImageData());
  };

  Morph.prototype.shadowImage = function(off_, color) {
    var clr, ctx, fb, img, offset, outline, sha;
    offset = off_ || new Point(7, 7);
    clr = color || new Color(0, 0, 0);
    fb = this.boundsIncludingChildren().extent();
    img = this.fullImage();
    outline = newCanvas(fb.scaleBy(pixelRatio));
    ctx = outline.getContext("2d");
    ctx.drawImage(img, 0, 0);
    ctx.globalCompositeOperation = "destination-out";
    ctx.drawImage(img, Math.round(-offset.x) * pixelRatio, Math.round(-offset.y) * pixelRatio);
    sha = newCanvas(fb.scaleBy(pixelRatio));
    ctx = sha.getContext("2d");
    ctx.drawImage(outline, 0, 0);
    ctx.globalCompositeOperation = "source-atop";
    ctx.fillStyle = clr.toString();
    ctx.fillRect(0, 0, fb.x * pixelRatio, fb.y * pixelRatio);
    return sha;
  };

  Morph.prototype.shadowImageBlurred = function(off_, color) {
    var blur, clr, ctx, fb, img, offset, sha;
    offset = off_ || new Point(7, 7);
    blur = this.shadowBlur;
    clr = color || new Color(0, 0, 0);
    fb = this.boundsIncludingChildren().extent().add(blur * 2);
    img = this.fullImage();
    sha = newCanvas(fb.scaleBy(pixelRatio));
    ctx = sha.getContext("2d");
    ctx.shadowOffsetX = offset.x * pixelRatio;
    ctx.shadowOffsetY = offset.y * pixelRatio;
    ctx.shadowBlur = blur * pixelRatio;
    ctx.shadowColor = clr.toString();
    ctx.drawImage(img, Math.round((blur - offset.x) * pixelRatio), Math.round((blur - offset.y) * pixelRatio));
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.shadowBlur = 0;
    ctx.globalCompositeOperation = "destination-out";
    ctx.drawImage(img, Math.round((blur - offset.x) * pixelRatio), Math.round((blur - offset.y) * pixelRatio));
    return sha;
  };

  Morph.prototype.addShadow = function(offset, alpha, color) {
    var shadow;
    shadow = new ShadowMorph(this, offset, alpha, color);
    this.addBack(shadow);
    this.fullChanged();
    return shadow;
  };

  Morph.prototype.getShadow = function() {
    return this.topmostChildSuchThat(function(child) {
      return child instanceof ShadowMorph;
    });
  };

  Morph.prototype.removeShadow = function() {
    var shadow;
    shadow = this.getShadow();
    if (shadow != null) {
      this.fullChanged();
      return this.removeChild(shadow);
    }
  };

  Morph.prototype.penTrails = function() {
    return this.image;
  };

  Morph.prototype.changed = function() {
    var w;
    if (this.trackChanges) {
      w = this.root();
      if (w instanceof WorldMorph && (this instanceof WorldMorph || (this.parent != null))) {
        w.broken.push(this.visibleBounds().spread());
      }
    }
    if (this.parent) {
      return this.parent.childChanged(this);
    }
  };

  Morph.prototype.fullChanged = function() {
    var w;
    if (this.trackChanges) {
      w = this.root();
      if (w instanceof WorldMorph && (this instanceof WorldMorph || (this.parent != null))) {
        return w.broken.push(this.boundsIncludingChildren().spread());
      }
    }
  };

  Morph.prototype.childChanged = function() {
    if (this.parent) {
      return this.parent.childChanged(this);
    }
  };

  Morph.prototype.world = function() {
    var root;
    root = this.root();
    if (root instanceof WorldMorph) {
      return root;
    }
    if (root instanceof HandMorph) {
      return root.world;
    }
    return null;
  };

  Morph.prototype.add = function(aMorph) {
    var owner;
    aMorph.changed();
    owner = aMorph.parent;
    if (owner != null) {
      owner.removeChild(aMorph);
    }
    this.addChild(aMorph);
    return aMorph.updateRendering();
  };

  Morph.prototype.addBack = function(aMorph) {
    var owner;
    owner = aMorph.parent;
    if (owner != null) {
      owner.removeChild(aMorph);
    }
    aMorph.updateRendering();
    return this.addChildFirst(aMorph);
  };

  Morph.prototype.morphAt = function(aPoint) {
    var morphs, result;
    morphs = this.allChildrenTopToBottom();
    result = null;
    morphs.forEach(function(m) {
      if (m.boundsIncludingChildren().containsPoint(aPoint) && (result === null)) {
        return result = m;
      }
    });
    return result;
  };

  Morph.prototype.getPixelColor = function(aPoint) {
    var context, data, point;
    point = aPoint.subtract(this.bounds.origin);
    context = this.image.getContext("2d");
    data = context.getImageData(point.x * pixelRatio, point.y * pixelRatio, 1, 1);
    return new Color(data.data[0], data.data[1], data.data[2], data.data[3]);
  };

  Morph.prototype.isTransparentAt = function(aPoint) {
    var context, data, point;
    if (this.bounds.containsPoint(aPoint)) {
      if (this.texture) {
        return false;
      }
      point = aPoint.subtract(this.bounds.origin);
      context = this.image.getContext("2d");
      data = context.getImageData(Math.floor(point.x) * pixelRatio, Math.floor(point.y) * pixelRatio, 1, 1);
      return data.data[3] === 0;
    }
    return false;
  };

  Morph.prototype.clone = function(target) {
    var theClone;
    if (typeof target === "object") {
      theClone = Object.create(target.constructor.prototype);
      theClone.assignUniqueID();
      return theClone;
    }
    return target;
  };

  Morph.prototype.shallowCopy = function(target) {
    var c, property;
    c = this.clone(target.constructor.prototype);
    for (property in target) {
      if (target.hasOwnProperty(property) && property !== "instanceNumericID") {
        c[property] = target[property];
      }
    }
    return c;
  };

  Morph.prototype.copy = function() {
    var c;
    c = this.shallowCopy(this);
    c.parent = null;
    c.children = [];
    c.bounds = this.bounds.copy();
    return c;
  };

  Morph.prototype.copyRecordingReferences = function(dict) {
    var c;
    c = this.copy();
    dict[this.uniqueIDString()] = c;
    this.children.forEach(function(m) {
      return c.add(m.copyRecordingReferences(dict));
    });
    return c;
  };

  Morph.prototype.fullCopy = function() {
    var c, dict;
    dict = {};
    c = this.copyRecordingReferences(dict);
    c.forAllChildrenBottomToTop(function(child) {
      return child.updateReferences(dict);
    });
    c.updateReferences(dict);
    return c;
  };

  Morph.prototype.updateReferences = function(dict) {
    var property, _results;
    _results = [];
    for (property in this) {
      if (this[property] != null) {
        if (this[property].isMorph && dict[this[property].uniqueIDString()]) {
          _results.push(this[property] = dict[this[property].uniqueIDString()]);
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Morph.prototype.rootForGrab = function() {
    if (this instanceof ShadowMorph) {
      return this.parent.rootForGrab();
    }
    if (this.parent instanceof ScrollFrameMorph) {
      return this.parent;
    }
    if (this.parent === null || this.parent instanceof WorldMorph || this.parent instanceof FrameMorph || this.isDraggable === true) {
      return this;
    }
    return this.parent.rootForGrab();
  };

  Morph.prototype.wantsDropOf = function(aMorph) {
    if ((aMorph instanceof HandleMorph) || (aMorph instanceof MenuMorph)) {
      return false;
    }
    return this.acceptsDrops;
  };

  Morph.prototype.pickUp = function() {
    this.setPosition(world.hand.position().subtract(this.extent().floorDivideBy(2)));
    return world.hand.grab(this);
  };

  Morph.prototype.isPickedUp = function() {
    return this.parentThatIsA(HandMorph) != null;
  };

  Morph.prototype.situation = function() {
    if (this.parent) {
      return {
        origin: this.parent,
        position: this.position().subtract(this.parent.position())
      };
    }
    return null;
  };

  Morph.prototype.slideBackTo = function(situation, inSteps) {
    var oldFps, oldStep, pos, stepCount, steps, xStep, yStep;
    steps = inSteps || 5;
    pos = situation.origin.position().add(situation.position);
    xStep = -(this.left() - pos.x) / steps;
    yStep = -(this.top() - pos.y) / steps;
    stepCount = 0;
    oldStep = this.step;
    oldFps = this.fps;
    this.fps = 0;
    return this.step = (function(_this) {
      return function() {
        _this.fullChanged();
        _this.silentMoveBy(new Point(xStep, yStep));
        _this.fullChanged();
        stepCount += 1;
        if (stepCount === steps) {
          situation.origin.add(_this);
          if (situation.origin.reactToDropOf) {
            situation.origin.reactToDropOf(_this);
          }
          _this.step = oldStep;
          return _this.fps = oldFps;
        }
      };
    })(this);
  };

  Morph.prototype.resize = function() {
    return this.world().activeHandle = new HandleMorph(this);
  };

  Morph.prototype.move = function() {
    return this.world().activeHandle = new HandleMorph(this, null, null, null, null, "move");
  };

  Morph.prototype.hint = function(msg) {
    var m, text;
    text = msg;
    if (msg) {
      if (msg.toString) {
        text = msg.toString();
      }
    } else {
      text = "NULL";
    }
    m = new MenuMorph(this, text);
    m.isDraggable = true;
    return m.popUpCenteredAtHand(this.world());
  };

  Morph.prototype.inform = function(msg) {
    var m, text;
    text = msg;
    if (msg) {
      if (msg.toString) {
        text = msg.toString();
      }
    } else {
      text = "NULL";
    }
    m = new MenuMorph(this, text);
    m.addItem("Ok");
    m.isDraggable = true;
    return m.popUpCenteredAtHand(this.world());
  };

  Morph.prototype.prompt = function(msg, callback, defaultContents, width, floorNum, ceilingNum, isRounded) {
    var entryField, isNumeric, menu, slider;
    if (ceilingNum) {
      isNumeric = true;
    }
    entryField = new StringFieldMorph(defaultContents || "", width || 100, WorldMorph.preferencesAndSettings.prompterFontSize, WorldMorph.preferencesAndSettings.prompterFontName, false, false, isNumeric);
    menu = new MenuMorph(this, msg || "", entryField);
    menu.items.push(entryField);
    if (ceilingNum || WorldMorph.preferencesAndSettings.useSliderForInput) {
      slider = new SliderMorph(floorNum || 0, ceilingNum, parseFloat(defaultContents), Math.floor((ceilingNum - floorNum) / 4), "horizontal");
      slider.alpha = 1;
      slider.color = new Color(225, 225, 225);
      slider.button.color = menu.borderColor;
      slider.button.highlightColor = slider.button.color.copy();
      slider.button.highlightColor.b += 100;
      slider.button.pressColor = slider.button.color.copy();
      slider.button.pressColor.b += 150;
      slider.setHeight(WorldMorph.preferencesAndSettings.prompterSliderSize);
      if (isRounded) {
        slider.action = function(num) {
          entryField.changed();
          entryField.text.text = Math.round(num).toString();
          entryField.text.updateRendering();
          entryField.text.changed();
          return entryField.text.edit();
        };
      } else {
        slider.action = function(num) {
          entryField.changed();
          entryField.text.text = num.toString();
          entryField.text.updateRendering();
          return entryField.text.changed();
        };
      }
      menu.items.push(slider);
    }
    menu.addLine(2);
    menu.addItem("Ok", callback);
    menu.addItem("Cancel", function() {
      return null;
    });
    menu.isDraggable = true;
    menu.popUpAtHand();
    return entryField.text.edit();
  };

  Morph.prototype.pickColor = function(msg, callback, defaultContents) {
    var colorPicker, menu;
    colorPicker = new ColorPickerMorph(defaultContents);
    menu = new MenuMorph(this, msg || "", colorPicker);
    menu.items.push(colorPicker);
    menu.addLine(2);
    menu.addItem("Ok", callback);
    menu.addItem("Cancel", function() {
      return null;
    });
    menu.isDraggable = true;
    return menu.popUpAtHand();
  };

  Morph.prototype.inspect = function(anotherObject) {
    var inspectee;
    inspectee = this;
    if (anotherObject) {
      inspectee = anotherObject;
    }
    return this.spawnInspector(inspectee);
  };

  Morph.prototype.spawnInspector = function(inspectee) {
    var inspector, world;
    inspector = new InspectorMorph(inspectee);
    world = (this.world instanceof Function ? this.world() : this.root() || this.world);
    inspector.setPosition(world.hand.position());
    inspector.keepWithin(world);
    world.add(inspector);
    return inspector.changed();
  };

  Morph.prototype.contextMenu = function() {
    var world;
    if (this.customContextMenu) {
      return this.customContextMenu();
    }
    world = (this.world instanceof Function ? this.world() : this.root() || this.world);
    if (world && world.isDevMode) {
      if (this.parent === world) {
        return this.developersMenu();
      }
      return this.hierarchyMenu();
    }
    return this.userMenu() || (this.parent && this.parent.userMenu());
  };

  Morph.prototype.hierarchyMenu = function() {
    var menu, parents, world;
    parents = this.allParentsTopToBottom();
    world = (this.world instanceof Function ? this.world() : this.root() || this.world);
    menu = new MenuMorph(this, null);
    parents.forEach(function(each) {
      var textLabelForMorph;
      if (each.developersMenu && (each !== world)) {
        textLabelForMorph = each.toString().slice(0, 50);
        return menu.addItem(textLabelForMorph, function() {
          return each.developersMenu().popUpAtHand();
        });
      }
    });
    return menu;
  };

  Morph.prototype.developersMenu = function() {
    var menu, takePic, userMenu, world;
    world = (this.world instanceof Function ? this.world() : this.root() || this.world);
    userMenu = this.userMenu() || (this.parent && this.parent.userMenu());
    menu = new MenuMorph(this, this.constructor.name || this.constructor.toString().split(" ")[1].split("(")[0]);
    if (userMenu) {
      menu.addItem("user features...", function() {
        return userMenu.popUpAtHand();
      });
      menu.addLine();
    }
    menu.addItem("color...", (function() {
      return this.pickColor(menu.title + "\ncolor:", this.setColor, this.color);
    }), "choose another color \nfor this morph");
    menu.addItem("transparency...", (function() {
      return this.prompt(menu.title + "\nalpha\nvalue:", this.setAlphaScaled, (this.alpha * 100).toString(), null, 1, 100, true);
    }), "set this morph's\nalpha value");
    menu.addItem("resize...", (function() {
      return this.resize();
    }), "show a handle\nwhich can be dragged\nto change this morph's" + " extent");
    menu.addLine();
    menu.addItem("duplicate", (function() {
      var aFullCopy;
      aFullCopy = this.fullCopy();
      return aFullCopy.pickUp();
    }), "make a copy\nand pick it up");
    menu.addItem("pick up", (function() {
      return this.pickUp();
    }), "disattach and put \ninto the hand");
    menu.addItem("attach...", (function() {
      return this.attach();
    }), "stick this morph\nto another one");
    menu.addItem("move", (function() {
      return this.move();
    }), "show a handle\nwhich can be dragged\nto move this morph");
    menu.addItem("inspect", (function() {
      return this.inspect();
    }), "open a window\non all properties");
    takePic = (function(_this) {
      return function() {
        if (SystemTestsRecorderAndPlayer.state === SystemTestsRecorderAndPlayer.RECORDING) {
          return window.world.systemTestsRecorderAndPlayer.takeScreenshot(_this);
        } else if (SystemTestsRecorderAndPlayer.state === SystemTestsRecorderAndPlayer.PLAYING) {
          return window.world.systemTestsRecorderAndPlayer.imageDataOfAParticularMorph = _this.fullImageData();
        } else {
          return window.open(_this.fullImageData());
        }
      };
    })(this);
    menu.addItem("take pic", takePic, "open a new window\nwith a picture of this morph");
    menu.addLine();
    if (this.isDraggable) {
      menu.addItem("lock", (function() {
        return this.toggleIsDraggable();
      }), "make this morph\nunmovable");
    } else {
      menu.addItem("unlock", (function() {
        return this.toggleIsDraggable();
      }), "make this morph\nmovable");
    }
    menu.addItem("hide", (function() {
      return this.minimise();
    }));
    menu.addItem("delete", (function() {
      return this.destroy();
    }));
    return menu;
  };

  Morph.prototype.userMenu = function() {
    return null;
  };

  Morph.prototype.calculateAlphaScaled = function(alpha) {
    var newAlpha, unscaled;
    if (typeof alpha === "number") {
      unscaled = alpha / 100;
      return Math.min(Math.max(unscaled, 0.1), 1);
    } else {
      newAlpha = parseFloat(alpha);
      if (!isNaN(newAlpha)) {
        unscaled = newAlpha / 100;
        return Math.min(Math.max(unscaled, 0.1), 1);
      }
    }
  };

  Morph.prototype.setAlphaScaled = function(alphaOrMorphGivingAlpha) {
    var alpha;
    if (alphaOrMorphGivingAlpha.getValue != null) {
      alpha = alphaOrMorphGivingAlpha.getValue();
    } else {
      alpha = alphaOrMorphGivingAlpha;
    }
    if (alpha) {
      this.alpha = this.calculateAlphaScaled(alpha);
      return this.changed();
    }
  };

  Morph.prototype.attach = function() {
    var choices, choicesExcludingParent, menu;
    if (world.activeMenu) {
      world.activeMenu = world.activeMenu.destroy();
    }
    choices = world.plausibleTargetAndDestinationMorphs(this);
    choicesExcludingParent = [];
    choices.forEach((function(_this) {
      return function(each) {
        if (each !== _this.parent) {
          return choicesExcludingParent.push(each);
        }
      };
    })(this));
    if (choicesExcludingParent.length > 0) {
      menu = new MenuMorph(this, "choose new parent:");
      choicesExcludingParent.forEach((function(_this) {
        return function(each) {
          return menu.addItem(each.toString().slice(0, 50), function() {
            each.add(_this);
            if (each instanceof FrameMorph) {
              return each.adjustBounds();
            } else {
              return _this.isDraggable = false;
            }
          });
        };
      })(this));
    } else {
      menu = new MenuMorph(this, "no morphs to attach to");
    }
    return menu.popUpAtHand();
  };

  Morph.prototype.toggleIsDraggable = function() {
    return this.isDraggable = !this.isDraggable;
  };

  Morph.prototype.colorSetters = function() {
    return ["color"];
  };

  Morph.prototype.numericalSetters = function() {
    return ["setLeft", "setTop", "setWidth", "setHeight", "setAlphaScaled"];
  };

  Morph.prototype.allEntryFields = function() {
    return this.collectAllChildrenBottomToTopSuchThat(function(each) {
      return each.isEditable && (each instanceof StringMorph || each instanceof TextMorph);
    });
  };

  Morph.prototype.nextEntryField = function(current) {
    var fields, idx;
    fields = this.allEntryFields();
    idx = fields.indexOf(current);
    if (idx !== -1) {
      if (fields.length > (idx + 1)) {
        return fields[idx + 1];
      }
    }
    return fields[0];
  };

  Morph.prototype.previousEntryField = function(current) {
    var fields, idx;
    fields = this.allEntryFields();
    idx = fields.indexOf(current);
    if (idx !== -1) {
      if (idx > 0) {
        return fields[idx - 1];
      }
      return fields[fields.length - 1];
    }
    return fields[0];
  };

  Morph.prototype.tab = function(editField) {
    if (this.nextTab) {
      return this.nextTab(editField);
    } else {
      if (this.parent) {
        return this.parent.tab(editField);
      }
    }
  };

  Morph.prototype.backTab = function(editField) {
    if (this.previousTab) {
      return this.previousTab(editField);
    } else {
      if (this.parent) {
        return this.parent.backTab(editField);
      }
    }
  };

  Morph.prototype.escalateEvent = function(functionName, arg) {
    var handler;
    handler = this.parent;
    if (handler != null) {
      while (!handler[functionName] && (handler.parent != null)) {
        handler = handler.parent;
      }
      if (handler[functionName]) {
        return handler[functionName](arg);
      }
    }
  };

  Morph.prototype.evaluateString = function(code) {
    var err, result;
    try {
      result = eval(code);
      this.updateRendering();
      this.changed();
    } catch (_error) {
      err = _error;
      this.inform(err);
    }
    return result;
  };

  Morph.prototype.isTouching = function(otherMorph) {
    var data, oImg;
    oImg = this.overlappingImage(otherMorph);
    data = oImg.getContext("2d").getImageData(1, 1, oImg.width, oImg.height).data;
    return detect(data, function(each) {
      return each !== 0;
    }) !== null;
  };

  Morph.prototype.overlappingImage = function(otherMorph) {
    var ctx, fb, oImg, oRect, otherFb;
    fb = this.boundsIncludingChildren();
    otherFb = otherMorph.boundsIncludingChildren();
    oRect = fb.intersect(otherFb);
    oImg = newCanvas(oRect.extent().scaleBy(pixelRatio));
    ctx = oImg.getContext("2d");
    ctx.scale(pixelRatio, pixelRatio);
    if (oRect.width() < 1 || oRect.height() < 1) {
      return newCanvas((new Point(1, 1)).scaleBy(pixelRatio));
    }
    ctx.drawImage(this.fullImage(), Math.round(oRect.origin.x - fb.origin.x), Math.round(oRect.origin.y - fb.origin.y));
    ctx.globalCompositeOperation = "source-in";
    ctx.drawImage(otherMorph.fullImage(), Math.round(otherFb.origin.x - oRect.origin.x), Math.round(otherFb.origin.y - oRect.origin.y));
    return oImg;
  };

  Morph.coffeeScriptSourceOfThisClass = '# Morph //////////////////////////////////////////////////////////////\n\n# A Morph (from the Greek "shape" or "form") is an interactive\n# graphical object. General information on the Morphic system\n# can be found at http://minnow.cc.gatech.edu/squeak/30. \n\n# Morphs exist in a tree, rooted at a World or at the Hand.\n# The morphs owns submorphs. Morphs are drawn recursively;\n# if a Morph has no owner it never gets drawn\n# (but note that there are other ways to hide a Morph).\n\n# this comment below is needed to figure our dependencies between classes\n# REQUIRES globalFunctions\n\nclass Morph extends MorphicNode\n\n  # we want to keep track of how many instances we have\n  # of each Morph for a few reasons:\n  # 1) it gives us an identifier for each Morph\n  # 2) profiling\n  # 3) generate a uniqueIDString that we can use\n  #    for example for hashtables\n  # each subclass of Morph has its own static\n  # instancesCounter which starts from zero. First object\n  # has instanceNumericID of 1.\n  # instanceNumericID is initialised in the constructor.\n  @instancesCounter: 0\n  # see roundNumericIDsToNextThousand method for an\n  # explanation of why we need to keep this extra\n  # count\n  @lastBuiltInstanceNumericID: 0\n  instanceNumericID: 0\n  \n  # Just some tests here ////////////////////\n  propertyUpTheChain: [1,2,3]\n  morphMethod: ->\n    3.14\n  @morphStaticMethod: ->\n    3.14\n  # End of tests here ////////////////////\n\n  isMorph: true\n  bounds: null\n  color: null\n  texture: null # optional url of a fill-image\n  cachedTexture: null # internal cache of actual bg image\n  lastTime: null\n  alpha: 1\n\n  # for a Morph, being visible and minimised\n  # are two separate things.\n  # isVisible means that the morph is meant to show\n  #  as empty or without any surface. For example\n  #  a scrollbar "collapses" itself when there is no\n  #  content to scroll and puts its isVisible = false\n  # isMinimised means that the morph, whatever its\n  #  content or appearance or design, is not drawn\n  #  on the desktop. So a minimised or unminimised scrollbar\n  #  can be independently either visible or not.\n  # If we merge the two flags into one, then the\n  # following happens: "hiding" a morph causes the\n  # scrollbars in it to hide. Unhiding it causes the\n  # scrollbars to show, even if they should be invisible.\n  # Hence the need of two separate flags.\n  # Also, it\'s semantically two\n  # separate reasons of why a morph is not being\n  # painted on screen, so it makes sense to have\n  # two separate flags.\n  isMinimised: false\n  isVisible: true\n\n  isDraggable: false\n  isTemplate: false\n  acceptsDrops: false\n  noticesTransparentClick: false\n  fps: 0\n  customContextMenu: null\n  trackChanges: true\n  shadowBlur: 10\n  # note that image contains only the CURRENT morph, not the composition of this\n  # morph with all of the submorphs. I.e. for an inspector, this will only\n  # contain the background of the window pane. Not any of its contents.\n  # for the worldMorph, this only contains the background\n  image: null\n  onNextStep: null # optional function to be run once. Not currently used in Zombie Kernel\n\n  # contains all the reactive vals\n  allValsInMorphByName: null\n  morphValsDependingOnChildrenVals: null\n  morphValsDirectlyDependingOnParentVals: null\n\n  ##########################################################\n  # These two methods are for mixins\n  ##########################################################\n  # adds class properties\n  @augmentWith: (obj) ->\n    for key, value of obj when key not in MixedClassKeywords\n      @[key] = value\n    obj.onceAddedClassProperties?.apply(@)\n    this\n\n  # adds instance properties\n  @addInstanceProperties: (obj) ->\n    for key, value of obj when key not in MixedClassKeywords\n      # Assign properties to the prototype\n      @::[key] = value\n    obj.included?.apply(@)\n    this\n  ################# end of mixins methods ##################\n\n  ##########################################################\n  # Reactive Values start\n  ##########################################################\n\n\n  connectValuesToAddedChild: (theChild) ->\n    #if theChild.constructor.name == "RectangleMorph"\n    #  debugger\n\n    # we have a data structure that contains,\n    # for each child valName, all vals of this\n    # morph that depend on it. Go through\n    # all child val names, find the\n    # actual val in the child, and connect all\n    # to the vals in this morph that depend on it.\n    for nameOfChildrenVar, morphValsDependingOnChildrenVals of @morphValsDependingOnChildrenVals\n      childVal = theChild.allValsInMorphByName[ nameOfChildrenVar ]\n      if childVal?\n        for valNameNotUsed, valDependingOnChildrenVal of morphValsDependingOnChildrenVals\n          valDependingOnChildrenVal.args.connectToChildVal valDependingOnChildrenVal, childVal\n\n    # we have a data structure that contains,\n    # for each parent (me) valName, all vals of the child\n    # morph that depend on it. Go through\n    # all parent (me) val names, find the\n    # actual val in the parent (me), and connect it\n    # to the vals in the child morph that depend on it.\n    for nameOfParentVar, morphValsDirectlyDependingOnParentVals of theChild.morphValsDirectlyDependingOnParentVals\n      parentVal = @allValsInMorphByName[ nameOfParentVar ]\n      if parentVal?\n        for valNameNotUsed, valDependingOnParentVal of morphValsDirectlyDependingOnParentVals\n          valDependingOnParentVal.args.connectToParentVal valDependingOnParentVal, parentVal\n\n  disconnectValuesFromRemovedChild: (theChild) ->\n    # we have a data structure that contains,\n    # for each child valName, all vals of this\n    # morph that depend on it. Go through\n    # all child val names, find the\n    # actual val in the child, and DISconnect it\n    # FROM the vals in this morph that depended on it.\n    for nameOfChildrenVar, morphValsDependingOnChildrenVals of @morphValsDependingOnChildrenVals\n      for valNameNotUsed, valDependingOnChildrenVal of morphValsDependingOnChildrenVals\n        childArg = valDependingOnChildrenVal.args.argById[theChild.id]\n        if childArg?\n          childArg.disconnectChildArg()\n\n    # we have a data structure that contains,\n    # for each parent (me) valName, all vals of the child\n    # morph that depend on it. Go through\n    # all parent (me) val names, find the\n    # actual val in the parent (me), and connect it\n    # to the vals in the child morph that depend on it.\n    for nameOfParentVar, morphValsDirectlyDependingOnParentVals of theChild.morphValsDirectlyDependingOnParentVals\n      for valNameNotUsed, valDependingOnParentVal of morphValsDirectlyDependingOnParentVals\n        parentArg = valDependingOnParentVal.args.parentArgByName[ nameOfParentVar ]\n        if parentArg?\n          parentArg.disconnectParentArg()\n\n\n  ############## end of reactive values ##########################\n\n  uniqueIDString: ->\n    @morphClassString() + "#" + @instanceNumericID\n\n  morphClassString: ->\n    (@constructor.name or @constructor.toString().split(" ")[1].split("(")[0])\n\n  @morphFromUniqueIDString: (theUniqueID) ->\n    result = world.topMorphSuchThat (m) =>\n      m.uniqueIDString() is theUniqueID\n    if not result?\n      alert "theUniqueID " + theUniqueID + " not found!"\n    return result\n\n  assignUniqueID: ->\n    @constructor.instancesCounter++\n    @constructor.lastBuiltInstanceNumericID++\n    @instanceNumericID = @constructor.lastBuiltInstanceNumericID\n\n  # some test commands specify morphs via\n  # their uniqueIDString. This means that\n  # if there is one more TextMorph anywhere during\n  # the playback, for example because\n  # one new menu item is added, then\n  # all the subsequent IDs for the TextMorph will be off.\n  # In order to sort that out, we occasionally re-align\n  # the counts to the next 1000, so the next Morphs\n  # being created will all be aligned and\n  # minor discrepancies are ironed-out\n  @roundNumericIDsToNextThousand: ->\n    console.log "@roundNumericIDsToNextThousand"\n    # this if is because zero and multiples of 1000\n    # don\'t go up to 1000\n    if @lastBuiltInstanceNumericID %1000 == 0\n      @lastBuiltInstanceNumericID++\n    @lastBuiltInstanceNumericID = 1000*Math.ceil(@lastBuiltInstanceNumericID/1000)\n\n  constructor: ->\n    super()\n    @assignUniqueID()\n\n    # [TODO] why is there this strange non-zero default bound?\n    @bounds = new Rectangle(0, 0, 50, 40)\n    @color = @color or new Color(80, 80, 80)\n    @lastTime = Date.now()\n    # Note that we don\'t call @updateRendering()\n    # that\'s because the actual extending morph will probably\n    # set more details of how it should look (e.g. size),\n    # so we wait and we let the actual extending\n    # morph to draw itself.\n\n    @allValsInMorphByName = {}\n    @morphValsDependingOnChildrenVals = {}\n    @morphValsDirectlyDependingOnParentVals = {}\n\n\n  \n  #\n  #    damage list housekeeping\n  #\n  #	the trackChanges property of the Morph prototype is a Boolean switch\n  #	that determines whether the World\'s damage list (\'broken\' rectangles)\n  #	tracks changes. By default the switch is always on. If set to false\n  #	changes are not stored. This can be very useful for housekeeping of\n  #	the damage list in situations where a large number of (sub-) morphs\n  #	are changed more or less at once. Instead of keeping track of every\n  #	single submorph\'s changes tremendous performance improvements can be\n  #	achieved by setting the trackChanges flag to false before propagating\n  #	the layout changes, setting it to true again and then storing the full\n  #	bounds of the surrounding morph. An an example refer to the\n  #\n  #		layoutSubmorphs()\n  #		\n  #	method of InspectorMorph, or the\n  #	\n  #		startLayout()\n  #		endLayout()\n  #\n  #	methods of SyntaxElementMorph in the Snap application.\n  #\n  \n  \n  # Morph string representation: e.g. \'a Morph#2 [20@45 | 130@250]\'\n  toString: ->\n    firstPart = "a "\n\n    if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.IDLE and SystemTestsRecorderAndPlayer.hidingOfMorphsNumberIDInLabels\n      firstPart = firstPart + @morphClassString()\n    else\n      firstPart = firstPart + @uniqueIDString()\n\n    if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.IDLE and SystemTestsRecorderAndPlayer.hidingOfMorphsGeometryInfoInLabels\n      return firstPart\n    else\n      return firstPart + " " + @bounds\n\n  # Morph string representation: e.g. \'a Morph#2\'\n  toStringWithoutGeometry: ->\n    "a " +\n      @uniqueIDString()\n  \n  \n  # Morph deleting:\n  destroy: ->\n    # todo there is something to be figured out here\n    # cause in theory ALL the morphs in here are not\n    # visible, not just the parent... but it kind of\n    # seems overkill...\n    @visible = false\n    if @parent?\n      @fullChanged()\n      @parent.removeChild @\n    return null\n  \n  destroyAll: ->\n    # we can\'t use forEach because we are iterating over\n    # an array that changes its values (and length) while\n    # we are iterating on it.\n    until @children.length == 0\n      @children[0].destroy()\n    return null\n\n  # Morph stepping:\n  runChildrensStepFunction: ->\n    # step is the function that this Morph wants to run at each step.\n    # If the Morph wants to do nothing and let no-one of the children do nothing,\n    # then step is set to null.\n    # If the morph wants to do nothing but the children might want to do something,\n    # then step is set to the function that does nothing (i.e. a function noOperation that\n    # only returns null) \n    return null  unless @step\n\n    # for objects where @fps is defined, check which ones are due to be stepped\n    # and which ones want to wait. \n    elapsed = WorldMorph.currentTime - @lastTime\n    if @fps > 0\n      timeRemainingToWaitedFrame = (1000 / @fps) - elapsed\n    else\n      timeRemainingToWaitedFrame = 0\n    \n    # Question: why 1 here below?\n    if timeRemainingToWaitedFrame < 1\n      @lastTime = WorldMorph.currentTime\n      if @onNextStep\n        nxt = @onNextStep\n        @onNextStep = null\n        nxt.call(@)\n      @step()\n      @children.forEach (child) ->\n        child.runChildrensStepFunction()\n\n  # not used within Zombie Kernel yet.\n  nextSteps: (arrayOfFunctions) ->\n    lst = arrayOfFunctions or []\n    nxt = lst.shift()\n    if nxt\n      @onNextStep = =>\n        nxt.call @\n        @nextSteps lst  \n  \n  # leaving this function as step means that the morph wants to do nothing\n  # but the children *are* traversed and their step function is invoked.\n  # If a Morph wants to do nothing and wants to prevent the children to be\n  # traversed, then this function should be set to null.\n  step: noOperation\n  \n  \n  # Morph accessing - geometry getting:\n  left: ->\n    @bounds.left()\n  \n  right: ->\n    @bounds.right()\n  \n  top: ->\n    @bounds.top()\n  \n  bottom: ->\n    @bounds.bottom()\n  \n  center: ->\n    @bounds.center()\n  \n  bottomCenter: ->\n    @bounds.bottomCenter()\n  \n  bottomLeft: ->\n    @bounds.bottomLeft()\n  \n  bottomRight: ->\n    @bounds.bottomRight()\n  \n  boundingBox: ->\n    @bounds\n  \n  corners: ->\n    @bounds.corners()\n  \n  leftCenter: ->\n    @bounds.leftCenter()\n  \n  rightCenter: ->\n    @bounds.rightCenter()\n  \n  topCenter: ->\n    @bounds.topCenter()\n  \n  topLeft: ->\n    @bounds.topLeft()\n  \n  topRight: ->\n    @bounds.topRight()\n  \n  position: ->\n    @bounds.origin\n  \n  extent: ->\n    @bounds.extent()\n  \n  width: ->\n    @bounds.width()\n  \n  height: ->\n    @bounds.height()\n\n\n  # used for example:\n  # - to determine which morphs you can attach a morph to\n  # - for a SliderMorph\'s "set target" so you can change properties of another Morph\n  # - by the HandleMorph when you attach it to some other morph\n  # Note that this method has a slightly different\n  # version in FrameMorph (because it clips, so we need\n  # to check that we don\'t consider overlaps with\n  # morphs contained in a frame that are clipped and\n  # hence *actually* not overlapping).\n  plausibleTargetAndDestinationMorphs: (theMorph) ->\n    # find if I intersect theMorph,\n    # then check my children recursively\n    # exclude me if I\'m a child of theMorph\n    # (cause it\'s usually odd to attach a Morph\n    # to one of its submorphs or for it to\n    # control the properties of one of its submorphs)\n    result = []\n    if !@isMinimised and\n        @isVisible and\n        !theMorph.containedInParentsOf(@) and\n        @bounds.intersects(theMorph.bounds)\n      result = [@]\n\n    @children.forEach (child) ->\n      result = result.concat(child.plausibleTargetAndDestinationMorphs(theMorph))\n\n    return result\n\n  \n  boundsIncludingChildren: ->\n    result = @bounds\n    @children.forEach (child) ->\n      if !child.isMinimised and child.isVisible\n        result = result.merge(child.boundsIncludingChildren())\n    result\n  \n  boundsIncludingChildrenNoShadow: ->\n    # answer my full bounds but ignore any shadow\n    result = @bounds\n    @children.forEach (child) ->\n      if (child not instanceof ShadowMorph) and (!child.isMinimised) and (child.isVisible)\n        result = result.merge(child.boundsIncludingChildrenNoShadow())\n    result\n  \n  visibleBounds: ->\n    # answer which part of me is not clipped by a Frame\n    visible = @bounds\n    frames = @allParentsTopToBottomSuchThat (p) ->\n      p instanceof FrameMorph\n    frames.forEach (f) ->\n      visible = visible.intersect(f.bounds)\n    #\n    visible\n  \n  \n  # Morph accessing - simple changes:\n  moveBy: (delta) ->\n    # note that changed() is called two times\n    # because there are two areas of the screens\n    # that are dirty: the starting\n    # position and the end position.\n    # Both need to be repainted.\n    @changed()\n    @bounds = @bounds.translateBy(delta)\n    @children.forEach (child) ->\n      child.moveBy delta\n    #\n    @changed()\n  \n  silentMoveBy: (delta) ->\n    @bounds = @bounds.translateBy(delta)\n    @children.forEach (child) ->\n      child.silentMoveBy delta\n  \n  \n  setPosition: (aPoint) ->\n    delta = aPoint.subtract(@topLeft())\n    @moveBy delta  if (delta.x isnt 0) or (delta.y isnt 0)\n  \n  silentSetPosition: (aPoint) ->\n    delta = aPoint.subtract(@topLeft())\n    @silentMoveBy delta  if (delta.x isnt 0) or (delta.y isnt 0)\n  \n  setLeft: (x) ->\n    @setPosition new Point(x, @top())\n  \n  setRight: (x) ->\n    @setPosition new Point(x - @width(), @top())\n  \n  setTop: (y) ->\n    @setPosition new Point(@left(), y)\n  \n  setBottom: (y) ->\n    @setPosition new Point(@left(), y - @height())\n  \n  setCenter: (aPoint) ->\n    @setPosition aPoint.subtract(@extent().floorDivideBy(2))\n  \n  setFullCenter: (aPoint) ->\n    @setPosition aPoint.subtract(@boundsIncludingChildren().extent().floorDivideBy(2))\n  \n  # make sure I am completely within another Morph\'s bounds\n  keepWithin: (aMorph) ->\n    leftOff = @boundsIncludingChildren().left() - aMorph.left()\n    @moveBy new Point(-leftOff, 0)  if leftOff < 0\n    rightOff = @boundsIncludingChildren().right() - aMorph.right()\n    @moveBy new Point(-rightOff, 0)  if rightOff > 0\n    topOff = @boundsIncludingChildren().top() - aMorph.top()\n    @moveBy new Point(0, -topOff)  if topOff < 0\n    bottomOff = @boundsIncludingChildren().bottom() - aMorph.bottom()\n    @moveBy new Point(0, -bottomOff)  if bottomOff > 0\n  \n  # the default of layoutSubmorphs\n  # is to do nothing, but things like\n  # the inspector might well want to\n  # tweak many of theor children...\n  layoutSubmorphs: ->\n    null\n  \n  # Morph accessing - dimensional changes requiring a complete redraw\n  setExtent: (aPoint) ->\n    # check whether we are actually changing the extent.\n    unless aPoint.eq(@extent())\n      @changed()\n      @silentSetExtent aPoint\n      @changed()\n      @updateRendering()\n      @layoutSubmorphs()\n  \n  silentSetExtent: (aPoint) ->\n    ext = aPoint.round()\n    newWidth = Math.max(ext.x, 0)\n    newHeight = Math.max(ext.y, 0)\n    @bounds.corner = new Point(@bounds.origin.x + newWidth, @bounds.origin.y + newHeight)\n  \n  setWidth: (width) ->\n    @setExtent new Point(width or 0, @height())\n  \n  silentSetWidth: (width) ->\n    # do not updateRendering() just yet\n    w = Math.max(Math.round(width or 0), 0)\n    @bounds.corner = new Point(@bounds.origin.x + w, @bounds.corner.y)\n  \n  setHeight: (height) ->\n    @setExtent new Point(@width(), height or 0)\n  \n  silentSetHeight: (height) ->\n    # do not updateRendering() just yet\n    h = Math.max(Math.round(height or 0), 0)\n    @bounds.corner = new Point(@bounds.corner.x, @bounds.origin.y + h)\n  \n  setColor: (aColorOrAMorphGivingAColor) ->\n    if aColorOrAMorphGivingAColor.getColor?\n      aColor = aColorOrAMorphGivingAColor.getColor()\n    else\n      aColor = aColorOrAMorphGivingAColor\n    if aColor\n      unless @color.eq(aColor)\n        @color = aColor\n        @changed()\n        @updateRendering()\n  \n  \n  # Morph displaying ###########################################################\n\n  # There are three fundamental methods for rendering and displaying anything.\n  # * updateRendering: this one creates/updates the local canvas of this morph only\n  #   i.e. not the children. For example: a ColorPickerMorph is a Morph which\n  #   contains three children Morphs (a color palette, a greyscale palette and\n  #   a feedback). The updateRendering method of ColorPickerMorph only creates\n  #   a canvas for the container Morph. So that\'s just a canvas with a\n  #   solid color. As the\n  #   ColorPickerMorph constructor runs, the three childredn Morphs will\n  #   run their own updateRendering method, so each child will have its own\n  #   canvas with their own contents.\n  #   Note that updateRendering should be called sparingly. A morph should repaint\n  #   its buffer pretty much only *after* it\'s been added to itf first parent and\n  #   whenever it changes dimensions. Things like changing parent and updating\n  #   the position shouldn\'t normally trigger an update of the buffer.\n  #   Also note that before the buffer is painted for the first time, they\n  #   might not know their extent. Typically text-related Morphs know their\n  #   extensions after they painted the text for the first time...\n  # * blit: takes the local canvas and blits it to a specific area in a passed\n  #   canvas. The local canvas doesn\'t contain any rendering of the children of\n  #   this morph.\n  # * recursivelyBlit: recursively draws all the local canvas of this morph and all\n  #   its children into a specific area of a passed canvas.\n\n  updateRendering: ->\n    # initialize my surface property\n    @image = newCanvas(@extent().scaleBy pixelRatio)\n    context = @image.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    context.fillStyle = @color.toString()\n    context.fillRect 0, 0, @width(), @height()\n    if @cachedTexture\n      @drawCachedTexture()\n    else @drawTexture @texture  if @texture\n    @changed()\n  \n  drawTexture: (url) ->\n    @cachedTexture = new Image()\n    @cachedTexture.onload = =>\n      @drawCachedTexture()\n    #\n    @cachedTexture.src = @texture = url # make absolute\n  \n  # tiles the texture\n  drawCachedTexture: ->\n    bg = @cachedTexture\n    cols = Math.floor(@image.width / bg.width)\n    lines = Math.floor(@image.height / bg.height)\n    context = @image.getContext("2d")\n    for y in [0..lines]\n      for x in [0..cols]\n        context.drawImage bg, Math.round(x * bg.width), Math.round(y * bg.height)\n    @changed()\n  \n  \n  #\n  #Morph.prototype.drawCachedTexture = function () {\n  #    var context = this.image.getContext(\'2d\'),\n  #        pattern = context.createPattern(this.cachedTexture, \'repeat\');\n  #	context.fillStyle = pattern;\n  #    context.fillRect(0, 0, this.image.width, this.image.height);\n  #    this.changed();\n  #};\n  #\n  \n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by recursivelyBlit, which\n  # eventually invokes blit.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  blit: (aCanvas, clippingRectangle) ->\n    return null  if @isMinimised or !@isVisible or !@image?\n    area = clippingRectangle.intersect(@bounds).round()\n    # test whether anything that we are going to be drawing\n    # is visible (i.e. within the clippingRectangle)\n    if area.isNotEmpty()\n      delta = @position().neg()\n      src = area.copy().translateBy(delta).round()\n      context = aCanvas.getContext("2d")\n      context.globalAlpha = @alpha\n      sl = src.left() * pixelRatio\n      st = src.top() * pixelRatio\n      al = area.left() * pixelRatio\n      at = area.top() * pixelRatio\n      w = Math.min(src.width() * pixelRatio, @image.width - sl)\n      h = Math.min(src.height() * pixelRatio, @image.height - st)\n      return null  if w < 1 or h < 1\n\n      context.drawImage @image,\n        Math.round(sl),\n        Math.round(st),\n        Math.round(w),\n        Math.round(h),\n        Math.round(al),\n        Math.round(at),\n        Math.round(w),\n        Math.round(h)\n\n      if world.showRedraws\n        randomR = Math.round(Math.random()*255)\n        randomG = Math.round(Math.random()*255)\n        randomB = Math.round(Math.random()*255)\n        context.globalAlpha = 0.5\n        context.fillStyle = "rgb("+randomR+","+randomG+","+randomB+")";\n        context.fillRect(Math.round(al),Math.round(at),Math.round(w),Math.round(h));\n  \n  \n  # "for debugging purposes:"\n  #\n  #		try {\n  #			context.drawImage(\n  #				this.image,\n  #				src.left(),\n  #				src.top(),\n  #				w,\n  #				h,\n  #				area.left(),\n  #				area.top(),\n  #				w,\n  #				h\n  #			);\n  #		} catch (err) {\n  #			alert(\'internal error\n\n\' + err\n  #				+ \'\n ---\'\n  #				+ \'\n canvas: \' + aCanvas\n  #				+ \'\n canvas.width: \' + aCanvas.width\n  #				+ \'\n canvas.height: \' + aCanvas.height\n  #				+ \'\n ---\'\n  #				+ \'\n image: \' + this.image\n  #				+ \'\n image.width: \' + this.image.width\n  #				+ \'\n image.height: \' + this.image.height\n  #				+ \'\n ---\'\n  #				+ \'\n w: \' + w\n  #				+ \'\n h: \' + h\n  #				+ \'\n sl: \' + sl\n  #				+ \'\n st: \' + st\n  #				+ \'\n area.left: \' + area.left()\n  #				+ \'\n area.top \' + area.top()\n  #				);\n  #		}\n  #	\n  recursivelyBlit: (aCanvas, clippingRectangle = @boundsIncludingChildren()) ->\n    return null  if @isMinimised or !@isVisible\n\n    # in general, the children of a Morph could be outside the\n    # bounds of the parent (they could also be much larger\n    # then the parent). This means that we have to traverse\n    # all the children to find out whether any of those overlap\n    # the clipping rectangle. Note that we can be smarter with\n    # FrameMorphs, as their children are actually all contained\n    # within the parent\'s boundary.\n\n    # Note that if we could dynamically and cheaply keep an updated\n    # boundsIncludingChildren property, then we could be smarter\n    # in discarding whole sections of the scene graph.\n    # (see https://github.com/davidedc/Zombie-Kernel/issues/150 )\n\n    @blit aCanvas, clippingRectangle\n    @children.forEach (child) ->\n      child.recursivelyBlit aCanvas, clippingRectangle\n  \n\n  hide: ->\n    @isVisible = false\n    @changed()\n    @children.forEach (child) ->\n      child.hide()\n\n  show: ->\n    @isVisible = true\n    @changed()\n    @children.forEach (child) ->\n      child.show()\n  \n  minimise: ->\n    @isMinimised = true\n    @changed()\n    @children.forEach (child) ->\n      child.minimise()\n  \n  unminimise: ->\n    @isMinimised = false\n    @changed()\n    @children.forEach (child) ->\n      child.unminimise()\n  \n  \n  toggleVisibility: ->\n    @isMinimised = (not @isMinimised)\n    @changed()\n    @children.forEach (child) ->\n      child.toggleVisibility()\n  \n  \n  # Morph full image:\n  \n  # Fixes https://github.com/jmoenig/morphic.js/issues/7\n  # and https://github.com/davidedc/Zombie-Kernel/issues/160\n  fullImage: ->\n    boundsIncludingChildren = @boundsIncludingChildren()\n    img = newCanvas(boundsIncludingChildren.extent().scaleBy pixelRatio)\n    ctx = img.getContext("2d")\n    # ctx.scale pixelRatio, pixelRatio\n    # we are going to draw this morph and its children into "img".\n    # note that the children are not necessarily geometrically\n    # contained in the morph (in which case it would be ok to\n    # translate the context so that the origin of *this* morph is\n    # at the top-left of the "img" canvas).\n    # Hence we have to translate the context\n    # so that the origin of the entire boundsIncludingChildren is at the\n    # very top-left of the "img" canvas.\n    ctx.translate -boundsIncludingChildren.origin.x * pixelRatio , -boundsIncludingChildren.origin.y * pixelRatio\n    @recursivelyBlit img, boundsIncludingChildren\n    img\n\n  fullImageData: ->\n    # returns a string like "data:image/png;base64,iVBORw0KGgoAA..."\n    # note that "image/png" below could be omitted as it\'s\n    # the default, but leaving it here for clarity.\n    @fullImage().toDataURL("image/png")\n\n  fullImageHashCode: ->\n    return hashCode(@fullImageData())\n  \n  # Morph shadow:\n  shadowImage: (off_, color) ->\n    # fallback for Windows Chrome-Shadow bug\n    offset = off_ or new Point(7, 7)\n    clr = color or new Color(0, 0, 0)\n    fb = @boundsIncludingChildren().extent()\n    img = @fullImage()\n    outline = newCanvas(fb.scaleBy pixelRatio)\n    ctx = outline.getContext("2d")\n    #ctx.scale pixelRatio, pixelRatio\n    ctx.drawImage img, 0, 0\n    ctx.globalCompositeOperation = "destination-out"\n    ctx.drawImage img, Math.round(-offset.x) * pixelRatio, Math.round(-offset.y) * pixelRatio\n    sha = newCanvas(fb.scaleBy pixelRatio)\n    ctx = sha.getContext("2d")\n    #ctx.scale pixelRatio, pixelRatio\n    ctx.drawImage outline, 0, 0\n    ctx.globalCompositeOperation = "source-atop"\n    ctx.fillStyle = clr.toString()\n    ctx.fillRect 0, 0, fb.x * pixelRatio, fb.y * pixelRatio\n    sha\n  \n  # the one used right now\n  shadowImageBlurred: (off_, color) ->\n    offset = off_ or new Point(7, 7)\n    blur = @shadowBlur\n    clr = color or new Color(0, 0, 0)\n    fb = @boundsIncludingChildren().extent().add(blur * 2)\n    img = @fullImage()\n    sha = newCanvas(fb.scaleBy pixelRatio)\n    ctx = sha.getContext("2d")\n    #ctx.scale pixelRatio, pixelRatio\n    ctx.shadowOffsetX = offset.x * pixelRatio\n    ctx.shadowOffsetY = offset.y * pixelRatio\n    ctx.shadowBlur = blur * pixelRatio\n    ctx.shadowColor = clr.toString()\n    ctx.drawImage img, Math.round((blur - offset.x)*pixelRatio), Math.round((blur - offset.y)*pixelRatio)\n    ctx.shadowOffsetX = 0\n    ctx.shadowOffsetY = 0\n    ctx.shadowBlur = 0\n    ctx.globalCompositeOperation = "destination-out"\n    ctx.drawImage img, Math.round((blur - offset.x)*pixelRatio), Math.round((blur - offset.y)*pixelRatio)\n    sha\n  \n  \n  # shadow is added to a morph by\n  # the HandMorph while dragging\n  addShadow: (offset, alpha, color) ->\n    shadow = new ShadowMorph(@, offset, alpha, color)\n    @addBack shadow\n    @fullChanged()\n    shadow\n  \n  getShadow: ->\n    return @topmostChildSuchThat (child) ->\n      child instanceof ShadowMorph\n  \n  removeShadow: ->\n    shadow = @getShadow()\n    if shadow?\n      @fullChanged()\n      @removeChild shadow\n  \n  \n  # Morph pen trails:\n  penTrails: ->\n    # answer my pen trails canvas. default is to answer my image\n    # The implication is that by default every Morph in the system\n    # (including the World) is able to act as turtle canvas and can\n    # display pen trails.\n    # BUT also this means that pen trails will be lost whenever\n    # the trail\'s morph (the pen\'s parent) performs a "drawNew()"\n    # operation. If you want to create your own pen trails canvas,\n    # you may wish to modify its **penTrails()** property, so that\n    # it keeps a separate offscreen canvas for pen trails\n    # (and doesn\'t lose these on redraw).\n    @image\n  \n  \n  # Morph updating ///////////////////////////////////////////////////////////////\n  changed: ->\n    if @trackChanges\n      w = @root()\n      # unless we are the main desktop, then if the morph has no parent\n      # don\'t add the broken rect since the morph is not visible\n      if w instanceof WorldMorph and (@ instanceof WorldMorph or @parent?)\n        w.broken.push @visibleBounds().spread()\n    @parent.childChanged @  if @parent\n  \n  fullChanged: ->\n    if @trackChanges\n      w = @root()\n      # unless we are the main desktop, then if the morph has no parent\n      # don\'t add the broken rect since the morph is not visible\n      if w instanceof WorldMorph and ((@ instanceof WorldMorph or @parent?))\n        w.broken.push @boundsIncludingChildren().spread()\n  \n  childChanged: ->\n    # react to a  change in one of my children,\n    # default is to just pass this message on upwards\n    # override this method for Morphs that need to adjust accordingly\n    @parent.childChanged @  if @parent\n  \n  \n  # Morph accessing - structure //////////////////////////////////////////////\n  world: ->\n    root = @root()\n    return root  if root instanceof WorldMorph\n    return root.world  if root instanceof HandMorph\n    null\n  \n  # attaches submorph on top\n  # ??? TODO you should handle the case of Morph\n  #     being added to itself and the case of\n  # ??? TODO a Morph being added to one of its\n  #     children\n  add: (aMorph) ->\n    # the morph that is being\n    # attached might be attached to\n    # a clipping morph. So we\n    # need to do a "changed" here\n    # to make sure that anything that\n    # is outside the clipping Morph gets\n    # painted over.\n    aMorph.changed()\n    owner = aMorph.parent\n    owner.removeChild aMorph  if owner?\n    @addChild aMorph\n    aMorph.updateRendering()\n  \n  # attaches submorph underneath\n  addBack: (aMorph) ->\n    owner = aMorph.parent\n    owner.removeChild aMorph  if owner?\n    aMorph.updateRendering()\n    # this is a curious instance where\n    # we first update the rendering and then\n    # we add the morph. This is because\n    # the rendering depends on the\n    # full extent including children of\n    # the morph we are attaching the shadow\n    # to. So if we add the shadow we are going\n    # to influence those measurements and\n    # make our life very difficult for\n    # ourselves.\n    @addChildFirst aMorph\n  \n\n  # never currently used in ZK\n  # TBD whether this is 100% correct,\n  # see "topMorphUnderPointer" implementation in\n  # HandMorph.\n  # Also there must be a quicker implementation\n  # cause there is no need to create the entire\n  # morph list. It would be sufficient to\n  # navigate the structure and just return\n  # at the first morph satisfying the test.\n  morphAt: (aPoint) ->\n    morphs = @allChildrenTopToBottom()\n    result = null\n    morphs.forEach (m) ->\n      if m.boundsIncludingChildren().containsPoint(aPoint) and (result is null)\n        result = m\n    #\n    result\n  \n  #\n  #	potential alternative - solution for morphAt.\n  #	Has some issues, commented out for now...\n  #\n  #Morph.prototype.morphAt = function (aPoint) {\n  #	return this.topMorphSuchThat(function (m) {\n  #		return m.boundsIncludingChildren().containsPoint(aPoint);\n  #	});\n  #};\n  #\n  \n  # Morph pixel access:\n  getPixelColor: (aPoint) ->\n    point = aPoint.subtract(@bounds.origin)\n    context = @image.getContext("2d")\n    data = context.getImageData(point.x * pixelRatio, point.y * pixelRatio, 1, 1)\n    new Color(data.data[0], data.data[1], data.data[2], data.data[3])\n  \n  isTransparentAt: (aPoint) ->\n    if @bounds.containsPoint(aPoint)\n      return false  if @texture\n      point = aPoint.subtract(@bounds.origin)\n      context = @image.getContext("2d")\n      data = context.getImageData(Math.floor(point.x)*pixelRatio, Math.floor(point.y)*pixelRatio, 1, 1)\n      # check the 4th byte - the Alpha (RGBA)\n      return data.data[3] is 0\n    false\n  \n  # Morph duplicating ////////////////////////////////////////////////////\n\n  # creates a new instance of target\'s type\n  clone: (target) ->\n    #alert "cloning a " + target.constructor.name\n    if typeof target is "object"\n      # note that the constructor method is not run!\n      theClone = Object.create(target.constructor.prototype)\n      #console.log "theClone class:" + theClone.constructor.name\n      theClone.assignUniqueID()\n      #theClone.constructor()\n      return theClone\n    target\n\n  # returns a shallow copy of target.\n  # Shallow copy keeps references to original objects, arrays or functions\n  # within the new object, so the “copy” is still linked to the original\n  # object. In other words, they will be pointing to the same memory\n  # location. String and Numbers are duplicated instead.\n  shallowCopy: (target) ->\n    c = @clone(target.constructor::)\n    for property of target\n      # there are a couple of properties that we don\'t want to copy over...\n      if target.hasOwnProperty(property) and property != "instanceNumericID"\n        c[property] = target[property]\n        #if target.constructor.name == "SliderMorph"\n        #  alert "copying property: " + property\n    c\n  \n  copy: ->\n    c = @shallowCopy(@)\n    c.parent = null\n    c.children = []\n    c.bounds = @bounds.copy()\n    c\n  \n  copyRecordingReferences: (dict) ->\n    # copies a Morph, its properties and its submorphs. Properties\n    # are shallow-copied, so for example Numbers and Strings\n    # are actually duplicated,\n    # but arrays objects and functions are not deep-copied i.e.\n    # just the references are copied.\n    # Also builds a correspondence of the morph and its submorphs to their\n    # respective clones.\n\n    c = @copy()\n    # "dict" maps the correspondences from this object to the\n    # copy one. So dict[propertyOfThisObject] = propertyOfCopyObject\n    dict[@uniqueIDString()] = c\n    @children.forEach (m) ->\n      # the result of this loop is that all the children of this\n      # object are (recursively) copied and attached to the copy of this\n      # object. dict will contain all the mappings between the\n      # children of this object and the copied children.\n      c.add m.copyRecordingReferences(dict)\n    c\n  \n  fullCopy: ->\n    #\n    #	Produce a copy of me with my entire tree of submorphs. Morphs\n    #	mentioned more than once are all directed to a single new copy.\n    #	Other properties are also *shallow* copied, so you must override\n    #	to deep copy Arrays and (complex) Objects\n    #	\n    #alert "doing a full copy"\n    dict = {}\n    c = @copyRecordingReferences(dict)\n    # note that child.updateReferences is invoked\n    # from the bottom up, i.e. from the leaf children up to the\n    # parents. This is important because it means that each\n    # child can properly fix the connections between the "mapped"\n    # children correctly.\n    #alert "### updating references"\n    #alert "number of children: " + c.children.length\n    c.forAllChildrenBottomToTop (child) ->\n      #alert ">>> updating reference of " + child\n      child.updateReferences dict\n    #alert ">>> updating reference of " + c\n    c.updateReferences dict\n    #\n    c\n  \n  # if the constructor of the object you are copying performs\n  # some complex building and connecting of the elements,\n  # and there are some callbacks around,\n  # then maybe you could need to override this method.\n  # The inspectorMorph needed to override this method\n  # until extensive refactoring was performed.\n  updateReferences: (dict) ->\n    #\n    #	Update intra-morph references within a composite morph that has\n    #	been copied. For example, if a button refers to morph X in the\n    #	orginal composite then the copy of that button in the new composite\n    #	should refer to the copy of X in new composite, not the original X.\n    # This is done via scanning all the properties of the object and\n    # checking whether any of those has a mapping. If so, then it is\n    # replaced with its mapping.\n    #	\n    #alert "updateReferences of " + @toString()\n    for property of @\n      if @[property]?\n        #if property == "button"\n        #  alert "!! property: " + property + " is morph: " + (@[property]).isMorph\n        #  alert "dict[property]: " + dict[(@[property]).uniqueIDString()]\n        if (@[property]).isMorph and dict[(@[property]).uniqueIDString()]\n          #if property == "button"\n          #  alert "!! updating property: " + property + " to: " + dict[(@[property]).uniqueIDString()]\n          @[property] = dict[(@[property]).uniqueIDString()]\n  \n  \n  # Morph dragging and dropping /////////////////////////////////////////\n  \n  rootForGrab: ->\n    if @ instanceof ShadowMorph\n      return @parent.rootForGrab()\n    if @parent instanceof ScrollFrameMorph\n      return @parent\n    if @parent is null or\n      @parent instanceof WorldMorph or\n      @parent instanceof FrameMorph or\n      @isDraggable is true\n        return @  \n    @parent.rootForGrab()\n  \n  wantsDropOf: (aMorph) ->\n    # default is to answer the general flag - change for my heirs\n    if (aMorph instanceof HandleMorph) or\n      (aMorph instanceof MenuMorph)\n        return false  \n    @acceptsDrops\n  \n  pickUp: ->\n    @setPosition world.hand.position().subtract(@extent().floorDivideBy(2))\n    world.hand.grab @\n  \n  isPickedUp: ->\n    @parentThatIsA(HandMorph)?\n  \n  situation: ->\n    # answer a dictionary specifying where I am right now, so\n    # I can slide back to it if I\'m dropped somewhere else\n    if @parent\n      return (\n        origin: @parent\n        position: @position().subtract(@parent.position())\n      )\n    null\n  \n  slideBackTo: (situation, inSteps) ->\n    steps = inSteps or 5\n    pos = situation.origin.position().add(situation.position)\n    xStep = -(@left() - pos.x) / steps\n    yStep = -(@top() - pos.y) / steps\n    stepCount = 0\n    oldStep = @step\n    oldFps = @fps\n    @fps = 0\n    @step = =>\n      @fullChanged()\n      @silentMoveBy new Point(xStep, yStep)\n      @fullChanged()\n      stepCount += 1\n      if stepCount is steps\n        situation.origin.add @\n        situation.origin.reactToDropOf @  if situation.origin.reactToDropOf\n        @step = oldStep\n        @fps = oldFps\n  \n  \n  # Morph utilities ////////////////////////////////////////////////////////\n  \n  resize: ->\n    @world().activeHandle = new HandleMorph(@)\n  \n  move: ->\n    @world().activeHandle = new HandleMorph(@, null, null, null, null, "move")\n  \n  hint: (msg) ->\n    text = msg\n    if msg\n      text = msg.toString()  if msg.toString\n    else\n      text = "NULL"\n    m = new MenuMorph(@, text)\n    m.isDraggable = true\n    m.popUpCenteredAtHand @world()\n  \n  inform: (msg) ->\n    text = msg\n    if msg\n      text = msg.toString()  if msg.toString\n    else\n      text = "NULL"\n    m = new MenuMorph(@, text)\n    m.addItem "Ok"\n    m.isDraggable = true\n    m.popUpCenteredAtHand @world()\n\n  prompt: (msg, callback, defaultContents, width, floorNum,\n    ceilingNum, isRounded) ->\n    isNumeric = true  if ceilingNum\n    entryField = new StringFieldMorph(\n      defaultContents or "",\n      width or 100,\n      WorldMorph.preferencesAndSettings.prompterFontSize,\n      WorldMorph.preferencesAndSettings.prompterFontName,\n      false,\n      false,\n      isNumeric)\n    menu = new MenuMorph(@, msg or "", entryField)\n    menu.items.push entryField\n    if ceilingNum or WorldMorph.preferencesAndSettings.useSliderForInput\n      slider = new SliderMorph(\n        floorNum or 0,\n        ceilingNum,\n        parseFloat(defaultContents),\n        Math.floor((ceilingNum - floorNum) / 4),\n        "horizontal")\n      slider.alpha = 1\n      slider.color = new Color(225, 225, 225)\n      slider.button.color = menu.borderColor\n      slider.button.highlightColor = slider.button.color.copy()\n      slider.button.highlightColor.b += 100\n      slider.button.pressColor = slider.button.color.copy()\n      slider.button.pressColor.b += 150\n      slider.setHeight WorldMorph.preferencesAndSettings.prompterSliderSize\n      if isRounded\n        slider.action = (num) ->\n          entryField.changed()\n          entryField.text.text = Math.round(num).toString()\n          entryField.text.updateRendering()\n          entryField.text.changed()\n          entryField.text.edit()\n      else\n        slider.action = (num) ->\n          entryField.changed()\n          entryField.text.text = num.toString()\n          entryField.text.updateRendering()\n          entryField.text.changed()\n      menu.items.push slider\n    menu.addLine 2\n    menu.addItem "Ok", callback\n    #\n    menu.addItem "Cancel", ->\n      null\n    #\n    menu.isDraggable = true\n    menu.popUpAtHand()\n    entryField.text.edit()\n  \n  pickColor: (msg, callback, defaultContents) ->\n    colorPicker = new ColorPickerMorph(defaultContents)\n    menu = new MenuMorph(@, msg or "", colorPicker)\n    menu.items.push colorPicker\n    menu.addLine 2\n    menu.addItem "Ok", callback\n    #\n    menu.addItem "Cancel", ->\n      null\n    #\n    menu.isDraggable = true\n    menu.popUpAtHand()\n\n  inspect: (anotherObject) ->\n    inspectee = @\n    inspectee = anotherObject  if anotherObject\n    @spawnInspector inspectee\n\n  spawnInspector: (inspectee) ->\n    inspector = new InspectorMorph(inspectee)\n    world = (if @world instanceof Function then @world() else (@root() or @world))\n    inspector.setPosition world.hand.position()\n    inspector.keepWithin world\n    world.add inspector\n    inspector.changed()\n    \n  \n  # Morph menus ////////////////////////////////////////////////////////////////\n  \n  contextMenu: ->\n    # Spacial multiplexing\n    # (search "multiplexing" for the other parts of\n    # code where this matters)\n    # There are two interpretations of what this\n    # list should be:\n    #   1) all morphs "pierced through" by the pointer\n    #   2) all morphs parents of the topmost morph under the pointer\n    # 2 is what is used in Cuis\n    \n    # commented-out addendum for the implementation of 1):\n    #show the normal menu in case there is text selected,\n    #otherwise show the spacial multiplexing list\n    #if !@world().caret\n    #  if @world().hand.allMorphsAtPointer().length > 2\n    #    return @hierarchyMenu()\n    if @customContextMenu\n      return @customContextMenu()\n    world = (if @world instanceof Function then @world() else (@root() or @world))\n    if world and world.isDevMode\n      if @parent is world\n        return @developersMenu()\n      return @hierarchyMenu()\n    @userMenu() or (@parent and @parent.userMenu())\n  \n  # When user right-clicks on a morph that is a child of other morphs,\n  # then it\'s ambiguous which of the morphs she wants to operate on.\n  # An example is right-clicking on a SpeechBubbleMorph: did she\n  # mean to operate on the BubbleMorph or did she mean to operate on\n  # the TextMorph contained in it?\n  # This menu lets her disambiguate.\n  hierarchyMenu: ->\n    # Spacial multiplexing\n    # (search "multiplexing" for the other parts of\n    # code where this matters)\n    # There are two interpretations of what this\n    # list should be:\n    #   1) all morphs "pierced through" by the pointer\n    #   2) all morphs parents of the topmost morph under the pointer\n    # 2 is what is used in Cuis\n    # commented-out addendum for the implementation of 1):\n    # parents = @world().hand.allMorphsAtPointer().reverse()\n    parents = @allParentsTopToBottom()\n    world = (if @world instanceof Function then @world() else (@root() or @world))\n    menu = new MenuMorph(@, null)\n    # show an entry for each of the morphs in the hierarchy.\n    # each entry will open the developer menu for each morph.\n    parents.forEach (each) ->\n      if each.developersMenu and (each isnt world)\n        textLabelForMorph = each.toString().slice(0, 50)\n        menu.addItem textLabelForMorph, ->\n          each.developersMenu().popUpAtHand()\n    #  \n    menu\n  \n  developersMenu: ->\n    # \'name\' is not an official property of a function, hence:\n    world = (if @world instanceof Function then @world() else (@root() or @world))\n    userMenu = @userMenu() or (@parent and @parent.userMenu())\n    menu = new MenuMorph(\n      @,\n      @constructor.name or @constructor.toString().split(" ")[1].split("(")[0])\n    if userMenu\n      menu.addItem "user features...", ->\n        userMenu.popUpAtHand()\n      #\n      menu.addLine()\n    menu.addItem "color...", (->\n      @pickColor menu.title + "\ncolor:", @setColor, @color\n    ), "choose another color \nfor this morph"\n\n    menu.addItem "transparency...", (->\n      @prompt menu.title + "\nalpha\nvalue:",\n        @setAlphaScaled, (@alpha * 100).toString(),\n        null,\n        1,\n        100,\n        true\n    ), "set this morph\'s\nalpha value"\n    menu.addItem "resize...", (->@resize()), "show a handle\nwhich can be dragged\nto change this morph\'s" + " extent"\n    menu.addLine()\n    menu.addItem "duplicate", (->\n      aFullCopy = @fullCopy()\n      aFullCopy.pickUp()\n    ), "make a copy\nand pick it up"\n    menu.addItem "pick up", (->@pickUp()), "disattach and put \ninto the hand"\n    menu.addItem "attach...", (->@attach()), "stick this morph\nto another one"\n    menu.addItem "move", (->@move()), "show a handle\nwhich can be dragged\nto move this morph"\n    menu.addItem "inspect", (->@inspect()), "open a window\non all properties"\n\n    # A) normally, just take a picture of this morph\n    # and open it in a new tab.\n    # B) If a test is being recorded, then the behaviour\n    # is slightly different: a system test command is\n    # triggered to take a screenshot of this particular\n    # morph.\n    # C) If a test is being played, then the screenshot of\n    # the particular morph is put in a special place\n    # in the test player. The command recorded at B) is\n    # going to replay but *waiting* for that screenshot\n    # first.\n    takePic = =>\n      if SystemTestsRecorderAndPlayer.state == SystemTestsRecorderAndPlayer.RECORDING\n        # While recording a test, just trigger for\n        # the takeScreenshot command to be recorded. \n        window.world.systemTestsRecorderAndPlayer.takeScreenshot(@)\n      else if SystemTestsRecorderAndPlayer.state == SystemTestsRecorderAndPlayer.PLAYING\n        # While playing a test, this command puts the\n        # screenshot of this morph in a special\n        # variable of the system test runner.\n        # The test runner will wait for this variable\n        # to contain the morph screenshot before\n        # doing the comparison as per command recorded\n        # in the case above.\n        window.world.systemTestsRecorderAndPlayer.imageDataOfAParticularMorph = @fullImageData()\n      else\n        # no system tests recording/playing ongoing,\n        # just open new tab with image of morph.\n        window.open @fullImageData()\n    menu.addItem "take pic", takePic, "open a new window\nwith a picture of this morph"\n\n    menu.addLine()\n    if @isDraggable\n      menu.addItem "lock", (->@toggleIsDraggable()), "make this morph\nunmovable"\n    else\n      menu.addItem "unlock", (->@toggleIsDraggable()), "make this morph\nmovable"\n    menu.addItem "hide", (->@minimise())\n    menu.addItem "delete", (->@destroy())\n    menu\n  \n  userMenu: ->\n    null\n  \n  \n  # Morph menu actions\n  calculateAlphaScaled: (alpha) ->\n    if typeof alpha is "number"\n      unscaled = alpha / 100\n      return Math.min(Math.max(unscaled, 0.1), 1)\n    else\n      newAlpha = parseFloat(alpha)\n      unless isNaN(newAlpha)\n        unscaled = newAlpha / 100\n        return Math.min(Math.max(unscaled, 0.1), 1)\n\n  setAlphaScaled: (alphaOrMorphGivingAlpha) ->\n    if alphaOrMorphGivingAlpha.getValue?\n      alpha = alphaOrMorphGivingAlpha.getValue()\n    else\n      alpha = alphaOrMorphGivingAlpha\n    if alpha\n      @alpha = @calculateAlphaScaled(alpha)\n      @changed()\n  \n  attach: ->\n    # get rid of any previous temporary\n    # active menu because it\'s meant to be\n    # out of view anyways, otherwise we show\n    # its overlapping morphs in the options\n    # which is most probably not wanted.\n    if world.activeMenu\n      world.activeMenu = world.activeMenu.destroy()\n    choices = world.plausibleTargetAndDestinationMorphs(@)\n\n    # my direct parent might be in the\n    # options which is silly, leave that one out\n    choicesExcludingParent = []\n    choices.forEach (each) =>\n      if each != @parent\n        choicesExcludingParent.push each\n\n    if choicesExcludingParent.length > 0\n      menu = new MenuMorph(@, "choose new parent:")\n      choicesExcludingParent.forEach (each) =>\n        menu.addItem each.toString().slice(0, 50), =>\n          # this is what happens when "each" is\n          # selected: we attach the selected morph\n          each.add @\n          if each instanceof FrameMorph\n            each.adjustBounds()\n          else\n            # you expect Morphs attached\n            # inside a FrameMorph\n            # to be draggable out of it\n            # (as opposed to the content of a ScrollFrameMorph)\n            @isDraggable = false\n    else\n      # the ideal would be to not show the\n      # "attach" menu entry at all but for the\n      # time being it\'s quite costly to\n      # find the eligible morphs to attach\n      # to, so for now let\'s just calculate\n      # this list if the user invokes the\n      # command, and if there are no good\n      # morphs then show some kind of message.\n      menu = new MenuMorph(@, "no morphs to attach to")\n    menu.popUpAtHand()\n  \n  toggleIsDraggable: ->\n    # for context menu demo purposes\n    @isDraggable = not @isDraggable\n  \n  colorSetters: ->\n    # for context menu demo purposes\n    ["color"]\n  \n  numericalSetters: ->\n    # for context menu demo purposes\n    ["setLeft", "setTop", "setWidth", "setHeight", "setAlphaScaled"]\n  \n  \n  # Morph entry field tabbing //////////////////////////////////////////////\n  \n  allEntryFields: ->\n    @collectAllChildrenBottomToTopSuchThat (each) ->\n      each.isEditable && (each instanceof StringMorph || each instanceof TextMorph);\n  \n  \n  nextEntryField: (current) ->\n    fields = @allEntryFields()\n    idx = fields.indexOf(current)\n    if idx isnt -1\n      if fields.length > (idx + 1)\n        return fields[idx + 1]\n    return fields[0]\n  \n  previousEntryField: (current) ->\n    fields = @allEntryFields()\n    idx = fields.indexOf(current)\n    if idx isnt -1\n      if idx > 0\n        return fields[idx - 1]\n      return fields[fields.length - 1]\n    return fields[0]\n  \n  tab: (editField) ->\n    #\n    #	the <tab> key was pressed in one of my edit fields.\n    #	invoke my "nextTab()" function if it exists, else\n    #	propagate it up my owner chain.\n    #\n    if @nextTab\n      @nextTab editField\n    else @parent.tab editField  if @parent\n  \n  backTab: (editField) ->\n    #\n    #	the <back tab> key was pressed in one of my edit fields.\n    #	invoke my "previousTab()" function if it exists, else\n    #	propagate it up my owner chain.\n    #\n    if @previousTab\n      @previousTab editField\n    else @parent.backTab editField  if @parent\n  \n  \n  #\n  #	the following are examples of what the navigation methods should\n  #	look like. Insert these at the World level for fallback, and at lower\n  #	levels in the Morphic tree (e.g. dialog boxes) for a more fine-grained\n  #	control over the tabbing cycle.\n  #\n  #Morph.prototype.nextTab = function (editField) {\n  #	var	next = this.nextEntryField(editField);\n  #	editField.clearSelection();\n  #	next.selectAll();\n  #	next.edit();\n  #};\n  #\n  #Morph.prototype.previousTab = function (editField) {\n  #	var	prev = this.previousEntryField(editField);\n  #	editField.clearSelection();\n  #	prev.selectAll();\n  #	prev.edit();\n  #};\n  #\n  #\n  \n  # Morph events:\n  escalateEvent: (functionName, arg) ->\n    handler = @parent\n    if handler?\n      handler = handler.parent  while not handler[functionName] and handler.parent?\n      handler[functionName] arg  if handler[functionName]\n  \n  \n  # Morph eval. Used by the Inspector and the TextMorph.\n  evaluateString: (code) ->\n    try\n      result = eval(code)\n      @updateRendering()\n      @changed()\n    catch err\n      @inform err\n    result\n  \n  \n  # Morph collision detection - not used anywhere at the moment ////////////////////////\n  \n  isTouching: (otherMorph) ->\n    oImg = @overlappingImage(otherMorph)\n    data = oImg.getContext("2d").getImageData(1, 1, oImg.width, oImg.height).data\n    detect(data, (each) ->\n      each isnt 0\n    ) isnt null\n  \n  overlappingImage: (otherMorph) ->\n    fb = @boundsIncludingChildren()\n    otherFb = otherMorph.boundsIncludingChildren()\n    oRect = fb.intersect(otherFb)\n    oImg = newCanvas(oRect.extent().scaleBy pixelRatio)\n    ctx = oImg.getContext("2d")\n    ctx.scale pixelRatio, pixelRatio\n    if oRect.width() < 1 or oRect.height() < 1\n      return newCanvas((new Point(1, 1)).scaleBy pixelRatio)\n    ctx.drawImage @fullImage(),\n      Math.round(oRect.origin.x - fb.origin.x),\n      Math.round(oRect.origin.y - fb.origin.y)\n    ctx.globalCompositeOperation = "source-in"\n    ctx.drawImage otherMorph.fullImage(),\n      Math.round(otherFb.origin.x - oRect.origin.x),\n      Math.round(otherFb.origin.y - oRect.origin.y)\n    oImg';

  return Morph;

})(MorphicNode);

BlinkerMorph = (function(_super) {
  __extends(BlinkerMorph, _super);

  function BlinkerMorph(fps) {
    this.fps = fps != null ? fps : 2;
    BlinkerMorph.__super__.constructor.call(this);
    this.color = new Color(0, 0, 0);
  }

  BlinkerMorph.prototype.step = function() {
    if (SystemTestsRecorderAndPlayer.animationsPacingControl && SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.IDLE) {
      return;
    }
    return this.toggleVisibility();
  };

  BlinkerMorph.coffeeScriptSourceOfThisClass = '# BlinkerMorph ////////////////////////////////////////////////////////\n\n# can be used for text caret\n\nclass BlinkerMorph extends Morph\n  constructor: (@fps = 2) ->\n    super()\n    @color = new Color(0, 0, 0)\n  \n  # BlinkerMorph stepping:\n  step: ->\n    # if we are recording or playing a test\n    # then there is a flag we need to check that allows\n    # the world to control all the animations.\n    # This is so there is a consistent check\n    # when taking/comparing\n    # screenshots.\n    # So we check here that flag, and make the\n    # caret is always going to be visible.\n    if SystemTestsRecorderAndPlayer.animationsPacingControl and\n     SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.IDLE\n      return\n \n    # in all other cases just\n    # do like usual, i.e. toggle\n    # visibility at the fps\n    # specified in the constructor.\n    @toggleVisibility()';

  return BlinkerMorph;

})(Morph);

BouncerMorph = (function(_super) {
  __extends(BouncerMorph, _super);

  BouncerMorph.prototype.isStopped = false;

  BouncerMorph.prototype.type = null;

  BouncerMorph.prototype.direction = null;

  BouncerMorph.prototype.speed = null;

  function BouncerMorph(type, speed) {
    this.type = type != null ? type : "vertical";
    this.speed = speed != null ? speed : 1;
    BouncerMorph.__super__.constructor.call(this);
    this.fps = 50;
    if (this.type === "vertical") {
      this.direction = "down";
    } else {
      this.direction = "right";
    }
  }

  BouncerMorph.prototype.resetPosition = function() {
    if (this.type === "vertical") {
      this.direction = "down";
    } else {
      this.direction = "right";
    }
    return this.setPosition(new Point(this.parent.position().x, this.parent.position().y));
  };

  BouncerMorph.prototype.moveUp = function(silently) {
    if (silently) {
      return this.silentMoveBy(new Point(0, -this.speed));
    } else {
      return this.moveBy(new Point(0, -this.speed));
    }
  };

  BouncerMorph.prototype.moveDown = function(silently) {
    if (silently) {
      return this.silentMoveBy(new Point(0, this.speed));
    } else {
      return this.moveBy(new Point(0, this.speed));
    }
  };

  BouncerMorph.prototype.moveRight = function(silently) {
    if (silently) {
      return this.silentMoveBy(new Point(this.speed, 0));
    } else {
      return this.moveBy(new Point(this.speed, 0));
    }
  };

  BouncerMorph.prototype.moveLeft = function(silently) {
    if (silently) {
      return this.silentMoveBy(new Point(-this.speed, 0));
    } else {
      return this.moveBy(new Point(-this.speed, 0));
    }
  };

  BouncerMorph.prototype.moveAccordingToBounce = function(silently) {
    if (this.type === "vertical") {
      if (this.direction === "down") {
        this.moveDown(silently);
      } else {
        this.moveUp(silently);
      }
      if (this.boundsIncludingChildren().top() < this.parent.top() && this.direction === "up") {
        this.direction = "down";
      }
      if (this.boundsIncludingChildren().bottom() > this.parent.bottom() && this.direction === "down") {
        return this.direction = "up";
      }
    } else if (this.type === "horizontal") {
      if (this.direction === "right") {
        this.moveRight(silently);
      } else {
        this.moveLeft(silently);
      }
      if (this.boundsIncludingChildren().left() < this.parent.left() && this.direction === "left") {
        this.direction = "right";
      }
      if (this.boundsIncludingChildren().right() > this.parent.right() && this.direction === "right") {
        return this.direction = "left";
      }
    }
  };

  BouncerMorph.prototype.step = function() {
    var i, _i, _j, _ref, _ref1;
    if (!this.isStopped) {
      if (SystemTestsRecorderAndPlayer.animationsPacingControl) {
        if (SystemTestsRecorderAndPlayer.state === SystemTestsRecorderAndPlayer.RECORDING) {
          this.resetPosition();
          for (i = _i = 0, _ref = window.world.systemTestsRecorderAndPlayer.testCommandsSequence.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            this.moveAccordingToBounce(true);
          }
          this.parent.changed();
          return;
        }
        if (SystemTestsRecorderAndPlayer.state === SystemTestsRecorderAndPlayer.PLAYING) {
          this.resetPosition();
          for (i = _j = 0, _ref1 = window.world.systemTestsRecorderAndPlayer.indexOfTestCommandBeingPlayedFromSequence; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            this.moveAccordingToBounce(true);
          }
          this.parent.changed();
          return;
        }
      }
      return this.moveAccordingToBounce(false);
    }
  };

  BouncerMorph.coffeeScriptSourceOfThisClass = '# BouncerMorph ////////////////////////////////////////////////////////\n# fishy constructor\n# I am a Demo of a stepping custom Morph\n# Bounces vertically or horizontally within the parent\n\nclass BouncerMorph extends Morph\n\n  isStopped: false\n  type: null\n  direction: null\n  speed: null\n\n  constructor: (@type = "vertical", @speed = 1) ->\n    super()\n    @fps = 50\n    # additional properties:\n    if @type is "vertical"\n      @direction = "down"\n    else\n      @direction = "right"\n\n    # @updateRendering() not needed, probably\n    # because it\'s repainted in the\n    # next frame since it\'s an animation?\n    #@updateRendering()\n\n  resetPosition: ->\n    if @type is "vertical"\n      @direction = "down"\n    else\n      @direction = "right"\n    @setPosition new Point(@parent.position().x, @parent.position().y)\n  \n  \n  # BouncerMorph moving.\n  # We need the silent option because\n  # we might move the bouncer many times\n  # consecutively in the case we tie\n  # the animation to the test step.\n  # The silent option avoids too many\n  # broken rectangles being pushed\n  # so it makes the whole thing smooth\n  # even with many movements at once.\n  moveUp: (silently) ->\n    if silently\n      @silentMoveBy new Point(0, -@speed)\n    else\n      @moveBy new Point(0, -@speed)\n  \n  moveDown: (silently) ->\n    if silently\n      @silentMoveBy new Point(0, @speed)\n    else\n      @moveBy new Point(0, @speed)\n  \n  moveRight: (silently) ->\n    if silently\n      @silentMoveBy new Point(@speed, 0)\n    else\n      @moveBy new Point(@speed, 0)\n  \n  moveLeft: (silently) ->\n    if silently\n      @silentMoveBy new Point(-@speed, 0)\n    else\n      @moveBy new Point(-@speed, 0)\n\n  moveAccordingToBounce: (silently) ->\n    if @type is "vertical"\n      if @direction is "down"\n        @moveDown(silently)\n      else\n        @moveUp(silently)\n      @direction = "down"  if @boundsIncludingChildren().top() < @parent.top() and @direction is "up"\n      @direction = "up"  if @boundsIncludingChildren().bottom() > @parent.bottom() and @direction is "down"\n    else if @type is "horizontal"\n      if @direction is "right"\n        @moveRight(silently)\n      else\n        @moveLeft(silently)\n      @direction = "right"  if @boundsIncludingChildren().left() < @parent.left() and @direction is "left"\n      @direction = "left"  if @boundsIncludingChildren().right() > @parent.right() and @direction is "right"\n  \n  \n  # BouncerMorph stepping:\n  step: ->\n    unless @isStopped\n      # if we are recording or playing a test\n      # then there is a flag we need to check that allows\n      # the world to control all the animations.\n      # This is so there is a consistent check\n      # when taking/comparing\n      # screenshots.\n      # So we check here that flag, and make the\n      # animation is exactly controlled\n      # by the test step count only.\n      #console.log "SystemTestsRecorderAndPlayer.animationsPacingControl: " + SystemTestsRecorderAndPlayer.animationsPacingControl\n      #console.log "state: " + SystemTestsRecorderAndPlayer.state\n      if SystemTestsRecorderAndPlayer.animationsPacingControl\n        if SystemTestsRecorderAndPlayer.state == SystemTestsRecorderAndPlayer.RECORDING\n          @resetPosition()\n          for i in [0... window.world.systemTestsRecorderAndPlayer.testCommandsSequence.length]\n            @moveAccordingToBounce(true)\n          @parent.changed()\n          return\n        if SystemTestsRecorderAndPlayer.state == SystemTestsRecorderAndPlayer.PLAYING\n          @resetPosition()\n          for i in [0... window.world.systemTestsRecorderAndPlayer.indexOfTestCommandBeingPlayedFromSequence]\n            @moveAccordingToBounce(true)\n          @parent.changed()\n          return\n\n      @moveAccordingToBounce(false)';

  return BouncerMorph;

})(Morph);

BoxMorph = (function(_super) {
  __extends(BoxMorph, _super);

  BoxMorph.prototype.edge = null;

  BoxMorph.prototype.border = null;

  BoxMorph.prototype.borderColor = null;

  function BoxMorph(edge, border, borderColor) {
    this.edge = edge != null ? edge : 4;
    this.border = border || (border === 0 ? 0 : 2);
    this.borderColor = borderColor || new Color();
    BoxMorph.__super__.constructor.call(this);
  }

  BoxMorph.prototype.updateRendering = function() {
    var context;
    this.image = newCanvas(this.extent().scaleBy(pixelRatio));
    context = this.image.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    if ((this.edge === 0) && (this.border === 0)) {
      BoxMorph.__super__.updateRendering.call(this);
      return null;
    }
    context.fillStyle = this.color.toString();
    context.beginPath();
    this.outlinePath(context, Math.max(this.edge - this.border, 0), this.border);
    context.closePath();
    return context.fill();
  };

  BoxMorph.prototype.outlinePath = function(context, radius, inset) {
    var h, offset, w;
    offset = radius + inset;
    w = this.width();
    h = this.height();
    context.arc(offset, offset, radius, radians(-180), radians(-90), false);
    context.arc(w - offset, offset, radius, radians(-90), radians(-0), false);
    context.arc(w - offset, h - offset, radius, radians(0), radians(90), false);
    return context.arc(offset, h - offset, radius, radians(90), radians(180), false);
  };

  BoxMorph.prototype.developersMenu = function() {
    var menu;
    menu = BoxMorph.__super__.developersMenu.call(this);
    menu.addLine();
    menu.addItem("border width...", (function() {
      return this.prompt(menu.title + "\nborder\nwidth:", this.setBorderWidth, this.border.toString(), null, 0, 100, true);
    }), "set the border's\nline size");
    menu.addItem("border color...", (function() {
      return this.pickColor(menu.title + "\nborder color:", this.setBorderColor, this.borderColor);
    }), "set the border's\nline color");
    menu.addItem("corner size...", (function() {
      return this.prompt(menu.title + "\ncorner\nsize:", this.setCornerSize, this.edge.toString(), null, 0, 100, true);
    }), "set the corner's\nradius");
    return menu;
  };

  BoxMorph.prototype.setBorderWidth = function(sizeOrMorphGivingSize) {
    var newSize, size;
    if (sizeOrMorphGivingSize.getValue != null) {
      size = sizeOrMorphGivingSize.getValue();
    } else {
      size = sizeOrMorphGivingSize;
    }
    if (typeof size === "number") {
      this.border = Math.max(size, 0);
    } else {
      newSize = parseFloat(size);
      if (!isNaN(newSize)) {
        this.border = Math.max(newSize, 0);
      }
    }
    this.updateRendering();
    return this.changed();
  };

  BoxMorph.prototype.setBorderColor = function(aColorOrAMorphGivingAColor) {
    var aColor;
    if (aColorOrAMorphGivingAColor.getColor != null) {
      aColor = aColorOrAMorphGivingAColor.getColor();
    } else {
      aColor = aColorOrAMorphGivingAColor;
    }
    if (aColor) {
      this.borderColor = aColor;
      this.updateRendering();
      return this.changed();
    }
  };

  BoxMorph.prototype.setCornerSize = function(sizeOrMorphGivingSize) {
    var newSize, size;
    if (sizeOrMorphGivingSize.getValue != null) {
      size = sizeOrMorphGivingSize.getValue();
    } else {
      size = sizeOrMorphGivingSize;
    }
    if (typeof size === "number") {
      this.edge = Math.max(size, 0);
    } else {
      newSize = parseFloat(size);
      if (!isNaN(newSize)) {
        this.edge = Math.max(newSize, 0);
      }
    }
    this.updateRendering();
    return this.changed();
  };

  BoxMorph.prototype.colorSetters = function() {
    return ["color", "borderColor"];
  };

  BoxMorph.prototype.numericalSetters = function() {
    var list;
    list = BoxMorph.__super__.numericalSetters.call(this);
    list.push("setBorderWidth", "setCornerSize");
    return list;
  };

  BoxMorph.coffeeScriptSourceOfThisClass = '# BoxMorph ////////////////////////////////////////////////////////////\n\n# I can have an optionally rounded border\n\nclass BoxMorph extends Morph\n\n  edge: null\n  border: null\n  borderColor: null\n\n  constructor: (@edge = 4, border, borderColor) ->\n    @border = border or ((if (border is 0) then 0 else 2))\n    @borderColor = borderColor or new Color()\n    super()\n\n  \n  # BoxMorph drawing:\n  updateRendering: ->\n    @image = newCanvas(@extent().scaleBy pixelRatio)\n    context = @image.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    if (@edge is 0) and (@border is 0)\n      super()\n      return null\n    context.fillStyle = @color.toString()\n    context.beginPath()\n    @outlinePath context, Math.max(@edge - @border, 0), @border\n    context.closePath()\n    context.fill()\n    #if @border > 0\n    #  context.lineWidth = @border\n    #  context.strokeStyle = @borderColor.toString()\n    #  context.beginPath()\n    #  @outlinePath context, @edge, @border / 2\n    #  context.closePath()\n    #  context.stroke()\n  \n  outlinePath: (context, radius, inset) ->\n    offset = radius + inset\n    w = @width()\n    h = @height()\n    # top left:\n    context.arc offset, offset, radius, radians(-180), radians(-90), false\n    # top right:\n    context.arc w - offset, offset, radius, radians(-90), radians(-0), false\n    # bottom right:\n    context.arc w - offset, h - offset, radius, radians(0), radians(90), false\n    # bottom left:\n    context.arc offset, h - offset, radius, radians(90), radians(180), false\n  \n  \n  # BoxMorph menus:\n  developersMenu: ->\n    menu = super()\n    menu.addLine()\n\n    menu.addItem "border width...", (->\n      @prompt menu.title + "\nborder\nwidth:",\n        @setBorderWidth,\n        @border.toString(),\n        null,\n        0,\n        100,\n        true\n    ), "set the border\'s\nline size"\n    menu.addItem "border color...", (->\n      @pickColor menu.title + "\nborder color:", @setBorderColor, @borderColor\n    ), "set the border\'s\nline color"\n    menu.addItem "corner size...", (->\n      @prompt menu.title + "\ncorner\nsize:",\n        @setCornerSize,\n        @edge.toString(),\n        null,\n        0,\n        100,\n        true\n    ), "set the corner\'s\nradius"\n    menu\n  \n  setBorderWidth: (sizeOrMorphGivingSize) ->\n    if sizeOrMorphGivingSize.getValue?\n      size = sizeOrMorphGivingSize.getValue()\n    else\n      size = sizeOrMorphGivingSize\n\n    # for context menu demo purposes\n    if typeof size is "number"\n      @border = Math.max(size, 0)\n    else\n      newSize = parseFloat(size)\n      @border = Math.max(newSize, 0)  unless isNaN(newSize)\n    @updateRendering()\n    @changed()\n  \n\n  setBorderColor: (aColorOrAMorphGivingAColor) ->\n    if aColorOrAMorphGivingAColor.getColor?\n      aColor = aColorOrAMorphGivingAColor.getColor()\n    else\n      aColor = aColorOrAMorphGivingAColor\n\n    if aColor\n      @borderColor = aColor\n      @updateRendering()\n      @changed()\n  \n  setCornerSize: (sizeOrMorphGivingSize) ->\n    if sizeOrMorphGivingSize.getValue?\n      size = sizeOrMorphGivingSize.getValue()\n    else\n      size = sizeOrMorphGivingSize\n\n    # for context menu demo purposes\n    if typeof size is "number"\n      @edge = Math.max(size, 0)\n    else\n      newSize = parseFloat(size)\n      @edge = Math.max(newSize, 0)  unless isNaN(newSize)\n    @updateRendering()\n    @changed()\n  \n  colorSetters: ->\n    # for context menu demo purposes\n    ["color", "borderColor"]\n  \n  numericalSetters: ->\n    # for context menu demo purposes\n    list = super()\n    list.push "setBorderWidth", "setCornerSize"\n    list';

  return BoxMorph;

})(Morph);

CaretMorph = (function(_super) {
  __extends(CaretMorph, _super);

  CaretMorph.prototype.keyDownEventUsed = false;

  CaretMorph.prototype.target = null;

  CaretMorph.prototype.originalContents = null;

  CaretMorph.prototype.slot = null;

  CaretMorph.prototype.viewPadding = 1;

  function CaretMorph(target) {
    var ls;
    this.target = target;
    this.originalContents = this.target.text;
    this.originalAlignment = this.target.alignment;
    this.slot = this.target.text.length;
    CaretMorph.__super__.constructor.call(this);
    ls = fontHeight(this.target.fontSize);
    this.setExtent(new Point(Math.max(Math.floor(ls / 20), 1), ls));
    if (this.target instanceof TextMorph && (this.target.alignment !== 'left')) {
      this.target.setAlignmentToLeft();
    }
    this.gotoSlot(this.slot);
  }

  CaretMorph.prototype.updateRendering = function() {
    var context;
    CaretMorph.__super__.updateRendering.call(this);
    context = this.image.getContext("2d");
    return context.font = this.target.font();
  };

  CaretMorph.prototype.processKeyPress = function(charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) {
    if (this.keyDownEventUsed) {
      this.keyDownEventUsed = false;
      return null;
    }
    if (ctrlKey) {
      this.ctrl(charCode);
    } else if (metaKey) {
      this.cmd(charCode);
    } else {
      this.insert(symbol, shiftKey);
    }
    return this.target.escalateEvent("reactToKeystroke", charCode, symbol, shiftKey, ctrlKey, altKey, metaKey);
  };

  CaretMorph.prototype.processKeyDown = function(scanCode, shiftKey, ctrlKey, altKey, metaKey) {
    this.keyDownEventUsed = false;
    if (ctrlKey) {
      this.ctrl(scanCode);
      this.target.escalateEvent("reactToKeystroke", scanCode, null, shiftKey, ctrlKey, altKey, metaKey);
      return;
    } else if (metaKey) {
      this.cmd(scanCode);
      this.target.escalateEvent("reactToKeystroke", scanCode, null, shiftKey, ctrlKey, altKey, metaKey);
      return;
    }
    switch (scanCode) {
      case 37:
        this.goLeft(shiftKey);
        this.keyDownEventUsed = true;
        break;
      case 39:
        this.goRight(shiftKey);
        this.keyDownEventUsed = true;
        break;
      case 38:
        this.goUp(shiftKey);
        this.keyDownEventUsed = true;
        break;
      case 40:
        this.goDown(shiftKey);
        this.keyDownEventUsed = true;
        break;
      case 36:
        this.goHome(shiftKey);
        this.keyDownEventUsed = true;
        break;
      case 35:
        this.goEnd(shiftKey);
        this.keyDownEventUsed = true;
        break;
      case 46:
        this.deleteRight();
        this.keyDownEventUsed = true;
        break;
      case 8:
        this.deleteLeft();
        this.keyDownEventUsed = true;
        break;
      case 13:
        if (this.target.constructor.name === "StringMorph") {
          this.accept();
        } else {
          this.insert("\n");
        }
        this.keyDownEventUsed = true;
        break;
      case 27:
        this.cancel();
        this.keyDownEventUsed = true;
        break;
    }
    return this.target.escalateEvent("reactToKeystroke", scanCode, null, shiftKey, ctrlKey, altKey, metaKey);
  };

  CaretMorph.prototype.gotoSlot = function(slot) {
    var left, length, pos, right;
    length = this.target.text.length;
    this.slot = (slot < 0 ? 0 : (slot > length ? length : slot));
    pos = this.target.slotCoordinates(this.slot);
    if (this.parent && this.target.isScrollable) {
      right = this.parent.right() - this.viewPadding;
      left = this.parent.left() + this.viewPadding;
      if (pos.x > right) {
        this.target.setLeft(this.target.left() + right - pos.x);
        pos.x = right;
      }
      if (pos.x < left) {
        left = Math.min(this.parent.left(), left);
        this.target.setLeft(this.target.left() + left - pos.x);
        pos.x = left;
      }
      if (this.target.right() < right && right - this.target.width() < left) {
        pos.x += right - this.target.right();
        this.target.setRight(right);
      }
    }
    this.show();
    this.setPosition(pos);
    if (this.parent && this.parent.parent instanceof ScrollFrameMorph && this.target.isScrollable) {
      return this.parent.parent.scrollCaretIntoView(this);
    }
  };

  CaretMorph.prototype.goLeft = function(shift) {
    this.updateSelection(shift);
    this.gotoSlot(this.slot - 1);
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.goRight = function(shift, howMany) {
    this.updateSelection(shift);
    this.gotoSlot(this.slot + (howMany || 1));
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.goUp = function(shift) {
    this.updateSelection(shift);
    this.gotoSlot(this.target.upFrom(this.slot));
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.goDown = function(shift) {
    this.updateSelection(shift);
    this.gotoSlot(this.target.downFrom(this.slot));
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.goHome = function(shift) {
    this.updateSelection(shift);
    this.gotoSlot(this.target.startOfLine(this.slot));
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.goEnd = function(shift) {
    this.updateSelection(shift);
    this.gotoSlot(this.target.endOfLine(this.slot));
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.gotoPos = function(aPoint) {
    this.gotoSlot(this.target.slotAt(aPoint));
    return this.show();
  };

  CaretMorph.prototype.updateSelection = function(shift) {
    if (shift) {
      if ((this.target.endMark === null) && (this.target.startMark === null)) {
        this.target.startMark = this.slot;
        return this.target.endMark = this.slot;
      } else if (this.target.endMark !== this.slot) {
        this.target.endMark = this.slot;
        this.target.updateRendering();
        return this.target.changed();
      }
    } else {
      return this.target.clearSelection();
    }
  };

  CaretMorph.prototype.accept = function() {
    var world;
    world = this.root();
    if (world) {
      world.stopEditing();
    }
    return this.escalateEvent("accept", null);
  };

  CaretMorph.prototype.cancel = function() {
    var world;
    world = this.root();
    this.undo();
    if (world) {
      world.stopEditing();
    }
    return this.escalateEvent('cancel', null);
  };

  CaretMorph.prototype.undo = function() {
    this.target.text = this.originalContents;
    this.target.clearSelection();
    this.target.changed();
    this.target.updateRendering();
    this.target.changed();
    return this.gotoSlot(0);
  };

  CaretMorph.prototype.insert = function(symbol, shiftKey) {
    var text;
    if (symbol === "\t") {
      this.target.escalateEvent('reactToEdit', this.target);
      if (shiftKey) {
        return this.target.backTab(this.target);
      }
      return this.target.tab(this.target);
    }
    if (!this.target.isNumeric || !isNaN(parseFloat(symbol)) || contains(["-", "."], symbol)) {
      if (this.target.selection() !== "") {
        this.gotoSlot(this.target.selectionStartSlot());
        this.target.deleteSelection();
      }
      text = this.target.text;
      text = text.slice(0, this.slot) + symbol + text.slice(this.slot);
      this.target.text = text;
      this.target.updateRendering();
      this.target.changed();
      return this.goRight(false, symbol.length);
    }
  };

  CaretMorph.prototype.ctrl = function(scanCodeOrCharCode) {
    if ((scanCodeOrCharCode === 97) || (scanCodeOrCharCode === 65)) {
      return this.target.selectAll();
    } else if (scanCodeOrCharCode === 90) {
      return this.undo();
    } else if (scanCodeOrCharCode === 123) {
      return this.insert("{");
    } else if (scanCodeOrCharCode === 125) {
      return this.insert("}");
    } else if (scanCodeOrCharCode === 91) {
      return this.insert("[");
    } else if (scanCodeOrCharCode === 93) {
      return this.insert("]");
    } else if (scanCodeOrCharCode === 64) {
      return this.insert("@");
    }
  };

  CaretMorph.prototype.cmd = function(scanCode) {
    if (scanCode === 65) {
      return this.target.selectAll();
    } else if (scanCode === 90) {
      return this.undo();
    }
  };

  CaretMorph.prototype.deleteRight = function() {
    var text;
    if (this.target.selection() !== "") {
      this.gotoSlot(this.target.selectionStartSlot());
      return this.target.deleteSelection();
    } else {
      text = this.target.text;
      this.target.changed();
      text = text.slice(0, this.slot) + text.slice(this.slot + 1);
      this.target.text = text;
      return this.target.updateRendering();
    }
  };

  CaretMorph.prototype.deleteLeft = function() {
    var text;
    if (this.target.selection()) {
      this.gotoSlot(this.target.selectionStartSlot());
      return this.target.deleteSelection();
    }
    text = this.target.text;
    this.target.changed();
    this.target.text = text.substring(0, this.slot - 1) + text.substr(this.slot);
    this.target.updateRendering();
    return this.goLeft();
  };

  CaretMorph.prototype.destroy = function() {
    if (this.target.alignment !== this.originalAlignment) {
      this.target.alignment = this.originalAlignment;
      this.target.updateRendering();
      this.target.changed();
    }
    return CaretMorph.__super__.destroy.apply(this, arguments);
  };

  CaretMorph.prototype.inspectKeyEvent = function(event) {
    return this.inform("Key pressed: " + String.fromCharCode(event.charCode) + "\n------------------------" + "\ncharCode: " + event.charCode + "\nkeyCode: " + event.keyCode + "\naltKey: " + event.altKey + "\nctrlKey: " + event.ctrlKey + "\ncmdKey: " + event.metaKey);
  };

  CaretMorph.coffeeScriptSourceOfThisClass = '# CaretMorph /////////////////////////////////////////////////////////\n\n# I mark where the caret is in a String/Text while editing\n\nclass CaretMorph extends BlinkerMorph\n\n  keyDownEventUsed: false\n  target: null\n  originalContents: null\n  slot: null\n  viewPadding: 1\n\n  constructor: (@target) ->\n    # additional properties:\n    @originalContents = @target.text\n    @originalAlignment = @target.alignment\n    @slot = @target.text.length\n    super()\n    ls = fontHeight(@target.fontSize)\n    @setExtent new Point(Math.max(Math.floor(ls / 20), 1), ls)\n    if (@target instanceof TextMorph && (@target.alignment != \'left\'))\n      @target.setAlignmentToLeft()\n    @gotoSlot @slot\n  \n  updateRendering: ->\n    super()\n    # it\'d be cool to do this only\n    # once but we don\'t want to paint stuff in\n    # the constructor...\n    context = @image.getContext("2d")\n    context.font = @target.font()\n\n  # CaretMorph event processing:\n  processKeyPress: (charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) ->\n    # @inspectKeyEvent event\n    if @keyDownEventUsed\n      @keyDownEventUsed = false\n      return null\n    if ctrlKey\n      @ctrl charCode\n    # in Chrome/OSX cmd-a and cmd-z\n    # don\'t trigger a keypress so this\n    # function invocation here does\n    # nothing.\n    else if metaKey\n      @cmd charCode\n    else\n      @insert symbol, shiftKey\n    # notify target\'s parent of key event\n    @target.escalateEvent "reactToKeystroke", charCode, symbol, shiftKey, ctrlKey, altKey, metaKey\n  \n  processKeyDown: (scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    # this.inspectKeyEvent(event);\n    @keyDownEventUsed = false\n    if ctrlKey\n      @ctrl scanCode\n      # notify target\'s parent of key event\n      @target.escalateEvent "reactToKeystroke", scanCode, null, shiftKey, ctrlKey, altKey, metaKey\n      return\n    else if metaKey\n      @cmd scanCode\n      # notify target\'s parent of key event\n      @target.escalateEvent "reactToKeystroke", scanCode, null, shiftKey, ctrlKey, altKey, metaKey\n      return\n    switch scanCode\n      when 37\n        @goLeft(shiftKey)\n        @keyDownEventUsed = true\n      when 39\n        @goRight(shiftKey)\n        @keyDownEventUsed = true\n      when 38\n        @goUp(shiftKey)\n        @keyDownEventUsed = true\n      when 40\n        @goDown(shiftKey)\n        @keyDownEventUsed = true\n      when 36\n        @goHome(shiftKey)\n        @keyDownEventUsed = true\n      when 35\n        @goEnd(shiftKey)\n        @keyDownEventUsed = true\n      when 46\n        @deleteRight()\n        @keyDownEventUsed = true\n      when 8\n        @deleteLeft()\n        @keyDownEventUsed = true\n      when 13\n        # we can\'t check the class using instanceOf\n        # because TextMorphs are instances of StringMorphs\n        # but they want the enter to insert a carriage return.\n        if @target.constructor.name == "StringMorph"\n          @accept()\n        else\n          @insert "\n"\n        @keyDownEventUsed = true\n      when 27\n        @cancel()\n        @keyDownEventUsed = true\n      else\n    # this.inspectKeyEvent(event);\n    # notify target\'s parent of key event\n    @target.escalateEvent "reactToKeystroke", scanCode, null, shiftKey, ctrlKey, altKey, metaKey\n  \n  \n  # CaretMorph navigation - simple version\n  #gotoSlot: (newSlot) ->\n  #  @setPosition @target.slotCoordinates(newSlot)\n  #  @slot = Math.max(newSlot, 0)\n\n  gotoSlot: (slot) ->\n    # check that slot is within the allowed boundaries of\n    # of zero and text length.\n    length = @target.text.length\n    @slot = (if slot < 0 then 0 else (if slot > length then length else slot))\n\n    pos = @target.slotCoordinates(@slot)\n    if @parent and @target.isScrollable\n      right = @parent.right() - @viewPadding\n      left = @parent.left() + @viewPadding\n      if pos.x > right\n        @target.setLeft @target.left() + right - pos.x\n        pos.x = right\n      if pos.x < left\n        left = Math.min(@parent.left(), left)\n        @target.setLeft @target.left() + left - pos.x\n        pos.x = left\n      if @target.right() < right and right - @target.width() < left\n        pos.x += right - @target.right()\n        @target.setRight right\n    @show()\n    @setPosition pos\n\n    if @parent and @parent.parent instanceof ScrollFrameMorph and @target.isScrollable\n      @parent.parent.scrollCaretIntoView @\n  \n  goLeft: (shift) ->\n    @updateSelection shift\n    @gotoSlot @slot - 1\n    @updateSelection shift\n  \n  goRight: (shift, howMany) ->\n    @updateSelection shift\n    @gotoSlot @slot + (howMany || 1)\n    @updateSelection shift\n  \n  goUp: (shift) ->\n    @updateSelection shift\n    @gotoSlot @target.upFrom(@slot)\n    @updateSelection shift\n  \n  goDown: (shift) ->\n    @updateSelection shift\n    @gotoSlot @target.downFrom(@slot)\n    @updateSelection shift\n  \n  goHome: (shift) ->\n    @updateSelection shift\n    @gotoSlot @target.startOfLine(@slot)\n    @updateSelection shift\n  \n  goEnd: (shift) ->\n    @updateSelection shift\n    @gotoSlot @target.endOfLine(@slot)\n    @updateSelection shift\n  \n  gotoPos: (aPoint) ->\n    @gotoSlot @target.slotAt(aPoint)\n    @show()\n\n  updateSelection: (shift) ->\n    if shift\n      if (@target.endMark is null) and (@target.startMark is null)\n        @target.startMark = @slot\n        @target.endMark = @slot\n      else if @target.endMark isnt @slot\n        @target.endMark = @slot\n        @target.updateRendering()\n        @target.changed()\n    else\n      @target.clearSelection()  \n  \n  # CaretMorph editing.\n\n  # User presses enter on a stringMorph\n  accept: ->\n    world = @root()\n    world.stopEditing()  if world\n    @escalateEvent "accept", null\n  \n  # User presses ESC\n  cancel: ->\n    world = @root()\n    @undo()\n    world.stopEditing()  if world\n    @escalateEvent \'cancel\', null\n    \n  # User presses CTRL-Z or CMD-Z\n  # Note that this is not a real undo,\n  # what we are doing here is just reverting\n  # all the changes and sort-of-resetting the\n  # state of the target.\n  undo: ->\n    @target.text = @originalContents\n    @target.clearSelection()\n    \n    # in theory these three lines are not\n    # needed because clearSelection runs them\n    # already, but I\'m leaving them here\n    # until I understand better this changed\n    # vs. updateRendering semantics.\n    @target.changed()\n    @target.updateRendering()\n    @target.changed()\n\n    @gotoSlot 0\n  \n  insert: (symbol, shiftKey) ->\n    if symbol is "\t"\n      @target.escalateEvent \'reactToEdit\', @target\n      if shiftKey\n        return @target.backTab(@target);\n      return @target.tab(@target)\n    if not @target.isNumeric or not isNaN(parseFloat(symbol)) or contains(["-", "."], symbol)\n      if @target.selection() isnt ""\n        @gotoSlot @target.selectionStartSlot()\n        @target.deleteSelection()\n      text = @target.text\n      text = text.slice(0, @slot) + symbol + text.slice(@slot)\n      @target.text = text\n      @target.updateRendering()\n      @target.changed()\n      @goRight false, symbol.length\n  \n  ctrl: (scanCodeOrCharCode) ->\n    # ctrl-a apparently can come from either\n    # keypress or keydown\n    # 64 is for keydown\n    # 97 is for keypress\n    # in Chrome on OSX there is no keypress\n    if (scanCodeOrCharCode is 97) or (scanCodeOrCharCode is 65)\n      @target.selectAll()\n    # ctrl-z arrives both via keypress and\n    # keydown but 90 here matches the keydown only\n    else if scanCodeOrCharCode is 90\n      @undo()\n    # unclear which keyboard needs ctrl\n    # to be pressed to give a keypressed\n    # event for {}[]@\n    # but this is what this catches\n    else if scanCodeOrCharCode is 123\n      @insert "{"\n    else if scanCodeOrCharCode is 125\n      @insert "}"\n    else if scanCodeOrCharCode is 91\n      @insert "["\n    else if scanCodeOrCharCode is 93\n      @insert "]"\n    else if scanCodeOrCharCode is 64\n      @insert "@"\n  \n  # these two arrive only from\n  # keypressed, at least in Chrome/OSX\n  # 65 and 90 are both scan codes.\n  cmd: (scanCode) ->\n    # CMD-A\n    if scanCode is 65\n      @target.selectAll()\n    # CMD-Z\n    else if scanCode is 90\n      @undo()\n  \n  deleteRight: ->\n    if @target.selection() isnt ""\n      @gotoSlot @target.selectionStartSlot()\n      @target.deleteSelection()\n    else\n      text = @target.text\n      @target.changed()\n      text = text.slice(0, @slot) + text.slice(@slot + 1)\n      @target.text = text\n      @target.updateRendering()\n  \n  deleteLeft: ->\n    if @target.selection()\n      @gotoSlot @target.selectionStartSlot()\n      return @target.deleteSelection()\n    text = @target.text\n    @target.changed()\n    @target.text = text.substring(0, @slot - 1) + text.substr(@slot)\n    @target.updateRendering()\n    @goLeft()\n\n  # CaretMorph destroying:\n  destroy: ->\n    if @target.alignment isnt @originalAlignment\n      @target.alignment = @originalAlignment\n      @target.updateRendering()\n      @target.changed()\n    super  \n  \n  # CaretMorph utilities:\n  inspectKeyEvent: (event) ->\n    # private\n    @inform "Key pressed: " + String.fromCharCode(event.charCode) + "\n------------------------" + "\ncharCode: " + event.charCode + "\nkeyCode: " + event.keyCode + "\naltKey: " + event.altKey + "\nctrlKey: " + event.ctrlKey  + "\ncmdKey: " + event.metaKey';

  return CaretMorph;

})(BlinkerMorph);

CircleBoxMorph = (function(_super) {
  __extends(CircleBoxMorph, _super);

  CircleBoxMorph.prototype.orientation = null;

  CircleBoxMorph.prototype.autoOrient = true;

  function CircleBoxMorph(orientation) {
    this.orientation = orientation != null ? orientation : "vertical";
    CircleBoxMorph.__super__.constructor.call(this);
    this.setExtent(new Point(20, 100));
  }

  CircleBoxMorph.prototype.autoOrientation = function() {
    if (this.height() > this.width()) {
      return this.orientation = "vertical";
    } else {
      return this.orientation = "horizontal";
    }
  };

  CircleBoxMorph.prototype.updateRendering = function() {
    var center1, center2, context, ext, points, radius, rect, x, y;
    if (this.autoOrient) {
      this.autoOrientation();
    }
    this.image = newCanvas(this.extent().scaleBy(pixelRatio));
    context = this.image.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    if (this.orientation === "vertical") {
      radius = this.width() / 2;
      x = this.center().x;
      center1 = new Point(x, this.top() + radius);
      center2 = new Point(x, this.bottom() - radius);
      rect = this.bounds.origin.add(new Point(0, radius)).corner(this.bounds.corner.subtract(new Point(0, radius)));
    } else {
      radius = this.height() / 2;
      y = this.center().y;
      center1 = new Point(this.left() + radius, y);
      center2 = new Point(this.right() - radius, y);
      rect = this.bounds.origin.add(new Point(radius, 0)).corner(this.bounds.corner.subtract(new Point(radius, 0)));
    }
    points = [center1.subtract(this.bounds.origin), center2.subtract(this.bounds.origin)];
    points.forEach((function(_this) {
      return function(center) {
        context.fillStyle = _this.color.toString();
        context.beginPath();
        context.arc(center.x, center.y, radius, 0, 2 * Math.PI, false);
        context.closePath();
        return context.fill();
      };
    })(this));
    rect = rect.translateBy(this.bounds.origin.neg());
    ext = rect.extent();
    if (ext.x > 0 && ext.y > 0) {
      return context.fillRect(rect.origin.x, rect.origin.y, rect.width(), rect.height());
    }
  };

  CircleBoxMorph.prototype.developersMenu = function() {
    var menu;
    menu = CircleBoxMorph.__super__.developersMenu.call(this);
    menu.addLine();
    if (this.orientation === "vertical") {
      menu.addItem("make horizontal", (function() {
        return this.toggleOrientation();
      }), "toggle the\norientation");
    } else {
      menu.addItem("make vertical", (function() {
        return this.toggleOrientation();
      }), "toggle the\norientation");
    }
    return menu;
  };

  CircleBoxMorph.prototype.toggleOrientation = function() {
    var center;
    center = this.center();
    this.changed();
    if (this.orientation === "vertical") {
      this.orientation = "horizontal";
    } else {
      this.orientation = "vertical";
    }
    this.silentSetExtent(new Point(this.height(), this.width()));
    this.setCenter(center);
    this.updateRendering();
    return this.changed();
  };

  CircleBoxMorph.coffeeScriptSourceOfThisClass = '# CircleBoxMorph //////////////////////////////////////////////////////\n\n# I can be used for sliders\n\nclass CircleBoxMorph extends Morph\n\n  orientation: null\n  autoOrient: true\n\n  constructor: (@orientation = "vertical") ->\n    super()\n    @setExtent new Point(20, 100)\n\n  \n  autoOrientation: ->\n    if @height() > @width()\n      @orientation = "vertical"\n    else\n      @orientation = "horizontal"\n  \n  updateRendering: ->\n    @autoOrientation()  if @autoOrient\n    @image = newCanvas(@extent().scaleBy pixelRatio)\n    context = @image.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    if @orientation is "vertical"\n      radius = @width() / 2\n      x = @center().x\n      center1 = new Point(x, @top() + radius)\n      center2 = new Point(x, @bottom() - radius)\n      rect = @bounds.origin.add(\n        new Point(0, radius)).corner(@bounds.corner.subtract(new Point(0, radius)))\n    else\n      radius = @height() / 2\n      y = @center().y\n      center1 = new Point(@left() + radius, y)\n      center2 = new Point(@right() - radius, y)\n      rect = @bounds.origin.add(\n        new Point(radius, 0)).corner(@bounds.corner.subtract(new Point(radius, 0)))\n    points = [center1.subtract(@bounds.origin), center2.subtract(@bounds.origin)]\n    points.forEach (center) =>\n      context.fillStyle = @color.toString()\n      context.beginPath()\n      context.arc center.x, center.y, radius, 0, 2 * Math.PI, false\n      context.closePath()\n      context.fill()\n    rect = rect.translateBy(@bounds.origin.neg())\n    ext = rect.extent()\n    if ext.x > 0 and ext.y > 0\n      context.fillRect rect.origin.x, rect.origin.y, rect.width(), rect.height()\n  \n  \n  # CircleBoxMorph menu:\n  developersMenu: ->\n    menu = super()\n    menu.addLine()\n    # todo Dan Ingalls did show a neat demo where the\n    # boxmorph was automatically chanding the orientation\n    # when resized, following the main direction.\n    if @orientation is "vertical"\n      menu.addItem "make horizontal", (->@toggleOrientation()), "toggle the\norientation"\n    else\n      menu.addItem "make vertical", (->@toggleOrientation()), "toggle the\norientation"\n    menu\n  \n  toggleOrientation: ->\n    center = @center()\n    @changed()\n    if @orientation is "vertical"\n      @orientation = "horizontal"\n    else\n      @orientation = "vertical"\n    @silentSetExtent new Point(@height(), @width())\n    @setCenter center\n    @updateRendering()\n    @changed()';

  return CircleBoxMorph;

})(Morph);

Color = (function() {
  Color.colourNamesValues = {
    aliceblue: [0xf0, 0xf8, 0xff],
    antiquewhite: [0xfa, 0xeb, 0xd7],
    aqua: [0x00, 0xff, 0xff],
    aquamarine: [0x7f, 0xff, 0xd4],
    azure: [0xf0, 0xff, 0xff],
    beige: [0xf5, 0xf5, 0xdc],
    bisque: [0xff, 0xe4, 0xc4],
    black: [0x00, 0x00, 0x00],
    blanchedalmond: [0xff, 0xeb, 0xcd],
    blue: [0x00, 0x00, 0xff],
    blueviolet: [0x8a, 0x2b, 0xe2],
    brown: [0xa5, 0x2a, 0x2a],
    burlywood: [0xde, 0xb8, 0x87],
    cadetblue: [0x5f, 0x9e, 0xa0],
    chartreuse: [0x7f, 0xff, 0x00],
    chocolate: [0xd2, 0x69, 0x1e],
    coral: [0xff, 0x7f, 0x50],
    cornflowerblue: [0x64, 0x95, 0xed],
    cornsilk: [0xff, 0xf8, 0xdc],
    crimson: [0xdc, 0x14, 0x3c],
    cyan: [0x00, 0xff, 0xff],
    darkblue: [0x00, 0x00, 0x8b],
    darkcyan: [0x00, 0x8b, 0x8b],
    darkgoldenrod: [0xb8, 0x86, 0x0b],
    darkgray: [0xa9, 0xa9, 0xa9],
    darkgrey: [0xa9, 0xa9, 0xa9],
    darkgreen: [0x00, 0x64, 0x00],
    darkkhaki: [0xbd, 0xb7, 0x6b],
    darkmagenta: [0x8b, 0x00, 0x8b],
    darkolivegreen: [0x55, 0x6b, 0x2f],
    darkorange: [0xff, 0x8c, 0x00],
    darkorchid: [0x99, 0x32, 0xcc],
    darkred: [0x8b, 0x00, 0x00],
    darksalmon: [0xe9, 0x96, 0x7a],
    darkseagreen: [0x8f, 0xbc, 0x8f],
    darkslateblue: [0x48, 0x3d, 0x8b],
    darkslategray: [0x2f, 0x4f, 0x4f],
    darkslategrey: [0x2f, 0x4f, 0x4f],
    darkturquoise: [0x00, 0xce, 0xd1],
    darkviolet: [0x94, 0x00, 0xd3],
    deeppink: [0xff, 0x14, 0x93],
    deepskyblue: [0x00, 0xbf, 0xff],
    dimgray: [0x69, 0x69, 0x69],
    dimgrey: [0x69, 0x69, 0x69],
    dodgerblue: [0x1e, 0x90, 0xff],
    firebrick: [0xb2, 0x22, 0x22],
    floralwhite: [0xff, 0xfa, 0xf0],
    forestgreen: [0x22, 0x8b, 0x22],
    fuchsia: [0xff, 0x00, 0xff],
    gainsboro: [0xdc, 0xdc, 0xdc],
    ghostwhite: [0xf8, 0xf8, 0xff],
    gold: [0xff, 0xd7, 0x00],
    goldenrod: [0xda, 0xa5, 0x20],
    gray: [0x80, 0x80, 0x80],
    grey: [0x80, 0x80, 0x80],
    green: [0x00, 0x80, 0x00],
    greenyellow: [0xad, 0xff, 0x2f],
    honeydew: [0xf0, 0xff, 0xf0],
    hotpink: [0xff, 0x69, 0xb4],
    indianred: [0xcd, 0x5c, 0x5c],
    indigo: [0x4b, 0x00, 0x82],
    ivory: [0xff, 0xff, 0xf0],
    khaki: [0xf0, 0xe6, 0x8c],
    lavender: [0xe6, 0xe6, 0xfa],
    lavenderblush: [0xff, 0xf0, 0xf5],
    lawngreen: [0x7c, 0xfc, 0x00],
    lemonchiffon: [0xff, 0xfa, 0xcd],
    lightblue: [0xad, 0xd8, 0xe6],
    lightcoral: [0xf0, 0x80, 0x80],
    lightcyan: [0xe0, 0xff, 0xff],
    lightgoldenrodyellow: [0xfa, 0xfa, 0xd2],
    lightgrey: [0xd3, 0xd3, 0xd3],
    lightgray: [0xd3, 0xd3, 0xd3],
    lightgreen: [0x90, 0xee, 0x90],
    lightpink: [0xff, 0xb6, 0xc1],
    lightsalmon: [0xff, 0xa0, 0x7a],
    lightseagreen: [0x20, 0xb2, 0xaa],
    lightskyblue: [0x87, 0xce, 0xfa],
    lightslategray: [0x77, 0x88, 0x99],
    lightslategrey: [0x77, 0x88, 0x99],
    lightsteelblue: [0xb0, 0xc4, 0xde],
    lightyellow: [0xff, 0xff, 0xe0],
    lime: [0x00, 0xff, 0x00],
    limegreen: [0x32, 0xcd, 0x32],
    linen: [0xfa, 0xf0, 0xe6],
    mintcream: [0xf5, 0xff, 0xfa],
    mistyrose: [0xff, 0xe4, 0xe1],
    moccasin: [0xff, 0xe4, 0xb5],
    navajowhite: [0xff, 0xde, 0xad],
    navy: [0x00, 0x00, 0x80],
    oldlace: [0xfd, 0xf5, 0xe6],
    olive: [0x80, 0x80, 0x00],
    olivedrab: [0x6b, 0x8e, 0x23],
    orange: [0xff, 0xa5, 0x00],
    orangered: [0xff, 0x45, 0x00],
    orchid: [0xda, 0x70, 0xd6],
    palegoldenrod: [0xee, 0xe8, 0xaa],
    palegreen: [0x98, 0xfb, 0x98],
    paleturquoise: [0xaf, 0xee, 0xee],
    palevioletred: [0xd8, 0x70, 0x93],
    papayawhip: [0xff, 0xef, 0xd5],
    peachpuff: [0xff, 0xda, 0xb9],
    peru: [0xcd, 0x85, 0x3f],
    pink: [0xff, 0xc0, 0xcb],
    plum: [0xdd, 0xa0, 0xdd],
    powderblue: [0xb0, 0xe0, 0xe6],
    purple: [0x80, 0x00, 0x80],
    red: [0xff, 0x00, 0x00],
    rosybrown: [0xbc, 0x8f, 0x8f],
    royalblue: [0x41, 0x69, 0xe1],
    saddlebrown: [0x8b, 0x45, 0x13],
    salmon: [0xfa, 0x80, 0x72],
    sandybrown: [0xf4, 0xa4, 0x60],
    seagreen: [0x2e, 0x8b, 0x57],
    seashell: [0xff, 0xf5, 0xee],
    sienna: [0xa0, 0x52, 0x2d],
    silver: [0xc0, 0xc0, 0xc0],
    skyblue: [0x87, 0xce, 0xeb],
    slateblue: [0x6a, 0x5a, 0xcd],
    slategray: [0x70, 0x80, 0x90],
    slategrey: [0x70, 0x80, 0x90],
    snow: [0xff, 0xfa, 0xfa],
    springgreen: [0x00, 0xff, 0x7f],
    steelblue: [0x46, 0x82, 0xb4],
    tan: [0xd2, 0xb4, 0x8c],
    teal: [0x00, 0x80, 0x80],
    thistle: [0xd8, 0xbf, 0xd8],
    tomato: [0xff, 0x63, 0x47],
    turquoise: [0x40, 0xe0, 0xd0],
    violet: [0xee, 0x82, 0xee],
    wheat: [0xf5, 0xde, 0xb3],
    white: [0xff, 0xff, 0xff],
    whitesmoke: [0xf5, 0xf5, 0xf5],
    yellow: [0xff, 0xff, 0x00],
    yellowgreen: [0x9a, 0xcd, 0x32]
  };

  Color.prototype.a = null;

  Color.prototype.r = null;

  Color.prototype.g = null;

  Color.prototype.b = null;

  function Color(r, g, b, a) {
    this.r = r != null ? r : 0;
    this.g = g != null ? g : 0;
    this.b = b != null ? b : 0;
    this.a = a || (a === 0 ? 0 : 1);
  }

  Color.prototype.toString = function() {
    return "rgba(" + Math.round(this.r) + "," + Math.round(this.g) + "," + Math.round(this.b) + "," + this.a + ")";
  };

  Color.prototype.copy = function() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  };

  Color.prototype.eq = function(aColor) {
    return aColor && this.r === aColor.r && this.g === aColor.g && this.b === aColor.b;
  };

  Color.prototype.hsv = function() {
    var bb, d, gg, h, max, min, rr, s, v;
    rr = this.r / 255;
    gg = this.g / 255;
    bb = this.b / 255;
    max = Math.max(rr, gg, bb);
    min = Math.min(rr, gg, bb);
    h = max;
    s = max;
    v = max;
    d = max - min;
    s = (max === 0 ? 0 : d / max);
    if (max === min) {
      h = 0;
    } else {
      switch (max) {
        case rr:
          h = (gg - bb) / d + (gg < bb ? 6 : 0);
          break;
        case gg:
          h = (bb - rr) / d + 2;
          break;
        case bb:
          h = (rr - gg) / d + 4;
      }
      h /= 6;
    }
    return [h, s, v];
  };

  Color.prototype.set_hsv = function(h, s, v) {
    var f, i, p, q, t;
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
      case 0:
        this.r = v;
        this.g = t;
        this.b = p;
        break;
      case 1:
        this.r = q;
        this.g = v;
        this.b = p;
        break;
      case 2:
        this.r = p;
        this.g = v;
        this.b = t;
        break;
      case 3:
        this.r = p;
        this.g = q;
        this.b = v;
        break;
      case 4:
        this.r = t;
        this.g = p;
        this.b = v;
        break;
      case 5:
        this.r = v;
        this.g = p;
        this.b = q;
    }
    this.r *= 255;
    this.g *= 255;
    return this.b *= 255;
  };

  Color.prototype.mixed = function(proportion, otherColor) {
    var frac1, frac2;
    frac1 = Math.min(Math.max(proportion, 0), 1);
    frac2 = 1 - frac1;
    return new this.constructor(this.r * frac1 + otherColor.r * frac2, this.g * frac1 + otherColor.g * frac2, this.b * frac1 + otherColor.b * frac2);
  };

  Color.prototype.darker = function(percent) {
    var fract;
    fract = 0.8333;
    if (percent) {
      fract = (100 - percent) / 100;
    }
    return this.mixed(fract, new this.constructor(0, 0, 0));
  };

  Color.prototype.lighter = function(percent) {
    var fract;
    fract = 0.8333;
    if (percent) {
      fract = (100 - percent) / 100;
    }
    return this.mixed(fract, new this.constructor(255, 255, 255));
  };

  Color.prototype.dansDarker = function() {
    var hsv, result, vv;
    hsv = this.hsv();
    result = new this.constructor();
    vv = Math.max(hsv[2] - 0.16, 0);
    result.set_hsv(hsv[0], hsv[1], vv);
    return result;
  };

  Color.transparent = function() {
    return new this.constructor(0, 0, 0, 0);
  };

  Color.coffeeScriptSourceOfThisClass = '# Colors //////////////////////////////////////////////////////////////\n\nclass Color\n\n  # This "colourNamesValues" data\n  # structure is only used to create\n  # all the CSS color literals, like\n  #   Color.red\n  # This creation of constants\n  # is done in WoldMorph, since\n  # it\'s the first morph to be\n  # created.\n  # In pure theory we\'d like these\n  # constants to be created by a piece\n  # of code at the end of the file, just\n  # after the class definition,\n  # unfortunately we can\'t add it there\n  # as the source in this file is\n  # appended as a further static variable\n  # in this class, so we can\'t\n  # "close" the class by adding code\n  # that it\'s supposed to be outside its\n  # definition.\n  @colourNamesValues =\n    aliceblue:            [0xf0,0xf8,0xff]\n    antiquewhite:         [0xfa,0xeb,0xd7]\n    aqua:                 [0x00,0xff,0xff]\n    aquamarine:           [0x7f,0xff,0xd4]\n    azure:                [0xf0,0xff,0xff]\n    beige:                [0xf5,0xf5,0xdc]\n    bisque:               [0xff,0xe4,0xc4]\n    black:                [0x00,0x00,0x00]\n    blanchedalmond:       [0xff,0xeb,0xcd]\n    blue:                 [0x00,0x00,0xff]\n    blueviolet:           [0x8a,0x2b,0xe2]\n    brown:                [0xa5,0x2a,0x2a]\n    burlywood:            [0xde,0xb8,0x87]\n    cadetblue:            [0x5f,0x9e,0xa0]\n    chartreuse:           [0x7f,0xff,0x00]\n    chocolate:            [0xd2,0x69,0x1e]\n    coral:                [0xff,0x7f,0x50]\n    cornflowerblue:       [0x64,0x95,0xed]\n    cornsilk:             [0xff,0xf8,0xdc]\n    crimson:              [0xdc,0x14,0x3c]\n    cyan:                 [0x00,0xff,0xff]\n    darkblue:             [0x00,0x00,0x8b]\n    darkcyan:             [0x00,0x8b,0x8b]\n    darkgoldenrod:        [0xb8,0x86,0x0b]\n    darkgray:             [0xa9,0xa9,0xa9]\n    darkgrey:             [0xa9,0xa9,0xa9]\n    darkgreen:            [0x00,0x64,0x00]\n    darkkhaki:            [0xbd,0xb7,0x6b]\n    darkmagenta:          [0x8b,0x00,0x8b]\n    darkolivegreen:       [0x55,0x6b,0x2f]\n    darkorange:           [0xff,0x8c,0x00]\n    darkorchid:           [0x99,0x32,0xcc]\n    darkred:              [0x8b,0x00,0x00]\n    darksalmon:           [0xe9,0x96,0x7a]\n    darkseagreen:         [0x8f,0xbc,0x8f]\n    darkslateblue:        [0x48,0x3d,0x8b]\n    darkslategray:        [0x2f,0x4f,0x4f]\n    darkslategrey:        [0x2f,0x4f,0x4f]\n    darkturquoise:        [0x00,0xce,0xd1]\n    darkviolet:           [0x94,0x00,0xd3]\n    deeppink:             [0xff,0x14,0x93]\n    deepskyblue:          [0x00,0xbf,0xff]\n    dimgray:              [0x69,0x69,0x69]\n    dimgrey:              [0x69,0x69,0x69]\n    dodgerblue:           [0x1e,0x90,0xff]\n    firebrick:            [0xb2,0x22,0x22]\n    floralwhite:          [0xff,0xfa,0xf0]\n    forestgreen:          [0x22,0x8b,0x22]\n    fuchsia:              [0xff,0x00,0xff]\n    gainsboro:            [0xdc,0xdc,0xdc]\n    ghostwhite:           [0xf8,0xf8,0xff]\n    gold:                 [0xff,0xd7,0x00]\n    goldenrod:            [0xda,0xa5,0x20]\n    gray:                 [0x80,0x80,0x80]\n    grey:                 [0x80,0x80,0x80]\n    green:                [0x00,0x80,0x00]\n    greenyellow:          [0xad,0xff,0x2f]\n    honeydew:             [0xf0,0xff,0xf0]\n    hotpink:              [0xff,0x69,0xb4]\n    indianred:            [0xcd,0x5c,0x5c]\n    indigo:               [0x4b,0x00,0x82]\n    ivory:                [0xff,0xff,0xf0]\n    khaki:                [0xf0,0xe6,0x8c]\n    lavender:             [0xe6,0xe6,0xfa]\n    lavenderblush:        [0xff,0xf0,0xf5]\n    lawngreen:            [0x7c,0xfc,0x00]\n    lemonchiffon:         [0xff,0xfa,0xcd]\n    lightblue:            [0xad,0xd8,0xe6]\n    lightcoral:           [0xf0,0x80,0x80]\n    lightcyan:            [0xe0,0xff,0xff]\n    lightgoldenrodyellow: [0xfa,0xfa,0xd2]\n    lightgrey:            [0xd3,0xd3,0xd3]\n    lightgray:            [0xd3,0xd3,0xd3]\n    lightgreen:           [0x90,0xee,0x90]\n    lightpink:            [0xff,0xb6,0xc1]\n    lightsalmon:          [0xff,0xa0,0x7a]\n    lightseagreen:        [0x20,0xb2,0xaa]\n    lightskyblue:         [0x87,0xce,0xfa]\n    lightslategray:       [0x77,0x88,0x99]\n    lightslategrey:       [0x77,0x88,0x99]\n    lightsteelblue:       [0xb0,0xc4,0xde]\n    lightyellow:          [0xff,0xff,0xe0]\n    lime:                 [0x00,0xff,0x00]\n    limegreen:            [0x32,0xcd,0x32]\n    linen:                [0xfa,0xf0,0xe6]\n    mintcream:            [0xf5,0xff,0xfa]\n    mistyrose:            [0xff,0xe4,0xe1]\n    moccasin:             [0xff,0xe4,0xb5]\n    navajowhite:          [0xff,0xde,0xad]\n    navy:                 [0x00,0x00,0x80]\n    oldlace:              [0xfd,0xf5,0xe6]\n    olive:                [0x80,0x80,0x00]\n    olivedrab:            [0x6b,0x8e,0x23]\n    orange:               [0xff,0xa5,0x00]\n    orangered:            [0xff,0x45,0x00]\n    orchid:               [0xda,0x70,0xd6]\n    palegoldenrod:        [0xee,0xe8,0xaa]\n    palegreen:            [0x98,0xfb,0x98]\n    paleturquoise:        [0xaf,0xee,0xee]\n    palevioletred:        [0xd8,0x70,0x93]\n    papayawhip:           [0xff,0xef,0xd5]\n    peachpuff:            [0xff,0xda,0xb9]\n    peru:                 [0xcd,0x85,0x3f]\n    pink:                 [0xff,0xc0,0xcb]\n    plum:                 [0xdd,0xa0,0xdd]\n    powderblue:           [0xb0,0xe0,0xe6]\n    purple:               [0x80,0x00,0x80]\n    red:                  [0xff,0x00,0x00]\n    rosybrown:            [0xbc,0x8f,0x8f]\n    royalblue:            [0x41,0x69,0xe1]\n    saddlebrown:          [0x8b,0x45,0x13]\n    salmon:               [0xfa,0x80,0x72]\n    sandybrown:           [0xf4,0xa4,0x60]\n    seagreen:             [0x2e,0x8b,0x57]\n    seashell:             [0xff,0xf5,0xee]\n    sienna:               [0xa0,0x52,0x2d]\n    silver:               [0xc0,0xc0,0xc0]\n    skyblue:              [0x87,0xce,0xeb]\n    slateblue:            [0x6a,0x5a,0xcd]\n    slategray:            [0x70,0x80,0x90]\n    slategrey:            [0x70,0x80,0x90]\n    snow:                 [0xff,0xfa,0xfa]\n    springgreen:          [0x00,0xff,0x7f]\n    steelblue:            [0x46,0x82,0xb4]\n    tan:                  [0xd2,0xb4,0x8c]\n    teal:                 [0x00,0x80,0x80]\n    thistle:              [0xd8,0xbf,0xd8]\n    tomato:               [0xff,0x63,0x47]\n    turquoise:            [0x40,0xe0,0xd0]\n    violet:               [0xee,0x82,0xee]\n    wheat:                [0xf5,0xde,0xb3]\n    white:                [0xff,0xff,0xff]\n    whitesmoke:           [0xf5,0xf5,0xf5]\n    yellow:               [0xff,0xff,0x00]\n    yellowgreen:          [0x9a,0xcd,0x32]\n\n  a: null\n  r: null\n  g: null\n  b: null\n\n  constructor: (@r = 0, @g = 0, @b = 0, a) ->\n    # all values are optional, just (r, g, b) is fine\n    @a = a or ((if (a is 0) then 0 else 1))\n  \n  # Color string representation: e.g. \'rgba(255,165,0,1)\'\n  toString: ->\n    "rgba(" + Math.round(@r) + "," + Math.round(@g) + "," + Math.round(@b) + "," + @a + ")"\n  \n  # Color copying:\n  copy: ->\n    new @constructor(@r, @g, @b, @a)\n  \n  # Color comparison:\n  eq: (aColor) ->\n    # ==\n    aColor and @r is aColor.r and @g is aColor.g and @b is aColor.b\n  \n  \n  # Color conversion (hsv):\n  hsv: ->\n    # ignore alpha\n    rr = @r / 255\n    gg = @g / 255\n    bb = @b / 255\n    max = Math.max(rr, gg, bb)\n    min = Math.min(rr, gg, bb)\n    h = max\n    s = max\n    v = max\n    d = max - min\n    s = (if max is 0 then 0 else d / max)\n    if max is min\n      h = 0\n    else\n      switch max\n        when rr\n          h = (gg - bb) / d + ((if gg < bb then 6 else 0))\n        when gg\n          h = (bb - rr) / d + 2\n        when bb\n          h = (rr - gg) / d + 4\n      h /= 6\n    [h, s, v]\n  \n  set_hsv: (h, s, v) ->\n    # ignore alpha\n    # h, s and v are to be within [0, 1]\n    i = Math.floor(h * 6)\n    f = h * 6 - i\n    p = v * (1 - s)\n    q = v * (1 - f * s)\n    t = v * (1 - (1 - f) * s)\n    switch i % 6\n      when 0\n        @r = v\n        @g = t\n        @b = p\n      when 1\n        @r = q\n        @g = v\n        @b = p\n      when 2\n        @r = p\n        @g = v\n        @b = t\n      when 3\n        @r = p\n        @g = q\n        @b = v\n      when 4\n        @r = t\n        @g = p\n        @b = v\n      when 5\n        @r = v\n        @g = p\n        @b = q\n    @r *= 255\n    @g *= 255\n    @b *= 255\n  \n  \n  # Color mixing:\n  mixed: (proportion, otherColor) ->\n    # answer a copy of this color mixed with another color, ignore alpha\n    frac1 = Math.min(Math.max(proportion, 0), 1)\n    frac2 = 1 - frac1\n    new @constructor(\n      @r * frac1 + otherColor.r * frac2,\n      @g * frac1 + otherColor.g * frac2,\n      @b * frac1 + otherColor.b * frac2)\n  \n  darker: (percent) ->\n    # return an rgb-interpolated darker copy of me, ignore alpha\n    fract = 0.8333\n    fract = (100 - percent) / 100  if percent\n    @mixed fract, new @constructor(0, 0, 0)\n  \n  lighter: (percent) ->\n    # return an rgb-interpolated lighter copy of me, ignore alpha\n    fract = 0.8333\n    fract = (100 - percent) / 100  if percent\n    @mixed fract, new @constructor(255, 255, 255)\n  \n  dansDarker: ->\n    # return an hsv-interpolated darker copy of me, ignore alpha\n    hsv = @hsv()\n    result = new @constructor()\n    vv = Math.max(hsv[2] - 0.16, 0)\n    result.set_hsv hsv[0], hsv[1], vv\n    result\n\n  @transparent: ->\n    return new @constructor(0,0,0,0)\n';

  return Color;

})();

ControllerMixin = {
  onceAddedClassProperties: function() {
    return this.addInstanceProperties({
      setTarget: function() {
        var choices, menu;
        if (world.activeMenu) {
          world.activeMenu = world.activeMenu.destroy();
        }
        choices = world.plausibleTargetAndDestinationMorphs(this);
        if (choices.length > 0) {
          menu = new MenuMorph(this, "choose target:");
          choices.forEach((function(_this) {
            return function(each) {
              return menu.addItem(each.toString().slice(0, 50), function() {
                return _this.setTargetSetter(each);
              });
            };
          })(this));
        } else {
          menu = new MenuMorph(this, "no targets available");
        }
        return menu.popUpAtHand();
      }
    });
  }
};

ColorPaletteMorph = (function(_super) {
  __extends(ColorPaletteMorph, _super);

  ColorPaletteMorph.augmentWith(ControllerMixin);

  ColorPaletteMorph.prototype.target = null;

  ColorPaletteMorph.prototype.targetSetter = "color";

  ColorPaletteMorph.prototype.choice = null;

  function ColorPaletteMorph(target, sizePoint) {
    this.target = target != null ? target : null;
    ColorPaletteMorph.__super__.constructor.call(this);
    this.silentSetExtent(sizePoint || new Point(80, 50));
  }

  ColorPaletteMorph.prototype.updateRendering = function() {
    var context, ext, h, l, x, y, _i, _ref, _results;
    ext = this.extent();
    this.image = newCanvas(this.extent().scaleBy(pixelRatio));
    context = this.image.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    this.choice = new Color();
    _results = [];
    for (x = _i = 0, _ref = ext.x; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
      h = 360 * x / ext.x;
      y = 0;
      _results.push((function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (y = _j = 0, _ref1 = ext.y; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          l = 100 - (y / ext.y * 100);
          context.fillStyle = "hsl(" + h + ",100%," + l + "%)";
          _results1.push(context.fillRect(x, y, 1, 1));
        }
        return _results1;
      })());
    }
    return _results;
  };

  ColorPaletteMorph.prototype.mouseMove = function(pos) {
    this.choice = this.getPixelColor(pos);
    return this.updateTarget();
  };

  ColorPaletteMorph.prototype.mouseDownLeft = function(pos) {
    this.choice = this.getPixelColor(pos);
    return this.updateTarget();
  };

  ColorPaletteMorph.prototype.updateTarget = function() {
    if (this.target instanceof Morph && (this.choice != null)) {
      if (this.target[this.targetSetter] instanceof Function) {
        return this.target[this.targetSetter](this.choice);
      } else {
        this.target[this.targetSetter] = this.choice;
        this.target.updateRendering();
        return this.target.changed();
      }
    }
  };

  ColorPaletteMorph.prototype.developersMenu = function() {
    var menu;
    menu = ColorPaletteMorph.__super__.developersMenu.call(this);
    menu.addLine();
    menu.addItem("set target", (function() {
      return this.setTarget();
    }), "choose another morph\nwhose color property\n will be" + " controlled by this one");
    return menu;
  };

  ColorPaletteMorph.prototype.setTargetSetter = function(theTarget) {
    var choices, menu;
    choices = theTarget.colorSetters();
    menu = new MenuMorph(this, "choose target property:");
    choices.forEach((function(_this) {
      return function(each) {
        return menu.addItem(each, function() {
          _this.target = theTarget;
          return _this.targetSetter = each;
        });
      };
    })(this));
    if (choices.length === 0) {
      menu = new MenuMorph(this, "no target properties available");
    }
    return menu.popUpAtHand();
  };

  ColorPaletteMorph.coffeeScriptSourceOfThisClass = '# ColorPaletteMorph ///////////////////////////////////////////////////\n# REQUIRES ControllerMixin\n\nclass ColorPaletteMorph extends Morph\n  @augmentWith ControllerMixin\n\n  target: null\n  targetSetter: "color"\n  choice: null\n\n  constructor: (@target = null, sizePoint) ->\n    super()\n    @silentSetExtent sizePoint or new Point(80, 50)\n  \n  updateRendering: ->\n    ext = @extent()\n    @image = newCanvas(@extent().scaleBy pixelRatio)\n    context = @image.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    @choice = new Color()\n    for x in [0..ext.x]\n      h = 360 * x / ext.x\n      y = 0\n      for y in [0..ext.y]\n        l = 100 - (y / ext.y * 100)\n        # see link below for alternatives on how to set a single\n        # pixel color.\n        # You should really be using putImageData of the whole buffer\n        # here anyways. But this is clearer.\n        # http://stackoverflow.com/questions/4899799/whats-the-best-way-to-set-a-single-pixel-in-an-html5-canvas\n        context.fillStyle = "hsl(" + h + ",100%," + l + "%)"\n        context.fillRect x, y, 1, 1\n  \n  mouseMove: (pos) ->\n    @choice = @getPixelColor(pos)\n    @updateTarget()\n  \n  mouseDownLeft: (pos) ->\n    @choice = @getPixelColor(pos)\n    @updateTarget()\n  \n  updateTarget: ->\n    if @target instanceof Morph and @choice?\n      if @target[@targetSetter] instanceof Function\n        @target[@targetSetter] @choice\n      else\n        @target[@targetSetter] = @choice\n        @target.updateRendering()\n        @target.changed()\n  \n    \n  # ColorPaletteMorph menu:\n  developersMenu: ->\n    menu = super()\n    menu.addLine()\n    menu.addItem "set target", (->@setTarget()), "choose another morph\nwhose color property\n will be" + " controlled by this one"\n    menu\n  \n  # setTarget: -> taken form the ControllerMixin\n  \n  setTargetSetter: (theTarget) ->\n    choices = theTarget.colorSetters()\n    menu = new MenuMorph(@, "choose target property:")\n    choices.forEach (each) =>\n      menu.addItem each, =>\n        @target = theTarget\n        @targetSetter = each\n    if choices.length == 0\n      menu = new MenuMorph(@, "no target properties available")\n    menu.popUpAtHand()';

  return ColorPaletteMorph;

})(Morph);

ColorPickerMorph = (function(_super) {
  __extends(ColorPickerMorph, _super);

  ColorPickerMorph.prototype.choice = null;

  function ColorPickerMorph(defaultColor) {
    this.choice = defaultColor || new Color(255, 255, 255);
    ColorPickerMorph.__super__.constructor.call(this);
    this.color = new Color(255, 255, 255);
    this.silentSetExtent(new Point(80, 80));
    this.buildSubmorphs();
  }

  ColorPickerMorph.prototype.buildSubmorphs = function() {
    var cpal, gpal, x, y;
    this.destroyAll();
    this.children = [];
    this.feedback = new RectangleMorph(new Point(20, 20), this.choice);
    cpal = new ColorPaletteMorph(this.feedback, new Point(this.width(), 50));
    gpal = new GrayPaletteMorph(this.feedback, new Point(this.width(), 5));
    cpal.setPosition(this.bounds.origin);
    this.add(cpal);
    gpal.setPosition(cpal.bottomLeft());
    this.add(gpal);
    x = gpal.left() + Math.floor((gpal.width() - this.feedback.width()) / 2);
    y = gpal.bottom() + Math.floor((this.bottom() - gpal.bottom() - this.feedback.height()) / 2);
    this.feedback.setPosition(new Point(x, y));
    return this.add(this.feedback);
  };

  ColorPickerMorph.prototype.getColor = function() {
    return this.feedback.color;
  };

  ColorPickerMorph.prototype.rootForGrab = function() {
    return this;
  };

  ColorPickerMorph.coffeeScriptSourceOfThisClass = '# ColorPickerMorph ///////////////////////////////////////////////////\n\nclass ColorPickerMorph extends Morph\n\n  choice: null\n\n  constructor: (defaultColor) ->\n    @choice = defaultColor or new Color(255, 255, 255)\n    super()\n    @color = new Color(255, 255, 255)\n    @silentSetExtent new Point(80, 80)\n    @buildSubmorphs()\n  \n  buildSubmorphs: ->\n    @destroyAll()\n    @children = []\n    @feedback = new RectangleMorph(new Point(20, 20), @choice)\n    cpal = new ColorPaletteMorph(@feedback, new Point(@width(), 50))\n    gpal = new GrayPaletteMorph(@feedback, new Point(@width(), 5))\n    cpal.setPosition @bounds.origin\n    @add cpal\n    gpal.setPosition cpal.bottomLeft()\n    @add gpal\n    x = (gpal.left() + Math.floor((gpal.width() - @feedback.width()) / 2))\n    y = gpal.bottom() + Math.floor((@bottom() - gpal.bottom() - @feedback.height()) / 2)\n    @feedback.setPosition new Point(x, y)\n    @add @feedback\n  \n  getColor: ->\n    @feedback.color\n  \n  rootForGrab: ->\n    @';

  return ColorPickerMorph;

})(Morph);

ContainerMixin = {
  onceAddedClassProperties: function() {
    return this.addInstanceProperties({
      setTarget: function() {
        var choices, menu;
        if (world.activeMenu) {
          world.activeMenu = world.activeMenu.destroy();
        }
        choices = world.plausibleTargetAndDestinationMorphs(this);
        if (choices.length > 0) {
          menu = new MenuMorph(this, "choose target:");
          choices.forEach((function(_this) {
            return function(each) {
              return menu.addItem(each.toString().slice(0, 50), function() {
                return _this.setTargetSetter(each);
              });
            };
          })(this));
        } else {
          menu = new MenuMorph(this, "no targets available");
        }
        return menu.popUpAtHand();
      }
    });
  },
  submorphBounds: function() {
    var result;
    result = null;
    if (this.children.length) {
      result = this.children[0].bounds;
      this.children.forEach(function(child) {
        return result = result.merge(child.boundsIncludingChildren());
      });
    }
    return result;
  },
  adjustBounds: function() {
    var newBounds;
    newBounds = this.submorphBounds();
    if (newBounds) {
      if (this.padding != null) {
        newBounds = newBounds.expandBy(this.padding);
      }
    } else {
      newBounds = this.bounds.copy();
    }
    if (!this.bounds.eq(newBounds)) {
      this.bounds = newBounds;
      this.changed();
      return this.updateRendering();
    }
  }
};

FrameMorph = (function(_super) {
  __extends(FrameMorph, _super);

  FrameMorph.prototype.scrollFrame = null;

  FrameMorph.prototype.extraPadding = 0;

  function FrameMorph(scrollFrame) {
    this.scrollFrame = scrollFrame != null ? scrollFrame : null;
    FrameMorph.__super__.constructor.call(this);
    this.color = new Color(255, 250, 245);
    this.acceptsDrops = true;
    if (this.scrollFrame) {
      this.isDraggable = false;
      this.noticesTransparentClick = false;
    }
  }

  FrameMorph.prototype.setColor = function(aColor) {
    if (this.scrollFrame) {
      this.scrollFrame.color = aColor;
    }
    return FrameMorph.__super__.setColor.call(this, aColor);
  };

  FrameMorph.prototype.setAlphaScaled = function(alpha) {
    if (this.scrollFrame) {
      this.scrollFrame.alpha = this.calculateAlphaScaled(alpha);
    }
    return FrameMorph.__super__.setAlphaScaled.call(this, alpha);
  };

  FrameMorph.prototype.plausibleTargetAndDestinationMorphs = function(theMorph) {
    var result;
    result = [];
    if (!this.isMinimised && this.isVisible && !theMorph.containedInParentsOf(this) && this.bounds.intersects(theMorph.bounds)) {
      result = [this];
    }
    if (this.bounds.intersects(theMorph.bounds)) {
      this.children.forEach(function(child) {
        return result = result.concat(child.plausibleTargetAndDestinationMorphs(theMorph));
      });
    }
    return result;
  };

  FrameMorph.prototype.boundsIncludingChildren = function() {
    var shadow;
    shadow = this.getShadow();
    if (shadow != null) {
      return this.bounds.merge(shadow.bounds);
    }
    return this.bounds;
  };

  FrameMorph.prototype.recursivelyBlit = function(aCanvas, clippingRectangle) {
    var dirtyPartOfFrame;
    if (clippingRectangle == null) {
      clippingRectangle = this.bounds;
    }
    if (!(!this.isMinimised && this.isVisible)) {
      return null;
    }
    dirtyPartOfFrame = this.bounds.intersect(clippingRectangle);
    if (dirtyPartOfFrame.isEmpty()) {
      return null;
    }
    this.blit(aCanvas, dirtyPartOfFrame);
    return this.children.forEach((function(_this) {
      return function(child) {
        if (child instanceof ShadowMorph) {
          return child.recursivelyBlit(aCanvas, clippingRectangle);
        } else {
          return child.recursivelyBlit(aCanvas, dirtyPartOfFrame);
        }
      };
    })(this));
  };

  FrameMorph.prototype.moveBy = function(delta) {
    this.changed();
    this.bounds = this.bounds.translateBy(delta);
    this.children.forEach(function(child) {
      return child.silentMoveBy(delta);
    });
    return this.changed();
  };

  FrameMorph.prototype.submorphBounds = function() {
    var result;
    result = null;
    if (this.children.length) {
      result = this.children[0].bounds;
      this.children.forEach(function(child) {
        return result = result.merge(child.boundsIncludingChildren());
      });
    }
    return result;
  };

  FrameMorph.prototype.keepInScrollFrame = function() {
    if (this.scrollFrame == null) {
      return null;
    }
    if (this.left() > this.scrollFrame.left()) {
      this.moveBy(new Point(this.scrollFrame.left() - this.left(), 0));
    }
    if (this.right() < this.scrollFrame.right()) {
      this.moveBy(new Point(this.scrollFrame.right() - this.right(), 0));
    }
    if (this.top() > this.scrollFrame.top()) {
      this.moveBy(new Point(0, this.scrollFrame.top() - this.top()));
    }
    if (this.bottom() < this.scrollFrame.bottom()) {
      return this.moveBy(0, new Point(this.scrollFrame.bottom() - this.bottom(), 0));
    }
  };

  FrameMorph.prototype.adjustBounds = function() {
    var newBounds, subBounds;
    if (this.scrollFrame == null) {
      return null;
    }
    if (this.scrollFrame.isTextLineWrapping) {
      this.children.forEach((function(_this) {
        return function(morph) {
          var totalPadding;
          if (morph instanceof TextMorph) {
            totalPadding = 2 * (_this.scrollFrame.extraPadding + _this.scrollFrame.padding);
            morph.setWidth(_this.width() - totalPadding);
            morph.maxWidth = _this.width() - totalPadding;
            return _this.setHeight(Math.max(morph.height(), _this.scrollFrame.height() - totalPadding));
          }
        };
      })(this));
    }
    subBounds = this.submorphBounds();
    if (subBounds) {
      newBounds = subBounds.expandBy(this.scrollFrame.padding + this.scrollFrame.extraPadding).growBy(this.scrollFrame.growth).merge(this.scrollFrame.bounds);
    } else {
      newBounds = this.scrollFrame.bounds.copy();
    }
    if (!this.bounds.eq(newBounds)) {
      this.bounds = newBounds;
      this.updateRendering();
      this.keepInScrollFrame();
    }
    return this.scrollFrame.adjustScrollBars();
  };

  FrameMorph.prototype.reactToDropOf = function() {
    return this.adjustBounds();
  };

  FrameMorph.prototype.reactToGrabOf = function() {
    return this.adjustBounds();
  };

  FrameMorph.prototype.developersMenu = function() {
    var menu;
    menu = FrameMorph.__super__.developersMenu.call(this);
    if (this.children.length) {
      menu.addLine();
      menu.addItem("move all inside", (function() {
        return this.keepAllSubmorphsWithin();
      }), "keep all submorphs\nwithin and visible");
    }
    return menu;
  };

  FrameMorph.prototype.keepAllSubmorphsWithin = function() {
    return this.children.forEach((function(_this) {
      return function(m) {
        return m.keepWithin(_this);
      };
    })(this));
  };

  FrameMorph.coffeeScriptSourceOfThisClass = '#| FrameMorph //////////////////////////////////////////////////////////\n#| \n#| I clip my submorphs at my bounds. Which potentially saves a lot of redrawing\n#| \n#| and event handling. \n#| \n#| It\'s a good idea to use me whenever it\'s clear that there is a  \n#| \n#| "container"/"contained" scenario going on.\n\nclass FrameMorph extends Morph\n\n  scrollFrame: null\n  extraPadding: 0\n\n  # if this frame belongs to a scrollFrame, then\n  # the @scrollFrame points to it\n  constructor: (@scrollFrame = null) ->\n    super()\n    @color = new Color(255, 250, 245)\n    @acceptsDrops = true\n    if @scrollFrame\n      @isDraggable = false\n      @noticesTransparentClick = false\n\n  setColor: (aColor) ->\n    # keep in synch the value of the container scrollFrame\n    # if there is one. Note that the container scrollFrame\n    # is actually not painted.\n    if @scrollFrame\n      @scrollFrame.color = aColor\n    super(aColor)\n\n  setAlphaScaled: (alpha) ->\n    # keep in synch the value of the container scrollFrame\n    # if there is one. Note that the container scrollFrame\n    # is actually not painted.\n    if @scrollFrame\n      @scrollFrame.alpha = @calculateAlphaScaled(alpha)\n    super(alpha)\n\n  # used for example:\n  # - to determine which morphs you can attach a morph to\n  # - for a SliderMorph\'s "set target" so you can change properties of another Morph\n  # - by the HandleMorph when you attach it to some other morph\n  # Note that this method has a slightly different\n  # version in Morph (because it doesn\'t clip)\n  plausibleTargetAndDestinationMorphs: (theMorph) ->\n    # find if I intersect theMorph,\n    # then check my children recursively\n    # exclude me if I\'m a child of theMorph\n    # (cause it\'s usually odd to attach a Morph\n    # to one of its submorphs or for it to\n    # control the properties of one of its submorphs)\n    result = []\n    if !@isMinimised and\n        @isVisible and\n        !theMorph.containedInParentsOf(@) and\n        @bounds.intersects(theMorph.bounds)\n      result = [@]\n\n    # Since the FrameMorph clips its children\n    # at its boundary, hence we need\n    # to check that we don\'t consider overlaps with\n    # morphs contained in this frame that are clipped and\n    # hence *actually* not overlapping with theMorph.\n    # So continue checking the children only if the\n    # frame itself actually overlaps.\n    if @bounds.intersects(theMorph.bounds)\n      @children.forEach (child) ->\n        result = result.concat(child.plausibleTargetAndDestinationMorphs(theMorph))\n\n    return result\n  \n  # frames clip at their boundaries\n  # so there is no need to do a deep\n  # traversal to find the bounds.\n  boundsIncludingChildren: ->\n    shadow = @getShadow()\n    if shadow?\n      return @bounds.merge(shadow.bounds)\n    @bounds\n  \n  recursivelyBlit: (aCanvas, clippingRectangle = @bounds) ->\n    return null  unless (!@isMinimised and @isVisible)\n\n    # a FrameMorph has the special property that all of its children\n    # are actually inside its boundary.\n    # This allows\n    # us to avoid the further traversal of potentially\n    # many many morphs if we see that the rectangle we\n    # want to blit is outside its frame.\n    # If the rectangle we want to blit is inside the frame\n    # then we do have to continue traversing all the\n    # children of the Frame.\n\n    # This is why as well it\'s good to use FrameMorphs whenever\n    # it\'s clear that there is a "container" case. Think\n    # for example that you could stick a small\n    # RectangleMorph (not a Frame) on the desktop and then\n    # attach a thousand\n    # CircleBoxMorphs on it.\n    # Say that the circles are all inside the rectangle,\n    # apart from four that are at the corners of the world.\n    # that\'s a nightmare scenegraph\n    # to *completely* traverse for *any* broken rectangle\n    # anywhere on the screen.\n    # The traversal is complete because a) Morphic doesn\'t\n    # assume that the rectangle clips its children and\n    # b) the bounding rectangle (which currently is not\n    # efficiently calculated anyways) is the whole screen.\n    # So the children could be anywhere and need to be all\n    # checked for damaged areas to repaint.\n    # If the RectangleMorph is made into a frame, one can\n    # avoid the traversal for any broken rectangle not\n    # overlapping it.\n\n    # Also note that in theory you could stop recursion on any\n    # FrameMorph completely covered by a large opaque morph\n    # (or on any Morph which boundsIncludingChildren are completely\n    # covered, for that matter). You could\n    # keep for example a list of the top n biggest opaque morphs\n    # (say, frames and rectangles)\n    # and check that case while you traverse the list.\n    # (see https://github.com/davidedc/Zombie-Kernel/issues/149 )\n    \n    # the part to be redrawn could be outside the frame entirely,\n    # in which case we can stop going down the morphs inside the frame\n    # since the whole point of the frame is to clip everything to a specific\n    # rectangle.\n    # So, check which part of the Frame should be redrawn:\n    dirtyPartOfFrame = @bounds.intersect(clippingRectangle)\n    \n    # if there is no dirty part in the frame then do nothing\n    return null if dirtyPartOfFrame.isEmpty()\n    \n    # this draws the background of the frame itself, which could\n    # contain an image or a pentrail\n    @blit aCanvas, dirtyPartOfFrame\n    \n    @children.forEach (child) =>\n      if child instanceof ShadowMorph\n        child.recursivelyBlit aCanvas, clippingRectangle\n      else\n        child.recursivelyBlit aCanvas, dirtyPartOfFrame\n  \n  \n  # FrameMorph scrolling optimization:\n  moveBy: (delta) ->\n    #console.log "moving all morphs in the frame"\n    @changed()\n    @bounds = @bounds.translateBy(delta)\n    @children.forEach (child) ->\n      child.silentMoveBy delta\n    @changed()\n  \n  \n  # FrameMorph scrolling support:\n  submorphBounds: ->\n    result = null\n    if @children.length\n      result = @children[0].bounds\n      @children.forEach (child) ->\n        result = result.merge(child.boundsIncludingChildren())\n    result\n  \n  # Should it be in the scrollframe rather than in Frame?\n  keepInScrollFrame: ->\n    if !@scrollFrame?\n      return null\n    if @left() > @scrollFrame.left()\n      @moveBy new Point(@scrollFrame.left() - @left(), 0)\n    if @right() < @scrollFrame.right()\n      @moveBy new Point(@scrollFrame.right() - @right(), 0)  \n    if @top() > @scrollFrame.top()\n      @moveBy new Point(0, @scrollFrame.top() - @top())  \n    if @bottom() < @scrollFrame.bottom()\n      @moveBy 0, new Point(@scrollFrame.bottom() - @bottom(), 0)\n  \n  adjustBounds: ->\n    if !@scrollFrame?\n      return null\n\n    # if FrameMorph is of type isTextLineWrapping\n    # it means that you don\'t want the TextMorph to\n    # extend indefinitely as you are typing. Rather,\n    # the width will be constrained and the text will\n    # wrap.\n    if @scrollFrame.isTextLineWrapping\n      @children.forEach (morph) =>\n        if morph instanceof TextMorph\n          totalPadding =  2*(@scrollFrame.extraPadding + @scrollFrame.padding)\n          # this re-layouts the text to fit the width.\n          # The new height of the TextMorph will then be used\n          # to redraw the vertical slider.\n          morph.setWidth @width() - totalPadding\n          morph.maxWidth = @width() - totalPadding\n          @setHeight Math.max(morph.height(), @scrollFrame.height() - totalPadding)\n\n    subBounds = @submorphBounds()\n    if subBounds\n      newBounds = subBounds.expandBy(@scrollFrame.padding + @scrollFrame.extraPadding).growBy(@scrollFrame.growth).merge(@scrollFrame.bounds)\n    else\n      newBounds = @scrollFrame.bounds.copy()\n    unless @bounds.eq(newBounds)\n      @bounds = newBounds\n      @updateRendering()\n      @keepInScrollFrame()\n    @scrollFrame.adjustScrollBars()\n  \n  \n  # FrameMorph dragging & dropping of contents:\n  reactToDropOf: ->\n    @adjustBounds()\n  \n  reactToGrabOf: ->\n    @adjustBounds()\n  \n    \n  # FrameMorph menus:\n  developersMenu: ->\n    menu = super()\n    if @children.length\n      menu.addLine()\n      menu.addItem "move all inside", (->@keepAllSubmorphsWithin()), "keep all submorphs\nwithin and visible"\n    menu\n  \n  keepAllSubmorphsWithin: ->\n    @children.forEach (m) =>\n      m.keepWithin @';

  return FrameMorph;

})(Morph);

GrayPaletteMorph = (function(_super) {
  __extends(GrayPaletteMorph, _super);

  function GrayPaletteMorph(target, sizePoint) {
    this.target = target != null ? target : null;
    GrayPaletteMorph.__super__.constructor.call(this, this.target, sizePoint || new Point(80, 10));
  }

  GrayPaletteMorph.prototype.updateRendering = function() {
    var context, ext, gradient;
    ext = this.extent();
    this.image = newCanvas(this.extent().scaleBy(pixelRatio));
    context = this.image.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    this.choice = new Color();
    gradient = context.createLinearGradient(0, 0, ext.x, ext.y);
    gradient.addColorStop(0, "black");
    gradient.addColorStop(1, "white");
    context.fillStyle = gradient;
    return context.fillRect(0, 0, ext.x, ext.y);
  };

  GrayPaletteMorph.coffeeScriptSourceOfThisClass = '# GrayPaletteMorph ///////////////////////////////////////////////////\n\nclass GrayPaletteMorph extends ColorPaletteMorph\n\n  constructor: (@target = null, sizePoint) ->\n    super @target, sizePoint or new Point(80, 10)\n  \n  updateRendering: ->\n    ext = @extent()\n    @image = newCanvas(@extent().scaleBy pixelRatio)\n    context = @image.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    @choice = new Color()\n    gradient = context.createLinearGradient(0, 0, ext.x, ext.y)\n    gradient.addColorStop 0, "black"\n    gradient.addColorStop 1, "white"\n    context.fillStyle = gradient\n    context.fillRect 0, 0, ext.x, ext.y';

  return GrayPaletteMorph;

})(ColorPaletteMorph);

HandMorph = (function(_super) {
  __extends(HandMorph, _super);

  HandMorph.prototype.world = null;

  HandMorph.prototype.mouseButton = null;

  HandMorph.prototype.mouseDownMorph = null;

  HandMorph.prototype.morphToGrab = null;

  HandMorph.prototype.grabOrigin = null;

  HandMorph.prototype.mouseOverList = null;

  HandMorph.prototype.temporaries = null;

  HandMorph.prototype.touchHoldTimeout = null;

  function HandMorph(world) {
    this.world = world;
    this.mouseOverList = [];
    this.temporaries = [];
    HandMorph.__super__.constructor.call(this);
    this.bounds = new Rectangle();
  }

  HandMorph.prototype.changed = function() {
    var b;
    if (this.world != null) {
      b = this.boundsIncludingChildren();
      if (!b.extent().eq(new Point())) {
        return this.world.broken.push(this.boundsIncludingChildren().spread());
      }
    }
  };

  HandMorph.prototype.topMorphUnderPointer = function() {
    var result;
    result = this.world.topMorphSuchThat((function(_this) {
      return function(m) {
        return m.visibleBounds().containsPoint(_this.bounds.origin) && !m.isMinimised && m.isVisible && (m.noticesTransparentClick || (!m.isTransparentAt(_this.bounds.origin))) && (!(m instanceof ShadowMorph));
      };
    })(this));
    if (result != null) {
      return result;
    } else {
      return this.world;
    }
  };

  HandMorph.prototype.menuAtPointer = function() {
    var result;
    result = this.world.topMorphSuchThat((function(_this) {
      return function(m) {
        return m.visibleBounds().containsPoint(_this.bounds.origin) && !m.isMinimised && m.isVisible && (m.noticesTransparentClick || (!m.isTransparentAt(_this.bounds.origin))) && (m instanceof MenuMorph);
      };
    })(this));
    return result;
  };

  HandMorph.prototype.leftOrRightClickOnMenuItemWithText = function(whichMouseButtonPressed, textLabelOfClickedItem, textLabelOccurrenceNumber) {
    var itemToTrigger;
    itemToTrigger = this.world.activeMenu.nthChildSuchThat(textLabelOccurrenceNumber, function(m) {
      return m.labelString === textLabelOfClickedItem;
    });
    this.destroyActiveMenuIfHandHasNotActionedIt(itemToTrigger);
    this.destroyActiveHandleIfHandHasNotActionedIt(itemToTrigger);
    this.stopEditingIfActionIsElsewhere(itemToTrigger);
    if (whichMouseButtonPressed === "left") {
      return itemToTrigger.mouseClickLeft();
    } else if (whichMouseButtonPressed === "right") {
      return this.openContextMenuAtPointer(itemToTrigger.children[0]);
    }
  };

  HandMorph.prototype.openContextMenuAtPointer = function(morphTheMenuIsAbout) {
    var contextMenu;
    this.destroyActiveMenuIfHandHasNotActionedIt(morphTheMenuIsAbout);
    this.destroyActiveHandleIfHandHasNotActionedIt(morphTheMenuIsAbout);
    this.stopEditingIfActionIsElsewhere(morphTheMenuIsAbout);
    contextMenu = morphTheMenuIsAbout.contextMenu();
    while ((!contextMenu) && morphTheMenuIsAbout.parent) {
      morphTheMenuIsAbout = morphTheMenuIsAbout.parent;
      contextMenu = morphTheMenuIsAbout.contextMenu();
    }
    if (contextMenu) {
      return contextMenu.popUpAtHand();
    }
  };

  HandMorph.prototype.allMorphsAtPointer = function() {
    return this.world.collectAllChildrenBottomToTopSuchThat((function(_this) {
      return function(m) {
        return !m.isMinimised && m.isVisible && m.visibleBounds().containsPoint(_this.bounds.origin);
      };
    })(this));
  };

  HandMorph.prototype.dropTargetFor = function(aMorph) {
    var target;
    target = this.topMorphUnderPointer();
    while (!target.wantsDropOf(aMorph)) {
      target = target.parent;
    }
    return target;
  };

  HandMorph.prototype.grab = function(aMorph) {
    var oldParent;
    oldParent = aMorph.parent;
    if (aMorph instanceof WorldMorph) {
      return null;
    }
    if (!this.children.length) {
      this.world.stopEditing();
      this.grabOrigin = aMorph.situation();
      if (aMorph.prepareToBeGrabbed) {
        aMorph.prepareToBeGrabbed(this);
      }
      this.add(aMorph);
      aMorph.addShadow();
      this.changed();
      if (oldParent && oldParent.reactToGrabOf) {
        return oldParent.reactToGrabOf(aMorph);
      }
    }
  };

  HandMorph.prototype.drop = function() {
    var morphToDrop, target;
    if (this.children.length) {
      morphToDrop = this.children[0];
      target = this.dropTargetFor(morphToDrop);
      this.changed();
      target.add(morphToDrop);
      morphToDrop.changed();
      morphToDrop.removeShadow();
      this.children = [];
      this.setExtent(new Point());
      if (morphToDrop.justDropped) {
        morphToDrop.justDropped(this);
      }
      if (target.reactToDropOf) {
        target.reactToDropOf(morphToDrop, this);
      }
      return this.dragOrigin = null;
    }
  };

  HandMorph.prototype.destroyActiveHandleIfHandHasNotActionedIt = function(actionedMorph) {
    if (this.world.activeHandle != null) {
      if (actionedMorph !== this.world.activeHandle) {
        return this.world.activeHandle = this.world.activeHandle.destroy();
      }
    }
  };

  HandMorph.prototype.destroyActiveMenuIfHandHasNotActionedIt = function(actionedMorph) {
    if (this.world.activeMenu != null) {
      if (!this.world.activeMenu.containedInParentsOf(actionedMorph)) {
        return this.world.activeMenu = this.world.activeMenu.destroy();
      } else {
        return clearInterval(this.touchHoldTimeout);
      }
    }
  };

  HandMorph.prototype.stopEditingIfActionIsElsewhere = function(actionedMorph) {
    if (this.world.caret != null) {
      if (actionedMorph !== this.world.caret.target) {
        if (this.world.activeMenu != null) {
          if (!this.world.activeMenu.containedInParentsOf(actionedMorph)) {
            return this.world.stopEditing();
          }
        } else {
          return this.world.stopEditing();
        }
      }
    }
  };

  HandMorph.prototype.processMouseDown = function(button, ctrlKey) {
    var actualClick, expectedClick, morph;
    this.destroyTemporaries();
    this.morphToGrab = null;
    if (this.children.length) {
      this.drop();
      return this.mouseButton = null;
    } else {
      morph = this.topMorphUnderPointer();
      this.destroyActiveMenuIfHandHasNotActionedIt(morph);
      this.destroyActiveHandleIfHandHasNotActionedIt(morph);
      this.stopEditingIfActionIsElsewhere(morph);
      if (!morph.mouseMove) {
        this.morphToGrab = morph.rootForGrab();
      }
      if (button === 2 || ctrlKey) {
        this.mouseButton = "right";
        actualClick = "mouseDownRight";
        expectedClick = "mouseClickRight";
      } else {
        this.mouseButton = "left";
        actualClick = "mouseDownLeft";
        expectedClick = "mouseClickLeft";
      }
      this.mouseDownMorph = morph;
      while (!this.mouseDownMorph[expectedClick]) {
        this.mouseDownMorph = this.mouseDownMorph.parent;
      }
      while (!morph[actualClick]) {
        morph = morph.parent;
      }
      return morph[actualClick](this.bounds.origin);
    }
  };

  HandMorph.prototype.processTouchStart = function(event) {
    event.preventDefault();
    WorldMorph.preferencesAndSettings.isTouchDevice = true;
    clearInterval(this.touchHoldTimeout);
    if (event.touches.length === 1) {
      this.touchHoldTimeout = setInterval((function(_this) {
        return function() {
          _this.processMouseDown(2);
          _this.processMouseUp(2);
          event.preventDefault();
          return clearInterval(_this.touchHoldTimeout);
        };
      })(this), 400);
      this.processMouseMove(event.touches[0].pageX, event.touches[0].pageY);
      return this.processMouseDown(0);
    }
  };

  HandMorph.prototype.processTouchMove = function(event) {
    var touch;
    event.preventDefault();
    if (event.touches.length === 1) {
      touch = event.touches[0];
      this.processMouseMove(touch.pageX, touch.pageY);
      return clearInterval(this.touchHoldTimeout);
    }
  };

  HandMorph.prototype.processTouchEnd = function(event) {
    WorldMorph.preferencesAndSettings.isTouchDevice = true;
    clearInterval(this.touchHoldTimeout);
    return this.processMouseUp(0);
  };

  HandMorph.prototype.processMouseUp = function(button) {
    var alreadyRecordedLeftOrRightClickOnMenuItem, expectedClick, labelString, menuItemMorph, morph, morphSpawningTheMenu, occurrenceNumber;
    morph = this.topMorphUnderPointer();
    alreadyRecordedLeftOrRightClickOnMenuItem = false;
    this.destroyTemporaries();
    if (this.children.length) {
      this.drop();
    } else {
      menuItemMorph = morph.parentThatIsA(MenuItemMorph);
      if (menuItemMorph) {
        if (this.world.activeMenu === menuItemMorph.parent) {
          labelString = menuItemMorph.labelString;
          morphSpawningTheMenu = menuItemMorph.parent.parent;
          occurrenceNumber = menuItemMorph.howManySiblingsBeforeMeSuchThat(function(m) {
            return m.labelString === labelString;
          });
          this.world.systemTestsRecorderAndPlayer.addCommandLeftOrRightClickOnMenuItem(this.mouseButton, labelString, occurrenceNumber + 1);
          alreadyRecordedLeftOrRightClickOnMenuItem = true;
        }
      }
      if (this.mouseButton === "left") {
        expectedClick = "mouseClickLeft";
      } else {
        expectedClick = "mouseClickRight";
        if (this.mouseButton) {
          if (!alreadyRecordedLeftOrRightClickOnMenuItem) {
            this.world.systemTestsRecorderAndPlayer.addOpenContextMenuCommand(morph.uniqueIDString());
          }
          this.openContextMenuAtPointer(morph);
        }
      }
      while (!morph[expectedClick]) {
        morph = morph.parent;
        if (morph == null) {
          break;
        }
      }
      if (morph != null) {
        if (morph === this.mouseDownMorph) {
          morph[expectedClick](this.bounds.origin);
        }
      }
    }
    return this.mouseButton = null;
  };

  HandMorph.prototype.processDoubleClick = function() {
    var morph;
    morph = this.topMorphUnderPointer();
    this.destroyTemporaries();
    if (this.children.length !== 0) {
      this.drop();
    } else {
      while (morph && !morph.mouseDoubleClick) {
        morph = morph.parent;
      }
      if (morph) {
        morph.mouseDoubleClick(this.bounds.origin);
      }
    }
    return this.mouseButton = null;
  };

  HandMorph.prototype.processMouseScroll = function(event) {
    var morph;
    morph = this.topMorphUnderPointer();
    while (morph && !morph.mouseScroll) {
      morph = morph.parent;
    }
    if (morph) {
      return morph.mouseScroll((event.detail / -3) || (Object.prototype.hasOwnProperty.call(event, 'wheelDeltaY') ? event.wheelDeltaY / 120 : event.wheelDelta / 120), event.wheelDeltaX / 120 || 0);
    }
  };

  HandMorph.prototype.processDrop = function(event) {
    var file, files, img, parseImgURL, readAudio, readBinary, readImage, readSVG, readText, src, target, targetDrop, txt, url, _i, _len, _results;
    files = (event instanceof FileList ? event : event.target.files || event.dataTransfer.files);
    url = (event.dataTransfer ? event.dataTransfer.getData("URL") : null);
    txt = (event.dataTransfer ? event.dataTransfer.getData("Text/HTML") : null);
    targetDrop = this.topMorphUnderPointer();
    img = new Image();
    readSVG = function(aFile) {
      var frd, pic, target;
      pic = new Image();
      frd = new FileReader();
      while (!target.droppedSVG) {
        target = target.parent;
      }
      pic.onload = function() {
        return target.droppedSVG(pic, aFile.name);
      };
      frd = new FileReader();
      frd.onloadend = function(e) {
        return pic.src = e.target.result;
      };
      return frd.readAsDataURL(aFile);
    };
    readImage = function(aFile) {
      var frd, pic;
      pic = new Image();
      frd = new FileReader();
      while (!targetDrop.droppedImage) {
        targetDrop = targetDrop.parent;
      }
      pic.onload = function() {
        var canvas;
        canvas = newCanvas(new Point(pic.width, pic.height));
        canvas.getContext("2d").drawImage(pic, 0, 0);
        return targetDrop.droppedImage(canvas, aFile.name);
      };
      frd = new FileReader();
      frd.onloadend = function(e) {
        return pic.src = e.target.result;
      };
      return frd.readAsDataURL(aFile);
    };
    readAudio = function(aFile) {
      var frd, snd;
      snd = new Audio();
      frd = new FileReader();
      while (!targetDrop.droppedAudio) {
        targetDrop = targetDrop.parent;
      }
      frd.onloadend = function(e) {
        snd.src = e.target.result;
        return targetDrop.droppedAudio(snd, aFile.name);
      };
      return frd.readAsDataURL(aFile);
    };
    readText = function(aFile) {
      var frd;
      frd = new FileReader();
      while (!targetDrop.droppedText) {
        targetDrop = targetDrop.parent;
      }
      frd.onloadend = function(e) {
        return targetDrop.droppedText(e.target.result, aFile.name);
      };
      return frd.readAsText(aFile);
    };
    readBinary = function(aFile) {
      var frd;
      frd = new FileReader();
      while (!targetDrop.droppedBinary) {
        targetDrop = targetDrop.parent;
      }
      frd.onloadend = function(e) {
        return targetDrop.droppedBinary(e.target.result, aFile.name);
      };
      return frd.readAsArrayBuffer(aFile);
    };
    parseImgURL = function(html) {
      var c, i, start, _i, _ref;
      url = "";
      start = html.indexOf("<img src=\"");
      if (start === -1) {
        return null;
      }
      start += 10;
      for (i = _i = start, _ref = html.length; start <= _ref ? _i < _ref : _i > _ref; i = start <= _ref ? ++_i : --_i) {
        c = html[i];
        if (c === "\"") {
          return url;
        }
        url = url.concat(c);
      }
      return null;
    };
    if (files.length) {
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        if (file.type.indexOf("svg") !== -1 && !WorldMorph.preferencesAndSettings.rasterizeSVGs) {
          _results.push(readSVG(file));
        } else if (file.type.indexOf("image") === 0) {
          _results.push(readImage(file));
        } else if (file.type.indexOf("audio") === 0) {
          _results.push(readAudio(file));
        } else if (file.type.indexOf("text") === 0) {
          _results.push(readText(file));
        } else {
          _results.push(readBinary(file));
        }
      }
      return _results;
    } else if (url) {
      if (contains(["gif", "png", "jpg", "jpeg", "bmp"], url.slice(url.lastIndexOf(".") + 1).toLowerCase())) {
        while (!target.droppedImage) {
          target = target.parent;
        }
        img = new Image();
        img.onload = function() {
          var canvas;
          canvas = newCanvas(new Point(img.width, img.height));
          canvas.getContext("2d").drawImage(img, 0, 0);
          return target.droppedImage(canvas);
        };
        return img.src = url;
      }
    } else if (txt) {
      while (!targetDrop.droppedImage) {
        targetDrop = targetDrop.parent;
      }
      img = new Image();
      img.onload = function() {
        var canvas;
        canvas = newCanvas(new Point(img.width, img.height));
        canvas.getContext("2d").drawImage(img, 0, 0);
        return targetDrop.droppedImage(canvas);
      };
      src = parseImgURL(txt);
      if (src) {
        return img.src = src;
      }
    }
  };

  HandMorph.prototype.destroyTemporaries = function() {
    return this.temporaries.forEach((function(_this) {
      return function(morph) {
        if (!(morph.isClickable && morph.bounds.containsPoint(_this.position()))) {
          morph = morph.destroy();
          return _this.temporaries.splice(_this.temporaries.indexOf(morph), 1);
        }
      };
    })(this));
  };

  HandMorph.prototype.moveBy = function(delta) {
    Morph.prototype.trackChanges = false;
    HandMorph.__super__.moveBy.call(this, delta);
    Morph.prototype.trackChanges = true;
    return this.fullChanged();
  };

  HandMorph.prototype.processMouseMove = function(pageX, pageY) {
    var fb, morph, mouseOverNew, pos, posInDocument, topMorph;
    posInDocument = getDocumentPositionOf(this.world.worldCanvas);
    pos = new Point(pageX - posInDocument.x, pageY - posInDocument.y);
    this.setPosition(pos);
    mouseOverNew = this.topMorphUnderPointer().allParentsTopToBottom();
    if ((!this.children.length) && (this.mouseButton === "left")) {
      topMorph = this.topMorphUnderPointer();
      morph = topMorph.rootForGrab();
      if (topMorph.mouseMove) {
        topMorph.mouseMove(pos);
      }
      if (this.morphToGrab) {
        if (this.morphToGrab.isDraggable) {
          morph = this.morphToGrab;
          this.grab(morph);
        } else if (this.morphToGrab.isTemplate) {
          morph = this.morphToGrab.fullCopy();
          morph.isTemplate = false;
          morph.isDraggable = true;
          this.grab(morph);
          this.grabOrigin = this.morphToGrab.situation();
        }
        if (morph) {
          fb = morph.boundsIncludingChildren();
          if (!fb.containsPoint(pos)) {
            this.bounds.origin = fb.center();
            this.grab(morph);
            this.setPosition(pos);
          }
        }
      }
    }
    this.mouseOverList.forEach((function(_this) {
      return function(old) {
        if (!contains(mouseOverNew, old)) {
          if (old.mouseLeave) {
            old.mouseLeave();
          }
          if (old.mouseLeaveDragging && _this.mouseButton) {
            return old.mouseLeaveDragging();
          }
        }
      };
    })(this));
    mouseOverNew.forEach((function(_this) {
      return function(newMorph) {
        if (!contains(_this.mouseOverList, newMorph)) {
          if (newMorph.mouseEnter) {
            newMorph.mouseEnter();
          }
          if (newMorph.mouseEnterDragging && _this.mouseButton) {
            newMorph.mouseEnterDragging();
          }
        }
        if (_this.children.length) {
          if (newMorph instanceof ScrollFrameMorph) {
            if (!newMorph.bounds.insetBy(WorldMorph.preferencesAndSettings.scrollBarSize * 3).containsPoint(_this.bounds.origin)) {
              return newMorph.startAutoScrolling();
            }
          }
        }
      };
    })(this));
    return this.mouseOverList = mouseOverNew;
  };

  HandMorph.coffeeScriptSourceOfThisClass = '# HandMorph ///////////////////////////////////////////////////////////\n\n# The mouse cursor. Note that it\'s not a child of the WorldMorph, this Morph\n# is never added to any other morph. [TODO] Find out why and write explanation.\n# Not to be confused with the HandleMorph\n\nclass HandMorph extends Morph\n\n  world: null\n  mouseButton: null\n  # used for example to check that\n  # mouseDown and mouseUp happen on the\n  # same Morph (otherwise clicks happen for\n  # example when resizing a button via the\n  # handle)\n  mouseDownMorph: null\n  morphToGrab: null\n  grabOrigin: null\n  mouseOverList: null\n  temporaries: null\n  touchHoldTimeout: null\n\n  constructor: (@world) ->\n    @mouseOverList = []\n    @temporaries = []\n    super()\n    @bounds = new Rectangle()\n  \n  changed: ->\n    if @world?\n      b = @boundsIncludingChildren()\n      if !b.extent().eq(new Point())\n        @world.broken.push @boundsIncludingChildren().spread()\n  \n  \n  # HandMorph navigation:\n  topMorphUnderPointer: ->\n    result = @world.topMorphSuchThat (m) =>\n      m.visibleBounds().containsPoint(@bounds.origin) and\n        !m.isMinimised and m.isVisible and (m.noticesTransparentClick or\n        (not m.isTransparentAt(@bounds.origin))) and (m not instanceof ShadowMorph)\n    if result?\n      return result\n    else\n      return @world\n\n  menuAtPointer: ->\n    result = @world.topMorphSuchThat (m) =>\n      m.visibleBounds().containsPoint(@bounds.origin) and\n        !m.isMinimised and m.isVisible and (m.noticesTransparentClick or\n        (not m.isTransparentAt(@bounds.origin))) and (m instanceof MenuMorph)\n    return result\n\n  leftOrRightClickOnMenuItemWithText: (whichMouseButtonPressed, textLabelOfClickedItem, textLabelOccurrenceNumber) ->\n    itemToTrigger = @world.activeMenu.nthChildSuchThat textLabelOccurrenceNumber, (m) ->\n      m.labelString == textLabelOfClickedItem\n\n    # these three are checks and actions that normally\n    # would happen on MouseDown event, but we\n    # removed that event as we collapsed the down and up\n    # into this colasesced higher-level event,\n    # but we still need to make these checks and actions\n    @destroyActiveMenuIfHandHasNotActionedIt itemToTrigger\n    @destroyActiveHandleIfHandHasNotActionedIt itemToTrigger\n    @stopEditingIfActionIsElsewhere itemToTrigger\n\n    if whichMouseButtonPressed == "left"\n      itemToTrigger.mouseClickLeft()\n    else if whichMouseButtonPressed == "right"\n      @openContextMenuAtPointer itemToTrigger.children[0]\n\n\n  openContextMenuAtPointer: (morphTheMenuIsAbout) ->\n    # note that the morphs that the menu\n    # belongs to might not be under the mouse.\n    # It usually is, but in cases\n    # where a system test is playing against\n    # a world setup that has varied since the\n    # recording, this could be the case.\n\n    # these three are checks and actions that normally\n    # would happen on MouseDown event, but we\n    # removed that event as we collapsed the down and up\n    # into this colasesced higher-level event,\n    # but we still need to make these checks and actions\n    @destroyActiveMenuIfHandHasNotActionedIt morphTheMenuIsAbout\n    @destroyActiveHandleIfHandHasNotActionedIt morphTheMenuIsAbout\n    @stopEditingIfActionIsElsewhere morphTheMenuIsAbout\n\n    contextMenu = morphTheMenuIsAbout.contextMenu()\n    while (not contextMenu) and morphTheMenuIsAbout.parent\n      morphTheMenuIsAbout = morphTheMenuIsAbout.parent\n      contextMenu = morphTheMenuIsAbout.contextMenu()\n\n    if contextMenu \n      contextMenu.popUpAtHand() \n\n  #\n  #    alternative -  more elegant and possibly more\n  #	performant - solution for topMorphUnderPointer.\n  #	Has some issues, commented out for now\n  #\n  #HandMorph.prototype.topMorphUnderPointer = function () {\n  #	var myself = this;\n  #	return this.world.topMorphSuchThat(function (m) {\n  #		return m.visibleBounds().containsPoint(myself.bounds.origin) &&\n  #			!m.isMinimised &&\n  #     m.isVisible &&\n  #			(m.noticesTransparentClick ||\n  #				(! m.isTransparentAt(myself.bounds.origin))) &&\n  #			(! (m instanceof ShadowMorph));\n  #	});\n  #};\n  #\n\n\n  # not used in ZK yet\n  allMorphsAtPointer: ->\n    return @world.collectAllChildrenBottomToTopSuchThat (m) =>\n      !m.isMinimised and m.isVisible and m.visibleBounds().containsPoint(@bounds.origin)\n  \n  \n  \n  # HandMorph dragging and dropping:\n  #\n  #	drag \'n\' drop events, method(arg) -> receiver:\n  #\n  #		prepareToBeGrabbed(handMorph) -> grabTarget\n  #		reactToGrabOf(grabbedMorph) -> oldParent\n  #		wantsDropOf(morphToDrop) ->  newParent\n  #		justDropped(handMorph) -> droppedMorph\n  #		reactToDropOf(droppedMorph, handMorph) -> newParent\n  #\n  dropTargetFor: (aMorph) ->\n    target = @topMorphUnderPointer()\n    target = target.parent  until target.wantsDropOf(aMorph)\n    target\n  \n  grab: (aMorph) ->\n    oldParent = aMorph.parent\n    return null  if aMorph instanceof WorldMorph\n    if !@children.length\n      @world.stopEditing()\n      @grabOrigin = aMorph.situation()\n      aMorph.prepareToBeGrabbed @  if aMorph.prepareToBeGrabbed\n      @add aMorph\n      # you must add the shadow\n      # after the morph has been added\n      # because "@add aMorph" causes\n      # the morph to be painted potentially\n      # for the first time.\n      # The shadow needs the image of the\n      # morph to make the shadow, so\n      # this is why we add the shadow after\n      # the morph has been added.\n      aMorph.addShadow()\n      @changed()\n      oldParent.reactToGrabOf aMorph  if oldParent and oldParent.reactToGrabOf\n  \n  drop: ->\n    if @children.length\n      morphToDrop = @children[0]\n      target = @dropTargetFor(morphToDrop)\n      @changed()\n      target.add morphToDrop\n      morphToDrop.changed()\n      morphToDrop.removeShadow()\n      @children = []\n      @setExtent new Point()\n      morphToDrop.justDropped @  if morphToDrop.justDropped\n      target.reactToDropOf morphToDrop, @  if target.reactToDropOf\n      @dragOrigin = null\n  \n  # HandMorph event dispatching:\n  #\n  #    mouse events:\n  #\n  #		mouseDownLeft\n  #		mouseDownRight\n  #		mouseClickLeft\n  #		mouseClickRight\n  #   mouseDoubleClick\n  #		mouseEnter\n  #		mouseLeave\n  #		mouseEnterDragging\n  #		mouseLeaveDragging\n  #		mouseMove\n  #		mouseScroll\n  #\n  # Note that some handlers don\'t want the event but the\n  # interesting parameters of the event. This is because\n  # the testing harness only stores the interesting parameters\n  # rather than a multifaceted and sometimes browser-specific\n  # event object.\n\n  destroyActiveHandleIfHandHasNotActionedIt: (actionedMorph) ->\n    if @world.activeHandle?\n      if actionedMorph isnt @world.activeHandle\n        @world.activeHandle = @world.activeHandle.destroy()    \n\n  destroyActiveMenuIfHandHasNotActionedIt: (actionedMorph) ->\n    if @world.activeMenu?\n      unless @world.activeMenu.containedInParentsOf(actionedMorph)\n        # if there is a menu open and the user clicked on\n        # something that is not part of the menu then\n        # destroy the menu \n        @world.activeMenu = @world.activeMenu.destroy()\n      else\n        clearInterval @touchHoldTimeout\n\n  stopEditingIfActionIsElsewhere: (actionedMorph) ->\n    if @world.caret?\n      # there is a caret on the screen\n      # depending on what the user is clicking on,\n      # we might need to close an ongoing edit\n      # operation, which means deleting the\n      # caret and un-selecting anything that was selected.\n      # Note that we don\'t want to interrupt an edit\n      # if the user is invoking/clicking on anything\n      # inside a menu, because the invoked function\n      # might do something with the selection\n      # (for example doSelection takes the current selection).\n      if actionedMorph isnt @world.caret.target\n        # user clicked on something other than what the\n        # caret is attached to\n        if @world.activeMenu?\n          unless @world.activeMenu.containedInParentsOf(actionedMorph)\n            # only dismiss editing if the actionedMorph the user\n            # clicked on is not part of a menu.\n            @world.stopEditing()\n        # there is no menu at all, in which case\n        # we know there was an editing operation going\n        # on that we need to stop\n        else\n          @world.stopEditing()\n\n  processMouseDown: (button, ctrlKey) ->\n    @destroyTemporaries()\n    @morphToGrab = null\n    # check whether we are in the middle\n    # of a drag/drop operation\n    if @children.length\n      @drop()\n      @mouseButton = null\n    else\n      morph = @topMorphUnderPointer()\n      @destroyActiveMenuIfHandHasNotActionedIt morph\n      @destroyActiveHandleIfHandHasNotActionedIt morph\n      @stopEditingIfActionIsElsewhere morph\n\n      @morphToGrab = morph.rootForGrab()  unless morph.mouseMove\n      if button is 2 or ctrlKey\n        @mouseButton = "right"\n        actualClick = "mouseDownRight"\n        expectedClick = "mouseClickRight"\n      else\n        @mouseButton = "left"\n        actualClick = "mouseDownLeft"\n        expectedClick = "mouseClickLeft"\n\n      @mouseDownMorph = morph\n      @mouseDownMorph = @mouseDownMorph.parent  until @mouseDownMorph[expectedClick]\n      morph = morph.parent  until morph[actualClick]\n      morph[actualClick] @bounds.origin\n  \n  # touch events, see:\n  # https://developer.apple.com/library/safari/documentation/appleapplications/reference/safariwebcontent/HandlingEvents/HandlingEvents.html\n  # A long touch emulates a right click. This is done via\n  # setting a timer 400ms after the touch which triggers\n  # a right mouse click. Any touch event before then just\n  # resets the timer, so one has to hold the finger in\n  # position for the right click to happen.\n  processTouchStart: (event) ->\n    event.preventDefault()\n    WorldMorph.preferencesAndSettings.isTouchDevice = true\n    clearInterval @touchHoldTimeout\n    if event.touches.length is 1\n      # simulate mouseRightClick\n      @touchHoldTimeout = setInterval(=>\n        @processMouseDown 2 # button 2 is the right one\n        @processMouseUp 2 # button 2 is the right one, we don\'t use this parameter\n        event.preventDefault() # I don\'t think that this is needed\n        clearInterval @touchHoldTimeout\n      , 400)\n      @processMouseMove event.touches[0].pageX, event.touches[0].pageY # update my position\n      @processMouseDown 0 # button zero is the left button\n  \n  processTouchMove: (event) ->\n    # Prevent scrolling on this element\n    event.preventDefault()\n\n    if event.touches.length is 1\n      touch = event.touches[0]\n      @processMouseMove touch.pageX, touch.pageY\n      clearInterval @touchHoldTimeout\n  \n  processTouchEnd: (event) ->\n    # note that the mouse down event handler\n    # that is calling this method has ALREADY\n    # added a mousdown command\n\n    WorldMorph.preferencesAndSettings.isTouchDevice = true\n    clearInterval @touchHoldTimeout\n    @processMouseUp 0 # button zero is the left button, we don\'t use this parameter\n  \n   # note that the button param is not used,\n   # but adding it for consistency...\n   processMouseUp: (button) ->\n    morph = @topMorphUnderPointer()\n    alreadyRecordedLeftOrRightClickOnMenuItem = false\n    @destroyTemporaries()\n    if @children.length\n      @drop()\n    else\n      # let\'s check if the user clicked on a menu item,\n      # in which case we add a special dedicated command\n      # [TODO] you need to do some of this only if you\n      # are recording a test, it\'s worth saving\n      # these steps...\n      menuItemMorph = morph.parentThatIsA(MenuItemMorph)\n      if menuItemMorph\n        # we check whether the menuitem is actually part\n        # of an activeMenu. Keep in mind you could have\n        # detached a menuItem and placed it on any other\n        # morph so you need to ascertain that you\'ll\n        # find it in the activeMenu later on...\n        if @world.activeMenu == menuItemMorph.parent\n          labelString = menuItemMorph.labelString\n          morphSpawningTheMenu = menuItemMorph.parent.parent\n          occurrenceNumber = menuItemMorph.howManySiblingsBeforeMeSuchThat (m) ->\n            m.labelString == labelString\n          # this method below is also going to remove\n          # the mouse down/up commands that have\n          # recently/jsut been added.\n          @world.systemTestsRecorderAndPlayer.addCommandLeftOrRightClickOnMenuItem(@mouseButton, labelString, occurrenceNumber + 1)\n          alreadyRecordedLeftOrRightClickOnMenuItem = true\n      if @mouseButton is "left"\n        expectedClick = "mouseClickLeft"\n      else\n        expectedClick = "mouseClickRight"\n        if @mouseButton\n          if !alreadyRecordedLeftOrRightClickOnMenuItem\n            # this being a right click, pop\n            # up a menu as needed.\n            @world.systemTestsRecorderAndPlayer.addOpenContextMenuCommand morph.uniqueIDString()\n          @openContextMenuAtPointer morph\n      until morph[expectedClick]\n        morph = morph.parent\n        if not morph?\n          break\n      if morph?\n        if morph == @mouseDownMorph\n          morph[expectedClick] @bounds.origin\n    @mouseButton = null\n\n  processDoubleClick: ->\n    morph = @topMorphUnderPointer()\n    @destroyTemporaries()\n    if @children.length isnt 0\n      @drop()\n    else\n      morph = morph.parent  while morph and not morph.mouseDoubleClick\n      morph.mouseDoubleClick @bounds.origin  if morph\n    @mouseButton = null\n  \n  processMouseScroll: (event) ->\n    morph = @topMorphUnderPointer()\n    morph = morph.parent  while morph and not morph.mouseScroll\n\n    morph.mouseScroll (event.detail / -3) or ((if Object.prototype.hasOwnProperty.call(event,\'wheelDeltaY\') then event.wheelDeltaY / 120 else event.wheelDelta / 120)), event.wheelDeltaX / 120 or 0  if morph\n  \n  \n  #\n  #	drop event:\n  #\n  #        droppedImage\n  #        droppedSVG\n  #        droppedAudio\n  #        droppedText\n  #\n  processDrop: (event) ->\n    #\n    #    find out whether an external image or audio file was dropped\n    #    onto the world canvas, turn it into an offscreen canvas or audio\n    #    element and dispatch the\n    #    \n    #        droppedImage(canvas, name)\n    #        droppedSVG(image, name)\n    #        droppedAudio(audio, name)\n    #    \n    #    events to interested Morphs at the mouse pointer\n    #    if none of the above content types can be determined, the file contents\n    #    is dispatched as an ArrayBuffer to interested Morphs:\n    #\n    #    ```droppedBinary(anArrayBuffer, name)```\n\n    files = (if event instanceof FileList then event else (event.target.files || event.dataTransfer.files))\n    url = (if event.dataTransfer then event.dataTransfer.getData("URL") else null)\n    txt = (if event.dataTransfer then event.dataTransfer.getData("Text/HTML") else null)\n    targetDrop = @topMorphUnderPointer()\n    img = new Image()\n\n    readSVG = (aFile) ->\n      pic = new Image()\n      frd = new FileReader()\n      target = target.parent  until target.droppedSVG\n      pic.onload = ->\n        target.droppedSVG pic, aFile.name\n      frd = new FileReader()\n      frd.onloadend = (e) ->\n        pic.src = e.target.result\n      frd.readAsDataURL aFile\n\n    readImage = (aFile) ->\n      pic = new Image()\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedImage\n      pic.onload = ->\n        canvas = newCanvas(new Point(pic.width, pic.height))\n        canvas.getContext("2d").drawImage pic, 0, 0\n        targetDrop.droppedImage canvas, aFile.name\n      #\n      frd = new FileReader()\n      frd.onloadend = (e) ->\n        pic.src = e.target.result\n      #\n      frd.readAsDataURL aFile\n    #\n    readAudio = (aFile) ->\n      snd = new Audio()\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedAudio\n      frd.onloadend = (e) ->\n        snd.src = e.target.result\n        targetDrop.droppedAudio snd, aFile.name\n      frd.readAsDataURL aFile\n    \n    readText = (aFile) ->\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedText\n      frd.onloadend = (e) ->\n        targetDrop.droppedText e.target.result, aFile.name\n      frd.readAsText aFile\n\n\n    readBinary = (aFile) ->\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedBinary\n      frd.onloadend = (e) ->\n        targetDrop.droppedBinary e.target.result, aFile.name\n      frd.readAsArrayBuffer aFile\n\n    parseImgURL = (html) ->\n      url = ""\n      start = html.indexOf("<img src=\"")\n      return null  if start is -1\n      start += 10\n      for i in [start...html.length]\n        c = html[i]\n        return url  if c is "\""\n        url = url.concat(c)\n      null\n    \n    if files.length\n      for file in files\n        if file.type.indexOf("svg") != -1 && !WorldMorph.preferencesAndSettings.rasterizeSVGs\n          readSVG file\n        else if file.type.indexOf("image") is 0\n          readImage file\n        else if file.type.indexOf("audio") is 0\n          readAudio file\n        else if file.type.indexOf("text") is 0\n          readText file\n        else\n          readBinary file\n    else if url\n      if contains(["gif", "png", "jpg", "jpeg", "bmp"], url.slice(url.lastIndexOf(".") + 1).toLowerCase())\n        target = target.parent  until target.droppedImage\n        img = new Image()\n        img.onload = ->\n          canvas = newCanvas(new Point(img.width, img.height))\n          canvas.getContext("2d").drawImage img, 0, 0\n          target.droppedImage canvas\n        img.src = url\n    else if txt\n      targetDrop = targetDrop.parent  until targetDrop.droppedImage\n      img = new Image()\n      img.onload = ->\n        canvas = newCanvas(new Point(img.width, img.height))\n        canvas.getContext("2d").drawImage img, 0, 0\n        targetDrop.droppedImage canvas\n      src = parseImgURL(txt)\n      img.src = src  if src\n  \n  \n  # HandMorph tools\n  destroyTemporaries: ->\n    #\n    #	temporaries are just an array of morphs which will be deleted upon\n    #	the next mouse click, or whenever another temporary Morph decides\n    #	that it needs to remove them. The primary purpose of temporaries is\n    #	to display tools tips of speech bubble help.\n    #\n    @temporaries.forEach (morph) =>\n      unless morph.isClickable and morph.bounds.containsPoint(@position())\n        morph = morph.destroy()\n        @temporaries.splice @temporaries.indexOf(morph), 1\n  \n  \n  # HandMorph dragging optimization\n  moveBy: (delta) ->\n    Morph::trackChanges = false\n    super delta\n    Morph::trackChanges = true\n    @fullChanged()\n\n  processMouseMove: (pageX, pageY) ->    \n    #startProcessMouseMove = new Date().getTime()\n    posInDocument = getDocumentPositionOf(@world.worldCanvas)\n    pos = new Point(pageX - posInDocument.x, pageY - posInDocument.y)\n    @setPosition pos\n\n    # determine the new mouse-over-list.\n    # Spacial multiplexing\n    # (search "multiplexing" for the other parts of\n    # code where this matters)\n    # There are two interpretations of what this\n    # list should be:\n    #   1) all morphs "pierced through" by the pointer\n    #   2) all morphs parents of the topmost morph under the pointer\n    # 2 is what is used in Cuis\n    \n    # commented-out implementation of 1):\n    # mouseOverNew = @allMorphsAtPointer().reverse()\n    mouseOverNew = @topMorphUnderPointer().allParentsTopToBottom()\n\n    if (!@children.length) and (@mouseButton is "left")\n      topMorph = @topMorphUnderPointer()\n      morph = topMorph.rootForGrab()\n      topMorph.mouseMove pos  if topMorph.mouseMove\n      #\n      # if a morph is marked for grabbing, just grab it\n      if @morphToGrab\n        if @morphToGrab.isDraggable\n          morph = @morphToGrab\n          @grab morph\n        else if @morphToGrab.isTemplate\n          morph = @morphToGrab.fullCopy()\n          morph.isTemplate = false\n          morph.isDraggable = true\n          @grab morph\n          @grabOrigin = @morphToGrab.situation()\n        #\n        # if the mouse has left its boundsIncludingChildren, center it\n        if morph\n          fb = morph.boundsIncludingChildren()\n          unless fb.containsPoint(pos)\n            @bounds.origin = fb.center()\n            @grab morph\n            @setPosition pos\n    #endProcessMouseMove = new Date().getTime()\n    #timeProcessMouseMove = endProcessMouseMove - startProcessMouseMove;\n    #console.log(\'Execution time ProcessMouseMove: \' + timeProcessMouseMove);\n    \n    #\n    #	original, more cautious code for grabbing Morphs,\n    #	retained in case of needing to fall back:\n    #\n    #		if (morph === this.morphToGrab) {\n    #			if (morph.isDraggable) {\n    #				this.grab(morph);\n    #			} else if (morph.isTemplate) {\n    #				morph = morph.fullCopy();\n    #				morph.isTemplate = false;\n    #				morph.isDraggable = true;\n    #				this.grab(morph);\n    #			}\n    #		}\n    #\n    @mouseOverList.forEach (old) =>\n      unless contains(mouseOverNew, old)\n        old.mouseLeave()  if old.mouseLeave\n        old.mouseLeaveDragging()  if old.mouseLeaveDragging and @mouseButton\n    #\n    mouseOverNew.forEach (newMorph) =>\n      unless contains(@mouseOverList, newMorph)\n        newMorph.mouseEnter()  if newMorph.mouseEnter\n        newMorph.mouseEnterDragging()  if newMorph.mouseEnterDragging and @mouseButton\n      #\n      # autoScrolling support:\n      if @children.length\n          if newMorph instanceof ScrollFrameMorph\n              if !newMorph.bounds.insetBy(\n                WorldMorph.preferencesAndSettings.scrollBarSize * 3\n                ).containsPoint(@bounds.origin)\n                  newMorph.startAutoScrolling();\n    #\n    @mouseOverList = mouseOverNew';

  return HandMorph;

})(Morph);

HandleMorph = (function(_super) {
  __extends(HandleMorph, _super);

  HandleMorph.prototype.target = null;

  HandleMorph.prototype.minExtent = null;

  HandleMorph.prototype.inset = null;

  HandleMorph.prototype.type = null;

  HandleMorph.prototype.step = null;

  function HandleMorph(target, minX, minY, insetX, insetY, type) {
    var size;
    this.target = target != null ? target : null;
    if (minX == null) {
      minX = 0;
    }
    if (minY == null) {
      minY = 0;
    }
    this.type = type != null ? type : "resize";
    this.minExtent = new Point(minX, minY);
    this.inset = new Point(insetX || 0, insetY || insetX || 0);
    HandleMorph.__super__.constructor.call(this);
    this.color = new Color(255, 255, 255);
    this.noticesTransparentClick = true;
    size = WorldMorph.preferencesAndSettings.handleSize;
    this.silentSetExtent(new Point(size, size));
    if (this.target) {
      this.target.add(this);
    }
    this.updatePosition();
  }

  HandleMorph.prototype.updatePosition = function() {
    if (this.target) {
      this.setPosition(this.target.bottomRight().subtract(this.extent().add(this.inset)));
      return this.target.changed();
    }
  };

  HandleMorph.prototype.updateRendering = function() {
    var highlightImageContext, normalImageContext;
    this.normalImage = newCanvas(this.extent().scaleBy(pixelRatio));
    normalImageContext = this.normalImage.getContext("2d");
    normalImageContext.scale(pixelRatio, pixelRatio);
    this.highlightImage = newCanvas(this.extent().scaleBy(pixelRatio));
    highlightImageContext = this.highlightImage.getContext("2d");
    highlightImageContext.scale(pixelRatio, pixelRatio);
    this.handleMorphRenderingHelper(normalImageContext, this.color, new Color(100, 100, 100));
    this.handleMorphRenderingHelper(highlightImageContext, new Color(100, 100, 255), new Color(255, 255, 255));
    return this.image = this.normalImage;
  };

  HandleMorph.prototype.handleMorphRenderingHelper = function(context, color, shadowColor) {
    var i, p1, p11, p2, p22, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3, _results;
    context.lineWidth = 1;
    context.lineCap = "round";
    context.strokeStyle = color.toString();
    if (this.type === "move") {
      p1 = this.bottomLeft().subtract(this.position());
      p11 = p1.copy();
      p2 = this.topRight().subtract(this.position());
      p22 = p2.copy();
      for (i = _i = 0, _ref = this.height(); _i <= _ref; i = _i += 6) {
        p11.y = p1.y - i;
        p22.y = p2.y - i;
        context.beginPath();
        context.moveTo(p11.x, p11.y);
        context.lineTo(p22.x, p22.y);
        context.closePath();
        context.stroke();
      }
    }
    p1 = this.bottomLeft().subtract(this.position());
    p11 = p1.copy();
    p2 = this.topRight().subtract(this.position());
    p22 = p2.copy();
    for (i = _j = 0, _ref1 = this.width(); _j <= _ref1; i = _j += 6) {
      p11.x = p1.x + i;
      p22.x = p2.x + i;
      context.beginPath();
      context.moveTo(p11.x, p11.y);
      context.lineTo(p22.x, p22.y);
      context.closePath();
      context.stroke();
    }
    context.strokeStyle = shadowColor.toString();
    if (this.type === "move") {
      p1 = this.bottomLeft().subtract(this.position());
      p11 = p1.copy();
      p2 = this.topRight().subtract(this.position());
      p22 = p2.copy();
      for (i = _k = -1, _ref2 = this.height(); _k <= _ref2; i = _k += 6) {
        p11.y = p1.y - i;
        p22.y = p2.y - i;
        context.beginPath();
        context.moveTo(p11.x, p11.y);
        context.lineTo(p22.x, p22.y);
        context.closePath();
        context.stroke();
      }
    }
    p1 = this.bottomLeft().subtract(this.position());
    p11 = p1.copy();
    p2 = this.topRight().subtract(this.position());
    p22 = p2.copy();
    _results = [];
    for (i = _l = 2, _ref3 = this.width(); _l <= _ref3; i = _l += 6) {
      p11.x = p1.x + i;
      p22.x = p2.x + i;
      context.beginPath();
      context.moveTo(p11.x, p11.y);
      context.lineTo(p22.x, p22.y);
      context.closePath();
      _results.push(context.stroke());
    }
    return _results;
  };

  HandleMorph.prototype.mouseClickLeft = function() {};

  HandleMorph.prototype.mouseUpLeft = function() {};

  HandleMorph.prototype.mouseDownLeft = function() {};

  HandleMorph.prototype.mouseDownLeft = function(pos) {
    var offset, world;
    world = this.root();
    offset = pos.subtract(this.bounds.origin);
    if (!this.target) {
      return null;
    }
    this.step = (function(_this) {
      return function() {
        var newExt, newPos;
        if (world.hand.mouseButton) {
          newPos = world.hand.bounds.origin.copy().subtract(offset);
          if (_this.type === "resize") {
            newExt = newPos.add(_this.extent().add(_this.inset)).subtract(_this.target.bounds.origin);
            newExt = newExt.max(_this.minExtent);
            _this.target.setExtent(newExt);
            _this.setPosition(_this.target.bottomRight().subtract(_this.extent().add(_this.inset)));
            if (_this.target.layoutSubmorphs != null) {
              return _this.target.layoutSubmorphs();
            }
          } else {
            return _this.target.setPosition(newPos.subtract(_this.target.extent()).add(_this.extent()));
          }
        } else {
          return _this.step = null;
        }
      };
    })(this);
    if (!this.target.step) {
      return this.target.step = noOperation;
    }
  };

  HandleMorph.prototype.rootForGrab = function() {
    return this;
  };

  HandleMorph.prototype.mouseEnter = function() {
    this.image = this.highlightImage;
    return this.changed();
  };

  HandleMorph.prototype.mouseLeave = function() {
    this.image = this.normalImage;
    return this.changed();
  };

  HandleMorph.prototype.attach = function() {
    var choices, menu;
    if (world.activeMenu) {
      world.activeMenu = world.activeMenu.destroy();
    }
    choices = world.plausibleTargetAndDestinationMorphs(this);
    menu = new MenuMorph(this, "choose target:");
    if (choices.length > 0) {
      choices.forEach((function(_this) {
        return function(each) {
          return menu.addItem(each.toString().slice(0, 50), function() {
            this.isDraggable = false;
            this.target = each;
            this.updateRendering();
            return this.noticesTransparentClick = true;
          });
        };
      })(this));
    } else {
      menu = new MenuMorph(this, "no morphs to attach to");
    }
    if (choices.length) {
      return menu.popUpAtHand();
    }
  };

  HandleMorph.coffeeScriptSourceOfThisClass = '# HandleMorph ////////////////////////////////////////////////////////\n# not to be confused with the HandMorph\n# I am a resize / move handle that can be attached to any Morph\n\n# this comment below is needed to figure our dependencies between classes\n# REQUIRES globalFunctions\n\nclass HandleMorph extends Morph\n\n  target: null\n  minExtent: null\n  inset: null\n  type: null # "resize" or "move"\n  step: null\n\n  constructor: (@target = null, minX = 0, minY = 0, insetX, insetY, @type = "resize") ->\n    # if insetY is missing, it will be the same as insetX\n    @minExtent = new Point(minX, minY)\n    @inset = new Point(insetX or 0, insetY or insetX or 0)\n    super()\n    @color = new Color(255, 255, 255)\n    @noticesTransparentClick = true\n    size = WorldMorph.preferencesAndSettings.handleSize\n    @silentSetExtent new Point(size, size)\n    if @target\n      @target.add @\n    @updatePosition()\n\n  updatePosition: ->\n    if @target\n        @setPosition @target.bottomRight().subtract(@extent().add(@inset))\n        # todo wow, wasteful!\n        @target.changed()\n  \n  \n  # HandleMorph drawing:\n  updateRendering: ->\n    @normalImage = newCanvas(@extent().scaleBy pixelRatio)\n    normalImageContext = @normalImage.getContext("2d")\n    normalImageContext.scale pixelRatio, pixelRatio\n    @highlightImage = newCanvas(@extent().scaleBy pixelRatio)\n    highlightImageContext = @highlightImage.getContext("2d")\n    highlightImageContext.scale pixelRatio, pixelRatio\n    @handleMorphRenderingHelper normalImageContext, @color, new Color(100, 100, 100)\n    @handleMorphRenderingHelper highlightImageContext, new Color(100, 100, 255), new Color(255, 255, 255)\n    @image = @normalImage\n  \n  handleMorphRenderingHelper: (context, color, shadowColor) ->\n    context.lineWidth = 1\n    context.lineCap = "round"\n    context.strokeStyle = color.toString()\n    if @type is "move"\n      p1 = @bottomLeft().subtract(@position())\n      p11 = p1.copy()\n      p2 = @topRight().subtract(@position())\n      p22 = p2.copy()\n      for i in [0..@height()] by 6\n        p11.y = p1.y - i\n        p22.y = p2.y - i\n        context.beginPath()\n        context.moveTo p11.x, p11.y\n        context.lineTo p22.x, p22.y\n        context.closePath()\n        context.stroke()\n\n    p1 = @bottomLeft().subtract(@position())\n    p11 = p1.copy()\n    p2 = @topRight().subtract(@position())\n    p22 = p2.copy()\n    for i in [0..@width()] by 6\n      p11.x = p1.x + i\n      p22.x = p2.x + i\n      context.beginPath()\n      context.moveTo p11.x, p11.y\n      context.lineTo p22.x, p22.y\n      context.closePath()\n      context.stroke()\n\n    context.strokeStyle = shadowColor.toString()\n    if @type is "move"\n      p1 = @bottomLeft().subtract(@position())\n      p11 = p1.copy()\n      p2 = @topRight().subtract(@position())\n      p22 = p2.copy()\n      for i in [-1..@height()] by 6\n        p11.y = p1.y - i\n        p22.y = p2.y - i\n        context.beginPath()\n        context.moveTo p11.x, p11.y\n        context.lineTo p22.x, p22.y\n        context.closePath()\n        context.stroke()\n\n    p1 = @bottomLeft().subtract(@position())\n    p11 = p1.copy()\n    p2 = @topRight().subtract(@position())\n    p22 = p2.copy()\n    for i in [2..@width()] by 6\n      p11.x = p1.x + i\n      p22.x = p2.x + i\n      context.beginPath()\n      context.moveTo p11.x, p11.y\n      context.lineTo p22.x, p22.y\n      context.closePath()\n      context.stroke()\n  \n\n  # implement dummy methods in here\n  # so the handle catches the clicks and\n  # prevents the parent to do anything.\n  mouseClickLeft: ->\n  mouseUpLeft: ->\n  mouseDownLeft: ->\n  \n  # HandleMorph stepping:\n  mouseDownLeft: (pos) ->\n    world = @root()\n    offset = pos.subtract(@bounds.origin)\n    return null  unless @target\n    @step = =>\n      if world.hand.mouseButton\n        newPos = world.hand.bounds.origin.copy().subtract(offset)\n        if @type is "resize"\n          newExt = newPos.add(@extent().add(@inset)).subtract(@target.bounds.origin)\n          newExt = newExt.max(@minExtent)\n          @target.setExtent newExt\n          @setPosition @target.bottomRight().subtract(@extent().add(@inset))\n          # not all morphs provide a layoutSubmorphs, so check\n          if @target.layoutSubmorphs?\n            @target.layoutSubmorphs()\n        else # type === \'move\'\n          @target.setPosition newPos.subtract(@target.extent()).add(@extent())\n      else\n        @step = null\n    \n    unless @target.step\n      @target.step = noOperation\n  \n  \n  # HandleMorph dragging and dropping:\n  rootForGrab: ->\n    @\n  \n  \n  # HandleMorph events:\n  mouseEnter: ->\n    @image = @highlightImage\n    @changed()\n  \n  mouseLeave: ->\n    @image = @normalImage\n    @changed()\n  \n    \n  # HandleMorph menu:\n  attach: ->\n    # get rid of any previous temporary\n    # active menu because it\'s meant to be\n    # out of view anyways, otherwise we show\n    # its submorphs in the "attach to..." options\n    # which is most probably not wanted.\n    if world.activeMenu\n      world.activeMenu = world.activeMenu.destroy()\n    choices = world.plausibleTargetAndDestinationMorphs(@)\n    menu = new MenuMorph(@, "choose target:")\n    if choices.length > 0\n      choices.forEach (each) =>\n        menu.addItem each.toString().slice(0, 50), ->\n          @isDraggable = false\n          @target = each\n          @updateRendering()\n          @noticesTransparentClick = true\n    else\n      # the ideal would be to not show the\n      # "attach" menu entry at all but for the\n      # time being it\'s quite costly to\n      # find the eligible morphs to attach\n      # to, so for now let\'s just calculate\n      # this list if the user invokes the\n      # command, and if there are no good\n      # morphs then show some kind of message.\n      menu = new MenuMorph(@, "no morphs to attach to")\n    menu.popUpAtHand()  if choices.length';

  return HandleMorph;

})(Morph);

HashCalculator = (function() {
  function HashCalculator() {}

  HashCalculator.calculateHash = function(theString) {
    var chr, hash, i, _i, _ref;
    if (theString.length === 0) {
      return hash;
    }
    for (i = _i = 0, _ref = theString.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      chr = theString.charCodeAt(i);
      hash = ((hash << 5) - hash) + chr;
      hash |= 0;
      i++;
    }
    return hash;
  };

  HashCalculator.coffeeScriptSourceOfThisClass = '# HashCalculator ///////////////////////////////////////////////////\n# adapted from http://stackoverflow.com/a/7616484\n\n# Currently used to differentiate the filenames\n# for test reference images taken in\n# different os/browser config: a hash of the\n# configuration is added to the filename.\n\nclass HashCalculator\n\n  @calculateHash: (theString) ->\n      return hash  if theString.length is 0\n\n      for i in [0...theString.length]\n        chr = theString.charCodeAt(i)\n        hash = ((hash << 5) - hash) + chr\n        hash |= 0 # Convert to 32bit integer\n        i++\n      return hash';

  return HashCalculator;

})();

InspectorMorph = (function(_super) {
  __extends(InspectorMorph, _super);

  InspectorMorph.prototype.target = null;

  InspectorMorph.prototype.currentProperty = null;

  InspectorMorph.prototype.showing = "attributes";

  InspectorMorph.prototype.markOwnershipOfProperties = false;

  InspectorMorph.prototype.label = null;

  InspectorMorph.prototype.list = null;

  InspectorMorph.prototype.detail = null;

  InspectorMorph.prototype.work = null;

  InspectorMorph.prototype.buttonInspect = null;

  InspectorMorph.prototype.buttonClose = null;

  InspectorMorph.prototype.buttonSubset = null;

  InspectorMorph.prototype.buttonEdit = null;

  InspectorMorph.prototype.resizer = null;

  function InspectorMorph(target) {
    this.target = target;
    this.selectionFromList = __bind(this.selectionFromList, this);
    InspectorMorph.__super__.constructor.call(this);
    this.silentSetExtent(new Point(WorldMorph.preferencesAndSettings.handleSize * 20, WorldMorph.preferencesAndSettings.handleSize * 20 * 2 / 3));
    this.isDraggable = true;
    this.border = 1;
    this.edge = WorldMorph.preferencesAndSettings.isFlat ? 1 : 5;
    this.color = new Color(60, 60, 60);
    this.borderColor = new Color(95, 95, 95);
    if (this.target) {
      this.buildAndConnectChildren();
    }
  }

  InspectorMorph.prototype.setTarget = function(target) {
    this.target = target;
    this.currentProperty = null;
    return this.buildAndConnectChildren();
  };

  InspectorMorph.prototype.buildAndConnectChildren = function() {
    var attribs, ctrl, doubleClickAction, ev, property, staticAttributes, staticFunctions, staticProperties, targetOwnMethods;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.IDLE && SystemTestsRecorderAndPlayer.alignmentOfMorphIDsMechanism) {
      world.alignIDsOfNextMorphsInSystemTests();
    }
    attribs = [];
    this.destroyAll();
    this.children = [];
    this.label = new TextMorph(this.target.toString());
    this.label.fontSize = WorldMorph.preferencesAndSettings.menuFontSize;
    this.label.isBold = true;
    this.label.color = new Color(255, 255, 255);
    this.add(this.label);
    for (property in this.target) {
      if (property) {
        attribs.push(property);
      }
    }
    if (this.showing === "attributes") {
      attribs = attribs.filter((function(_this) {
        return function(prop) {
          return !isFunction(_this.target[prop]);
        };
      })(this));
    } else if (this.showing === "methods") {
      attribs = attribs.filter((function(_this) {
        return function(prop) {
          return isFunction(_this.target[prop]);
        };
      })(this));
    }
    staticProperties = Object.getOwnPropertyNames(this.target.constructor);
    staticProperties = staticProperties.filter((function(_this) {
      return function(prop) {
        return prop !== "name" && prop !== "length" && prop !== "prototype" && prop !== "caller" && prop !== "__super__" && prop !== "arguments";
      };
    })(this));
    if (this.showing === "attributes") {
      staticFunctions = [];
      staticAttributes = staticProperties.filter((function(_this) {
        return function(prop) {
          return !isFunction(_this.target.constructor[prop]);
        };
      })(this));
    } else if (this.showing === "methods") {
      staticFunctions = staticProperties.filter((function(_this) {
        return function(prop) {
          return isFunction(_this.target.constructor[prop]);
        };
      })(this));
      staticAttributes = [];
    } else {
      staticFunctions = staticProperties.filter((function(_this) {
        return function(prop) {
          return isFunction(_this.target.constructor[prop]);
        };
      })(this));
      staticAttributes = staticProperties.filter((function(_this) {
        return function(prop) {
          return __indexOf.call(staticFunctions, prop) < 0;
        };
      })(this));
    }
    attribs = (attribs.concat(staticFunctions)).concat(staticAttributes);
    if (this.markOwnershipOfProperties) {
      targetOwnMethods = Object.getOwnPropertyNames(this.target.constructor.prototype);
    }
    doubleClickAction = (function(_this) {
      return function() {
        var inspector, world;
        if (!isObject(_this.currentProperty)) {
          return;
        }
        world = _this.world();
        inspector = _this.constructor(_this.currentProperty);
        inspector.setPosition(world.hand.position());
        inspector.keepWithin(world);
        world.add(inspector);
        return inspector.changed();
      };
    })(this);
    this.list = new ListMorph(this, InspectorMorph.prototype.selectionFromList, (this.target instanceof Array ? attribs : attribs.sort()), null, (this.markOwnershipOfProperties ? [
      [
        new Color(0, 0, 180), (function(_this) {
          return function(element) {
            return true;
          };
        })(this)
      ], [
        new Color(255, 165, 0), (function(_this) {
          return function(element) {
            return __indexOf.call(staticProperties, element) >= 0;
          };
        })(this)
      ], [
        new Color(0, 180, 0), (function(_this) {
          return function(element) {
            return Object.prototype.hasOwnProperty.call(_this.target, element);
          };
        })(this)
      ], [
        new Color(180, 0, 0), (function(_this) {
          return function(element) {
            return __indexOf.call(targetOwnMethods, element) >= 0;
          };
        })(this)
      ]
    ] : null), doubleClickAction);
    this.list.listContents.step = null;
    this.add(this.list);
    this.detail = new ScrollFrameMorph();
    this.detail.acceptsDrops = false;
    this.detail.contents.acceptsDrops = false;
    this.detail.isTextLineWrapping = true;
    this.detail.color = new Color(255, 255, 255);
    ctrl = new TextMorph("");
    ctrl.isEditable = true;
    ctrl.enableSelecting();
    ctrl.setReceiver(this.target);
    this.detail.setContents(ctrl, 2);
    this.add(this.detail);
    this.work = new ScrollFrameMorph();
    this.work.acceptsDrops = false;
    this.work.contents.acceptsDrops = false;
    this.work.isTextLineWrapping = true;
    this.work.color = new Color(255, 255, 255);
    ev = new TextMorph("");
    ev.isEditable = true;
    ev.enableSelecting();
    ev.setReceiver(this.target);
    this.work.setContents(ev, 2);
    this.add(this.work);
    this.buttonSubset = new TriggerMorph(this);
    this.buttonSubset.setLabel("show...");
    this.buttonSubset.alignCenter();
    this.buttonSubset.action = function() {
      var menu;
      menu = new MenuMorph();
      menu.addItem("attributes", (function(_this) {
        return function() {
          _this.showing = "attributes";
          return _this.buildAndConnectChildren();
        };
      })(this));
      menu.addItem("methods", (function(_this) {
        return function() {
          _this.showing = "methods";
          return _this.buildAndConnectChildren();
        };
      })(this));
      menu.addItem("all", (function(_this) {
        return function() {
          _this.showing = "all";
          return _this.buildAndConnectChildren();
        };
      })(this));
      menu.addLine();
      menu.addItem((this.markOwnershipOfProperties ? "un-mark ownership" : "mark ownership"), ((function(_this) {
        return function() {
          _this.markOwnershipOfProperties = !_this.markOwnershipOfProperties;
          return _this.buildAndConnectChildren();
        };
      })(this)), "highlight\nownership of properties");
      return menu.popUpAtHand();
    };
    this.add(this.buttonSubset);
    this.buttonInspect = new TriggerMorph(this);
    this.buttonInspect.setLabel("inspect");
    this.buttonInspect.alignCenter();
    this.buttonInspect.action = function() {
      var menu;
      if (isObject(this.currentProperty)) {
        menu = new MenuMorph();
        menu.addItem("in new inspector...", (function(_this) {
          return function() {
            var inspector, world;
            world = _this.world();
            inspector = new _this.constructor(_this.currentProperty);
            inspector.setPosition(world.hand.position());
            inspector.keepWithin(world);
            world.add(inspector);
            return inspector.changed();
          };
        })(this));
        menu.addItem("here...", (function(_this) {
          return function() {
            return _this.setTarget(_this.currentProperty);
          };
        })(this));
        return menu.popUpAtHand();
      } else {
        return this.inform((this.currentProperty === null ? "null" : typeof this.currentProperty) + "\nis not inspectable");
      }
    };
    this.add(this.buttonInspect);
    this.buttonEdit = new TriggerMorph(this);
    this.buttonEdit.setLabel("edit...");
    this.buttonEdit.alignCenter();
    this.buttonEdit.action = function() {
      var menu;
      menu = new MenuMorph(this);
      menu.addItem("save", (function() {
        return this.save();
      }), "accept changes");
      menu.addLine();
      menu.addItem("add property...", (function() {
        return this.addProperty();
      }));
      menu.addItem("rename...", (function() {
        return this.renameProperty();
      }));
      menu.addItem("remove", (function() {
        return this.removeProperty();
      }));
      return menu.popUpAtHand();
    };
    this.add(this.buttonEdit);
    this.buttonClose = new TriggerMorph(this);
    this.buttonClose.setLabel("close");
    this.buttonClose.alignCenter();
    this.buttonClose.action = function() {
      return this.destroy();
    };
    this.add(this.buttonClose);
    this.resizer = new HandleMorph(this, 150, 100, this.edge, this.edge);
    return this.layoutSubmorphs();
  };

  InspectorMorph.prototype.selectionFromList = function(selected) {
    var cnts, txt, val;
    if (selected === void 0) {
      return;
    }
    val = this.target[selected];
    if (val === void 0) {
      val = this.target.constructor[selected];
    }
    this.currentProperty = val;
    if (val === null) {
      txt = "null";
    } else if (isString(val)) {
      txt = '"' + val + '"';
    } else {
      txt = val.toString();
    }
    cnts = new TextMorph(txt);
    cnts.isEditable = true;
    cnts.enableSelecting();
    cnts.setReceiver(this.target);
    return this.detail.setContents(cnts, 2);
  };

  InspectorMorph.prototype.layoutSubmorphs = function() {
    var b, h, r, w, x, y;
    console.log("fixing the layout of the inspector");
    Morph.prototype.trackChanges = false;
    x = this.left() + this.edge;
    y = this.top() + this.edge;
    r = this.right() - this.edge;
    w = r - x;
    this.label.setPosition(new Point(x, y));
    this.label.setWidth(w);
    if (this.label.height() > (this.height() - 50)) {
      this.silentSetHeight(this.label.height() + 50);
      this.updateRendering();
      this.changed();
      this.resizer.updatePosition();
    }
    y = this.label.bottom() + 2;
    w = Math.min(Math.floor(this.width() / 3), this.list.listContents.width());
    w -= this.edge;
    b = this.bottom() - (2 * this.edge) - WorldMorph.preferencesAndSettings.handleSize;
    h = b - y;
    this.list.setPosition(new Point(x, y));
    this.list.setExtent(new Point(w, h));
    x = this.list.right() + this.edge;
    r = this.right() - this.edge;
    w = r - x;
    this.detail.setPosition(new Point(x, y));
    this.detail.setExtent(new Point(w, (h * 2 / 3) - this.edge));
    y = this.detail.bottom() + this.edge;
    this.work.setPosition(new Point(x, y));
    this.work.setExtent(new Point(w, h / 3));
    x = this.list.left();
    y = this.list.bottom() + this.edge;
    w = this.list.width();
    h = WorldMorph.preferencesAndSettings.handleSize;
    this.buttonSubset.setPosition(new Point(x, y));
    this.buttonSubset.setExtent(new Point(w, h));
    x = this.detail.left();
    w = this.detail.width() - this.edge - WorldMorph.preferencesAndSettings.handleSize;
    w = w / 3 - this.edge / 3;
    this.buttonInspect.setPosition(new Point(x, y));
    this.buttonInspect.setExtent(new Point(w, h));
    x = this.buttonInspect.right() + this.edge;
    this.buttonEdit.setPosition(new Point(x, y));
    this.buttonEdit.setExtent(new Point(w, h));
    x = this.buttonEdit.right() + this.edge;
    r = this.detail.right() - this.edge - WorldMorph.preferencesAndSettings.handleSize;
    w = r - x;
    this.buttonClose.setPosition(new Point(x, y));
    this.buttonClose.setExtent(new Point(w, h));
    Morph.prototype.trackChanges = true;
    this.changed();
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.IDLE && SystemTestsRecorderAndPlayer.alignmentOfMorphIDsMechanism) {
      return world.alignIDsOfNextMorphsInSystemTests();
    }
  };

  InspectorMorph.prototype.setExtent = function(aPoint) {
    InspectorMorph.__super__.setExtent.call(this, aPoint);
    return this.layoutSubmorphs();
  };

  InspectorMorph.prototype.save = function() {
    var err, propertyName, txt;
    txt = this.detail.contents.children[0].text.toString();
    propertyName = this.list.selected.labelString;
    try {
      this.target.evaluateString("this." + propertyName + " = " + txt);
      if (this.target.updateRendering) {
        this.target.changed();
        this.target.updateRendering();
        return this.target.changed();
      }
    } catch (_error) {
      err = _error;
      return this.inform(err);
    }
  };

  InspectorMorph.prototype.addProperty = function() {
    return this.prompt("new property name:", ((function(_this) {
      return function(prop) {
        if (prop != null) {
          if (prop.getValue != null) {
            prop = prop.getValue();
          }
          _this.target[prop] = null;
          _this.buildAndConnectChildren();
          if (_this.target.updateRendering) {
            _this.target.changed();
            _this.target.updateRendering();
            return _this.target.changed();
          }
        }
      };
    })(this)), "property");
  };

  InspectorMorph.prototype.renameProperty = function() {
    var propertyName;
    propertyName = this.list.selected.labelString;
    return this.prompt("property name:", ((function(_this) {
      return function(prop) {
        var err;
        if (prop.getValue != null) {
          prop = prop.getValue();
        }
        try {
          delete _this.target[propertyName];
          _this.target[prop] = _this.currentProperty;
        } catch (_error) {
          err = _error;
          _this.inform(err);
        }
        _this.buildAndConnectChildren();
        if (_this.target.updateRendering) {
          _this.target.changed();
          _this.target.updateRendering();
          return _this.target.changed();
        }
      };
    })(this)), propertyName);
  };

  InspectorMorph.prototype.removeProperty = function() {
    var err, propertyName;
    propertyName = this.list.selected.labelString;
    try {
      delete this.target[propertyName];
      this.currentProperty = null;
      this.buildAndConnectChildren();
      if (this.target.updateRendering) {
        this.target.changed();
        this.target.updateRendering();
        return this.target.changed();
      }
    } catch (_error) {
      err = _error;
      return this.inform(err);
    }
  };

  InspectorMorph.coffeeScriptSourceOfThisClass = '# InspectorMorph //////////////////////////////////////////////////////\n\nclass InspectorMorph extends BoxMorph\n\n  target: null\n  currentProperty: null\n  showing: "attributes"\n  markOwnershipOfProperties: false\n  # panes:\n  label: null\n  list: null\n  detail: null\n  work: null\n  buttonInspect: null\n  buttonClose: null\n  buttonSubset: null\n  buttonEdit: null\n  resizer: null\n\n  constructor: (@target) ->\n    super()\n    # override inherited properties:\n    @silentSetExtent new Point(WorldMorph.preferencesAndSettings.handleSize * 20,\n      WorldMorph.preferencesAndSettings.handleSize * 20 * 2 / 3)\n    @isDraggable = true\n    @border = 1\n    @edge = if WorldMorph.preferencesAndSettings.isFlat then 1 else 5\n    @color = new Color(60, 60, 60)\n    @borderColor = new Color(95, 95, 95)\n    @buildAndConnectChildren()  if @target\n  \n  setTarget: (target) ->\n    @target = target\n    @currentProperty = null\n    @buildAndConnectChildren()\n  \n  buildAndConnectChildren: ->\n    if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.IDLE and SystemTestsRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n    attribs = []\n    #\n    # remove existing panes\n    @destroyAll()\n\n    #\n    @children = []\n    #\n    # label\n    @label = new TextMorph(@target.toString())\n    @label.fontSize = WorldMorph.preferencesAndSettings.menuFontSize\n    @label.isBold = true\n    @label.color = new Color(255, 255, 255)\n    @add @label\n    \n    # properties list. Note that this picks up ALL properties\n    # (enumerable such as strings and un-enumerable such as functions)\n    # of the whole prototype chain.\n    #\n    #   a) some of these are DECLARED as part of the class that defines the object\n    #   and are proprietary to the object. These are shown RED\n    # \n    #   b) some of these are proprietary to the object but are initialised by\n    #   code higher in the prototype chain. These are shown GREEN\n    #\n    #   c) some of these are not proprietary, i.e. they belong to an object up\n    #   the chain of prototypes. These are shown BLUE\n    #\n    # todo: show the static methods and variables in yet another color.\n    \n    for property of @target\n      # dummy condition, to be refined\n      attribs.push property  if property\n    if @showing is "attributes"\n      attribs = attribs.filter((prop) =>\n        not isFunction @target[prop]\n      )\n    else if @showing is "methods"\n      attribs = attribs.filter((prop) =>\n        isFunction @target[prop]\n      )\n    # otherwise show all properties\n    # label getter\n    # format list\n    # format element: [color, predicate(element]\n    \n    staticProperties = Object.getOwnPropertyNames(@target.constructor)\n    # get rid of all the standar fuff properties that are in classes\n    staticProperties = staticProperties.filter((prop) =>\n        prop not in ["name","length","prototype","caller","__super__","arguments"]\n    )\n    if @showing is "attributes"\n      staticFunctions = []\n      staticAttributes = staticProperties.filter((prop) =>\n        not isFunction(@target.constructor[prop])\n      )\n    else if @showing is "methods"\n      staticFunctions = staticProperties.filter((prop) =>\n        isFunction(@target.constructor[prop])\n      )\n      staticAttributes = []\n    else\n      staticFunctions = staticProperties.filter((prop) =>\n        isFunction(@target.constructor[prop])\n      )\n      staticAttributes = staticProperties.filter((prop) =>\n        prop not in staticFunctions\n      )\n    #alert "stat fun " + staticFunctions + " stat attr " + staticAttributes\n    attribs = (attribs.concat staticFunctions).concat staticAttributes\n    #alert " all attribs " + attribs\n    \n    # caches the own methods of the object\n    if @markOwnershipOfProperties\n      targetOwnMethods = Object.getOwnPropertyNames(@target.constructor.prototype)\n      #alert targetOwnMethods\n\n    doubleClickAction = =>\n      if (!isObject(@currentProperty))\n        return\n      world = @world()\n      inspector = @constructor @currentProperty\n      inspector.setPosition world.hand.position()\n      inspector.keepWithin world\n      world.add inspector\n      inspector.changed()\n\n    @list = new ListMorph(@, InspectorMorph.prototype.selectionFromList, (if @target instanceof Array then attribs else attribs.sort()), null,(\n      if @markOwnershipOfProperties\n        [\n          # give color criteria from the most general to the most specific\n          [new Color(0, 0, 180),\n            (element) =>\n              # if the element is either an enumerable property of the object\n              # or it belongs to the own methods, then it is highlighted.\n              # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n              # functions.\n              # In theory, getOwnPropertyNames should give ALL the properties but the methods\n              # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n              true\n          ],\n          [new Color(255, 165, 0),\n            (element) =>\n              # if the element is either an enumerable property of the object\n              # or it belongs to the own methods, then it is highlighted.\n              # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n              # functions.\n              # In theory, getOwnPropertyNames should give ALL the properties but the methods\n              # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n              element in staticProperties\n          ],\n          [new Color(0, 180, 0),\n            (element) =>\n              # if the element is either an enumerable property of the object\n              # or it belongs to the own methods, then it is highlighted.\n              # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n              # functions.\n              # In theory, getOwnPropertyNames should give ALL the properties but the methods\n              # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n              (Object.prototype.hasOwnProperty.call(@target, element))\n          ],\n          [new Color(180, 0, 0),\n            (element) =>\n              # if the element is either an enumerable property of the object\n              # or it belongs to the own methods, then it is highlighted.\n              # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n              # functions.\n              # In theory, getOwnPropertyNames should give ALL the properties but the methods\n              # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n              (element in targetOwnMethods)\n          ]\n        ]\n      else null\n    ),doubleClickAction)\n\n    # we know that the content of this list in this pane is not going to need the\n    # step function, so we disable that from here by setting it to null, which\n    # prevents the recursion to children. We could have disabled that from the\n    # constructor of MenuMorph, but who knows, maybe someone might intend to use a MenuMorph\n    # with some animated content? We know that in this specific case it won\'t need animation so\n    # we set that here. Note that the ListMorph itself does require animation because of the\n    # scrollbars, but the MenuMorph (which contains the actual list contents)\n    # in this context doesn\'t.\n    @list.listContents.step = null\n    @add @list\n    #\n    # details pane\n    @detail = new ScrollFrameMorph()\n    @detail.acceptsDrops = false\n    @detail.contents.acceptsDrops = false\n    @detail.isTextLineWrapping = true\n    @detail.color = new Color(255, 255, 255)\n    ctrl = new TextMorph("")\n    ctrl.isEditable = true\n    ctrl.enableSelecting()\n    ctrl.setReceiver @target\n    @detail.setContents ctrl, 2\n    @add @detail\n    #\n    # work (\'evaluation\') pane\n    @work = new ScrollFrameMorph()\n    @work.acceptsDrops = false\n    @work.contents.acceptsDrops = false\n    @work.isTextLineWrapping = true\n    @work.color = new Color(255, 255, 255)\n    ev = new TextMorph("")\n    ev.isEditable = true\n    ev.enableSelecting()\n    ev.setReceiver @target\n    @work.setContents ev, 2\n    @add @work\n    #\n    # properties button\n    @buttonSubset = new TriggerMorph(@)\n    @buttonSubset.setLabel "show..."\n    @buttonSubset.alignCenter()\n    @buttonSubset.action = ->\n      menu = new MenuMorph()\n      menu.addItem "attributes", =>\n        @showing = "attributes"\n        @buildAndConnectChildren()\n      #\n      menu.addItem "methods", =>\n        @showing = "methods"\n        @buildAndConnectChildren()\n      #\n      menu.addItem "all", =>\n        @showing = "all"\n        @buildAndConnectChildren()\n      #\n      menu.addLine()\n      menu.addItem ((if @markOwnershipOfProperties then "un-mark ownership" else "mark ownership")), (=>\n        @markOwnershipOfProperties = not @markOwnershipOfProperties\n        @buildAndConnectChildren()\n      ), "highlight\nownership of properties"\n      menu.popUpAtHand()\n    #\n    @add @buttonSubset\n    #\n    # inspect button\n    @buttonInspect = new TriggerMorph(@)\n    @buttonInspect.setLabel "inspect"\n    @buttonInspect.alignCenter()\n    @buttonInspect.action = ->\n      if isObject(@currentProperty)\n        menu = new MenuMorph()\n        menu.addItem "in new inspector...", =>\n          world = @world()\n          inspector = new @constructor(@currentProperty)\n          inspector.setPosition world.hand.position()\n          inspector.keepWithin world\n          world.add inspector\n          inspector.changed()\n        #\n        menu.addItem "here...", =>\n          @setTarget @currentProperty\n        #\n        menu.popUpAtHand()\n      else\n        @inform ((if @currentProperty is null then "null" else typeof @currentProperty)) + "\nis not inspectable"\n    #\n    @add @buttonInspect\n    #\n    # edit button\n    @buttonEdit = new TriggerMorph(@)\n    @buttonEdit.setLabel "edit..."\n    @buttonEdit.alignCenter()\n    @buttonEdit.action = ->\n      menu = new MenuMorph(@)\n      menu.addItem "save", (->@save()), "accept changes"\n      menu.addLine()\n      menu.addItem "add property...", (->@addProperty())\n      menu.addItem "rename...", (->@renameProperty())\n      menu.addItem "remove", (->@removeProperty())\n      menu.popUpAtHand()\n    #\n    @add @buttonEdit\n    #\n    # close button\n    @buttonClose = new TriggerMorph(@)\n    @buttonClose.setLabel "close"\n    @buttonClose.alignCenter()\n    @buttonClose.action = ->\n      @destroy()\n    #\n    @add @buttonClose\n    #\n    # resizer\n    @resizer = new HandleMorph(@, 150, 100, @edge, @edge)\n    #\n    # update layout\n    @layoutSubmorphs()\n\n  selectionFromList: (selected) =>\n    if (selected == undefined) then return\n    val = @target[selected]\n    # this is for finding the static variables\n    if val is undefined\n      val = @target.constructor[selected]\n    @currentProperty = val\n    if val is null\n      txt = "null"\n    else if isString(val)\n      txt = \'"\'+val+\'"\'\n    else\n      txt = val.toString()\n    cnts = new TextMorph(txt)\n    cnts.isEditable = true\n    cnts.enableSelecting()\n    cnts.setReceiver @target\n    @detail.setContents cnts, 2\n  \n  layoutSubmorphs: ->\n    console.log "fixing the layout of the inspector"\n    Morph::trackChanges = false\n    #\n    # label\n    x = @left() + @edge\n    y = @top() + @edge\n    r = @right() - @edge\n    w = r - x\n    @label.setPosition new Point(x, y)\n    @label.setWidth w\n    if @label.height() > (@height() - 50)\n      @silentSetHeight @label.height() + 50\n      @updateRendering()\n      @changed()\n      @resizer.updatePosition()\n    #\n    # list\n    y = @label.bottom() + 2\n    w = Math.min(Math.floor(@width() / 3), @list.listContents.width())\n    w -= @edge\n    b = @bottom() - (2 * @edge) - WorldMorph.preferencesAndSettings.handleSize\n    h = b - y\n    @list.setPosition new Point(x, y)\n    @list.setExtent new Point(w, h)\n    #\n    # detail\n    x = @list.right() + @edge\n    r = @right() - @edge\n    w = r - x\n    @detail.setPosition new Point(x, y)\n    @detail.setExtent new Point(w, (h * 2 / 3) - @edge)\n    #\n    # work\n    y = @detail.bottom() + @edge\n    @work.setPosition new Point(x, y)\n    @work.setExtent new Point(w, h / 3)\n    #\n    # properties button\n    x = @list.left()\n    y = @list.bottom() + @edge\n    w = @list.width()\n    h = WorldMorph.preferencesAndSettings.handleSize\n    @buttonSubset.setPosition new Point(x, y)\n    @buttonSubset.setExtent new Point(w, h)\n    #\n    # inspect button\n    x = @detail.left()\n    w = @detail.width() - @edge - WorldMorph.preferencesAndSettings.handleSize\n    w = w / 3 - @edge / 3\n    @buttonInspect.setPosition new Point(x, y)\n    @buttonInspect.setExtent new Point(w, h)\n    #\n    # edit button\n    x = @buttonInspect.right() + @edge\n    @buttonEdit.setPosition new Point(x, y)\n    #@buttonEdit.setPosition new Point(x, y + 20)\n    @buttonEdit.setExtent new Point(w, h)\n    #\n    # close button\n    x = @buttonEdit.right() + @edge\n    r = @detail.right() - @edge - WorldMorph.preferencesAndSettings.handleSize\n    w = r - x\n    @buttonClose.setPosition new Point(x, y)\n    @buttonClose.setExtent new Point(w, h)\n    Morph::trackChanges = true\n    @changed()\n    if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.IDLE and SystemTestsRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n  \n  setExtent: (aPoint) ->\n    super aPoint\n    @layoutSubmorphs()\n  \n  \n  #InspectorMorph editing ops:\n  save: ->\n    txt = @detail.contents.children[0].text.toString()\n    propertyName = @list.selected.labelString\n    try\n      #\n      # this.target[propertyName] = evaluate(txt);\n      @target.evaluateString "this." + propertyName + " = " + txt\n      if @target.updateRendering\n        @target.changed()\n        @target.updateRendering()\n        @target.changed()\n    catch err\n      @inform err\n  \n  addProperty: ->\n    @prompt "new property name:", ((prop) =>\n      if prop?\n        if prop.getValue?\n          prop = prop.getValue()\n        @target[prop] = null\n        @buildAndConnectChildren()\n        if @target.updateRendering\n          @target.changed()\n          @target.updateRendering()\n          @target.changed()\n    ), "property" # Chrome cannot handle empty strings (others do)\n  \n  renameProperty: ->\n    propertyName = @list.selected.labelString\n    @prompt "property name:", ((prop) =>\n      if prop.getValue?\n        prop = prop.getValue()\n      try\n        delete (@target[propertyName])\n        @target[prop] = @currentProperty\n      catch err\n        @inform err\n      @buildAndConnectChildren()\n      if @target.updateRendering\n        @target.changed()\n        @target.updateRendering()\n        @target.changed()\n    ), propertyName\n  \n  removeProperty: ->\n    propertyName = @list.selected.labelString\n    try\n      delete (@target[propertyName])\n      #\n      @currentProperty = null\n      @buildAndConnectChildren()\n      if @target.updateRendering\n        @target.changed()\n        @target.updateRendering()\n        @target.changed()\n    catch err\n      @inform err';

  return InspectorMorph;

})(BoxMorph);

RectangleMorph = (function(_super) {
  __extends(RectangleMorph, _super);

  function RectangleMorph(extent, color) {
    RectangleMorph.__super__.constructor.call(this);
    if (extent != null) {
      this.silentSetExtent(extent);
    }
    if (color != null) {
      this.color = color;
    }
  }

  RectangleMorph.coffeeScriptSourceOfThisClass = '# RectangleMorph /////////////////////////////////////////////////////////\n# a plain rectangular Morph. Because it\'s so basic, it\'s the building\n# block of many more complex constructions, for example containers\n# , clipping windows, and clipping windows which allow content to be\n# scrolled (clipping is particularly easy to do along a rectangular\n# path and it allows many optimisations and it\'s a very common case)\n# It\'s important that the basic unadulterated version of\n# rectangle doesn\'t draw a border, to keep this basic\n# and versatile, so for example there is no case where the children\n# are painted over the border, which would look bad.\n\nclass RectangleMorph extends Morph\n  constructor: (extent, color) ->\n    super()\n    @silentSetExtent(extent) if extent?\n    @color = color if color?  ';

  return RectangleMorph;

})(Morph);

LayoutAdjustingMorph = (function(_super) {
  __extends(LayoutAdjustingMorph, _super);

  LayoutAdjustingMorph.prototype.hand = null;

  LayoutAdjustingMorph.prototype.indicator = null;

  function LayoutAdjustingMorph() {}

  LayoutAdjustingMorph.includeInNewMorphMenu = function() {
    return false;
  };


  /*
  adoptWidgetsColor: (paneColor) ->
    super adoptWidgetsColor paneColor
    @color = paneColord
  
  cursor: ->
    if @owner.direction == "#horizontal"
      Cursor.resizeLeft()
    else
      Cursor.resizeTop()
   */

  LayoutAdjustingMorph.coffeeScriptSourceOfThisClass = '# LayoutAdjustingMorph\n\n# this comment below is needed to figure our dependencies between classes\n\n# This is a port of the\n# respective Cuis Smalltalk classes (version 4.2-1766)\n# Cuis is by Juan Vuletich\n\n\nclass LayoutAdjustingMorph extends RectangleMorph\n\n  hand: null\n  indicator: null\n\n  constructor: ->\n\n  @includeInNewMorphMenu: ->\n    # Return true for all classes that can be instantiated from the menu\n    return false\n\n  ###\n  adoptWidgetsColor: (paneColor) ->\n    super adoptWidgetsColor paneColor\n    @color = paneColord\n\n  cursor: ->\n    if @owner.direction == "#horizontal"\n      Cursor.resizeLeft()\n    else\n      Cursor.resizeTop()\n  ###';

  return LayoutAdjustingMorph;

})(RectangleMorph);

Point = (function() {
  Point.prototype.x = null;

  Point.prototype.y = null;

  function Point(x, y) {
    this.x = x != null ? x : 0;
    this.y = y != null ? y : 0;
  }

  Point.prototype.toString = function() {
    return Math.round(this.x) + "@" + Math.round(this.y);
  };

  Point.prototype.copy = function() {
    return new this.constructor(this.x, this.y);
  };

  Point.prototype.eq = function(aPoint) {
    return this.x === aPoint.x && this.y === aPoint.y;
  };

  Point.prototype.lt = function(aPoint) {
    return this.x < aPoint.x && this.y < aPoint.y;
  };

  Point.prototype.gt = function(aPoint) {
    return this.x > aPoint.x && this.y > aPoint.y;
  };

  Point.prototype.ge = function(aPoint) {
    return this.x >= aPoint.x && this.y >= aPoint.y;
  };

  Point.prototype.le = function(aPoint) {
    return this.x <= aPoint.x && this.y <= aPoint.y;
  };

  Point.prototype.max = function(aPoint) {
    return new this.constructor(Math.max(this.x, aPoint.x), Math.max(this.y, aPoint.y));
  };

  Point.prototype.min = function(aPoint) {
    return new this.constructor(Math.min(this.x, aPoint.x), Math.min(this.y, aPoint.y));
  };

  Point.prototype.round = function() {
    return new this.constructor(Math.round(this.x), Math.round(this.y));
  };

  Point.prototype.abs = function() {
    return new this.constructor(Math.abs(this.x), Math.abs(this.y));
  };

  Point.prototype.neg = function() {
    return new this.constructor(-this.x, -this.y);
  };

  Point.prototype.mirror = function() {
    return new this.constructor(this.y, this.x);
  };

  Point.prototype.floor = function() {
    return new this.constructor(Math.max(Math.floor(this.x), 0), Math.max(Math.floor(this.y), 0));
  };

  Point.prototype.ceil = function() {
    return new this.constructor(Math.ceil(this.x), Math.ceil(this.y));
  };

  Point.prototype.add = function(other) {
    if (other instanceof Point) {
      return new this.constructor(this.x + other.x, this.y + other.y);
    }
    return new this.constructor(this.x + other, this.y + other);
  };

  Point.prototype.subtract = function(other) {
    if (other instanceof Point) {
      return new this.constructor(this.x - other.x, this.y - other.y);
    }
    return new this.constructor(this.x - other, this.y - other);
  };

  Point.prototype.multiplyBy = function(other) {
    if (other instanceof Point) {
      return new this.constructor(this.x * other.x, this.y * other.y);
    }
    return new this.constructor(this.x * other, this.y * other);
  };

  Point.prototype.divideBy = function(other) {
    if (other instanceof Point) {
      return new this.constructor(this.x / other.x, this.y / other.y);
    }
    return new this.constructor(this.x / other, this.y / other);
  };

  Point.prototype.floorDivideBy = function(other) {
    if (other instanceof Point) {
      return new this.constructor(Math.floor(this.x / other.x), Math.floor(this.y / other.y));
    }
    return new this.constructor(Math.floor(this.x / other), Math.floor(this.y / other));
  };

  Point.prototype.r = function() {
    var t;
    t = this.multiplyBy(this);
    return Math.sqrt(t.x + t.y);
  };

  Point.prototype.degrees = function() {
    var tan, theta;
    if (this.x === 0) {
      if (this.y >= 0) {
        return 90;
      }
      return 270;
    }
    tan = this.y / this.x;
    theta = Math.atan(tan);
    if (this.x >= 0) {
      if (this.y >= 0) {
        return degrees(theta);
      }
      return 360 + (degrees(theta));
    }
    return 180 + degrees(theta);
  };

  Point.prototype.theta = function() {
    var tan, theta;
    if (this.x === 0) {
      if (this.y >= 0) {
        return radians(90);
      }
      return radians(270);
    }
    tan = this.y / this.x;
    theta = Math.atan(tan);
    if (this.x >= 0) {
      if (this.y >= 0) {
        return theta;
      }
      return radians(360) + theta;
    }
    return radians(180) + theta;
  };

  Point.prototype.distanceTo = function(aPoint) {
    return (aPoint.subtract(this)).r();
  };

  Point.prototype.rotate = function(direction, center) {
    var offset;
    offset = this.subtract(center);
    if (direction === "right") {
      return new this.constructor(-offset.y, offset.y).add(center);
    }
    if (direction === "left") {
      return new this.constructor(offset.y, -offset.y).add(center);
    }
    return center.subtract(offset);
  };

  Point.prototype.flip = function(direction, center) {
    if (direction === "vertical") {
      return new this.constructor(this.x, center.y * 2 - this.y);
    }
    return new this.constructor(center.x * 2 - this.x, this.y);
  };

  Point.prototype.distanceAngle = function(dist, angle) {
    var deg, x, y;
    deg = angle;
    if (deg > 270) {
      deg = deg - 360;
    } else {
      if (deg < -270) {
        deg = deg + 360;
      }
    }
    if (-90 <= deg && deg <= 90) {
      x = Math.sin(radians(deg)) * dist;
      y = Math.sqrt((dist * dist) - (x * x));
      return new this.constructor(x + this.x, this.y - y);
    }
    x = Math.sin(radians(180 - deg)) * dist;
    y = Math.sqrt((dist * dist) - (x * x));
    return new this.constructor(x + this.x, this.y + y);
  };

  Point.prototype.scaleBy = function(scalePoint) {
    return this.multiplyBy(scalePoint);
  };

  Point.prototype.translateBy = function(deltaPoint) {
    return this.add(deltaPoint);
  };

  Point.prototype.rotateBy = function(angle, centerPoint) {
    var center, p, r, theta;
    center = centerPoint || new this.constructor(0, 0);
    p = this.subtract(center);
    r = p.r();
    theta = angle - p.theta();
    return new this.constructor(center.x + (r * Math.cos(theta)), center.y - (r * Math.sin(theta)));
  };

  Point.prototype.asArray = function() {
    return [this.x, this.y];
  };

  Point.prototype.corner = function(cornerPoint) {
    return new Rectangle(this.x, this.y, cornerPoint.x, cornerPoint.y);
  };

  Point.prototype.rectangle = function(aPoint) {
    var crn, org;
    org = this.min(aPoint);
    crn = this.max(aPoint);
    return new Rectangle(org.x, org.y, crn.x, crn.y);
  };

  Point.prototype.extent = function(aPoint) {
    var crn;
    crn = this.add(aPoint);
    return new Rectangle(this.x, this.y, crn.x, crn.y);
  };

  Point.coffeeScriptSourceOfThisClass = '# Points //////////////////////////////////////////////////////////////\n\nclass Point\n\n  x: null\n  y: null\n   \n  constructor: (@x = 0, @y = 0) ->\n  \n  # Point string representation: e.g. \'12@68\'\n  toString: ->\n    Math.round(@x) + "@" + Math.round(@y)\n  \n  # Point copying:\n  copy: ->\n    new @constructor(@x, @y)\n  \n  # Point comparison:\n  eq: (aPoint) ->\n    # ==\n    @x is aPoint.x and @y is aPoint.y\n  \n  lt: (aPoint) ->\n    # <\n    @x < aPoint.x and @y < aPoint.y\n  \n  gt: (aPoint) ->\n    # >\n    @x > aPoint.x and @y > aPoint.y\n  \n  ge: (aPoint) ->\n    # >=\n    @x >= aPoint.x and @y >= aPoint.y\n  \n  le: (aPoint) ->\n    # <=\n    @x <= aPoint.x and @y <= aPoint.y\n  \n  max: (aPoint) ->\n    new @constructor(Math.max(@x, aPoint.x), Math.max(@y, aPoint.y))\n  \n  min: (aPoint) ->\n    new @constructor(Math.min(@x, aPoint.x), Math.min(@y, aPoint.y))\n  \n  \n  # Point conversion:\n  round: ->\n    new @constructor(Math.round(@x), Math.round(@y))\n  \n  abs: ->\n    new @constructor(Math.abs(@x), Math.abs(@y))\n  \n  neg: ->\n    new @constructor(-@x, -@y)\n  \n  mirror: ->\n    new @constructor(@y, @x)\n  \n  floor: ->\n    new @constructor(Math.max(Math.floor(@x), 0), Math.max(Math.floor(@y), 0))\n  \n  ceil: ->\n    new @constructor(Math.ceil(@x), Math.ceil(@y))\n  \n  \n  # Point arithmetic:\n  add: (other) ->\n    return new @constructor(@x + other.x, @y + other.y)  if other instanceof Point\n    new @constructor(@x + other, @y + other)\n  \n  subtract: (other) ->\n    return new @constructor(@x - other.x, @y - other.y)  if other instanceof Point\n    new @constructor(@x - other, @y - other)\n  \n  multiplyBy: (other) ->\n    return new @constructor(@x * other.x, @y * other.y)  if other instanceof Point\n    new @constructor(@x * other, @y * other)\n  \n  divideBy: (other) ->\n    return new @constructor(@x / other.x, @y / other.y)  if other instanceof Point\n    new @constructor(@x / other, @y / other)\n  \n  floorDivideBy: (other) ->\n    if other instanceof Point\n      return new @constructor(Math.floor(@x / other.x), Math.floor(@y / other.y))\n    new @constructor(Math.floor(@x / other), Math.floor(@y / other))\n  \n  \n  # Point polar coordinates:\n  r: ->\n    t = (@multiplyBy(@))\n    Math.sqrt t.x + t.y\n  \n  degrees: ->\n    #\n    #    answer the angle I make with origin in degrees.\n    #    Right is 0, down is 90\n    #\n    if @x is 0\n      return 90  if @y >= 0\n      return 270\n    tan = @y / @x\n    theta = Math.atan(tan)\n    if @x >= 0\n      return degrees(theta)  if @y >= 0\n      return 360 + (degrees(theta))\n    180 + degrees(theta)\n  \n  theta: ->\n    #\n    #    answer the angle I make with origin in radians.\n    #    Right is 0, down is 90\n    #\n    if @x is 0\n      return radians(90)  if @y >= 0\n      return radians(270)\n    tan = @y / @x\n    theta = Math.atan(tan)\n    if @x >= 0\n      return theta  if @y >= 0\n      return radians(360) + theta\n    radians(180) + theta\n  \n  \n  # Point functions:\n  distanceTo: (aPoint) ->\n    (aPoint.subtract(@)).r()\n  \n  rotate: (direction, center) ->\n    # direction must be \'right\', \'left\' or \'pi\'\n    offset = @subtract(center)\n    return new @constructor(-offset.y, offset.y).add(center)  if direction is "right"\n    return new @constructor(offset.y, -offset.y).add(center)  if direction is "left"\n    #\n    # direction === \'pi\'\n    center.subtract offset\n  \n  flip: (direction, center) ->\n    # direction must be \'vertical\' or \'horizontal\'\n    return new @constructor(@x, center.y * 2 - @y)  if direction is "vertical"\n    #\n    # direction === \'horizontal\'\n    new @constructor(center.x * 2 - @x, @y)\n  \n  distanceAngle: (dist, angle) ->\n    deg = angle\n    if deg > 270\n      deg = deg - 360\n    else deg = deg + 360  if deg < -270\n    if -90 <= deg and deg <= 90\n      x = Math.sin(radians(deg)) * dist\n      y = Math.sqrt((dist * dist) - (x * x))\n      return new @constructor(x + @x, @y - y)\n    x = Math.sin(radians(180 - deg)) * dist\n    y = Math.sqrt((dist * dist) - (x * x))\n    new @constructor(x + @x, @y + y)\n  \n  \n  # Point transforming:\n  scaleBy: (scalePoint) ->\n    @multiplyBy scalePoint\n  \n  translateBy: (deltaPoint) ->\n    @add deltaPoint\n  \n  rotateBy: (angle, centerPoint) ->\n    center = centerPoint or new @constructor(0, 0)\n    p = @subtract(center)\n    r = p.r()\n    theta = angle - p.theta()\n    new @constructor(center.x + (r * Math.cos(theta)), center.y - (r * Math.sin(theta)))\n  \n  \n  # Point conversion:\n  asArray: ->\n    [@x, @y]\n  \n  # creating Rectangle instances from Points:\n  corner: (cornerPoint) ->\n    # answer a new Rectangle\n    new Rectangle(@x, @y, cornerPoint.x, cornerPoint.y)\n  \n  rectangle: (aPoint) ->\n    # answer a new Rectangle\n    org = @min(aPoint)\n    crn = @max(aPoint)\n    new Rectangle(org.x, org.y, crn.x, crn.y)\n  \n  extent: (aPoint) ->\n    #answer a new Rectangle\n    crn = @add(aPoint)\n    new Rectangle(@x, @y, crn.x, crn.y)';

  return Point;

})();

Rectangle = (function() {
  Rectangle.prototype.origin = null;

  Rectangle.prototype.corner = null;

  function Rectangle(left, top, right, bottom) {
    this.origin = new Point(left || 0, top || 0);
    this.corner = new Point(right || 0, bottom || 0);
  }

  Rectangle.prototype.toString = function() {
    return "[" + this.origin + " | " + this.extent() + "]";
  };

  Rectangle.prototype.copy = function() {
    return new this.constructor(this.left(), this.top(), this.right(), this.bottom());
  };

  Rectangle.prototype.setTo = function(left, top, right, bottom) {
    this.origin = new Point(left || (left === 0 ? 0 : this.left()), top || (top === 0 ? 0 : this.top()));
    return this.corner = new Point(right || (right === 0 ? 0 : this.right()), bottom || (bottom === 0 ? 0 : this.bottom()));
  };

  Rectangle.prototype.area = function() {
    var w;
    w = this.width();
    if (w < 0) {
      return 0;
    }
    return Math.max(w * this.height(), 0);
  };

  Rectangle.prototype.bottom = function() {
    return this.corner.y;
  };

  Rectangle.prototype.bottomCenter = function() {
    return new Point(this.center().x, this.bottom());
  };

  Rectangle.prototype.bottomLeft = function() {
    return new Point(this.origin.x, this.corner.y);
  };

  Rectangle.prototype.bottomRight = function() {
    return this.corner.copy();
  };

  Rectangle.prototype.boundingBox = function() {
    return this;
  };

  Rectangle.prototype.center = function() {
    return this.origin.add(this.corner.subtract(this.origin).floorDivideBy(2));
  };

  Rectangle.prototype.corners = function() {
    return [this.origin, this.bottomLeft(), this.corner, this.topRight()];
  };

  Rectangle.prototype.extent = function() {
    return this.corner.subtract(this.origin);
  };

  Rectangle.prototype.isEmpty = function() {
    var theExtent;
    theExtent = this.corner.subtract(this.origin);
    return theExtent.x = 0 || (theExtent.y = 0);
  };

  Rectangle.prototype.isNotEmpty = function() {
    var theExtent;
    theExtent = this.corner.subtract(this.origin);
    return theExtent.x > 0 && theExtent.y > 0;
  };

  Rectangle.prototype.height = function() {
    return this.corner.y - this.origin.y;
  };

  Rectangle.prototype.left = function() {
    return this.origin.x;
  };

  Rectangle.prototype.leftCenter = function() {
    return new Point(this.left(), this.center().y);
  };

  Rectangle.prototype.right = function() {
    return this.corner.x;
  };

  Rectangle.prototype.rightCenter = function() {
    return new Point(this.right(), this.center().y);
  };

  Rectangle.prototype.top = function() {
    return this.origin.y;
  };

  Rectangle.prototype.topCenter = function() {
    return new Point(this.center().x, this.top());
  };

  Rectangle.prototype.topLeft = function() {
    return this.origin;
  };

  Rectangle.prototype.topRight = function() {
    return new Point(this.corner.x, this.origin.y);
  };

  Rectangle.prototype.width = function() {
    return this.corner.x - this.origin.x;
  };

  Rectangle.prototype.position = function() {
    return this.origin;
  };

  Rectangle.prototype.eq = function(aRect) {
    return this.origin.eq(aRect.origin) && this.corner.eq(aRect.corner);
  };

  Rectangle.prototype.abs = function() {
    var newCorner, newOrigin;
    newOrigin = this.origin.abs();
    newCorner = this.corner.max(newOrigin);
    return newOrigin.corner(newCorner);
  };

  Rectangle.prototype.insetBy = function(delta) {
    var result;
    result = new this.constructor();
    result.origin = this.origin.add(delta);
    result.corner = this.corner.subtract(delta);
    return result;
  };

  Rectangle.prototype.expandBy = function(delta) {
    var result;
    result = new this.constructor();
    result.origin = this.origin.subtract(delta);
    result.corner = this.corner.add(delta);
    return result;
  };

  Rectangle.prototype.growBy = function(delta) {
    var result;
    result = new this.constructor();
    result.origin = this.origin.copy();
    result.corner = this.corner.add(delta);
    return result;
  };

  Rectangle.prototype.intersect = function(aRect) {
    var result;
    result = new this.constructor();
    result.origin = this.origin.max(aRect.origin);
    result.corner = this.corner.min(aRect.corner);
    return result;
  };

  Rectangle.prototype.merge = function(aRect) {
    var result;
    result = new this.constructor();
    result.origin = this.origin.min(aRect.origin);
    result.corner = this.corner.max(aRect.corner);
    return result;
  };

  Rectangle.prototype.round = function() {
    return this.origin.round().corner(this.corner.round());
  };

  Rectangle.prototype.spread = function() {
    return this.origin.floor().corner(this.corner.ceil());
  };

  Rectangle.prototype.amountToTranslateWithin = function(aRect) {
    var dx, dy;
    if (this.right() > aRect.right()) {
      dx = aRect.right() - this.right();
    }
    if (this.bottom() > aRect.bottom()) {
      dy = aRect.bottom() - this.bottom();
    }
    if ((this.left() + dx) < aRect.left()) {
      dx = aRect.left() - this.left();
    }
    if ((this.top() + dy) < aRect.top()) {
      dy = aRect.top() - this.top();
    }
    return new Point(dx, dy);
  };

  Rectangle.prototype.containsPoint = function(aPoint) {
    return this.origin.le(aPoint) && aPoint.lt(this.corner);
  };

  Rectangle.prototype.containsRectangle = function(aRect) {
    return aRect.origin.gt(this.origin) && aRect.corner.lt(this.corner);
  };

  Rectangle.prototype.intersects = function(aRect) {
    var rc, ro;
    ro = aRect.origin;
    rc = aRect.corner;
    return (rc.x >= this.origin.x) && (rc.y >= this.origin.y) && (ro.x <= this.corner.x) && (ro.y <= this.corner.y);
  };

  Rectangle.prototype.scaleBy = function(scale) {
    var c, o;
    o = this.origin.multiplyBy(scale);
    c = this.corner.multiplyBy(scale);
    return new this.constructor(o.x, o.y, c.x, c.y);
  };

  Rectangle.prototype.translateBy = function(factor) {
    var c, o;
    o = this.origin.add(factor);
    c = this.corner.add(factor);
    return new this.constructor(o.x, o.y, c.x, c.y);
  };

  Rectangle.prototype.asArray = function() {
    return [this.left(), this.top(), this.right(), this.bottom()];
  };

  Rectangle.prototype.asArray_xywh = function() {
    return [this.left(), this.top(), this.width(), this.height()];
  };

  Rectangle.coffeeScriptSourceOfThisClass = '# Rectangles //////////////////////////////////////////////////////////\n\nclass Rectangle\n\n  origin: null\n  corner: null\n  \n  constructor: (left, top, right, bottom) ->\n    \n    @origin = new Point((left or 0), (top or 0))\n    @corner = new Point((right or 0), (bottom or 0))\n  \n  \n  # Rectangle string representation: e.g. \'[0@0 | 160@80]\'\n  toString: ->\n    "[" + @origin + " | " + @extent() + "]"\n  \n  # Rectangle copying:\n  copy: ->\n    new @constructor(@left(), @top(), @right(), @bottom())\n  \n  # Rectangle accessing - setting:\n  setTo: (left, top, right, bottom) ->\n    # note: all inputs are optional and can be omitted\n    @origin = new Point(\n      left or ((if (left is 0) then 0 else @left())),\n      top or ((if (top is 0) then 0 else @top())))\n    @corner = new Point(\n      right or ((if (right is 0) then 0 else @right())),\n      bottom or ((if (bottom is 0) then 0 else @bottom())))\n  \n  # Rectangle accessing - getting:\n  area: ->\n    #requires width() and height() to be defined\n    w = @width()\n    return 0  if w < 0\n    Math.max w * @height(), 0\n  \n  bottom: ->\n    @corner.y\n  \n  bottomCenter: ->\n    new Point(@center().x, @bottom())\n  \n  bottomLeft: ->\n    new Point(@origin.x, @corner.y)\n  \n  bottomRight: ->\n    @corner.copy()\n  \n  boundingBox: ->\n    @\n  \n  center: ->\n    @origin.add @corner.subtract(@origin).floorDivideBy(2)\n  \n  corners: ->\n    [@origin, @bottomLeft(), @corner, @topRight()]\n  \n  extent: ->\n    @corner.subtract @origin\n  \n  isEmpty: ->\n    # The subtract method creates a new Point\n    theExtent = @corner.subtract @origin\n    theExtent.x = 0 or theExtent.y = 0\n\n  isNotEmpty: ->\n    # The subtract method creates a new Point\n    theExtent = @corner.subtract @origin\n    theExtent.x > 0 and theExtent.y > 0\n  \n  height: ->\n    @corner.y - @origin.y\n  \n  left: ->\n    @origin.x\n  \n  leftCenter: ->\n    new Point(@left(), @center().y)\n  \n  right: ->\n    @corner.x\n  \n  rightCenter: ->\n    new Point(@right(), @center().y)\n  \n  top: ->\n    @origin.y\n  \n  topCenter: ->\n    new Point(@center().x, @top())\n  \n  topLeft: ->\n    @origin\n  \n  topRight: ->\n    new Point(@corner.x, @origin.y)\n  \n  width: ->\n    @corner.x - @origin.x\n  \n  position: ->\n    @origin\n  \n  # Rectangle comparison:\n  eq: (aRect) ->\n    @origin.eq(aRect.origin) and @corner.eq(aRect.corner)\n  \n  abs: ->\n    newOrigin = @origin.abs()\n    newCorner = @corner.max(newOrigin)\n    newOrigin.corner newCorner\n  \n  # Rectangle functions:\n  insetBy: (delta) ->\n    # delta can be either a Point or a Number\n    result = new @constructor()\n    result.origin = @origin.add(delta)\n    result.corner = @corner.subtract(delta)\n    result\n  \n  expandBy: (delta) ->\n    # delta can be either a Point or a Number\n    result = new @constructor()\n    result.origin = @origin.subtract(delta)\n    result.corner = @corner.add(delta)\n    result\n  \n  growBy: (delta) ->\n    # delta can be either a Point or a Number\n    result = new @constructor()\n    result.origin = @origin.copy()\n    result.corner = @corner.add(delta)\n    result\n  \n  intersect: (aRect) ->\n    result = new @constructor()\n    result.origin = @origin.max(aRect.origin)\n    result.corner = @corner.min(aRect.corner)\n    result\n  \n  merge: (aRect) ->\n    result = new @constructor()\n    result.origin = @origin.min(aRect.origin)\n    result.corner = @corner.max(aRect.corner)\n    result\n  \n  round: ->\n    @origin.round().corner @corner.round()\n  \n  spread: ->\n    # round me by applying floor() to my origin and ceil() to my corner\n    @origin.floor().corner @corner.ceil()\n  \n  amountToTranslateWithin: (aRect) ->\n    #\n    #    Answer a Point, delta, such that self + delta is forced within\n    #    aRectangle. when all of me cannot be made to fit, prefer to keep\n    #    my topLeft inside. Taken from Squeak.\n    #\n    dx = aRect.right() - @right()  if @right() > aRect.right()\n    dy = aRect.bottom() - @bottom()  if @bottom() > aRect.bottom()\n    dx = aRect.left() - @left()  if (@left() + dx) < aRect.left()\n    dy = aRect.top() - @top()  if (@top() + dy) < aRect.top()\n    new Point(dx, dy)\n  \n  \n  # Rectangle testing:\n  containsPoint: (aPoint) ->\n    @origin.le(aPoint) and aPoint.lt(@corner)\n  \n  containsRectangle: (aRect) ->\n    aRect.origin.gt(@origin) and aRect.corner.lt(@corner)\n  \n  intersects: (aRect) ->\n    ro = aRect.origin\n    rc = aRect.corner\n    (rc.x >= @origin.x) and\n      (rc.y >= @origin.y) and\n      (ro.x <= @corner.x) and\n      (ro.y <= @corner.y)\n  \n  \n  # Rectangle transforming:\n  scaleBy: (scale) ->\n    # scale can be either a Point or a scalar\n    o = @origin.multiplyBy(scale)\n    c = @corner.multiplyBy(scale)\n    new @constructor(o.x, o.y, c.x, c.y)\n  \n  translateBy: (factor) ->\n    # factor can be either a Point or a scalar\n    o = @origin.add(factor)\n    c = @corner.add(factor)\n    new @constructor(o.x, o.y, c.x, c.y)\n  \n  \n  # Rectangle converting:\n  asArray: ->\n    [@left(), @top(), @right(), @bottom()]\n  \n  asArray_xywh: ->\n    [@left(), @top(), @width(), @height()]';

  return Rectangle;

})();

LayoutMorph = (function(_super) {
  __extends(LayoutMorph, _super);

  LayoutMorph.prototype.instanceVariableNames = 'direction separation padding';

  LayoutMorph.prototype.classVariableNames = '';

  LayoutMorph.prototype.poolDictionaries = '';

  LayoutMorph.prototype.category = 'Morphic-Layouts';

  LayoutMorph.prototype.direction = "";

  LayoutMorph.prototype.padding = 0;

  LayoutMorph.prototype.separation = null;

  LayoutMorph.prototype.layoutNeeded = false;

  function LayoutMorph() {
    LayoutMorph.__super__.constructor.call(this);
    this.separation = new Point(0, 0);
  }

  LayoutMorph.newColumn = function() {
    var newLayoutMorph;
    newLayoutMorph = new this();
    newLayoutMorph.beColumn();
    return newLayoutMorph;
  };

  LayoutMorph.newRow = function() {
    var newLayoutMorph;
    newLayoutMorph = new this();
    newLayoutMorph.beRow();
    return newLayoutMorph;
  };

  LayoutMorph.prototype.beColumn = function() {
    this.direction = "#vertical";
    return this.setPadding("#center");
  };

  LayoutMorph.prototype.beRow = function() {
    this.direction = "#horizontal";
    return this.setPadding = "#left";
  };

  LayoutMorph.prototype.defaultColor = function() {
    return Color.transparent();
  };

  LayoutMorph.prototype.setPadding = function(howMuchPadding) {
    switch (howMuchPadding) {
      case "#top":
        return this.padding = 0.0;
      case "#left":
        return this.padding = 0.0;
      case "#center":
        return this.padding = 0.5;
      case "#right":
        return this.padding = 1.0;
      case "#bottom":
        return this.padding = 1.0;
      default:
        return this.padding = howMuchPadding;
    }
  };

  LayoutMorph.prototype.setSeparation = function(howMuchSeparation) {
    return this.separation = howMuchSeparation;
  };

  LayoutMorph.prototype.xSeparation = function() {
    return this.separation.x;
  };

  LayoutMorph.prototype.ySeparation = function() {
    return this.separation.y;
  };

  LayoutMorph.prototype.layoutSubmorphs = function() {
    console.log("layoutSubmorphs in LayoutMorph");
    if (this.children.length === 0) {
      this.layoutNeeded = false;
      return this;
    }
    if (this.direction === "#horizontal") {
      this.layoutSubmorphsHorizontallyIn(this.bounds);
    }
    if (this.direction === "#vertical") {
      this.layoutSubmorphsVerticallyIn(this.bounds);
    }
    return this.layoutNeeded = false;
  };

  LayoutMorph.prototype.layoutSubmorphsHorizontallyIn = function(boundsForLayout) {
    var availableForPropWidth, boundsRight, boundsTop, h, i, l, ls, m, normalizationFactor, sumOfFixed, sumOfWidths, t, usableHeight, usableWidth, w, widths, xSep, ySep, _i, _ref, _results;
    xSep = this.xSeparation();
    ySep = this.ySeparation();
    usableWidth = boundsForLayout.width() - ((this.children.length + 1) * xSep);
    sumOfFixed = 0;
    this.children.forEach((function(_this) {
      return function(child) {
        if (child.layoutSpec != null) {
          if (child.layoutSpec.fixedWidth != null) {
            return sumOfFixed += child.layoutSpec.getFixedWidth();
          }
        }
      };
    })(this));
    availableForPropWidth = usableWidth - sumOfFixed;
    normalizationFactor = this.proportionalWidthNormalizationFactor();
    availableForPropWidth = availableForPropWidth * normalizationFactor;
    widths = [];
    sumOfWidths = 0;
    this.children.forEach((function(_this) {
      return function(child) {
        var theWidth;
        if (child.layoutSpec != null) {
          theWidth = child.layoutSpec.widthFor(availableForPropWidth);
          sumOfWidths += theWidth;
          return widths.push(theWidth);
        }
      };
    })(this));
    l = ((usableWidth - sumOfWidths) * this.padding + Math.max(xSep, 0)) + boundsForLayout.left();
    usableHeight = boundsForLayout.height() - Math.max(2 * ySep, 0);
    boundsTop = boundsForLayout.top();
    boundsRight = boundsForLayout.right();
    _results = [];
    for (i = _i = _ref = this.children.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
      m = this.children[i];
      w = widths[i];
      ls = m.layoutSpec;
      if (ls == null) {
        continue;
      }
      h = Math.min(usableHeight, ls.heightFor(usableHeight));
      t = (usableHeight - h) * ls.minorDirectionPadding + ySep + boundsTop;
      m.setPosition(new Point(l, t));
      m.setExtent(new Point(Math.min(w, boundsForLayout.width()), h));
      if (w > 0) {
        _results.push(l = Math.min(l + w + xSep, boundsRight));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  LayoutMorph.prototype.layoutSubmorphsVerticallyIn = function(boundsForLayout) {
    var availableForPropHeight, boundsBottom, boundsLeft, h, heights, i, l, ls, m, normalizationFactor, sumOfFixed, sumOfHeights, t, usableWidth, w, xSep, ySep, _i, _ref, _results;
    usableHeight(boundsTop(boundsRight(t | (xSep = this.xSeparation()))));
    ySep = this.ySeparation();
    usableWidth = boundsForLayout.height() - ((this.children.length + 1) * ySep);
    sumOfFixed = 0;
    this.children.forEach((function(_this) {
      return function(child) {
        if (child.layoutSpec != null) {
          if (child.layoutSpec.fixedWidth != null) {
            return sumOfFixed += child.layoutSpec.fixedHeight;
          }
        }
      };
    })(this));
    availableForPropHeight = usableHeight - sumOfFixed;
    normalizationFactor = this.proportionalHeightNormalizationFactor;
    availableForPropHeight = availableForPropHeight * normalizationFactor;
    heights = [];
    sumOfHeights = 0;
    this.children.forEach((function(_this) {
      return function(child) {
        var theHeight;
        if (child.layoutSpec != null) {
          theHeight = child.layoutSpec.heightFor(availableForPropHeight);
          sumOfHeights += theHeight;
          return heights.push(theHeight);
        }
      };
    })(this));
    t = ((usableHeight - sumOfHeights) * this.padding + Math.max(ySep, 0)) + boundsForLayout.top();
    usableWidth = boundsForLayout.width() - Math.max(2 * xSep, 0);
    boundsBottom = boundsForLayout.bottom();
    boundsLeft = boundsForLayout.left();
    _results = [];
    for (i = _i = _ref = children.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
      m = this.children[i];
      h = heights[i];
      ls = m.layoutSpec;
      w = Math.min(usableWidth, ls.widthFor(usableWidth));
      l = (usableWidth - w) * ls.minorDirectionPadding() + xSep + boundsLeft;
      m.setPosition(new Point(l, t));
      m.setExtent(Math.min(w, boundsForLayout.height()), h);
      if (h > 0) {
        _results.push(t = Math.min(t + h + ySep, boundsBottom));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  LayoutMorph.prototype.addAdjusterMorph = function() {
    var thickness;
    thickness = 4;
    if (this.direction === "#horizontal") {
      this.addMorph(new LayoutAdjustingMorph());
      this.layoutSpec = LayoutSpec.fixedWidth(thickness);
    }
    if (this.direction === "#vertical") {
      this.addMorph(new LayoutAdjustingMorph());
      return this.layoutSpec = LayoutSpec.fixedHeight(thickness);
    }
  };

  LayoutMorph.prototype.addMorphWithLayoutSpec = function(aMorph, aLayoutSpec) {
    aMorph.layoutSpec = aLayoutSpec;
    return this.addMorph(aMorph);
  };

  LayoutMorph.prototype.minPaneHeightForReframe = function() {
    return 20;
  };

  LayoutMorph.prototype.minPaneWidthForReframe = function() {
    return 40;
  };

  LayoutMorph.prototype.proportionalHeightNormalizationFactor = function() {
    var sumOfProportional;
    sumOfProportional = 0;
    this.children.forEach((function(_this) {
      return function(child) {
        if (child.layoutSpec != null) {
          return sumOfProportional += child.layoutSpec.proportionalHeight();
        }
      };
    })(this));
    return 1.0 / Math.max(sumOfProportional, 1.0);
  };

  LayoutMorph.prototype.proportionalWidthNormalizationFactor = function() {
    var sumOfProportional;
    sumOfProportional = 0;
    this.children.forEach((function(_this) {
      return function(child) {
        if (child.layoutSpec != null) {
          return sumOfProportional += child.layoutSpec.getProportionalWidth();
        }
      };
    })(this));
    return 1.0 / Math.max(sumOfProportional, 1.0);
  };

  LayoutMorph.prototype.adjustByAt = function(aLayoutAdjustMorph, aPoint) {
    if (this.direction === "#horizontal") {
      this.adjustHorizontallyByAt(aLayoutAdjustMorph, aPoint);
    }
    if (this.direction === "#vertical") {
      return this.adjustVerticallyByAt(aLayoutAdjustMorph, aPoint);
    }
  };

  LayoutMorph.prototype.adjustHorizontallyByAt = function(aLayoutAdjustMorph, aPoint) {
    var delta, doNotResizeBelow, i, l, lCurrentWidth, lNewWidth, ls, r, rCurrentWidth, rNewWidth, rs;
    doNotResizeBelow = this.minPaneWidthForReframe;
    i = this.children[aLayoutAdjustMorph];
    l = this.children[i + 1];
    ls = l.layoutSpec;
    lCurrentWidth = Math.max(l.morphWidth(), 1);
    r = this.children[i - 1];
    rs = r.layoutSpec;
    rCurrentWidth = Math.max(r.morphWidth(), 1);
    delta = aPoint.x - aLayoutAdjustMorph.position().x;
    delta = Math.max(delta, doNotResizeBelow - lCurrentWidth);
    delta = Math.min(delta, rCurrentWidth - doNotResizeBelow);
    if (delta === 0) {
      return this;
    }
    rNewWidth = rCurrentWidth - delta;
    lNewWidth = lCurrentWidth + delta;
    if (ls.isProportionalWidth() && rs.isProportionalWidth()) {
      ls.setProportionalWidth(1.0 * lNewWidth / lCurrentWidth * ls.proportionalWidth());
      rs.setProportionalWidth(1.0 * rNewWidth / rCurrentWidth * rs.proportionalWidth());
    } else {
      if (!ls.isProportionalWidth()) {
        ls.fixedOrMorphWidth(lNewWidth);
      }
      if (!rs.isProportionalWidth()) {
        rs.fixedOrMorphWidth(rNewWidth);
      }
    }
    return this.layoutSubmorphs();
  };

  LayoutMorph.prototype.adjustVerticallyByAt = function(aLayoutAdjustMorph, aPoint) {
    var b, bCurrentHeight, bNewHeight, bs, delta, doNotResizeBelow, i, t, tCurrentHeight, tNewHeight, ts;
    doNotResizeBelow = this.minPaneHeightForReframe();
    i = this.children[aLayoutAdjustMorph];
    t = this.children[i + 1];
    ts = t.layoutSpec();
    tCurrentHeight = Math.max(t.morphHeight(), 1);
    b = this.children[i - 1];
    bs = b.layoutSpec;
    bCurrentHeight = Math.max(b.morphHeight(), 1);
    delta = aPoint.y - aLayoutAdjustMorph.position().y;
    delta = Math.max(delta, doNotResizeBelow - tCurrentHeight);
    delta = Math.min(delta, bCurrentHeight - doNotResizeBelow);
    if (delta === 0) {
      return this;
    }
    tNewHeight = tCurrentHeight + delta;
    bNewHeight = bCurrentHeight - delta;
    if (ts.isProportionalHeight() && bs.isProportionalHeight()) {
      ts.setProportionalHeight(1.0 * tNewHeight / tCurrentHeight * ts.proportionalHeight());
      bs.setProportionalHeight(1.0 * bNewHeight / bCurrentHeight * bs.proportionalHeight());
    } else {
      if (!ts.isProportionalHeight()) {
        ts.fixedOrMorphHeight(tNewHeight);
      }
      if (!bs.isProportionalHeight()) {
        bs.fixedOrMorphHeight(bNewHeight);
      }
    }
    return this.layoutSubmorphs();
  };

  LayoutMorph.prototype.addAdjusterAndMorphFixedHeight = function(aMorph, aNumber) {
    return this.addAdjusterAndMorphLayoutSpec(aMorph, LayoutSpec.newWithFixedHeight(aNumber));
  };

  LayoutMorph.prototype.addAdjusterAndMorphLayoutSpec = function(aMorph, aLayoutSpec) {
    this.addAdjusterMorph();
    return this.addMorphLayoutSpec(aMorph, aLayoutSpec);
  };

  LayoutMorph.prototype.addAdjusterAndMorphProportionalHeight = function(aMorph, aNumber) {
    return this.addAdjusterAndMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalHeight(aNumber));
  };

  LayoutMorph.prototype.addAdjusterAndMorphProportionalWidth = function(aMorph, aNumber) {
    return this.addAdjusterAndMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalWidth(aNumber));
  };

  LayoutMorph.prototype.addMorphFixedHeight = function(aMorph, aNumber) {
    return this.addMorphLayoutSpec(aMorph, LayoutSpec.newWithFixedHeight(aNumber));
  };

  LayoutMorph.prototype.addMorphFixedWidth = function(aMorph, aNumber) {
    return this.addMorphLayoutSpec(aMorph, LayoutSpec.newWithFixedWidth(aNumber));
  };

  LayoutMorph.prototype.addMorphLayoutSpec = function(aMorph, aLayoutSpec) {
    aMorph.layoutSpec = aLayoutSpec;
    return this.add(aMorph);
  };

  LayoutMorph.prototype.addMorphProportionalHeight = function(aMorph, aNumber) {
    return this.addMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalHeight(aNumber));
  };

  LayoutMorph.prototype.addMorphProportionalWidth = function(aMorph, aNumber) {
    return this.addMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalWidth(aNumber));
  };

  LayoutMorph.prototype.addMorphUseAll = function(aMorph) {
    return this.addMorphLayoutSpec(aMorph, LayoutSpec.useAll());
  };

  LayoutMorph.prototype.addMorphs = function(morphs) {
    return morphs.forEach((function(_this) {
      return function(morph) {
        return _this.addMorphProportionalWidth(m, 1);
      };
    })(this));
  };

  LayoutMorph.prototype.addMorphsWidthProportionalTo = function(morphs, widths) {
    return morphs.forEach((function(_this) {
      return function(morph) {
        return _this.addMorphProportionalWidth(m, w);
      };
    })(this));
  };

  LayoutMorph.prototype.is = function(aSymbol) {
    return aSymbol === "#LayoutMorph";
  };

  LayoutMorph.test1 = function() {
    var handle, rect1, rect2, row;
    rect1 = new RectangleMorph(new Point(20, 20), new Color(255, 0, 0));
    rect2 = new RectangleMorph(new Point(20, 20), new Color(0, 255, 0));
    row = LayoutMorph.newRow();
    row.addMorphProportionalWidth(rect1, 2);
    row.addMorphProportionalWidth(rect2, 1);
    row.layoutSubmorphs();
    row.setPosition(world.hand.position());
    row.keepWithin(world);
    world.add(row);
    row.changed();
    handle = new HandleMorph();
    handle.isDraggable = false;
    handle.target = row;
    handle.updateRendering();
    return handle.noticesTransparentClick = true;
  };

  LayoutMorph.test2 = function() {
    var handle, rect3, rect4, row2;
    rect3 = new RectangleMorph(new Point(20, 20), new Color(255, 0, 0));
    rect4 = new RectangleMorph(new Point(20, 20), new Color(0, 255, 0));
    row2 = LayoutMorph.newRow();
    row2.addMorphFixedWidth(rect3, 10);
    row2.addMorphProportionalWidth(rect4, 1);
    row2.layoutSubmorphs();
    row2.setPosition(world.hand.position());
    row2.keepWithin(world);
    world.add(row2);
    row2.changed();
    handle = new HandleMorph();
    handle.isDraggable = false;
    handle.target = row2;
    handle.updateRendering();
    return handle.noticesTransparentClick = true;
  };

  LayoutMorph.test3 = function() {
    var handle, rect5, rect6, rect7, row3;
    rect5 = new RectangleMorph(new Point(20, 20), new Color(255, 0, 0));
    rect6 = new RectangleMorph(new Point(20, 20), new Color(0, 255, 0));
    rect7 = new RectangleMorph(new Point(20, 20), new Color(0, 0, 255));
    row3 = LayoutMorph.newRow();
    row3.addMorphProportionalWidth(rect6, 2);
    row3.addMorphFixedWidth(rect5, 10);
    row3.addMorphProportionalWidth(rect7, 1);
    row3.layoutSubmorphs();
    row3.setPosition(world.hand.position());
    row3.keepWithin(world);
    world.add(row3);
    row3.changed();
    handle = new HandleMorph();
    handle.isDraggable = false;
    handle.target = row3;
    handle.updateRendering();
    return handle.noticesTransparentClick = true;
  };

  LayoutMorph.test4 = function() {
    var handle, rect5, rect6, rect7, row3;
    rect5 = new RectangleMorph(new Point(20, 20), new Color(255, 0, 0));
    rect6 = new RectangleMorph(new Point(20, 20), new Color(0, 255, 0));
    rect7 = new RectangleMorph(new Point(20, 20), new Color(0, 0, 255));
    row3 = LayoutMorph.newRow();
    row3.addMorphProportionalHeight(rect6, 0.5);
    row3.addMorphFixedHeight(rect5, 200);
    row3.addMorphProportionalHeight(rect7, 1.1);
    row3.layoutSubmorphs();
    row3.setPosition(world.hand.position());
    row3.keepWithin(world);
    world.add(row3);
    row3.changed();
    handle = new HandleMorph();
    handle.isDraggable = false;
    handle.target = row3;
    handle.updateRendering();
    return handle.noticesTransparentClick = true;
  };

  LayoutMorph.coffeeScriptSourceOfThisClass = '# LayoutMorph\n\n# this comment below is needed to figure our dependencies between classes\n# REQUIRES Color\n# REQUIRES Point\n# REQUIRES Rectangle\n\n# This is a port of the\n# respective Cuis Smalltalk classes (version 4.2-1766)\n# Cuis is by Juan Vuletich\n\n# A row or column of widgets, does layout by placing\n# them either horizontally or vertically.\n\n# Submorphs might specify a LayoutSpec.\n# If some don\'t, then, for a column, the column\n# width is taken as the width, and any morph height\n# is kept. Same for rows: submorph width would be\n# maintained, and submorph height would be made\n# equal to row height.\n\nclass LayoutMorph extends Morph\n\n  instanceVariableNames: \'direction separation padding\'\n  classVariableNames: \'\'\n  poolDictionaries: \'\'\n  category: \'Morphic-Layouts\'\n\n  direction: ""\n  padding: 0\n  separation: null # contains a Point\n  layoutNeeded: false\n\n  constructor: ->\n    super()\n    @separation = new Point 0,0\n  \n  @newColumn: ->\n    newLayoutMorph =  new @()\n    newLayoutMorph.beColumn()\n    return newLayoutMorph\n\n  @newRow: ->\n    #debugger\n    newLayoutMorph =  new @()\n    newLayoutMorph.beRow()\n    return newLayoutMorph\n\n  beColumn: ->\n    @direction = "#vertical"\n    @setPadding "#center"\n\n  beRow: ->\n    @direction = "#horizontal"\n    @setPadding= "#left"\n\n  defaultColor: ->\n    return Color.transparent()\n\n  # This sets how extra space is used when doing layout.\n  # For example, a column might have extra , unneded\n  # vertical space. #top means widgets are set close\n  # to the top, and extra space is at bottom. Conversely,\n  # #bottom means widgets are set close to the bottom,\n  # and extra space is at top. Valid values include\n  # #left and #right (for rows) and #center. Alternatively,\n  # any number between 0.0 and 1.0 might be used.\n  #   self new padding: #center\n  #   self new padding: 0.9\n  setPadding: (howMuchPadding) ->\n    switch howMuchPadding\n      when "#top" then @padding = 0.0\n      when "#left" then @padding = 0.0\n      when "#center" then @padding = 0.5\n      when "#right" then @padding = 1.0\n      when "#bottom" then @padding = 1.0\n      else @padding = howMuchPadding\n\n  setSeparation: (howMuchSeparation) ->\n    @separation = howMuchSeparation\n\n  xSeparation: ->\n    return @separation.x\n\n  ySeparation: ->\n    return @separation.y\n\n  # Compute a new layout based on the given layout bounds\n  layoutSubmorphs: ->\n    console.log "layoutSubmorphs in LayoutMorph"\n    #debugger\n    if @children.length == 0\n      @layoutNeeded = false\n      return @\n\n    if @direction == "#horizontal"\n      @layoutSubmorphsHorizontallyIn @bounds\n\n    if @direction == "#vertical"\n      @layoutSubmorphsVerticallyIn @bounds\n\n    @layoutNeeded = false\n\n  # Compute a new layout based on the given layout bounds.\n  layoutSubmorphsHorizontallyIn: (boundsForLayout) ->\n    #| xSep ySep usableWidth sumOfFixed normalizationFactor availableForPropWidth widths l usableHeight boundsTop boundsRight t |\n    xSep = @xSeparation()\n    ySep = @ySeparation()\n    usableWidth = boundsForLayout.width() - ((@children.length + 1) * xSep)\n    sumOfFixed = 0\n    @children.forEach (child) =>\n      if child.layoutSpec?\n        if child.layoutSpec.fixedWidth?\n          sumOfFixed += child.layoutSpec.getFixedWidth()\n    availableForPropWidth = usableWidth - sumOfFixed\n    normalizationFactor = @proportionalWidthNormalizationFactor()\n    availableForPropWidth = availableForPropWidth * normalizationFactor\n    widths = []\n    sumOfWidths = 0\n    @children.forEach (child) =>\n      if child.layoutSpec?\n        #debugger\n        theWidth = child.layoutSpec.widthFor availableForPropWidth\n        sumOfWidths += theWidth\n        widths.push theWidth\n    l = ((usableWidth - sumOfWidths) * @padding + Math.max(xSep, 0)) +  boundsForLayout.left()\n    usableHeight = boundsForLayout.height() - Math.max(2*ySep,0)\n    boundsTop = boundsForLayout.top()\n    boundsRight = boundsForLayout.right()\n    for i in [@children.length-1 .. 0]\n      m = @children[i]\n      # major direction\n      w = widths[i]\n      # minor direction\n      ls = m.layoutSpec\n      if not ls?\n        # there might be submorphs that don\'t have a layout.\n        # for example, currently, the HandleMorph can be attached\n        # to the LayoutMorph without a layoutSpec.\n        # just skip those. The HandleMorph does its own\n        # layouting.\n        continue\n      h = Math.min(usableHeight, ls.heightFor(usableHeight))\n      t = (usableHeight - h) * ls.minorDirectionPadding + ySep + boundsTop\n      # Set bounds and adjust major direction for next step\n      # self flag: #jmvVer2.\n      # should extent be set in m\'s coordinate system? what if its scale is not 1?\n      m.setPosition(new Point(l,t))\n      #debugger\n      m.setExtent(new Point(Math.min(w,boundsForLayout.width()),h))\n      if w>0\n        l = Math.min(l + w + xSep, boundsRight)\n\n  # this is the symmetric of the previous method\n  layoutSubmorphsVerticallyIn: (boundsForLayout) ->\n    usableHeight boundsTop boundsRight t |\n    xSep = @xSeparation()\n    ySep = @ySeparation()\n    usableWidth = boundsForLayout.height() - ((@children.length + 1) * ySep)\n    sumOfFixed = 0\n    @children.forEach (child) =>\n      if child.layoutSpec?\n        if child.layoutSpec.fixedWidth?\n          sumOfFixed += child.layoutSpec.fixedHeight\n    availableForPropHeight = usableHeight - sumOfFixed\n    normalizationFactor = @proportionalHeightNormalizationFactor\n    availableForPropHeight = availableForPropHeight * normalizationFactor\n    heights = []\n    sumOfHeights = 0\n    @children.forEach (child) =>\n      if child.layoutSpec?\n        theHeight = child.layoutSpec.heightFor availableForPropHeight\n        sumOfHeights += theHeight\n        heights.push theHeight\n    t = ((usableHeight - sumOfHeights) * @padding + Math.max(ySep, 0)) +  boundsForLayout.top()\n    usableWidth = boundsForLayout.width() - Math.max(2*xSep,0)\n    boundsBottom = boundsForLayout.bottom()\n    boundsLeft = boundsForLayout.left()\n    for i in [children.length-1 .. 0]\n      m = @children[i]\n      # major direction\n      h = heights[i]\n      # minor direction\n      ls = m.layoutSpec\n      w = Math.min(usableWidth, ls.widthFor(usableWidth))\n      l = (usableWidth - w) * ls.minorDirectionPadding() + xSep + boundsLeft\n      # Set bounds and adjust major direction for next step\n      # self flag: #jmvVer2.\n      # should extent be set in m\'s coordinate system? what if its scale is not 1?\n      m.setPosition(new Point(l,t))\n      m.setExtent(Math.min(w,boundsForLayout.height()),h)\n      if h>0\n        t = Math.min(t + h + ySep, boundsBottom)\n\n  # So the user can adjust layout\n  addAdjusterMorph: ->\n    thickness = 4\n\n    if @direction == "#horizontal"\n      @addMorph( new LayoutAdjustingMorph() )\n      @layoutSpec = LayoutSpec.fixedWidth(thickness)\n\n    if @direction == "#vertical"\n      @addMorph( new LayoutAdjustingMorph() )\n      @layoutSpec = LayoutSpec.fixedHeight(thickness)\n\n  #"Add a submorph, at the bottom or right, with aLayoutSpec"\n  addMorphWithLayoutSpec: (aMorph, aLayoutSpec) ->\n    aMorph.layoutSpec = aLayoutSpec\n    @addMorph aMorph\n\n  minPaneHeightForReframe: ->\n    return 20\n\n  minPaneWidthForReframe: ->\n    return 40\n\n  proportionalHeightNormalizationFactor: ->\n    sumOfProportional = 0\n    @children.forEach (child) =>\n      if child.layoutSpec?\n        sumOfProportional += child.layoutSpec.proportionalHeight()\n    return 1.0/Math.max(sumOfProportional, 1.0)\n\n  proportionalWidthNormalizationFactor: ->\n    sumOfProportional = 0\n    @children.forEach (child) =>\n      if child.layoutSpec?\n        sumOfProportional += child.layoutSpec.getProportionalWidth()\n    return 1.0/Math.max(sumOfProportional, 1.0)\n\n  adjustByAt: (aLayoutAdjustMorph, aPoint) ->\n    if @direction == "#horizontal"\n      @adjustHorizontallyByAt aLayoutAdjustMorph, aPoint\n\n    if @direction == "#vertical"\n      @adjustVerticallyByAt aLayoutAdjustMorph, aPoint\n\n  adjustHorizontallyByAt: (aLayoutAdjustMorph, aPoint) ->\n    # | delta l ls r rs lNewWidth rNewWidth i lCurrentWidth rCurrentWidth doNotResizeBelow |\n    doNotResizeBelow =  @minPaneWidthForReframe\n    i = @children[aLayoutAdjustMorph]\n    l = @children[i+1]\n    ls = l.layoutSpec\n    lCurrentWidth = Math.max(l.morphWidth(),1) # avoid division by zero\n    r = @children[i - 1]\n    rs = r.layoutSpec\n    rCurrentWidth = Math.max(r.morphWidth(),1) # avoid division by zero\n    delta = aPoint.x - aLayoutAdjustMorph.position().x\n    delta = Math.max(delta, doNotResizeBelow - lCurrentWidth)\n    delta = Math.min(delta, rCurrentWidth - doNotResizeBelow)\n    if delta == 0 then return @\n    rNewWidth = rCurrentWidth - delta\n    lNewWidth = lCurrentWidth + delta\n    if ls.isProportionalWidth() and rs.isProportionalWidth()\n      # If both proportional, update them\n      ls.setProportionalWidth 1.0 * lNewWidth / lCurrentWidth * ls.proportionalWidth()\n      rs.setProportionalWidth 1.0 * rNewWidth / rCurrentWidth * rs.proportionalWidth()\n    else\n      # If at least one is fixed, update only the fixed\n      if !ls.isProportionalWidth()\n          ls.fixedOrMorphWidth lNewWidth\n      if !rs.isProportionalWidth()\n          rs.fixedOrMorphWidth rNewWidth\n    @layoutSubmorphs()\n\n  adjustVerticallyByAt: (aLayoutAdjustMorph, aPoint) ->\n    # | delta t ts b bs tNewHeight bNewHeight i tCurrentHeight bCurrentHeight doNotResizeBelow |\n    doNotResizeBelow = @minPaneHeightForReframe()\n    i = @children[aLayoutAdjustMorph]\n    t = @children[i+1]\n    ts = t.layoutSpec()\n    tCurrentHeight = Math.max(t.morphHeight(),1) # avoid division by zero\n    b = @children[i - 1]\n    bs = b.layoutSpec\n    bCurrentHeight = Math.max(b.morphHeight(),1) # avoid division by zero\n    delta = aPoint.y - aLayoutAdjustMorph.position().y\n    delta = Math.max(delta, doNotResizeBelow - tCurrentHeight)\n    delta = Math.min(delta, bCurrentHeight - doNotResizeBelow)\n    if delta == 0 then return @\n    tNewHeight = tCurrentHeight + delta\n    bNewHeight = bCurrentHeight - delta\n    if ts.isProportionalHeight() and bs.isProportionalHeight()\n      # If both proportional, update them\n      ts.setProportionalHeight 1.0 * tNewHeight / tCurrentHeight * ts.proportionalHeight()\n      bs.setProportionalHeight 1.0 * bNewHeight / bCurrentHeight * bs.proportionalHeight()\n    else\n      # If at least one is fixed, update only the fixed\n      if !ts.isProportionalHeight()\n          ts.fixedOrMorphHeight tNewHeight\n      if !bs.isProportionalHeight()\n          bs.fixedOrMorphHeight bNewHeight\n    @layoutSubmorphs()\n\n  #####################\n  # convenience methods\n  #####################\n\n  addAdjusterAndMorphFixedHeight: (aMorph,aNumber) ->\n    @addAdjusterAndMorphLayoutSpec(aMorph, LayoutSpec.newWithFixedHeight aNumber)\n\n  addAdjusterAndMorphLayoutSpec: (aMorph, aLayoutSpec) ->\n    #Add a submorph, at the bottom or right, with aLayoutSpec"\n    @addAdjusterMorph()\n    @addMorphLayoutSpec(aMorph, aLayoutSpec)\n\n  addAdjusterAndMorphProportionalHeight: (aMorph, aNumber) ->\n    @addAdjusterAndMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalHeight(aNumber))\n\n  addAdjusterAndMorphProportionalWidth: (aMorph, aNumber) ->\n    @addAdjusterAndMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalWidth(aNumber))\n\n  addMorphFixedHeight: (aMorph, aNumber) ->\n    @addMorphLayoutSpec(aMorph, LayoutSpec.newWithFixedHeight(aNumber))\n\n  addMorphFixedWidth: (aMorph, aNumber) ->\n    @addMorphLayoutSpec(aMorph, LayoutSpec.newWithFixedWidth(aNumber))\n\n  addMorphLayoutSpec: (aMorph, aLayoutSpec) ->\n    # Add a submorph, at the bottom or right, with aLayoutSpec\n    aMorph.layoutSpec = aLayoutSpec\n    @add aMorph\n\n  addMorphProportionalHeight: (aMorph, aNumber) ->\n    @addMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalHeight(aNumber))\n\n  addMorphProportionalWidth: (aMorph, aNumber) ->\n    @addMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalWidth(aNumber))\n\n  addMorphUseAll: (aMorph) ->\n    @addMorphLayoutSpec(aMorph, LayoutSpec.useAll())\n\n  addMorphs: (morphs) ->\n    morphs.forEach (morph) =>\n      @addMorphProportionalWidth(m,1)\n\n  addMorphsWidthProportionalTo: (morphs, widths) ->\n    morphs.forEach (morph) =>\n      @addMorphProportionalWidth(m,w)\n\n  # unclear how to translate this one for the time being\n  is: (aSymbol) ->\n    return aSymbol == "#LayoutMorph" # or [ super is: aSymbol ]\n\n  @test1: ->\n    rect1 = new RectangleMorph(new Point(20,20), new Color(255,0,0));\n    rect2 = new RectangleMorph(new Point(20,20), new Color(0,255,0));\n    row = LayoutMorph.newRow()\n    row.addMorphProportionalWidth(rect1,2)\n    row.addMorphProportionalWidth(rect2,1)\n    row.layoutSubmorphs()\n    row.setPosition(world.hand.position());\n    row.keepWithin(world);\n    world.add(row);\n    row.changed();\n\n    # attach a HandleMorph to it so that\n    # we can check how it resizes\n    handle = new HandleMorph()\n    handle.isDraggable = false\n    handle.target = row\n    handle.updateRendering()\n    handle.noticesTransparentClick = true\n\n  @test2: ->\n    rect3 = new RectangleMorph(new Point(20,20), new Color(255,0,0));\n    rect4 = new RectangleMorph(new Point(20,20), new Color(0,255,0));\n    row2 = LayoutMorph.newRow()\n    row2.addMorphFixedWidth(rect3,10)\n    row2.addMorphProportionalWidth(rect4,1)\n    row2.layoutSubmorphs()\n    row2.setPosition(world.hand.position());\n    row2.keepWithin(world);\n    world.add(row2);\n    row2.changed();\n\n    # attach a HandleMorph to it so that\n    # we can check how it resizes\n    handle = new HandleMorph()\n    handle.isDraggable = false\n    handle.target = row2\n    handle.updateRendering()\n    handle.noticesTransparentClick = true\n\n  @test3: ->\n    rect5 = new RectangleMorph(new Point(20,20), new Color(255,0,0));\n    rect6 = new RectangleMorph(new Point(20,20), new Color(0,255,0));\n    rect7 = new RectangleMorph(new Point(20,20), new Color(0,0,255));\n    row3 = LayoutMorph.newRow()\n    row3.addMorphProportionalWidth(rect6,2)\n    row3.addMorphFixedWidth(rect5,10)\n    row3.addMorphProportionalWidth(rect7,1)\n    row3.layoutSubmorphs()\n    row3.setPosition(world.hand.position());\n    row3.keepWithin(world);\n    world.add(row3);\n    row3.changed();\n\n    # attach a HandleMorph to it so that\n    # we can check how it resizes\n    handle = new HandleMorph()\n    handle.isDraggable = false\n    handle.target = row3\n    handle.updateRendering()\n    handle.noticesTransparentClick = true\n\n  @test4: ->\n    # //////////////////////////////////////////////////\n    # note how the vertical spacing in the horizontal layout\n    # is different. the vertical size is not adjusted considering\n    # all other morphs. A proportional of 1.1 is proportional to the\n    # container, not to the other layouts.\n    # Equivalent smalltalk code:\n    # | pane rect1 rect2 |\n    # pane _ LayoutMorph newRow separation: 5. "3"\n    # pane addMorph: (StringMorph contents: \'3\').\n    # \n    # rect1 := BorderedRectMorph new color: (Color lightOrange).\n    # pane addMorph: rect1 \n    #          layoutSpec: (LayoutSpec  fixedWidth: 20 proportionalHeight: 1.1 minorDirectionPadding: #center).\n    # rect2 := BorderedRectMorph new color: (Color cyan);\n    #   layoutSpec: (LayoutSpec  fixedWidth: 20 proportionalHeight: 0.5 minorDirectionPadding: #center).\n    # pane addMorph: rect2.\n    # pane\n    #   color: Color lightGreen;\n    #   openInWorld;\n    #   morphPosition: 520 @ 50;\n    #   morphExtent: 180 @ 100\n    # //////////////////////////////////////////////////\n\n    rect5 = new RectangleMorph(new Point(20,20), new Color(255,0,0));\n    rect6 = new RectangleMorph(new Point(20,20), new Color(0,255,0));\n    rect7 = new RectangleMorph(new Point(20,20), new Color(0,0,255));\n    row3 = LayoutMorph.newRow()\n    row3.addMorphProportionalHeight(rect6,0.5)\n    row3.addMorphFixedHeight(rect5,200)\n    row3.addMorphProportionalHeight(rect7,1.1)\n    row3.layoutSubmorphs()\n    row3.setPosition(world.hand.position());\n    row3.keepWithin(world);\n    world.add(row3);\n    row3.changed();\n\n    # attach a HandleMorph to it so that\n    # we can check how it resizes\n    handle = new HandleMorph()\n    handle.isDraggable = false\n    handle.target = row3\n    handle.updateRendering()\n    handle.noticesTransparentClick = true #';

  return LayoutMorph;

})(Morph);

LayoutSpec = (function() {
  LayoutSpec.prototype.morph = null;

  LayoutSpec.prototype.minorDirectionPadding = 0.5;

  LayoutSpec.prototype.fixedWidth = 0;

  LayoutSpec.prototype.fixedHeight = 0;

  LayoutSpec.prototype.proportionalWidth = 1.0;

  LayoutSpec.prototype.proportionalHeight = 1.0;

  function LayoutSpec() {}

  LayoutSpec.newWithFixedExtent = function(aPoint) {
    return this.newWithFixedWidthFixedHeight(aPoint.x, aPoint.y);
  };

  LayoutSpec.newWithFixedHeight = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setFixedHeight(aNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithFixedWidth = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setFixedWidth(aNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithFixedWidthFixedHeight = function(aNumber, otherNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setFixedWidth(aNumber);
    layoutSpec.setFixedHeight(otherNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithFixedWidthFixedHeightMinorDirectionPadding = function(aNumber, otherNumber, aSymbolOrNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setFixedWidth(aNumber);
    layoutSpec.setFixedHeight(otherNumber);
    layoutSpec.setMinorDirectionPadding(aSymbolOrNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithFixedWidthProportionalHeight = function(aNumber, otherNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setFixedWidth(aNumber);
    layoutSpec.setProportionalHeight(otherNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithFixedWidthProportionalHeightMinorDirectionPadding = function(aNumber, otherNumber, aSymbolOrNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setFixedWidth(aNumber);
    layoutSpec.setProportionalHeight(otherNumber);
    layoutSpec.setMinorDirectionPadding(aSymbolOrNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithKeepMorphExtent = function() {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.useMorphWidth;
    layoutSpec.useMorphHeight;
    return layoutSpec;
  };

  LayoutSpec.newWithMorphHeightFixedWidth = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setFixedWidth(aNumber);
    layoutSpec.useMorphHeight;
    return layoutSpec;
  };

  LayoutSpec.newWithMorphHeightProportionalWidth = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setProportionalWidth(aNumber);
    layoutSpec.useMorphHeight();
    return layoutSpec;
  };

  LayoutSpec.newWithMorphWidthFixedHeight = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.useMorphWidth();
    layoutSpec.setFixedHeight(aNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithMorphWidthProportionalHeight = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.useMorphWidth();
    layoutSpec.setProportionalHeight(aNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithProportionalHeight = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setProportionalHeight(aNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithProportionalWidth = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setProportionalWidth(aNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithProportionalWidthFixedHeight = function(aNumber, otherNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setProportionalWidth(aNumber);
    layoutSpec.setFixedHeight(otherNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithProportionalWidthFixedHeightMinorDirectionPadding = function(aNumber, otherNumber, aSymbolOrNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setProportionalWidth(aNumber);
    layoutSpec.setFixedHeight(otherNumber);
    layoutSpec.setMinorDirectionPadding(aSymbolOrNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithProportionalWidthProportionalHeight = function(aNumber, otherNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setProportionalWidth(aNumber);
    layoutSpec.setProportionalHeight(otherNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithProportionalWidthProportionalHeightMinorDirectionPadding = function(aNumber, otherNumber, aSymbolOrNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setProportionalWidth(aNumber);
    layoutSpec.setProportionalHeight(otherNumber);
    layoutSpec.setMinorDirectionPadding(aSymbolOrNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithUseAll = function() {
    return new this();
  };

  LayoutSpec.prototype.setFixedHeight = function(aNumber) {
    this.fixedHeight = aNumber;
    return this.proportionalHeight = null;
  };

  LayoutSpec.prototype.setFixedOrMorphHeight = function(aNumber) {
    if (typeof fixedHeight !== "undefined" && fixedHeight !== null) {
      this.fixedHeight = aNumber;
    } else {
      this.morph.setHeight(aNumber);
    }
    return this.proportionalHeight = null;
  };

  LayoutSpec.prototype.setFixedOrMorphWidth = function(aNumber) {
    if (typeof fixedWidth !== "undefined" && fixedWidth !== null) {
      this.fixedWidth = aNumber;
    } else {
      this.morph.setWidth(aNumber);
    }
    return this.proportionalWidth = null;
  };

  LayoutSpec.prototype.setFixedWidth = function(aNumber) {
    this.fixedWidth = aNumber;
    return this.proportionalWidth = null;
  };

  LayoutSpec.prototype.setMinorDirectionPadding = function(howMuchPadding) {
    switch (howMuchPadding) {
      case "#top":
        return this.minorDirectionPadding = 0.0;
      case "#left":
        return this.minorDirectionPadding = 0.0;
      case "#center":
        return this.minorDirectionPadding = 0.5;
      case "#right":
        return this.minorDirectionPadding = 1.0;
      case "#bottom":
        return this.minorDirectionPadding = 1.0;
      default:
        return this.minorDirectionPadding = howMuchPadding;
    }
  };

  LayoutSpec.prototype.setProportionalHeight = function(aNumber) {
    return this.setProportionalHeightMinimum(aNumber, 0.0);
  };

  LayoutSpec.prototype.setProportionalHeightMinimum = function(aNumberOrNil, otherNumberOrNil) {
    this.proportionalHeight = aNumberOrNil;
    return this.fixedHeight = otherNumberOrNil;
  };

  LayoutSpec.prototype.setProportionalWidth = function(aNumber) {
    return this.setProportionalWidthMinimum(aNumber, 0);
  };

  LayoutSpec.prototype.setProportionalWidthMinimum = function(aNumberOrNil, otherNumberOrNil) {
    this.proportionalWidth = aNumberOrNil;
    return this.fixedWidth = otherNumberOrNil;
  };

  LayoutSpec.prototype.setProportionalHeight = function(aNumberOrNil) {
    return this.proportionalHeight = aNumberOrNil;
  };

  LayoutSpec.prototype.setProportionalWidth = function(aNumberOrNil) {
    return this.proportionalWidth = aNumberOrNil;
  };

  LayoutSpec.prototype.useMorphHeight = function() {
    this.fixedHeight = null;
    return this.proportionalHeight = null;
  };

  LayoutSpec.prototype.useMorphWidth = function() {
    this.fixedWidth = null;
    return this.proportionalWidth = null;
  };

  LayoutSpec.prototype.getFixedHeight = function() {
    if (this.proportionalHeight != null) {
      return 0;
    }
    if (this.fixedHeight == null) {
      return this.morph.height();
    }
  };

  LayoutSpec.prototype.getFixedWidth = function() {
    if (this.proportionalWidth != null) {
      return 0;
    }
    if (this.fixedWidth == null) {
      return this.morph.width();
    }
  };

  LayoutSpec.prototype.heightFor = function(availableSpace) {
    if (this.proportionalHeight != null) {
      return Math.max(this.fixedHeight, Math.round(this.proportionalHeight * availableSpace));
    }
    return this.getFixedHeight();
  };

  LayoutSpec.prototype.getFixedHeight = function() {
    if (this.fixedHeight == null) {
      return 0;
    } else {
      return this.fixedHeight;
    }
  };

  LayoutSpec.prototype.getFixedWidth = function() {
    if (this.fixedWidth == null) {
      return 0;
    } else {
      return this.fixedWidth;
    }
  };

  LayoutSpec.prototype.getProportionalHeight = function() {
    if (this.proportionalHeight == null) {
      return 0;
    } else {
      return this.proportionalHeight;
    }
  };

  LayoutSpec.prototype.getProportionalWidth = function() {
    if (this.proportionalWidth == null) {
      return 0;
    } else {
      return this.proportionalWidth;
    }
  };

  LayoutSpec.prototype.widthFor = function(availableSpace) {
    if (this.proportionalWidth != null) {
      return Math.max(this.fixedWidth, Math.round(this.proportionalWidth * availableSpace));
    }
    return this.getFixedWidth();
  };

  LayoutSpec.prototype.isProportionalHeight = function() {
    return this.proportionalHeight != null;
  };

  LayoutSpec.prototype.isProportionalWidth = function() {
    return this.proportionalWidth != null;
  };

  LayoutSpec.coffeeScriptSourceOfThisClass = '# LayoutSpec\n\n# this comment below is needed to figure our dependencies between classes\n\n# This is a port of the\n# respective Cuis Smalltalk classes (version 4.2-1766)\n# Cuis is by Juan Vuletich\n\n# LayoutSpecs are the basis for the layout mechanism.\n# Any Morph can be given a LayoutSpec, but in order to honor it,\n# its owner must be a LayoutMorph.\n\n# A LayoutSpec specifies how a morph wants to be layed out.\n# It can specify either a fixed width or a fraction of some\n# available owner width. Same goes for height. If a fraction\n# is specified, a minimum extent is also possible.\n\n\n# Alternatives:\n#  - proportionalWidth notNil, fixedWidth notNil ->    Use fraction of available space, take fixedWidth as minimum desired width\n#  - proportionalWidth isNil, fixedWidth isNil   ->    Use current morph width\n#  - proportionalWidth isNil, fixedWidth notNil    ->    Use fixedWidth\n#  - proportionalWidth notNil, fixedWidth isNil    ->    NOT VALID\n\n#Same goes for proportionalHeight and fixedHeight\n\nclass LayoutSpec\n\n  morph: null\n  minorDirectionPadding: 0.5\n  fixedWidth: 0\n  fixedHeight: 0\n  proportionalWidth: 1.0\n  proportionalHeight: 1.0\n\n\n  # Just some reasonable defaults, use all available space\n  constructor: ->\n\n  @newWithFixedExtent: (aPoint) ->\n    @newWithFixedWidthFixedHeight(aPoint.x, aPoint.y)\n\n  @newWithFixedHeight: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setFixedHeight aNumber\n   return layoutSpec\n\n  @newWithFixedWidth: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setFixedWidth aNumber\n   return layoutSpec\n\n  @newWithFixedWidthFixedHeight: (aNumber, otherNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setFixedWidth aNumber\n   layoutSpec.setFixedHeight otherNumber\n   return layoutSpec\n\n  @newWithFixedWidthFixedHeightMinorDirectionPadding: (aNumber, otherNumber, aSymbolOrNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setFixedWidth aNumber\n   layoutSpec.setFixedHeight otherNumber\n   layoutSpec.setMinorDirectionPadding aSymbolOrNumber\n   return layoutSpec\n\n  @newWithFixedWidthProportionalHeight: (aNumber, otherNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setFixedWidth aNumber\n   layoutSpec.setProportionalHeight otherNumber\n   return layoutSpec\n\n  @newWithFixedWidthProportionalHeightMinorDirectionPadding: (aNumber, otherNumber, aSymbolOrNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setFixedWidth aNumber\n   layoutSpec.setProportionalHeight otherNumber\n   layoutSpec.setMinorDirectionPadding aSymbolOrNumber\n   return layoutSpec\n\n  @newWithKeepMorphExtent: ->\n   layoutSpec = new @()\n   layoutSpec.useMorphWidth\n   layoutSpec.useMorphHeight\n   return layoutSpec\n\n  @newWithMorphHeightFixedWidth: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setFixedWidth aNumber\n   layoutSpec.useMorphHeight\n   return layoutSpec\n\n  @newWithMorphHeightProportionalWidth: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setProportionalWidth aNumber\n   layoutSpec.useMorphHeight()\n   return layoutSpec\n\n  @newWithMorphWidthFixedHeight: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.useMorphWidth()\n   layoutSpec.setFixedHeight aNumber\n   return layoutSpec\n\n  @newWithMorphWidthProportionalHeight: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.useMorphWidth()\n   layoutSpec.setProportionalHeight aNumber\n   return layoutSpec\n\n  # Will use all available width\n  @newWithProportionalHeight: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setProportionalHeight aNumber\n   return layoutSpec\n\n  # Will use all available height\n  @newWithProportionalWidth: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setProportionalWidth aNumber\n   return layoutSpec\n\n  @newWithProportionalWidthFixedHeight: (aNumber, otherNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setProportionalWidth aNumber\n   layoutSpec.setFixedHeight otherNumber\n   return layoutSpec\n\n  @newWithProportionalWidthFixedHeightMinorDirectionPadding: (aNumber, otherNumber, aSymbolOrNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setProportionalWidth aNumber\n   layoutSpec.setFixedHeight otherNumber\n   layoutSpec.setMinorDirectionPadding aSymbolOrNumber\n   return layoutSpec\n\n  @newWithProportionalWidthProportionalHeight: (aNumber, otherNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setProportionalWidth aNumber\n   layoutSpec.setProportionalHeight otherNumber\n   return layoutSpec\n\n  @newWithProportionalWidthProportionalHeightMinorDirectionPadding: (aNumber, otherNumber, aSymbolOrNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setProportionalWidth aNumber\n   layoutSpec.setProportionalHeight otherNumber\n   layoutSpec.setMinorDirectionPadding aSymbolOrNumber\n   return layoutSpec\n\n  # Use all available space\n  @newWithUseAll: ->\n   return new @()\n\n  setFixedHeight: (aNumber) ->\n   # aNumber is taken as the fixed height to use.\n   # No proportional part.\n   @fixedHeight = aNumber\n   @proportionalHeight = null\n\n  setFixedOrMorphHeight: (aNumber) ->\n    # aNumber is taken as the fixed height to use.\n    # No proportional part.\n    if fixedHeight?\n      @fixedHeight = aNumber\n    else\n      @morph.setHeight aNumber\n    @proportionalHeight = null\n\n  setFixedOrMorphWidth: (aNumber) ->\n    # aNumber is taken as the fixed width to use.\n    # No proportional part.\n    if fixedWidth?\n      @fixedWidth = aNumber\n    else\n      @morph.setWidth aNumber\n    @proportionalWidth = null\n\n  setFixedWidth: (aNumber) ->\n    # aNumber is taken as the fixed width to use.\n    # No proportional part.\n    @fixedWidth = aNumber\n    @proportionalWidth = null\n\n  setMinorDirectionPadding: (howMuchPadding) ->\n    # This sets how padding is done in the secondary direction.\n    # For instance, if the owning morph is set in a row,\n    # the row will control horizontal layout. But if there\n    # is unused vertical space, it will be used according to\n    # this parameter. For instance, #top sets the owning morph\n    # at the top. Same for #bottom and #center. If the owner is\n    # contained in a column, #left, #center or #right should be\n    # used. Alternatively, any number between 0.0 and 1.0 can be\n    # used.\n    #  self new minorDirectionPadding: #center\n    #  self new minorDirectionPadding: 0.9\n\n    switch howMuchPadding\n      when "#top" then @minorDirectionPadding = 0.0\n      when "#left" then @minorDirectionPadding = 0.0\n      when "#center" then @minorDirectionPadding = 0.5\n      when "#right" then @minorDirectionPadding = 1.0\n      when "#bottom" then @minorDirectionPadding = 1.0\n      else @minorDirectionPadding = howMuchPadding\n\n  setProportionalHeight: (aNumber) ->\n   @setProportionalHeightMinimum(aNumber, 0.0)\n\n  setProportionalHeightMinimum: (aNumberOrNil, otherNumberOrNil) ->\n    # Alternatives: same as in #proportionalWidth:minimum:\n    # see comment there\n    @proportionalHeight = aNumberOrNil\n    @fixedHeight = otherNumberOrNil\n\n  setProportionalWidth: (aNumber) ->\n    return @setProportionalWidthMinimum aNumber, 0\n\n  setProportionalWidthMinimum: (aNumberOrNil, otherNumberOrNil) ->\n    # Alternatives:\n    #  - proportionalWidth notNil, fixedWidth notNil ->    Use fraction of available space, take fixedWidth as minimum desired width\n    #  - proportionalWidth isNil, fixedWidth isNil   ->    Use current morph width\n    #  - proportionalWidth isNil, fixedWidth notNil  ->    Use fixedWidth\n    #  - proportionalWidth notNil, fixedWidth isNil  ->    NOT VALID\n    @proportionalWidth = aNumberOrNil\n    @fixedWidth = otherNumberOrNil\n\n  setProportionalHeight: (aNumberOrNil) ->\n   # Alternatives: same as in #proportionalWidth:minimum:, see comment there\n   @proportionalHeight = aNumberOrNil\n\n  setProportionalWidth: (aNumberOrNil) ->\n    # Alternatives:\n    #  - proportionalWidth notNil, fixedWidth notNil ->    Use fraction of available space, take fixedWidth as minimum desired width\n    #  - proportionalWidth isNil, fixedWidth isNil   ->    Use current morph width\n    #  - proportionalWidth isNil, fixedWidth notNil  ->    Use fixedWidth\n    #  - proportionalWidth notNil, fixedWidth isNil  ->    NOT VALID"\n    @proportionalWidth = aNumberOrNil\n\n  useMorphHeight: ->\n    # Do not attempt to layout height. Use current morph height if at all possible\n    @fixedHeight = null\n    @proportionalHeight = null\n\n  useMorphWidth: ->\n    # Do not attempt to layout width. Use current morph width if at all possible\n    @fixedWidth = null\n    @proportionalWidth = null\n\n  getFixedHeight: ->\n    # If proportional is zero, answer stored fixed extent,\n    # or actual morph extent if undefined. (no proportional extent is computed)\n    # Otherwise, we do proportional layout, and the stored extent is\n    # a minimum extent, so we don\'t  really a fixed extent.\n    if @proportionalHeight?\n      return 0\n    if not @fixedHeight?\n      return @morph.height()\n\n  getFixedWidth: ->\n    # If proportional is zero, answer stored fixed extent,\n    # or actual morph extent if undefined. (no proportional extent is computed)\n    # Otherwise, we do proportional layout, and the stored extent is\n    # a minimum extent, so we don\'t  really a fixed extent.\n    if @proportionalWidth?\n      return 0\n    if not @fixedWidth?\n      return @morph.width()\n\n  heightFor: (availableSpace) ->\n    # If proportional is zero, answer stored fixed extent,\n    # or actual morph extent if undefined.\n    # Otherwise, we do proportional layout, and the stored\n    # extent is a minimum extent.\n    # If there is no minimum extent, it should be set to zero.\n\n    if @proportionalHeight?\n      return Math.max( @fixedHeight, Math.round(@proportionalHeight * availableSpace) )\n    return @getFixedHeight()\n\n  getFixedHeight: ->\n    if not @fixedHeight?\n      return 0\n    else\n      @fixedHeight\n\n  getFixedWidth: ->\n    if not @fixedWidth?\n      return 0\n    else\n      @fixedWidth\n\n  getProportionalHeight: ->\n    if not @proportionalHeight?\n      return 0\n    else\n      @proportionalHeight\n\n  getProportionalWidth: ->\n    if not @proportionalWidth?\n      return 0\n    else\n      @proportionalWidth\n\n  widthFor: (availableSpace) ->\n    # If proportional is zero, answer stored fixed extent,\n    # or actual morph extent if undefined.\n    # Otherwise, we do proportional layout, and the\n    # stored extent is a minimum extent.\n    # If there is no minimum extent, it should be set to zero.\n    if @proportionalWidth?\n      return Math.max( @fixedWidth, Math.round(@proportionalWidth * availableSpace) )\n    return @getFixedWidth()\n\n  isProportionalHeight: ->\n    return @proportionalHeight?\n\n  isProportionalWidth: ->\n    return @proportionalWidth?  ';

  return LayoutSpec;

})();

ScrollFrameMorph = (function(_super) {
  __extends(ScrollFrameMorph, _super);

  ScrollFrameMorph.prototype.autoScrollTrigger = null;

  ScrollFrameMorph.prototype.hasVelocity = true;

  ScrollFrameMorph.prototype.padding = 0;

  ScrollFrameMorph.prototype.growth = 0;

  ScrollFrameMorph.prototype.isTextLineWrapping = false;

  ScrollFrameMorph.prototype.isScrollingByDragging = true;

  ScrollFrameMorph.prototype.scrollBarSize = null;

  ScrollFrameMorph.prototype.contents = null;

  ScrollFrameMorph.prototype.vBar = null;

  ScrollFrameMorph.prototype.hBar = null;

  function ScrollFrameMorph(contents, scrollBarSize, sliderColor) {
    this.contents = contents;
    this.sliderColor = sliderColor;
    this.alpha = 0;
    ScrollFrameMorph.__super__.constructor.call(this);
    this.scrollBarSize = scrollBarSize || WorldMorph.preferencesAndSettings.scrollBarSize;
    if (this.contents == null) {
      this.contents = new FrameMorph(this);
    }
    this.add(this.contents);
    this.color = this.contents.color;
    this.alpha = this.contents.alpha;
    this.hBar = new SliderMorph(null, null, null, null, "horizontal", this.sliderColor);
    this.hBar.setHeight(this.scrollBarSize);
    this.hBar.isDraggable = false;
    this.hBar.target = this;
    this.add(this.hBar);
    this.vBar = new SliderMorph(null, null, null, null, "vertical", this.sliderColor);
    this.vBar.setWidth(this.scrollBarSize);
    this.vBar.isDraggable = false;
    this.vBar.target = this;
    this.add(this.vBar);
    this.hBar.action = (function(_this) {
      return function(num, target) {
        target.contents.setPosition(new Point(target.left() - num, target.contents.position().y));
        return target.contents.adjustBounds();
      };
    })(this);
    this.vBar.action = (function(_this) {
      return function(num, target) {
        target.contents.setPosition(new Point(target.contents.position().x, target.top() - num));
        return target.contents.adjustBounds();
      };
    })(this);
    this.adjustScrollBars();
  }

  ScrollFrameMorph.prototype.setColor = function(aColor) {
    this.color = aColor;
    return this.contents.setColor(aColor);
  };

  ScrollFrameMorph.prototype.setAlphaScaled = function(alpha) {
    this.alpha = this.calculateAlphaScaled(alpha);
    return this.contents.setAlphaScaled(alpha);
  };

  ScrollFrameMorph.prototype.adjustScrollBars = function() {
    var hWidth, vHeight;
    hWidth = this.width() - this.scrollBarSize;
    vHeight = this.height() - this.scrollBarSize;
    this.changed();
    if (this.hBar.target === this) {
      if (this.contents.width() >= this.width() + 1) {
        this.hBar.show();
        if (this.hBar.width() !== hWidth) {
          this.hBar.setWidth(hWidth);
        }
        if (this.hBar.parent === this) {
          this.hBar.setPosition(new Point(this.left(), this.bottom() - this.hBar.height()));
        }
        this.hBar.start = 0;
        this.hBar.stop = this.contents.width() - this.width();
        this.hBar.size = this.width() / this.contents.width() * this.hBar.stop;
        this.hBar.value = this.left() - this.contents.left();
        this.hBar.updateRendering();
      } else {
        this.hBar.hide();
      }
    }
    if (this.vBar.target === this) {
      if (this.contents.height() >= this.height() + 1) {
        this.vBar.show();
        if (this.vBar.height() !== vHeight) {
          this.vBar.setHeight(vHeight);
        }
        if (this.vBar.parent === this) {
          this.vBar.setPosition(new Point(this.right() - this.vBar.width(), this.top()));
        }
        this.vBar.start = 0;
        this.vBar.stop = this.contents.height() - this.height();
        this.vBar.size = this.height() / this.contents.height() * this.vBar.stop;
        this.vBar.value = this.top() - this.contents.top();
        return this.vBar.updateRendering();
      } else {
        return this.vBar.hide();
      }
    }
  };

  ScrollFrameMorph.prototype.addContents = function(aMorph) {
    this.contents.add(aMorph);
    this.contents.adjustBounds();
    return this.adjustScrollBars();
  };

  ScrollFrameMorph.prototype.setContents = function(aMorph, extraPadding) {
    this.extraPadding = extraPadding;
    this.contents.destroyAll();
    this.contents.children = [];
    aMorph.setPosition(this.position().add(this.padding + this.extraPadding));
    return this.addContents(aMorph);
  };

  ScrollFrameMorph.prototype.setExtent = function(aPoint) {
    if (this.isTextLineWrapping) {
      this.contents.setPosition(this.position().copy());
    }
    ScrollFrameMorph.__super__.setExtent.call(this, aPoint);
    this.contents.adjustBounds();
    return this.adjustScrollBars();
  };

  ScrollFrameMorph.prototype.scrollX = function(steps) {
    var cl, cw, l, newX, r;
    cl = this.contents.left();
    l = this.left();
    cw = this.contents.width();
    r = this.right();
    newX = cl + steps;
    if (newX + cw < r) {
      newX = r - cw;
    }
    if (newX > l) {
      newX = l;
    }
    if (newX !== cl) {
      return this.contents.setLeft(newX);
    }
  };

  ScrollFrameMorph.prototype.scrollY = function(steps) {
    var b, ch, ct, newY, t;
    ct = this.contents.top();
    t = this.top();
    ch = this.contents.height();
    b = this.bottom();
    newY = ct + steps;
    if (newY + ch < b) {
      newY = b - ch;
    }
    if (newY > t) {
      newY = t;
    }
    if (newY !== ct) {
      return this.contents.setTop(newY);
    }
  };

  ScrollFrameMorph.prototype.mouseDownLeft = function(pos) {
    var deltaX, deltaY, friction, oldPos, world;
    if (!this.isScrollingByDragging) {
      return null;
    }
    world = this.root();
    oldPos = pos;
    deltaX = 0;
    deltaY = 0;
    friction = 0.8;
    return this.step = (function(_this) {
      return function() {
        var newPos;
        if (world.hand.mouseButton && (!world.hand.children.length) && (_this.bounds.containsPoint(world.hand.position()))) {
          newPos = world.hand.bounds.origin;
          if (_this.hBar.isVisible) {
            deltaX = newPos.x - oldPos.x;
            if (deltaX !== 0) {
              _this.scrollX(deltaX);
            }
          }
          if (_this.vBar.isVisible) {
            deltaY = newPos.y - oldPos.y;
            if (deltaY !== 0) {
              _this.scrollY(deltaY);
            }
          }
          oldPos = newPos;
        } else {
          if (!_this.hasVelocity) {
            _this.step = noOperation;
          } else {
            if ((Math.abs(deltaX) < 0.5) && (Math.abs(deltaY) < 0.5)) {
              _this.step = noOperation;
            } else {
              if (_this.hBar.isVisible) {
                deltaX = deltaX * friction;
                _this.scrollX(Math.round(deltaX));
              }
              if (_this.vBar.isVisible) {
                deltaY = deltaY * friction;
                _this.scrollY(Math.round(deltaY));
              }
            }
          }
        }
        _this.contents.adjustBounds();
        return _this.adjustScrollBars();
      };
    })(this);
  };

  ScrollFrameMorph.prototype.startAutoScrolling = function() {
    var hand, inset, world;
    inset = WorldMorph.preferencesAndSettings.scrollBarSize * 3;
    world = this.world();
    if (!world) {
      return null;
    }
    hand = world.hand;
    if (!this.autoScrollTrigger) {
      this.autoScrollTrigger = Date.now();
    }
    return this.step = (function(_this) {
      return function() {
        var inner, pos;
        pos = hand.bounds.origin;
        inner = _this.bounds.insetBy(inset);
        if ((_this.bounds.containsPoint(pos)) && (!(inner.containsPoint(pos))) && hand.children.length) {
          return _this.autoScroll(pos);
        } else {
          _this.step = noOperation;
          return _this.autoScrollTrigger = null;
        }
      };
    })(this);
  };

  ScrollFrameMorph.prototype.autoScroll = function(pos) {
    var area, inset;
    if (Date.now() - this.autoScrollTrigger < 500) {
      return null;
    }
    inset = WorldMorph.preferencesAndSettings.scrollBarSize * 3;
    area = this.topLeft().extent(new Point(this.width(), inset));
    if (area.containsPoint(pos)) {
      this.scrollY(inset - (pos.y - this.top()));
    }
    area = this.topLeft().extent(new Point(inset, this.height()));
    if (area.containsPoint(pos)) {
      this.scrollX(inset - (pos.x - this.left()));
    }
    area = (new Point(this.right() - inset, this.top())).extent(new Point(inset, this.height()));
    if (area.containsPoint(pos)) {
      this.scrollX(-(inset - (this.right() - pos.x)));
    }
    area = (new Point(this.left(), this.bottom() - inset)).extent(new Point(this.width(), inset));
    if (area.containsPoint(pos)) {
      this.scrollY(-(inset - (this.bottom() - pos.y)));
    }
    this.contents.adjustBounds();
    return this.adjustScrollBars();
  };

  ScrollFrameMorph.prototype.scrollCaretIntoView = function(caretMorph) {
    var fb, fl, fr, ft, offset, txt;
    txt = caretMorph.target;
    offset = txt.position().subtract(this.contents.position());
    ft = this.top() + this.padding;
    fb = this.bottom() - this.padding;
    fl = this.left() + this.padding;
    fr = this.right() - this.padding;
    this.contents.adjustBounds();
    if (caretMorph.top() < ft) {
      this.contents.setTop(this.contents.top() + ft - caretMorph.top());
      caretMorph.setTop(ft);
    } else if (caretMorph.bottom() > fb) {
      this.contents.setBottom(this.contents.bottom() + fb - caretMorph.bottom());
      caretMorph.setBottom(fb);
    }
    if (caretMorph.left() < fl) {
      this.contents.setLeft(this.contents.left() + fl - caretMorph.left());
      caretMorph.setLeft(fl);
    } else if (caretMorph.right() > fr) {
      this.contents.setRight(this.contents.right() + fr - caretMorph.right());
      caretMorph.setRight(fr);
    }
    this.contents.adjustBounds();
    return this.adjustScrollBars();
  };

  ScrollFrameMorph.prototype.mouseScroll = function(y, x) {
    if (y) {
      this.scrollY(y * WorldMorph.preferencesAndSettings.mouseScrollAmount);
    }
    if (x) {
      this.scrollX(x * WorldMorph.preferencesAndSettings.mouseScrollAmount);
    }
    this.contents.adjustBounds();
    return this.adjustScrollBars();
  };

  ScrollFrameMorph.prototype.developersMenu = function() {
    var menu;
    menu = ScrollFrameMorph.__super__.developersMenu.call(this);
    if (this.isTextLineWrapping) {
      menu.addItem("auto line wrap off...", (function() {
        return this.toggleTextLineWrapping();
      }), "turn automatic\nline wrapping\noff");
    } else {
      menu.addItem("auto line wrap on...", (function() {
        return this.toggleTextLineWrapping();
      }), "enable automatic\nline wrapping");
    }
    return menu;
  };

  ScrollFrameMorph.prototype.toggleTextLineWrapping = function() {
    return this.isTextLineWrapping = !this.isTextLineWrapping;
  };

  ScrollFrameMorph.coffeeScriptSourceOfThisClass = '# ScrollFrameMorph ////////////////////////////////////////////////////\n\n# this comment below is needed to figure our dependencies between classes\n# REQUIRES globalFunctions\n\nclass ScrollFrameMorph extends FrameMorph\n\n  autoScrollTrigger: null\n  hasVelocity: true # dto.\n  padding: 0 # around the scrollable area\n  growth: 0 # pixels or Point to grow right/left when near edge\n  isTextLineWrapping: false\n  isScrollingByDragging: true\n  scrollBarSize: null\n  contents: null\n  vBar: null\n  hBar: null\n\n  constructor: (@contents, scrollBarSize, @sliderColor) ->\n    # super() paints the scrollframe, which we don\'t want,\n    # so we set 0 opacity here.\n    @alpha = 0\n    super()\n    @scrollBarSize = scrollBarSize or WorldMorph.preferencesAndSettings.scrollBarSize\n\n    @contents = new FrameMorph(@) unless @contents?\n    @add @contents\n\n    # the scrollFrame is never going to paint itself,\n    # but its values are going to mimick the values of the\n    # contained frame\n    @color = @contents.color\n    @alpha = @contents.alpha\n    \n    #@setColor = @contents.setColor\n    #@setAlphaScaled = @contents.setAlphaScaled\n\n    @hBar = new SliderMorph(null, null, null, null, "horizontal", @sliderColor)\n    @hBar.setHeight @scrollBarSize\n\n    @hBar.isDraggable = false\n    @hBar.target = @\n    @add @hBar\n\n    @vBar = new SliderMorph(null, null, null, null, "vertical", @sliderColor)\n    @vBar.setWidth @scrollBarSize\n    @vBar.isDraggable = false\n    @vBar.target = @\n    @add @vBar\n\n    @hBar.action = (num, target) =>\n      target.contents.setPosition new Point(target.left() - num, target.contents.position().y)\n      target.contents.adjustBounds()\n    @vBar.action = (num, target) =>\n      target.contents.setPosition new Point(target.contents.position().x, target.top() - num)\n      target.contents.adjustBounds()\n    @adjustScrollBars()\n\n  setColor: (aColor) ->\n    # update the color of the scrollFrame - note\n    # that we are never going to paint the scrollFrame\n    # we are updating the color so that its value is the same as the\n    # contained frame\n    @color = aColor\n    @contents.setColor(aColor)\n\n  setAlphaScaled: (alpha) ->\n    # update the alpha of the scrollFrame - note\n    # that we are never going to paint the scrollFrame\n    # we are updating the alpha so that its value is the same as the\n    # contained frame\n    @alpha = @calculateAlphaScaled(alpha)\n    @contents.setAlphaScaled(alpha)\n\n  adjustScrollBars: ->\n    hWidth = @width() - @scrollBarSize\n    vHeight = @height() - @scrollBarSize\n    @changed()\n\n    # this check is to see whether the bar actually belongs to this\n    # scrollframe. The reason why the bar could belong to another\n    # scrollframe is the following: the bar could have been detached\n    # from a scrollframe A. The scrollframe A (which is still fully\n    # working albeit detached) is then duplicated into\n    # a scrollframe B. What happens is that because the bar is not\n    # a child of A (rather, it\'s only referenced as a property),\n    # the duplication mechanism does not duplicate the bar and it does\n    # not update the reference to it. This is correct because one cannot\n    # just change all the references to other objects that are not children\n    # , a good example being the targets, i.e. if you duplicate a colorPicker\n    # which targets a Morph you want the duplication of the colorPicker to\n    # still change color of that same Morph.\n    # So: the scrollframe B could still reference the scrollbar\n    # detached from A and that causes a problem because changes to B would\n    # change the dimensions and hiding/unhiding of the scrollbar.\n    # So here we avoid that by actually checking what the scrollbar is\n    # attached to.\n    if @hBar.target == @ \n      if @contents.width() >= @width() + 1\n        @hBar.show()\n        @hBar.setWidth hWidth  if @hBar.width() isnt hWidth\n        # we check whether the bar has been detached. If it\'s still\n        # attached then we possibly move it, together with the\n        # scrollframe, otherwise we don\'t move it.\n        if @hBar.parent == @\n          @hBar.setPosition new Point(@left(), @bottom() - @hBar.height())\n        @hBar.start = 0\n        @hBar.stop = @contents.width() - @width()\n        @hBar.size = @width() / @contents.width() * @hBar.stop\n        @hBar.value = @left() - @contents.left()\n        @hBar.updateRendering()\n      else\n        @hBar.hide()\n\n    # see comment on equivalent if line above.\n    if @vBar.target == @ \n      if @contents.height() >= @height() + 1\n        @vBar.show()\n        @vBar.setHeight vHeight  if @vBar.height() isnt vHeight\n        # we check whether the bar has been detached. If it\'s still\n        # attached then we possibly move it, together with the\n        # scrollframe, otherwise we don\'t move it.\n        if @vBar.parent == @\n          @vBar.setPosition new Point(@right() - @vBar.width(), @top())\n        @vBar.start = 0\n        @vBar.stop = @contents.height() - @height()\n        @vBar.size = @height() / @contents.height() * @vBar.stop\n        @vBar.value = @top() - @contents.top()\n        @vBar.updateRendering()\n      else\n        @vBar.hide()\n  \n  addContents: (aMorph) ->\n    @contents.add aMorph\n    @contents.adjustBounds()\n    @adjustScrollBars()\n  \n  setContents: (aMorph, extraPadding) ->\n    @extraPadding = extraPadding\n    @contents.destroyAll()\n    #\n    @contents.children = []\n    aMorph.setPosition @position().add(@padding + @extraPadding)\n    @addContents aMorph\n  \n  setExtent: (aPoint) ->\n    @contents.setPosition @position().copy()  if @isTextLineWrapping\n    super aPoint\n    @contents.adjustBounds()\n    @adjustScrollBars()\n  \n  # ScrollFrameMorph scrolling by dragging:\n  scrollX: (steps) ->\n    cl = @contents.left()\n    l = @left()\n    cw = @contents.width()\n    r = @right()\n    newX = cl + steps\n    newX = r - cw  if newX + cw < r\n    newX = l  if newX > l\n    @contents.setLeft newX  if newX isnt cl\n  \n  scrollY: (steps) ->\n    ct = @contents.top()\n    t = @top()\n    ch = @contents.height()\n    b = @bottom()\n    newY = ct + steps\n    if newY + ch < b\n      newY = b - ch\n    # prevents content to be scrolled to the frame\'s\n    # bottom if the content is otherwise empty\n    newY = t  if newY > t\n    @contents.setTop newY  if newY isnt ct\n  \n  mouseDownLeft: (pos) ->\n    return null  unless @isScrollingByDragging\n    world = @root()\n    oldPos = pos\n    deltaX = 0\n    deltaY = 0\n    friction = 0.8\n    @step = =>\n      if world.hand.mouseButton and\n        (!world.hand.children.length) and\n        (@bounds.containsPoint(world.hand.position()))\n          newPos = world.hand.bounds.origin\n          if @hBar.isVisible\n            deltaX = newPos.x - oldPos.x\n            @scrollX deltaX  if deltaX isnt 0\n          if @vBar.isVisible\n            deltaY = newPos.y - oldPos.y\n            @scrollY deltaY  if deltaY isnt 0\n          oldPos = newPos\n      else\n        unless @hasVelocity\n          @step = noOperation\n        else\n          if (Math.abs(deltaX) < 0.5) and (Math.abs(deltaY) < 0.5)\n            @step = noOperation\n          else\n            if @hBar.isVisible\n              deltaX = deltaX * friction\n              @scrollX Math.round(deltaX)\n            if @vBar.isVisible\n              deltaY = deltaY * friction\n              @scrollY Math.round(deltaY)\n      #console.log "adjusting..."\n      @contents.adjustBounds()\n      @adjustScrollBars()\n  \n  startAutoScrolling: ->\n    inset = WorldMorph.preferencesAndSettings.scrollBarSize * 3\n    world = @world()\n    return null  unless world\n    hand = world.hand\n    @autoScrollTrigger = Date.now()  unless @autoScrollTrigger\n    @step = =>\n      pos = hand.bounds.origin\n      inner = @bounds.insetBy(inset)\n      if (@bounds.containsPoint(pos)) and\n        (not (inner.containsPoint(pos))) and\n        (hand.children.length)\n          @autoScroll pos\n      else\n        @step = noOperation\n        @autoScrollTrigger = null\n  \n  autoScroll: (pos) ->\n    return null  if Date.now() - @autoScrollTrigger < 500\n    inset = WorldMorph.preferencesAndSettings.scrollBarSize * 3\n    area = @topLeft().extent(new Point(@width(), inset))\n    @scrollY inset - (pos.y - @top())  if area.containsPoint(pos)\n    area = @topLeft().extent(new Point(inset, @height()))\n    @scrollX inset - (pos.x - @left())  if area.containsPoint(pos)\n    area = (new Point(@right() - inset, @top())).extent(new Point(inset, @height()))\n    @scrollX -(inset - (@right() - pos.x))  if area.containsPoint(pos)\n    area = (new Point(@left(), @bottom() - inset)).extent(new Point(@width(), inset))\n    @scrollY -(inset - (@bottom() - pos.y))  if area.containsPoint(pos)\n    @contents.adjustBounds()\n    @adjustScrollBars()  \n  \n  # ScrollFrameMorph scrolling when editing text\n  # so to bring the caret fully into view.\n  scrollCaretIntoView: (caretMorph) ->\n    txt = caretMorph.target\n    offset = txt.position().subtract(@contents.position())\n    ft = @top() + @padding\n    fb = @bottom() - @padding\n    fl = @left() + @padding\n    fr = @right() - @padding\n    @contents.adjustBounds()\n    if caretMorph.top() < ft\n      @contents.setTop @contents.top() + ft - caretMorph.top()\n      caretMorph.setTop ft\n    else if caretMorph.bottom() > fb\n      @contents.setBottom @contents.bottom() + fb - caretMorph.bottom()\n      caretMorph.setBottom fb\n    if caretMorph.left() < fl\n      @contents.setLeft @contents.left() + fl - caretMorph.left()\n      caretMorph.setLeft fl\n    else if caretMorph.right() > fr\n      @contents.setRight @contents.right() + fr - caretMorph.right()\n      caretMorph.setRight fr\n    @contents.adjustBounds()\n    @adjustScrollBars()\n\n  # ScrollFrameMorph events:\n  mouseScroll: (y, x) ->\n    @scrollY y * WorldMorph.preferencesAndSettings.mouseScrollAmount  if y\n    @scrollX x * WorldMorph.preferencesAndSettings.mouseScrollAmount  if x\n    @contents.adjustBounds()\n    @adjustScrollBars()\n  \n  \n  developersMenu: ->\n    menu = super()\n    if @isTextLineWrapping\n      menu.addItem "auto line wrap off...", (->@toggleTextLineWrapping()), "turn automatic\nline wrapping\noff"\n    else\n      menu.addItem "auto line wrap on...", (->@toggleTextLineWrapping()), "enable automatic\nline wrapping"\n    menu\n  \n  toggleTextLineWrapping: ->\n    @isTextLineWrapping = not @isTextLineWrapping';

  return ScrollFrameMorph;

})(FrameMorph);

ListMorph = (function(_super) {
  __extends(ListMorph, _super);

  ListMorph.prototype.elements = null;

  ListMorph.prototype.labelGetter = null;

  ListMorph.prototype.format = null;

  ListMorph.prototype.listContents = null;

  ListMorph.prototype.selected = null;

  ListMorph.prototype.active = null;

  ListMorph.prototype.action = null;

  ListMorph.prototype.target = null;

  ListMorph.prototype.doubleClickAction = null;

  function ListMorph(target, action, elements, labelGetter, format, doubleClickAction) {
    this.target = target;
    this.action = action;
    this.elements = elements != null ? elements : [];
    this.format = format != null ? format : [];
    this.doubleClickAction = doubleClickAction != null ? doubleClickAction : null;
    ListMorph.__super__.constructor.call(this);
    this.contents.acceptsDrops = false;
    this.color = new Color(255, 255, 255);
    this.labelGetter = labelGetter || function(element) {
      if (isString(element)) {
        return element;
      }
      if (element.toSource) {
        return element.toSource();
      }
      return element.toString();
    };
    this.buildListContents();
  }

  ListMorph.prototype.buildListContents = function() {
    if (this.listContents) {
      this.listContents = this.listContents.destroy();
    }
    this.listContents = new MenuMorph(this, null, null);
    if (!this.elements.length) {
      this.elements = ["(empty)"];
    }
    this.elements.forEach((function(_this) {
      return function(element) {
        var bold, color, italic;
        color = null;
        bold = false;
        italic = false;
        _this.format.forEach(function(pair) {
          if (pair[1].call(null, element)) {
            if (pair[0] === 'bold') {
              return bold = true;
            } else if (pair[0] === 'italic') {
              return italic = true;
            } else {
              return color = pair[0];
            }
          }
        });
        return _this.listContents.addItem(_this.labelGetter(element), _this.select, null, color, bold, italic, _this.doubleClickAction);
      };
    })(this));
    this.listContents.setPosition(this.contents.position());
    this.listContents.isListContents = true;
    this.listContents.updateRendering();
    return this.addContents(this.listContents);
  };

  ListMorph.prototype.select = function(item, trigger) {
    this.selected = item;
    this.active = trigger;
    if (this.action) {
      return this.action.call(this.target, item.labelString);
    }
  };

  ListMorph.prototype.setExtent = function(aPoint) {
    var lb, nb;
    lb = this.listContents.bounds;
    nb = this.bounds.origin.copy().corner(this.bounds.origin.add(aPoint));
    if (nb.right() > lb.right() && nb.width() <= lb.width()) {
      this.listContents.setRight(nb.right());
    }
    if (nb.bottom() > lb.bottom() && nb.height() <= lb.height()) {
      this.listContents.setBottom(nb.bottom());
    }
    return ListMorph.__super__.setExtent.call(this, aPoint);
  };

  ListMorph.coffeeScriptSourceOfThisClass = '# ListMorph ///////////////////////////////////////////////////////////\n\nclass ListMorph extends ScrollFrameMorph\n  \n  elements: null\n  labelGetter: null\n  format: null\n  listContents: null\n  selected: null # actual element currently selected\n  active: null # menu item representing the selected element\n  action: null\n  target: null\n  doubleClickAction: null\n\n  constructor: (@target, @action, @elements = [], labelGetter, @format = [], @doubleClickAction = null) ->\n    #\n    #    passing a format is optional. If the format parameter is specified\n    #    it has to be of the following pattern:\n    #\n    #        [\n    #            [<color>, <single-argument predicate>],\n    #            [\'bold\', <single-argument predicate>],\n    #            [\'italic\', <single-argument predicate>],\n    #            ...\n    #        ]\n    #\n    #    multiple conditions can be passed in such a format list, the\n    #    last predicate to evaluate true when given the list element sets\n    #    the given format category (color, bold, italic).\n    #    If no condition is met, the default format (color black, non-bold,\n    #    non-italic) will be assigned.\n    #    \n    #    An example of how to use fomats can be found in the InspectorMorph\'s\n    #    "markOwnProperties" mechanism.\n    #\n    #debugger\n    super()\n    @contents.acceptsDrops = false\n    @color = new Color(255, 255, 255)\n    @labelGetter = labelGetter or (element) ->\n        return element  if isString(element)\n        return element.toSource()  if element.toSource\n        element.toString()\n    @buildListContents()\n    # it\'s important to leave the step as the default noOperation\n    # instead of null because the scrollbars (inherited from scrollframe)\n    # need the step function to react to mouse drag.\n  \n  buildListContents: ->\n    if @listContents\n      @listContents = @listContents.destroy()\n    @listContents = new MenuMorph(@, null, null)\n    @elements = ["(empty)"]  if !@elements.length\n    @elements.forEach (element) =>\n      color = null\n      bold = false\n      italic = false\n      @format.forEach (pair) ->\n        if pair[1].call(null, element)\n          if pair[0] == \'bold\'\n            bold = true\n          else if pair[0] == \'italic\'\n            italic = true\n          else # assume it\'s a color\n            color = pair[0]\n      #\n      #labelString,\n      #action,\n      #hint,\n      #color,\n      #bold = false,\n      #italic = false,\n      #doubleClickAction # optional, when used as list contents\n      @listContents.addItem @labelGetter(element), @select, null, color, bold, italic, @doubleClickAction\n    #\n    @listContents.setPosition @contents.position()\n    @listContents.isListContents = true\n    @listContents.updateRendering()\n    @addContents @listContents\n  \n  select: (item, trigger) ->\n    @selected = item\n    @active = trigger\n    if @action\n      @action.call @target, item.labelString\n  \n  setExtent: (aPoint) ->\n    lb = @listContents.bounds\n    nb = @bounds.origin.copy().corner(@bounds.origin.add(aPoint))\n    if nb.right() > lb.right() and nb.width() <= lb.width()\n      @listContents.setRight nb.right()\n    if nb.bottom() > lb.bottom() and nb.height() <= lb.height()\n      @listContents.setBottom nb.bottom()\n    super aPoint';

  return ListMorph;

})(ScrollFrameMorph);

TriggerMorph = (function(_super) {
  __extends(TriggerMorph, _super);

  TriggerMorph.prototype.target = null;

  TriggerMorph.prototype.action = null;

  TriggerMorph.prototype.dataSourceMorphForTarget = null;

  TriggerMorph.prototype.label = null;

  TriggerMorph.prototype.labelString = null;

  TriggerMorph.prototype.labelColor = null;

  TriggerMorph.prototype.labelBold = null;

  TriggerMorph.prototype.labelItalic = null;

  TriggerMorph.prototype.doubleClickAction = null;

  TriggerMorph.prototype.hint = null;

  TriggerMorph.prototype.fontSize = null;

  TriggerMorph.prototype.fontStyle = null;

  TriggerMorph.prototype.highlightColor = new Color(192, 192, 192);

  TriggerMorph.prototype.highlightImage = null;

  TriggerMorph.prototype.pressColor = new Color(128, 128, 128);

  TriggerMorph.prototype.normalImage = null;

  TriggerMorph.prototype.pressImage = null;

  TriggerMorph.prototype.centered = false;

  function TriggerMorph(target, action, labelString, fontSize, fontStyle, centered, dataSourceMorphForTarget, hint, labelColor, labelBold, labelItalic, doubleClickAction) {
    this.target = target != null ? target : null;
    this.action = action != null ? action : null;
    this.labelString = labelString != null ? labelString : null;
    this.centered = centered != null ? centered : false;
    this.dataSourceMorphForTarget = dataSourceMorphForTarget != null ? dataSourceMorphForTarget : null;
    this.hint = hint != null ? hint : null;
    this.labelBold = labelBold != null ? labelBold : false;
    this.labelItalic = labelItalic != null ? labelItalic : false;
    this.doubleClickAction = doubleClickAction != null ? doubleClickAction : null;
    this.fontSize = fontSize || WorldMorph.preferencesAndSettings.menuFontSize;
    this.fontStyle = fontStyle || "sans-serif";
    this.labelColor = labelColor || new Color(0, 0, 0);
    TriggerMorph.__super__.constructor.call(this);
    this.color = new Color(255, 255, 255);
    if (this.labelString != null) {
      this.layoutSubmorphs();
    }
  }

  TriggerMorph.prototype.layoutSubmorphs = function() {
    if (this.label == null) {
      this.createLabel();
    }
    if (this.centered) {
      return this.label.setPosition(this.center().subtract(this.label.extent().floorDivideBy(2)));
    }
  };

  TriggerMorph.prototype.setLabel = function(labelString) {
    this.labelString = labelString;
    if (this.label != null) {
      this.label = this.label.destroy();
    }
    return this.layoutSubmorphs();
  };

  TriggerMorph.prototype.alignCenter = function() {
    if (!this.centered) {
      this.centered = true;
      return this.layoutSubmorphs();
    }
  };

  TriggerMorph.prototype.alignLeft = function() {
    if (this.centered) {
      this.centered = false;
      return this.layoutSubmorphs();
    }
  };

  TriggerMorph.prototype.updateRendering = function() {
    var context, ext;
    ext = this.extent();
    this.normalImage = newCanvas(ext.scaleBy(pixelRatio));
    context = this.normalImage.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    context.fillStyle = this.color.toString();
    context.fillRect(0, 0, ext.x, ext.y);
    this.highlightImage = newCanvas(ext.scaleBy(pixelRatio));
    context = this.highlightImage.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    context.fillStyle = this.highlightColor.toString();
    context.fillRect(0, 0, ext.x, ext.y);
    this.pressImage = newCanvas(ext.scaleBy(pixelRatio));
    context = this.pressImage.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    context.fillStyle = this.pressColor.toString();
    context.fillRect(0, 0, ext.x, ext.y);
    return this.image = this.normalImage;
  };

  TriggerMorph.prototype.createLabel = function() {
    this.label = new StringMorph(this.labelString || "", this.fontSize, this.fontStyle, false, false, false, null, null, this.labelColor, this.labelBold, this.labelItalic);
    return this.add(this.label);
  };

  TriggerMorph.prototype.trigger = function() {
    return this.action.call(this.target, this.dataSourceMorphForTarget);
  };

  TriggerMorph.prototype.triggerDoubleClick = function() {
    if (!this.doubleClickAction) {
      return;
    }
    if (typeof this.target === "function") {
      if (typeof this.doubleClickAction === "function") {
        return this.target.call(this.dataSourceMorphForTarget, this.doubleClickAction.call(), this);
      } else {
        return this.target.call(this.dataSourceMorphForTarget, this.doubleClickAction, this);
      }
    } else {
      if (typeof this.doubleClickAction === "function") {
        return this.doubleClickAction.call(this.target);
      } else {
        return this.target[this.doubleClickAction]();
      }
    }
  };

  TriggerMorph.prototype.mouseEnter = function() {
    this.image = this.highlightImage;
    this.changed();
    if (this.hint) {
      return this.startCountdownForBubbleHelp(this.hint);
    }
  };

  TriggerMorph.prototype.mouseLeave = function() {
    this.image = this.normalImage;
    this.changed();
    if (this.hint) {
      return this.world().hand.destroyTemporaries();
    }
  };

  TriggerMorph.prototype.mouseDownLeft = function() {
    this.image = this.pressImage;
    return this.changed();
  };

  TriggerMorph.prototype.mouseClickLeft = function() {
    this.image = this.highlightImage;
    this.changed();
    return this.trigger();
  };

  TriggerMorph.prototype.mouseDoubleClick = function() {
    return this.triggerDoubleClick();
  };

  TriggerMorph.prototype.rootForGrab = function() {
    if (this.isDraggable) {
      return TriggerMorph.__super__.rootForGrab.call(this);
    }
    return null;
  };

  TriggerMorph.prototype.startCountdownForBubbleHelp = function(contents) {
    return SpeechBubbleMorph.createInAWhileIfHandStillContainedInMorph(this, contents);
  };

  TriggerMorph.coffeeScriptSourceOfThisClass = '# TriggerMorph ////////////////////////////////////////////////////////\n\n# I provide basic button functionality.\n# All menu items and buttons are TriggerMorphs.\n# The handling of the triggering is not\n# trivial, as the concepts of\n# dataSourceMorphForTarget, target and action\n# are used - see comments.\n\nclass TriggerMorph extends Morph\n\n  target: null\n  action: null\n  dataSourceMorphForTarget: null\n  label: null\n  labelString: null\n  labelColor: null\n  labelBold: null\n  labelItalic: null\n  doubleClickAction: null\n  hint: null\n  fontSize: null\n  fontStyle: null\n  # careful: this Color object is shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  highlightColor: new Color(192, 192, 192)\n  highlightImage: null\n  # careful: this Color object is shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  pressColor: new Color(128, 128, 128)\n  normalImage: null\n  pressImage: null\n  centered: false\n\n  constructor: (\n      @target = null,\n      @action = null,\n      @labelString = null,\n      fontSize,\n      fontStyle,\n      @centered = false,\n      @dataSourceMorphForTarget = null,\n      @hint = null,\n      labelColor,\n      @labelBold = false,\n      @labelItalic = false\n      @doubleClickAction = null) ->\n\n    # additional properties:\n    @fontSize = fontSize or WorldMorph.preferencesAndSettings.menuFontSize\n    @fontStyle = fontStyle or "sans-serif"\n    @labelColor = labelColor or new Color(0, 0, 0)\n    #\n    super()\n    #\n    #@color = new Color(255, 152, 152)\n    @color = new Color(255, 255, 255)\n    if @labelString?\n      @layoutSubmorphs()\n  \n  layoutSubmorphs: ->\n    if not @label?\n      @createLabel()\n    if @centered\n      @label.setPosition @center().subtract(@label.extent().floorDivideBy(2))\n\n  setLabel: (@labelString) ->\n    # just recreated the label\n    # from scratch\n    if @label?\n      @label = @label.destroy()\n    @layoutSubmorphs()\n\n  alignCenter: ->\n    if !@centered\n      @centered = true\n      @layoutSubmorphs()\n\n  alignLeft: ->\n    if @centered\n      @centered = false\n      @layoutSubmorphs()\n  \n  updateRendering: ->\n    ext = @extent()\n    @normalImage = newCanvas(ext.scaleBy pixelRatio)\n    context = @normalImage.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    context.fillStyle = @color.toString()\n    context.fillRect 0, 0, ext.x, ext.y\n    @highlightImage = newCanvas(ext.scaleBy pixelRatio)\n    context = @highlightImage.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    context.fillStyle = @highlightColor.toString()\n    context.fillRect 0, 0, ext.x, ext.y\n    @pressImage = newCanvas(ext.scaleBy pixelRatio)\n    context = @pressImage.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    context.fillStyle = @pressColor.toString()\n    context.fillRect 0, 0, ext.x, ext.y\n    @image = @normalImage\n  \n  createLabel: ->\n    # bold\n    # italic\n    # numeric\n    # shadow offset\n    # shadow color\n    @label = new StringMorph(\n      @labelString or "",\n      @fontSize,\n      @fontStyle,\n      false,\n      false,\n      false,\n      null,\n      null,\n      @labelColor,\n      @labelBold,\n      @labelItalic\n    )\n    @add @label\n    \n  \n  # TriggerMorph action:\n  trigger: ->\n    @action.call @target, @dataSourceMorphForTarget\n\n  triggerDoubleClick: ->\n    # same as trigger() but use doubleClickAction instead of action property\n    # note that specifying a doubleClickAction is optional\n    return  unless @doubleClickAction\n    if typeof @target is "function"\n      if typeof @doubleClickAction is "function"\n        @target.call @dataSourceMorphForTarget, @doubleClickAction.call(), this\n      else\n        @target.call @dataSourceMorphForTarget, @doubleClickAction, this\n    else\n      if typeof @doubleClickAction is "function"\n        @doubleClickAction.call @target\n      else # assume it\'s a String\n        @target[@doubleClickAction]()  \n  \n  # TriggerMorph events:\n  mouseEnter: ->\n    @image = @highlightImage\n    @changed()\n    @startCountdownForBubbleHelp @hint  if @hint\n  \n  mouseLeave: ->\n    @image = @normalImage\n    @changed()\n    @world().hand.destroyTemporaries()  if @hint\n  \n  mouseDownLeft: ->\n    @image = @pressImage\n    @changed()\n  \n  mouseClickLeft: ->\n    @image = @highlightImage\n    @changed()\n    @trigger()\n\n  mouseDoubleClick: ->\n    @triggerDoubleClick()\n\n  # Disable dragging compound Morphs by Triggers\n  # User can still move the trigger itself though\n  # (it it\'s unlocked)\n  rootForGrab: ->\n    if @isDraggable\n      return super()\n    null\n  \n  # TriggerMorph bubble help:\n  startCountdownForBubbleHelp: (contents) ->\n    SpeechBubbleMorph.createInAWhileIfHandStillContainedInMorph @, contents';

  return TriggerMorph;

})(Morph);

MenuItemMorph = (function(_super) {
  __extends(MenuItemMorph, _super);

  function MenuItemMorph(target, action, labelString, fontSize, fontStyle, centered, environment, hint, color, bold, italic, doubleClickAction) {
    MenuItemMorph.__super__.constructor.call(this, target, action, labelString, fontSize, fontStyle, centered, environment, hint, color, bold, italic, doubleClickAction);
  }

  MenuItemMorph.prototype.createLabel = function() {
    var icon, lbl, np, w;
    if (this.label != null) {
      this.label = this.label.destroy();
    }
    if (isString(this.labelString)) {
      this.label = this.createLabelString(this.labelString);
    } else if (this.labelString instanceof Array) {
      this.label = new Morph();
      this.label.alpha = 0;
      icon = this.createIcon(this.labelString[0]);
      this.label.add(icon);
      lbl = this.createLabelString(this.labelString[1]);
      this.label.add(lbl);
      lbl.setCenter(icon.center());
      lbl.setLeft(icon.right() + 4);
      this.label.bounds = icon.bounds.merge(lbl.bounds);
    } else {
      this.label = this.createIcon(this.labelString);
    }
    this.add(this.label);
    w = this.width();
    this.silentSetExtent(this.label.extent().add(new Point(8, 0)));
    this.silentSetWidth(w);
    np = this.position().add(new Point(4, 0));
    return this.label.bounds = np.extent(this.label.extent());
  };

  MenuItemMorph.prototype.createIcon = function(source) {
    var context, icon, src;
    icon = new Morph();
    icon.image = (source instanceof Morph ? source.fullImage() : source);
    if (source instanceof Morph && source.getShadow()) {
      src = icon.image;
      icon.image = newCanvas(source.fullBounds().extent().subtract(this.shadowBlur * (WorldMorph.preferencesAndSettings.useBlurredShadows ? 1 : 2)).scaleBy(pixelRatio));
      context = icon.image.getContext("2d");
      context.drawImage(src, 0, 0);
    }
    icon.silentSetWidth(icon.image.width);
    icon.silentSetHeight(icon.image.height);
    return icon;
  };

  MenuItemMorph.prototype.createLabelString = function(string) {
    var lbl;
    lbl = new TextMorph(string, this.fontSize, this.fontStyle);
    lbl.setColor(this.labelColor);
    return lbl;
  };

  MenuItemMorph.prototype.mouseEnter = function() {
    if (!this.isListItem()) {
      this.image = this.highlightImage;
      this.changed();
    }
    if (this.hint) {
      return this.startCountdownForBubbleHelp(this.hint);
    }
  };

  MenuItemMorph.prototype.mouseLeave = function() {
    if (!this.isListItem()) {
      this.image = this.normalImage;
      this.changed();
    }
    if (this.hint) {
      return world.hand.destroyTemporaries();
    }
  };

  MenuItemMorph.prototype.mouseDownLeft = function(pos) {
    if (this.isListItem()) {
      this.parent.unselectAllItems();
      this.escalateEvent("mouseDownLeft", pos);
    }
    this.image = this.pressImage;
    return this.changed();
  };

  MenuItemMorph.prototype.mouseMove = function() {
    if (this.isListItem()) {
      return this.escalateEvent("mouseMove");
    }
  };

  MenuItemMorph.prototype.mouseClickLeft = function() {
    this.trigger();
    if (this.parent.itemSelected) {
      return this.parent.itemSelected();
    }
  };

  MenuItemMorph.prototype.isListItem = function() {
    if (this.parent) {
      return this.parent.isListContents;
    }
    return false;
  };

  MenuItemMorph.prototype.isSelectedListItem = function() {
    if (this.isListItem()) {
      return this.image === this.pressImage;
    }
    return false;
  };

  MenuItemMorph.coffeeScriptSourceOfThisClass = '# MenuItemMorph ///////////////////////////////////////////////////////\n\n# I automatically determine my bounds\n\nclass MenuItemMorph extends TriggerMorph\n\n  # labelString can also be a Morph or a Canvas or a tuple: [icon, string]\n  constructor: (target, action, labelString, fontSize, fontStyle, centered, environment, hint, color, bold, italic, doubleClickAction) ->\n    #console.log "menuitem constructing"\n    super target, action, labelString, fontSize, fontStyle, centered, environment, hint, color, bold, italic, doubleClickAction \n  \n  createLabel: ->\n    # console.log "menuitem createLabel"\n    if @label?\n      @label = @label.destroy()\n\n    if isString(@labelString)\n      @label = @createLabelString(@labelString)\n    else if @labelString instanceof Array      \n      # assume its pattern is: [icon, string] \n      @label = new Morph()\n      @label.alpha = 0 # transparent\n\n      icon = @createIcon(@labelString[0])\n      @label.add icon\n      lbl = @createLabelString(@labelString[1])\n      @label.add lbl\n\n      lbl.setCenter icon.center()\n      lbl.setLeft icon.right() + 4\n      @label.bounds = (icon.bounds.merge(lbl.bounds))\n    else # assume it\'s either a Morph or a Canvas\n      @label = @createIcon(@labelString)\n\n    @add @label\n  \n    w = @width()\n    @silentSetExtent @label.extent().add(new Point(8, 0))\n    @silentSetWidth w\n    np = @position().add(new Point(4, 0))\n    @label.bounds = np.extent(@label.extent())\n  \n  createIcon: (source) ->\n    # source can be either a Morph or an HTMLCanvasElement\n    icon = new Morph()\n    icon.image = (if source instanceof Morph then source.fullImage() else source)\n\n    # adjust shadow dimensions\n    if source instanceof Morph and source.getShadow()\n      src = icon.image\n      icon.image = newCanvas(\n        source.fullBounds().extent().subtract(\n          @shadowBlur * ((if WorldMorph.preferencesAndSettings.useBlurredShadows then 1 else 2))).scaleBy pixelRatio)\n      context = icon.image.getContext("2d")\n      #context.scale pixelRatio, pixelRatio\n      context.drawImage src, 0, 0\n\n    icon.silentSetWidth icon.image.width\n    icon.silentSetHeight icon.image.height\n    icon\n\n  createLabelString: (string) ->\n    # console.log "menuitem createLabelString"\n    lbl = new TextMorph(string, @fontSize, @fontStyle)\n    lbl.setColor @labelColor\n    lbl  \n\n  # MenuItemMorph events:\n  mouseEnter: ->\n    unless @isListItem()\n      @image = @highlightImage\n      @changed()\n    if @hint\n      @startCountdownForBubbleHelp @hint\n  \n  mouseLeave: ->\n    unless @isListItem()\n      @image = @normalImage\n      @changed()\n    world.hand.destroyTemporaries()  if @hint\n  \n  mouseDownLeft: (pos) ->\n    if @isListItem()\n      @parent.unselectAllItems()\n      @escalateEvent "mouseDownLeft", pos\n    @image = @pressImage\n    @changed()\n  \n  mouseMove: ->\n    @escalateEvent "mouseMove"  if @isListItem()\n  \n  mouseClickLeft: ->\n    @trigger()\n    # this might now destroy the\n    # menu this morph is in\n    # The menu item might be detached\n    # from the menu so check existence of\n    # method\n    if @parent.itemSelected\n      @parent.itemSelected()\n  \n  isListItem: ->\n    return @parent.isListContents  if @parent\n    false\n  \n  isSelectedListItem: ->\n    return @image is @pressImage  if @isListItem()\n    false';

  return MenuItemMorph;

})(TriggerMorph);

MenuMorph = (function(_super) {
  __extends(MenuMorph, _super);

  MenuMorph.prototype.target = null;

  MenuMorph.prototype.title = null;

  MenuMorph.prototype.environment = null;

  MenuMorph.prototype.fontSize = null;

  MenuMorph.prototype.items = null;

  MenuMorph.prototype.label = null;

  MenuMorph.prototype.isListContents = false;

  function MenuMorph(target, title, environment, fontSize) {
    this.target = target;
    this.title = title != null ? title : null;
    this.environment = environment != null ? environment : null;
    this.fontSize = fontSize != null ? fontSize : null;
    this.items = [];
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.IDLE && SystemTestsRecorderAndPlayer.alignmentOfMorphIDsMechanism) {
      world.alignIDsOfNextMorphsInSystemTests();
    }
    MenuMorph.__super__.constructor.call(this);
    this.border = null;
  }

  MenuMorph.prototype.addItem = function(labelString, action, hint, color, bold, italic, doubleClickAction) {
    if (bold == null) {
      bold = false;
    }
    if (italic == null) {
      italic = false;
    }
    return this.items.push([localize(labelString || "close"), action || nop, hint, color, bold, italic, doubleClickAction]);
  };

  MenuMorph.prototype.prependItem = function(labelString, action, hint, color, bold, italic, doubleClickAction) {
    if (bold == null) {
      bold = false;
    }
    if (italic == null) {
      italic = false;
    }
    return this.items.unshift([localize(labelString || "close"), action || nop, hint, color, bold, italic, doubleClickAction]);
  };

  MenuMorph.prototype.addLine = function(width) {
    return this.items.push([0, width || 1]);
  };

  MenuMorph.prototype.prependLine = function(width) {
    return this.items.unshift([0, width || 1]);
  };

  MenuMorph.prototype.createLabel = function() {
    var text;
    if (this.label != null) {
      this.label = this.label.destroy();
    }
    text = new TextMorph(localize(this.title), this.fontSize || WorldMorph.preferencesAndSettings.menuFontSize, WorldMorph.preferencesAndSettings.menuFontName, true, false, "center");
    text.alignment = "center";
    text.color = new Color(255, 255, 255);
    text.backgroundColor = this.borderColor;
    this.label = new BoxMorph(3, 0);
    this.label.add(text);
    if (WorldMorph.preferencesAndSettings.isFlat) {
      this.label.edge = 0;
    }
    this.label.color = this.borderColor;
    this.label.borderColor = this.borderColor;
    this.label.setExtent(text.extent().add(4));
    return this.label.text = text;
  };

  MenuMorph.prototype.updateRendering = function() {
    var fb, isLine, x, y;
    isLine = false;
    this.destroyAll();
    this.children = [];
    if (!this.isListContents) {
      this.edge = WorldMorph.preferencesAndSettings.isFlat ? 0 : 5;
      this.border = WorldMorph.preferencesAndSettings.isFlat ? 1 : 2;
    }
    this.color = new Color(255, 255, 255);
    this.borderColor = new Color(60, 60, 60);
    this.silentSetExtent(new Point(0, 0));
    y = this.top() + 2;
    x = this.left() + 4;
    if (!this.isListContents) {
      if (this.title) {
        this.createLabel();
        this.label.setPosition(this.bounds.origin.add(4));
        this.add(this.label);
        y = this.label.bottom();
      } else {
        y = this.top() + 4;
      }
    }
    y += 1;
    this.items.forEach((function(_this) {
      return function(tuple) {
        var item;
        isLine = false;
        if (tuple instanceof StringFieldMorph || tuple instanceof ColorPickerMorph || tuple instanceof SliderMorph) {
          item = tuple;
        } else if (tuple[0] === 0) {
          isLine = true;
          item = new Morph();
          item.color = _this.borderColor;
          item.setHeight(tuple[1]);
        } else {
          item = new MenuItemMorph(_this.target, tuple[1], tuple[0], _this.fontSize || WorldMorph.preferencesAndSettings.menuFontSize, WorldMorph.preferencesAndSettings.menuFontName, false, _this.environment, tuple[2], tuple[3], tuple[4], tuple[5], tuple[6]);
          if (_this.environment == null) {
            item.dataSourceMorphForTarget = item;
          }
        }
        if (isLine) {
          y += 1;
        }
        item.setPosition(new Point(x, y));
        _this.add(item);
        y = y + item.height();
        if (isLine) {
          return y += 1;
        }
      };
    })(this));
    this.adjustWidthsOfMenuEntries();
    fb = this.boundsIncludingChildren();
    this.silentSetExtent(fb.extent().add(4));
    return MenuMorph.__super__.updateRendering.call(this);
  };

  MenuMorph.prototype.maxWidth = function() {
    var w;
    w = 0;
    if (this.parent instanceof FrameMorph) {
      if (this.parent.scrollFrame instanceof ScrollFrameMorph) {
        w = this.parent.scrollFrame.width();
      }
    }
    this.children.forEach(function(item) {
      if (item instanceof MenuItemMorph) {
        return w = Math.max(w, item.children[0].width() + 8);
      } else if ((item instanceof StringFieldMorph) || (item instanceof ColorPickerMorph) || (item instanceof SliderMorph)) {
        return w = Math.max(w, item.width());
      }
    });
    if (this.label) {
      w = Math.max(w, this.label.width());
    }
    return w;
  };

  MenuMorph.prototype.adjustWidthsOfMenuEntries = function() {
    var w;
    w = this.maxWidth();
    return this.children.forEach((function(_this) {
      return function(item) {
        var isSelected;
        item.setWidth(w);
        if (item instanceof MenuItemMorph) {
          isSelected = item.image === item.pressImage;
          item.layoutSubmorphs();
          if (isSelected) {
            return item.image = item.pressImage;
          }
        } else {
          if (item === _this.label) {
            return item.text.setPosition(item.center().subtract(item.text.extent().floorDivideBy(2)));
          }
        }
      };
    })(this));
  };

  MenuMorph.prototype.unselectAllItems = function() {
    this.children.forEach(function(item) {
      if (item instanceof MenuItemMorph) {
        return item.image = item.normalImage;
      }
    });
    return this.changed();
  };

  MenuMorph.prototype.itemSelected = function() {
    if (!this.isListContents) {
      world.unfocusMenu(this);
      return this.destroy();
    }
  };

  MenuMorph.prototype.popup = function(world, pos) {
    if (world.activeMenu) {
      world.activeMenu = world.activeMenu.destroy();
    }
    this.setPosition(pos);
    world.add(this);
    this.keepWithin(world);
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.IDLE && SystemTestsRecorderAndPlayer.alignmentOfMorphIDsMechanism) {
      world.alignIDsOfNextMorphsInSystemTests();
    }
    this.addShadow(new Point(2, 2), 80);
    world.activeMenu = this;
    return this.fullChanged();
  };

  MenuMorph.prototype.popUpAtHand = function() {
    return this.popup(world, world.hand.position());
  };

  MenuMorph.prototype.popUpCenteredAtHand = function(world) {
    var wrrld;
    wrrld = world || this.world();
    return this.popup(wrrld, wrrld.hand.position().subtract(this.extent().floorDivideBy(2)));
  };

  MenuMorph.prototype.popUpCenteredInWorld = function(world) {
    var wrrld;
    wrrld = world || this.world();
    return this.popup(wrrld, wrrld.center().subtract(this.extent().floorDivideBy(2)));
  };

  MenuMorph.coffeeScriptSourceOfThisClass = '# MenuMorph ///////////////////////////////////////////////////////////\n\nclass MenuMorph extends BoxMorph\n\n  target: null\n  title: null\n  environment: null\n  fontSize: null\n  items: null\n  label: null\n  isListContents: false\n\n  constructor: (@target, @title = null, @environment = null, @fontSize = null) ->\n    # console.log "menu constructor"\n    # Note that Morph does a updateRendering upon creation (TODO Why?), so we need\n    # to initialise the items before calling super. We can\'t initialise it\n    # outside the constructor because the array would be shared across instantiated\n    # objects.\n    @items = []\n    # console.log "menu super"\n    if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.IDLE and SystemTestsRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n    super()\n\n    @border = null # the Box Morph constructor puts this to 2\n    # important not to traverse all the children for stepping through, because\n    # there could be a lot of entries for example in the inspector the number\n    # of properties of an object - there could be a 100 of those and we don\'t\n    # want to traverse them all. Setting step to null (as opposed to nop)\n    # achieves that.\n  \n  addItem: (\n      labelString,\n      action,\n      hint,\n      color,\n      bold = false,\n      italic = false,\n      doubleClickAction # optional, when used as list contents\n      ) ->\n    # labelString is normally a single-line string. But it can also be one\n    # of the following:\n    #     * a multi-line string (containing line breaks)\n    #     * an icon (either a Morph or a Canvas)\n    #     * a tuple of format: [icon, string]\n    @items.push [\n      localize(labelString or "close"),\n      action or nop,\n      hint,\n      color,\n      bold,\n      italic,\n      doubleClickAction\n    ]\n\n  prependItem: (\n      labelString,\n      action,\n      hint,\n      color,\n      bold = false,\n      italic = false,\n      doubleClickAction # optional, when used as list contents\n      ) ->\n    # labelString is normally a single-line string. But it can also be one\n    # of the following:\n    #     * a multi-line string (containing line breaks)\n    #     * an icon (either a Morph or a Canvas)\n    #     * a tuple of format: [icon, string]\n    @items.unshift [\n      localize(labelString or "close"),\n      action or nop,\n      hint,\n      color,\n      bold,\n      italic,\n      doubleClickAction\n    ]\n  \n  addLine: (width) ->\n    @items.push [0, width or 1]\n\n  prependLine: (width) ->\n    @items.unshift [0, width or 1]\n  \n  createLabel: ->\n    # console.log "menu create label"\n    if @label?\n      @label = @label.destroy()\n    text = new TextMorph(localize(@title),\n      @fontSize or WorldMorph.preferencesAndSettings.menuFontSize,\n      WorldMorph.preferencesAndSettings.menuFontName, true, false, "center")\n    text.alignment = "center"\n    text.color = new Color(255, 255, 255)\n    text.backgroundColor = @borderColor\n\n    @label = new BoxMorph(3, 0)\n    @label.add text\n    if WorldMorph.preferencesAndSettings.isFlat\n      @label.edge = 0\n    @label.color = @borderColor\n    @label.borderColor = @borderColor\n    @label.setExtent text.extent().add(4) # here!\n    @label.text = text\n  \n  updateRendering: ->\n    # console.log "menu update rendering"\n    isLine = false\n    @destroyAll()\n    #\n    @children = []\n    unless @isListContents\n      @edge = if WorldMorph.preferencesAndSettings.isFlat then 0 else 5\n      @border = if WorldMorph.preferencesAndSettings.isFlat then 1 else 2\n    @color = new Color(255, 255, 255)\n    @borderColor = new Color(60, 60, 60)\n    @silentSetExtent new Point(0, 0)\n    y = @top() + 2\n    x = @left() + 4\n\n\n    unless @isListContents\n      if @title\n        @createLabel()\n        @label.setPosition @bounds.origin.add(4)\n        @add @label\n        y = @label.bottom()\n      else\n        y = @top() + 4\n    y += 1\n\n    # note that menus can contain:\n    # strings, colorpickers,\n    # sliders, menuItems (which are buttons)\n    # and lines.\n    # console.log "menu @items.length " + @items.length\n    @items.forEach (tuple) =>\n      isLine = false\n      # string, color picker and slider\n      if tuple instanceof StringFieldMorph or\n        tuple instanceof ColorPickerMorph or\n        tuple instanceof SliderMorph\n          item = tuple\n      # line. A thin Morph is used\n      # to draw the line.\n      else if tuple[0] is 0\n        isLine = true\n        item = new Morph()\n        item.color = @borderColor\n        item.setHeight tuple[1]\n      # menuItem\n      else\n        # console.log "menu creating MenuItemMorph "\n        item = new MenuItemMorph(\n          @target,\n          tuple[1], # action\n          tuple[0], # target\n          @fontSize or WorldMorph.preferencesAndSettings.menuFontSize,\n          WorldMorph.preferencesAndSettings.menuFontName,\n          false,\n          @environment,\n          tuple[2], # bubble help hint\n          tuple[3], # color\n          tuple[4], # bold\n          tuple[5], # italic\n          tuple[6]  # doubleclick action\n          )\n        if !@environment?\n          item.dataSourceMorphForTarget = item\n      y += 1  if isLine\n      item.setPosition new Point(x, y)\n      @add item\n      #console.log "item added: " + item.bounds\n      y = y + item.height()\n      y += 1  if isLine\n  \n    @adjustWidthsOfMenuEntries()\n    fb = @boundsIncludingChildren()\n    #console.log "fb: " + fb\n    @silentSetExtent fb.extent().add(4)\n  \n    super()\n  \n  maxWidth: ->\n    w = 0\n    if @parent instanceof FrameMorph\n      if @parent.scrollFrame instanceof ScrollFrameMorph\n        w = @parent.scrollFrame.width()    \n    @children.forEach (item) ->\n      if (item instanceof MenuItemMorph)\n        w = Math.max(w, item.children[0].width() + 8)\n      else if (item instanceof StringFieldMorph) or\n        (item instanceof ColorPickerMorph) or\n        (item instanceof SliderMorph)\n          w = Math.max(w, item.width())  \n    #\n    w = Math.max(w, @label.width())  if @label\n    w\n  \n  # makes all the elements of this menu the\n  # right width.\n  adjustWidthsOfMenuEntries: ->\n    w = @maxWidth()\n    @children.forEach (item) =>\n      item.setWidth w\n      if item instanceof MenuItemMorph\n        isSelected = (item.image == item.pressImage)\n        item.layoutSubmorphs()\n        if isSelected then item.image = item.pressImage          \n      else\n        if item is @label\n          item.text.setPosition item.center().subtract(item.text.extent().floorDivideBy(2))\n  \n  \n  unselectAllItems: ->\n    @children.forEach (item) ->\n      item.image = item.normalImage  if item instanceof MenuItemMorph\n    #\n    @changed()\n\n  itemSelected: ->\n    unless @isListContents\n      world.unfocusMenu @\n      @destroy()\n  \n  popup: (world, pos) ->\n    # console.log "menu popup"\n    # keep only one active menu at a time, destroy the\n    # previous one.\n    if world.activeMenu\n      world.activeMenu = world.activeMenu.destroy()\n    @setPosition pos\n    world.add @\n    # the @keepWithin method\n    # needs to know the extent of the morph\n    # so it must be called after the world.add\n    # method. If you call before, there is\n    # nopainting happening and the morph doesn\'t\n    # know its extent.\n    @keepWithin world\n    if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.IDLE and SystemTestsRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n    # shadow must be added after the morph\n    # has been placed somewhere because\n    # otherwise there is no visible image\n    # to base the shadow on\n    @addShadow new Point(2, 2), 80\n    world.activeMenu = @\n    @fullChanged()\n  \n  popUpAtHand: ->\n    @popup world, world.hand.position()\n  \n  popUpCenteredAtHand: (world) ->\n    wrrld = world or @world()\n    @popup wrrld, wrrld.hand.position().subtract(@extent().floorDivideBy(2))\n  \n  popUpCenteredInWorld: (world) ->\n    wrrld = world or @world()\n    @popup wrrld, wrrld.center().subtract(@extent().floorDivideBy(2))';

  return MenuMorph;

})(BoxMorph);

MorphsListMorph = (function(_super) {
  __extends(MorphsListMorph, _super);

  MorphsListMorph.prototype.morphsList = null;

  MorphsListMorph.prototype.buttonClose = null;

  MorphsListMorph.prototype.resizer = null;

  function MorphsListMorph(target) {
    MorphsListMorph.__super__.constructor.call(this);
    this.silentSetExtent(new Point(WorldMorph.preferencesAndSettings.handleSize * 10, WorldMorph.preferencesAndSettings.handleSize * 20 * 2 / 3));
    this.isDraggable = true;
    this.border = 1;
    this.edge = 5;
    this.color = new Color(60, 60, 60);
    this.borderColor = new Color(95, 95, 95);
    this.buildAndConnectChildren();
  }

  MorphsListMorph.prototype.setTarget = function(target) {
    this.target = target;
    this.currentProperty = null;
    return this.buildAndConnectChildren();
  };

  MorphsListMorph.prototype.buildAndConnectChildren = function() {
    var ListOfMorphs, attribs, theWordMorph;
    attribs = [];
    this.destroyAll();
    this.children = [];
    this.label = new TextMorph("Morphs List");
    this.label.fontSize = WorldMorph.preferencesAndSettings.menuFontSize;
    this.label.isBold = true;
    this.label.color = new Color(255, 255, 255);
    this.add(this.label);
    theWordMorph = "Morph";
    ListOfMorphs = (Object.keys(window)).filter(function(i) {
      return i.indexOf(theWordMorph, i.length - theWordMorph.length) !== -1;
    });
    this.morphsList = new ListMorph(ListOfMorphs, null);
    this.morphsList.hBar.alpha = 0.6;
    this.morphsList.vBar.alpha = 0.6;
    this.add(this.morphsList);
    this.buttonClose = new TriggerMorph(this);
    this.buttonClose.setLabel("close");
    this.buttonClose.action = (function(_this) {
      return function() {
        return _this.destroy();
      };
    })(this);
    this.add(this.buttonClose);
    this.resizer = new HandleMorph(this, 150, 100, this.edge, this.edge);
    return this.layoutSubmorphs();
  };

  MorphsListMorph.prototype.layoutSubmorphs = function() {
    var b, h, r, w, x, y;
    Morph.prototype.trackChanges = false;
    x = this.left() + this.edge;
    y = this.top() + this.edge;
    r = this.right() - this.edge;
    w = r - x;
    this.label.setPosition(new Point(x, y));
    this.label.setWidth(w);
    if (this.label.height() > (this.height() - 50)) {
      this.setHeight(this.label.height() + 50);
      this.changed();
    }
    y = this.label.bottom() + 2;
    w = this.width() - this.edge;
    w -= this.edge;
    b = this.bottom() - (2 * this.edge) - WorldMorph.preferencesAndSettings.handleSize;
    h = b - y;
    this.morphsList.setPosition(new Point(x, y));
    this.morphsList.setExtent(new Point(w, h));
    x = this.morphsList.left();
    y = this.morphsList.bottom() + this.edge;
    h = WorldMorph.preferencesAndSettings.handleSize;
    w = this.morphsList.width() - h - this.edge;
    this.buttonClose.setPosition(new Point(x, y));
    this.buttonClose.setExtent(new Point(w, h));
    Morph.prototype.trackChanges = true;
    return this.changed();
  };

  MorphsListMorph.prototype.setExtent = function(aPoint) {
    MorphsListMorph.__super__.setExtent.call(this, aPoint);
    return this.layoutSubmorphs();
  };

  MorphsListMorph.coffeeScriptSourceOfThisClass = '# MorphsListMorph //////////////////////////////////////////////////////\n\nclass MorphsListMorph extends BoxMorph\n\n  # panes:\n  morphsList: null\n  buttonClose: null\n  resizer: null\n\n  constructor: (target) ->\n    super()\n\n    @silentSetExtent new Point(\n      WorldMorph.preferencesAndSettings.handleSize * 10,\n      WorldMorph.preferencesAndSettings.handleSize * 20 * 2 / 3)\n    @isDraggable = true\n    @border = 1\n    @edge = 5\n    @color = new Color(60, 60, 60)\n    @borderColor = new Color(95, 95, 95)\n    @buildAndConnectChildren()\n  \n  setTarget: (target) ->\n    @target = target\n    @currentProperty = null\n    @buildAndConnectChildren()\n  \n  buildAndConnectChildren: ->\n    attribs = []\n\n    # remove existing panes\n    @destroyAll()\n\n    @children = []\n\n    # label\n    @label = new TextMorph("Morphs List")\n    @label.fontSize = WorldMorph.preferencesAndSettings.menuFontSize\n    @label.isBold = true\n    @label.color = new Color(255, 255, 255)\n    @add @label\n\n    # Check which objects end with the word Morph\n    theWordMorph = "Morph"\n    ListOfMorphs = (Object.keys(window)).filter (i) ->\n      i.indexOf(theWordMorph, i.length - theWordMorph.length) isnt -1\n    @morphsList = new ListMorph(ListOfMorphs, null)\n\n    # so far nothing happens when items are selected\n    #@morphsList.action = (selected) ->\n    #  val = myself.target[selected]\n    #  myself.currentProperty = val\n    #  if val is null\n    #    txt = "NULL"\n    #  else if isString(val)\n    #    txt = val\n    #  else\n    #    txt = val.toString()\n    #  cnts = new TextMorph(txt)\n    #  cnts.isEditable = true\n    #  cnts.enableSelecting()\n    #  cnts.setReceiver myself.target\n    #  myself.detail.setContents cnts\n\n    @morphsList.hBar.alpha = 0.6\n    @morphsList.vBar.alpha = 0.6\n    @add @morphsList\n\n    # close button\n    @buttonClose = new TriggerMorph(@)\n    @buttonClose.setLabel "close"\n    @buttonClose.action = =>\n      @destroy()\n\n    @add @buttonClose\n\n    # resizer\n    @resizer = new HandleMorph(@, 150, 100, @edge, @edge)\n\n    # update layout\n    @layoutSubmorphs()\n  \n  layoutSubmorphs: ->\n    Morph::trackChanges = false\n\n    # label\n    x = @left() + @edge\n    y = @top() + @edge\n    r = @right() - @edge\n    w = r - x\n    @label.setPosition new Point(x, y)\n    @label.setWidth w\n    if @label.height() > (@height() - 50)\n      @setHeight @label.height() + 50\n      @changed()\n      #@resizer.updateRendering()\n\n    # morphsList\n    y = @label.bottom() + 2\n    w = @width() - @edge\n    w -= @edge\n    b = @bottom() - (2 * @edge) - WorldMorph.preferencesAndSettings.handleSize\n    h = b - y\n    @morphsList.setPosition new Point(x, y)\n    @morphsList.setExtent new Point(w, h)\n\n    # close button\n    x = @morphsList.left()\n    y = @morphsList.bottom() + @edge\n    h = WorldMorph.preferencesAndSettings.handleSize\n    w = @morphsList.width() - h - @edge\n    @buttonClose.setPosition new Point(x, y)\n    @buttonClose.setExtent new Point(w, h)\n    Morph::trackChanges = true\n    @changed()\n  \n  setExtent: (aPoint) ->\n    super aPoint\n    @layoutSubmorphs()';

  return MorphsListMorph;

})(BoxMorph);

MouseSensorMorph = (function(_super) {
  __extends(MouseSensorMorph, _super);

  function MouseSensorMorph(edge, border, borderColor) {
    MouseSensorMorph.__super__.constructor.apply(this, arguments);
    this.edge = edge || 4;
    this.border = border || 2;
    this.color = new Color(255, 255, 255);
    this.borderColor = borderColor || new Color();
    this.isTouched = false;
    this.upStep = 0.05;
    this.downStep = 0.02;
    this.noticesTransparentClick = false;
  }

  MouseSensorMorph.prototype.touch = function() {
    if (!this.isTouched) {
      this.isTouched = true;
      this.alpha = 0.6;
      return this.step = (function(_this) {
        return function() {
          if (_this.isTouched) {
            if (_this.alpha < 1) {
              _this.alpha = _this.alpha + _this.upStep;
            }
          } else if (_this.alpha > _this.downStep) {
            _this.alpha = _this.alpha - _this.downStep;
          } else {
            _this.alpha = 0;
            _this.step = null;
          }
          return _this.changed();
        };
      })(this);
    }
  };

  MouseSensorMorph.prototype.unTouch = function() {
    return this.isTouched = false;
  };

  MouseSensorMorph.prototype.mouseEnter = function() {
    return this.touch();
  };

  MouseSensorMorph.prototype.mouseLeave = function() {
    return this.unTouch();
  };

  MouseSensorMorph.prototype.mouseDownLeft = function() {
    return this.touch();
  };

  MouseSensorMorph.prototype.mouseClickLeft = function() {
    return this.unTouch();
  };

  MouseSensorMorph.coffeeScriptSourceOfThisClass = '# MouseSensorMorph ////////////////////////////////////////////////////\n\n# for demo and debuggin purposes only, to be removed later\nclass MouseSensorMorph extends BoxMorph\n  constructor: (edge, border, borderColor) ->\n    super\n    @edge = edge or 4\n    @border = border or 2\n    @color = new Color(255, 255, 255)\n    @borderColor = borderColor or new Color()\n    @isTouched = false\n    @upStep = 0.05\n    @downStep = 0.02\n    @noticesTransparentClick = false\n  \n  touch: ->\n    unless @isTouched\n      @isTouched = true\n      @alpha = 0.6\n      @step = =>\n        if @isTouched\n          @alpha = @alpha + @upStep  if @alpha < 1\n        else if @alpha > (@downStep)\n          @alpha = @alpha - @downStep\n        else\n          @alpha = 0\n          @step = null\n        @changed()\n  \n  unTouch: ->\n    @isTouched = false\n  \n  mouseEnter: ->\n    @touch()\n  \n  mouseLeave: ->\n    @unTouch()\n  \n  mouseDownLeft: ->\n    @touch()\n  \n  mouseClickLeft: ->\n    @unTouch()';

  return MouseSensorMorph;

})(BoxMorph);


/*
Copyright 2013 Craig Campbell
coffeescript port by Davide Della Casa

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Mousetrap is a simple keyboard shortcut library for Javascript with
no external dependencies

@version 1.3.1
@url craig.is/killing/mice
 */


/*
mapping of special keycodes to their corresponding keys

everything in this dictionary cannot use keypress events
so it has to be here to map to the correct keycodes for
keyup/keydown events

@type {Object}
 */

_MAP = {
  8: "backspace",
  9: "tab",
  13: "enter",
  16: "shift",
  17: "ctrl",
  18: "alt",
  20: "capslock",
  27: "esc",
  32: "space",
  33: "pageup",
  34: "pagedown",
  35: "end",
  36: "home",
  37: "left",
  38: "up",
  39: "right",
  40: "down",
  45: "ins",
  46: "del",
  91: "meta",
  93: "meta",
  224: "meta"
};


/*
mapping for special characters so they can support

this dictionary is only used incase you want to bind a
keyup or keydown event to one of these keys

@type {Object}
 */

_KEYCODE_MAP = {
  106: "*",
  107: "+",
  109: "-",
  110: ".",
  111: "/",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};


/*
this is a mapping of keys that require shift on a US keypad
back to the non shift equivelents

this is so you can use keyup events with these keys

note that this will only work reliably on US keyboards

@type {Object}
 */

_SHIFT_MAP = {
  "~": "`",
  "!": "1",
  "@": "2",
  "#": "3",
  $: "4",
  "%": "5",
  "^": "6",
  "&": "7",
  "*": "8",
  "(": "9",
  ")": "0",
  _: "-",
  "+": "=",
  ":": ";",
  "\"": "'",
  "<": ",",
  ">": ".",
  "?": "/",
  "|": "\\"
};


/*
this is a list of special strings you can use to map
to modifier keys when you specify your keyboard shortcuts

@type {Object}
 */

_SPECIAL_ALIASES = {
  option: "alt",
  command: "meta",
  "return": "enter",
  escape: "esc"
};


/*
variable to store the flipped version of _MAP from above
needed to check if we should use keypress or not when no action
is specified

@type {Object|undefined}
 */

_REVERSE_MAP = void 0;


/*
a list of all the callbacks setup via Mousetrap.bind()

@type {Object}
 */

_callbacks = {};


/*
direct map of string combinations to callbacks used for trigger()

@type {Object}
 */

_directMap = {};


/*
keeps track of what level each sequence is at since multiple
sequences can start out with the same sequence

@type {Object}
 */

_sequenceLevels = {};


/*
variable to store the setTimeout call

@type {null|number}
 */

_resetTimer = void 0;


/*
temporary state where we will ignore the next keyup

@type {boolean|string}
 */

_ignoreNextKeyup = false;


/*
are we currently inside of a sequence?
type of action ("keyup" or "keydown" or "keypress") or false

@type {boolean|string}
 */

_sequenceType = false;


/*
loop through the f keys, f1 to f19 and add them to the map
programatically
 */

i = 1;

while (i < 20) {
  _MAP[111 + i] = "f" + i;
  ++i;
}


/*
loop through to map numbers on the numeric keypad
 */

i = 0;

while (i <= 9) {
  _MAP[i + 96] = i;
  ++i;
}


/*
cross browser add event method

@param {Element|HTMLDocument} object
@param {string} type
@param {Function} callback
@returns void
 */

_addEvent = function(object, type, callback) {
  if (object.addEventListener) {
    object.addEventListener(type, callback, false);
    return;
  }
  return object.attachEvent("on" + type, callback);
};


/*
takes the event and returns the key character

@param {Event} e
@return {string}
 */

_characterFromEvent = function(e) {
  if (e.type === "keypress") {
    return String.fromCharCode(e.which);
  }
  if (_MAP[e.which]) {
    return _MAP[e.which];
  }
  if (_KEYCODE_MAP[e.which]) {
    return _KEYCODE_MAP[e.which];
  }
  return String.fromCharCode(e.which).toLowerCase();
};


/*
checks if two arrays are equal

@param {Array} modifiers1
@param {Array} modifiers2
@returns {boolean}
 */

_modifiersMatch = function(modifiers1, modifiers2) {
  return modifiers1.sort().join(",") === modifiers2.sort().join(",");
};


/*
resets all sequence counters except for the ones passed in

@param {Object} doNotReset
@returns void
 */

_resetSequences = function(doNotReset, maxLevel) {
  var activeSequences, key;
  doNotReset = doNotReset || {};
  activeSequences = false;
  key = void 0;
  for (key in _sequenceLevels) {
    if (doNotReset[key] && _sequenceLevels[key] > maxLevel) {
      activeSequences = true;
      continue;
    }
    _sequenceLevels[key] = 0;
  }
  if (!activeSequences) {
    return _sequenceType = false;
  }
};


/*
finds all callbacks that match based on the keycode, modifiers,
and action

@param {string} character
@param {Array} modifiers
@param {Event|Object} e
@param {boolean=} remove - should we remove any matches
@param {string=} combination
@returns {Array}
 */

_getMatches = function(character, modifiers, e, remove, combination) {
  var action, callback, matches, _i, _ref;
  i = void 0;
  callback = void 0;
  matches = [];
  action = e.type;
  if (!_callbacks[character]) {
    return [];
  }
  if (action === "keyup" && _isModifier(character)) {
    modifiers = [character];
  }
  for (i = _i = 0, _ref = _callbacks[character].length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    callback = _callbacks[character][i];
    if (callback.seq && _sequenceLevels[callback.seq] !== callback.level) {
      continue;
    }
    if (action !== callback.action) {
      continue;
    }
    if ((action === "keypress" && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {
      if (remove && callback.combo === combination) {
        _callbacks[character].splice(i, 1);
      }
      matches.push(callback);
    }
  }
  return matches;
};


/*
takes a key event and figures out what the modifiers are

@param {Event} e
@returns {Array}
 */

_eventModifiers = function(e) {
  var modifiers;
  modifiers = [];
  if (e.shiftKey) {
    modifiers.push("shift");
  }
  if (e.altKey) {
    modifiers.push("alt");
  }
  if (e.ctrlKey) {
    modifiers.push("ctrl");
  }
  if (e.metaKey) {
    modifiers.push("meta");
  }
  return modifiers;
};


/*
actually calls the callback function

if your callback function returns false this will use the jquery
convention - prevent default and stop propogation on the event

@param {Function} callback
@param {Event} e
@returns void
 */

_fireCallback = function(callback, e, combo) {
  if (Mousetrap.stopCallback(e, e.target || e.srcElement, combo)) {
    return;
  }
  if (callback(e, combo) === false) {
    if (e.preventDefault) {
      e.preventDefault();
    }
    if (e.stopPropagation) {
      e.stopPropagation();
    }
    e.returnValue = false;
    return e.cancelBubble = true;
  }
};


/*
handles a character key event

@param {string} character
@param {Event} e
@returns void
 */

_handleCharacter = function(character, e) {
  var callbacks, doNotReset, maxLevel, processedSequenceCallback;
  callbacks = _getMatches(character, _eventModifiers(e), e);
  i = void 0;
  doNotReset = {};
  maxLevel = 0;
  processedSequenceCallback = false;
  i = 0;
  while (i < callbacks.length) {
    if (callbacks[i].seq) {
      processedSequenceCallback = true;
      maxLevel = Math.max(maxLevel, callbacks[i].level);
      doNotReset[callbacks[i].seq] = 1;
      _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
      continue;
    }
    if (!processedSequenceCallback && !_sequenceType) {
      _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
    }
    ++i;
  }
  if (e.type === _sequenceType && !_isModifier(character)) {
    return _resetSequences(doNotReset, maxLevel);
  }
};


/*
handles a keydown event

@param {Event} e
@returns void
 */

_handleKey = function(e) {
  var character;
  if (typeof e.which !== "number") {
    e.which = e.keyCode;
  }
  character = _characterFromEvent(e);
  if (!character) {
    return;
  }
  if (e.type === "keyup" && _ignoreNextKeyup === character) {
    _ignoreNextKeyup = false;
    return;
  }
  return _handleCharacter(character, e);
};


/*
determines if the keycode specified is a modifier key or not

@param {string} key
@returns {boolean}
 */

_isModifier = function(key) {
  return key === "shift" || key === "ctrl" || key === "alt" || key === "meta";
};


/*
called to set a 1 second timeout on the specified sequence

this is so after each key press in the sequence you have 1 second
to press the next key before you have to start over

@returns void
 */

_resetSequenceTimer = function() {
  clearTimeout(_resetTimer);
  return _resetTimer = setTimeout(_resetSequences, 1000);
};


/*
reverses the map lookup so that we can look for specific keys
to see what can and can't use keypress

@return {Object}
 */

_getReverseMap = function() {
  var key;
  if (!_REVERSE_MAP) {
    _REVERSE_MAP = {};
    for (key in _MAP) {
      if (key > 95 && key < 112) {
        continue;
      }
      if (_MAP.hasOwnProperty(key)) {
        _REVERSE_MAP[_MAP[key]] = key;
      }
    }
  }
  return _REVERSE_MAP;
};


/*
picks the best action based on the key combination

@param {string} key - character for key
@param {Array} modifiers
@param {string=} action passed in
 */

_pickBestAction = function(key, modifiers, action) {
  if (!action) {
    action = (_getReverseMap()[key] ? "keydown" : "keypress");
  }
  if (action === "keypress" && modifiers.length) {
    action = "keydown";
  }
  return action;
};


/*
binds a key sequence to an event

@param {string} combo - combo specified in bind call
@param {Array} keys
@param {Function} callback
@param {string=} action
@returns void
 */

_bindSequence = function(combo, keys, callback, action) {
  var _callbackAndReset, _increaseSequence, _results;
  _sequenceLevels[combo] = 0;
  if (!action) {
    action = _pickBestAction(keys[0], []);
  }

  /*
  callback to increase the sequence level for this sequence and reset
  all other sequences that were active
  
  @param {Event} e
  @returns void
   */
  _increaseSequence = function() {
    _sequenceType = action;
    ++_sequenceLevels[combo];
    return _resetSequenceTimer();
  };

  /*
  wraps the specified callback inside of another function in order
  to reset all sequence counters as soon as this sequence is done
  
  @param {Event} e
  @returns void
   */
  _callbackAndReset = function(e) {
    _fireCallback(callback, e, combo);
    if (action !== "keyup") {
      _ignoreNextKeyup = _characterFromEvent(e);
    }
    return setTimeout(_resetSequences, 10);
  };
  i = void 0;
  i = 0;
  _results = [];
  while (i < keys.length) {
    _bindSingle(keys[i], (i < keys.length - 1 ? _increaseSequence : _callbackAndReset), action, combo, i);
    _results.push(++i);
  }
  return _results;
};


/*
binds a single keyboard combination

@param {string} combination
@param {Function} callback
@param {string=} action
@param {string=} sequenceName - name of sequence if part of sequence
@param {number=} level - what part of the sequence the command is
@returns void
 */

_bindSingle = function(combination, callback, action, sequenceName, level) {
  var key, keys, modifiers, sequence;
  _directMap[combination + ":" + action] = callback;
  combination = combination.replace(/\s+/g, " ");
  sequence = combination.split(" ");
  i = void 0;
  key = void 0;
  keys = void 0;
  modifiers = [];
  if (sequence.length > 1) {
    _bindSequence(combination, sequence, callback, action);
    return;
  }
  keys = (combination === "+" ? ["+"] : combination.split("+"));
  i = 0;
  while (i < keys.length) {
    key = keys[i];
    if (_SPECIAL_ALIASES[key]) {
      key = _SPECIAL_ALIASES[key];
    }
    if (action && action !== "keypress" && _SHIFT_MAP[key]) {
      key = _SHIFT_MAP[key];
      modifiers.push("shift");
    }
    if (_isModifier(key)) {
      modifiers.push(key);
    }
    ++i;
  }
  action = _pickBestAction(key, modifiers, action);
  if (!_callbacks[key]) {
    _callbacks[key] = [];
  }
  _getMatches(key, modifiers, {
    type: action
  }, !sequenceName, combination);
  return _callbacks[key][(sequenceName ? "unshift" : "push")]({
    callback: callback,
    modifiers: modifiers,
    action: action,
    seq: sequenceName,
    level: level,
    combo: combination
  });
};


/*
binds multiple combinations to the same callback

@param {Array} combinations
@param {Function} callback
@param {string|undefined} action
@returns void
 */

_bindMultiple = function(combinations, callback, action) {
  var _results;
  i = 0;
  _results = [];
  while (i < combinations.length) {
    _bindSingle(combinations[i], callback, action);
    _results.push(++i);
  }
  return _results;
};

_addEvent(document, "keypress", _handleKey);

_addEvent(document, "keydown", _handleKey);

_addEvent(document, "keyup", _handleKey);

Mousetrap = {

  /*
  binds an event to mousetrap
  
  can be a single key, a combination of keys separated with +,
  an array of keys, or a sequence of keys separated by spaces
  
  be sure to list the modifier keys first to make sure that the
  correct key ends up getting bound (the last key in the pattern)
  
  @param {string|Array} keys
  @param {Function} callback
  @param {string=} action - 'keypress', 'keydown', or 'keyup'
  @returns void
   */
  bind: function(keys, callback, action) {
    keys = (keys instanceof Array ? keys : [keys]);
    _bindMultiple(keys, callback, action);
    return this;
  },

  /*
  unbinds an event to mousetrap
  
  the unbinding sets the callback function of the specified key combo
  to an empty function and deletes the corresponding key in the
  _directMap dict.
  
  TODO: actually remove this from the _callbacks dictionary instead
  of binding an empty function
  
  the keycombo+action has to be exactly the same as
  it was defined in the bind method
  
  @param {string|Array} keys
  @param {string} action
  @returns void
   */
  unbind: function(keys, action) {
    return Mousetrap.bind(keys, (function() {}), action);
  },

  /*
  triggers an event that has already been bound
  
  @param {string} keys
  @param {string=} action
  @returns void
   */
  trigger: function(keys, action) {
    if (_directMap[keys + ":" + action]) {
      _directMap[keys + ":" + action]({}, keys);
    }
    return this;
  },

  /*
  resets the library back to its initial state.  this is useful
  if you want to clear out the current keyboard shortcuts and bind
  new ones - for example if you switch to another page
  
  @returns void
   */
  reset: function() {
    _callbacks = {};
    _directMap = {};
    return this;
  },

  /*
  should we stop this event before firing off callbacks
  
  @param {Event} e
  @param {Element} element
  @return {boolean}
   */
  stopCallback: function(e, element) {
    if ((" " + element.className + " ").indexOf(" mousetrap ") > -1) {
      return false;
    }
    return element.tagName === "INPUT" || element.tagName === "SELECT" || element.tagName === "TEXTAREA" || (element.contentEditable && element.contentEditable === "true");
  }
};

window.Mousetrap = Mousetrap;

PenMorph = (function(_super) {
  __extends(PenMorph, _super);

  PenMorph.prototype.heading = 0;

  PenMorph.prototype.penSize = null;

  PenMorph.prototype.isWarped = false;

  PenMorph.prototype.isDown = true;

  PenMorph.prototype.wantsRedraw = false;

  PenMorph.prototype.penPoint = 'tip';

  function PenMorph() {
    this.penSize = WorldMorph.preferencesAndSettings.handleSize * 4;
    PenMorph.__super__.constructor.call(this);
    this.setExtent(new Point(this.penSize, this.penSize));
    this.penSize = 1;
  }

  PenMorph.staticVariable = 1;

  PenMorph.staticFunction = function() {
    return 3.14;
  };

  PenMorph.prototype.changed = function() {
    var w;
    if (this.isWarped === false) {
      w = this.root();
      if (w instanceof WorldMorph && (this instanceof WorldMorph || (this.parent != null))) {
        w.broken.push(this.visibleBounds().spread());
      }
      if (this.parent) {
        return this.parent.childChanged(this);
      }
    }
  };

  PenMorph.prototype.updateRendering = function(facing) {
    var context, dest, direction, left, len, right, start;
    direction = facing || this.heading;
    if (this.isWarped) {
      this.wantsRedraw = true;
      return;
    }
    this.image = newCanvas(this.extent().scaleBy(pixelRatio));
    context = this.image.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    len = this.width() / 2;
    start = this.center().subtract(this.bounds.origin);
    if (this.penPoint === "tip") {
      dest = start.distanceAngle(len * 0.75, direction - 180);
      left = start.distanceAngle(len, direction + 195);
      right = start.distanceAngle(len, direction - 195);
    } else {
      dest = start.distanceAngle(len * 0.75, direction);
      left = start.distanceAngle(len * 0.33, direction + 230);
      right = start.distanceAngle(len * 0.33, direction - 230);
    }
    context.fillStyle = this.color.toString();
    context.beginPath();
    context.moveTo(start.x, start.y);
    context.lineTo(left.x, left.y);
    context.lineTo(dest.x, dest.y);
    context.lineTo(right.x, right.y);
    context.closePath();
    context.strokeStyle = "white";
    context.lineWidth = 3;
    context.stroke();
    context.strokeStyle = "black";
    context.lineWidth = 1;
    context.stroke();
    context.fill();
    return this.wantsRedraw = false;
  };

  PenMorph.prototype.setHeading = function(degrees) {
    this.heading = parseFloat(degrees) % 360;
    this.updateRendering();
    return this.changed();
  };

  PenMorph.prototype.drawLine = function(start, dest) {
    var context, from, to;
    context = this.parent.penTrails().getContext("2d");
    from = start.subtract(this.parent.bounds.origin);
    to = dest.subtract(this.parent.bounds.origin);
    if (this.isDown) {
      context.lineWidth = this.penSize;
      context.strokeStyle = this.color.toString();
      context.lineCap = "round";
      context.lineJoin = "round";
      context.beginPath();
      context.moveTo(from.x, from.y);
      context.lineTo(to.x, to.y);
      context.stroke();
      if (this.isWarped === false && (this instanceof WorldMorph || (this.parent != null))) {
        return this.world().broken.push(start.rectangle(dest).expandBy(Math.max(this.penSize / 2, 1)).intersect(this.parent.visibleBounds()).spread());
      }
    }
  };

  PenMorph.prototype.turn = function(degrees) {
    return this.setHeading(this.heading + parseFloat(degrees));
  };

  PenMorph.prototype.forward = function(steps) {
    var dest, dist, start;
    start = this.center();
    dist = parseFloat(steps);
    if (dist >= 0) {
      dest = this.position().distanceAngle(dist, this.heading);
    } else {
      dest = this.position().distanceAngle(Math.abs(dist), this.heading - 180);
    }
    this.setPosition(dest);
    return this.drawLine(start, this.center());
  };

  PenMorph.prototype.down = function() {
    return this.isDown = true;
  };

  PenMorph.prototype.up = function() {
    return this.isDown = false;
  };

  PenMorph.prototype.clear = function() {
    this.parent.updateRendering();
    return this.parent.changed();
  };

  PenMorph.prototype.startWarp = function() {
    this.wantsRedraw = false;
    return this.isWarped = true;
  };

  PenMorph.prototype.endWarp = function() {
    this.isWarped = false;
    if (this.wantsRedraw) {
      this.updateRendering();
      this.wantsRedraw = false;
    }
    return this.parent.changed();
  };

  PenMorph.prototype.warp = function(fun) {
    this.startWarp();
    fun.call(this);
    return this.endWarp();
  };

  PenMorph.prototype.warpOp = function(selector, argsArray) {
    this.startWarp();
    this[selector].apply(this, argsArray);
    return this.endWarp();
  };

  PenMorph.prototype.warpSierpinski = function(length, min) {
    return this.warpOp("sierpinski", [length, min]);
  };

  PenMorph.prototype.sierpinski = function(length, min) {
    var _i, _results;
    if (length > min) {
      _results = [];
      for (i = _i = 0; _i < 3; i = ++_i) {
        this.sierpinski(length * 0.5, min);
        this.turn(120);
        _results.push(this.forward(length));
      }
      return _results;
    }
  };

  PenMorph.prototype.warpTree = function(level, length, angle) {
    return this.warpOp("tree", [level, length, angle]);
  };

  PenMorph.prototype.tree = function(level, length, angle) {
    if (level > 0) {
      this.penSize = level;
      this.forward(length);
      this.turn(angle);
      this.tree(level - 1, length * 0.75, angle);
      this.turn(angle * -2);
      this.tree(level - 1, length * 0.75, angle);
      this.turn(angle);
      return this.forward(-length);
    }
  };

  PenMorph.coffeeScriptSourceOfThisClass = '# PenMorph ////////////////////////////////////////////////////////////\n\n# I am a simple LOGO-wise turtle.\n\nclass PenMorph extends Morph\n  \n  heading: 0\n  penSize: null\n  isWarped: false # internal optimization\n  isDown: true\n  wantsRedraw: false # internal optimization\n  penPoint: \'tip\' # or \'center\'\n  \n  constructor: ->\n    @penSize = WorldMorph.preferencesAndSettings.handleSize * 4\n    super()\n    @setExtent new Point(@penSize, @penSize)\n    # todo we need to change the size two times, for getting the right size\n    # of the arrow and of the line. Probably should make the two distinct\n    @penSize = 1\n    #alert @morphMethod() # works\n    # doesn\'t work cause coffeescript doesn\'t support static inheritance\n    #alert @morphStaticMethod()\n\n    # no need to call @updateRendering() because @setExtent does it.\n    # (should it?)\n    #@updateRendering()\n\n\n  @staticVariable: 1\n  @staticFunction: -> 3.14\n    \n  # PenMorph updating - optimized for warping, i.e atomic recursion\n  changed: ->\n    if @isWarped is false\n      w = @root()\n      # unless we are the main desktop, then if the morph has no parent\n      # don\'t add the broken rect since the morph is not visible\n      if w instanceof WorldMorph and (@ instanceof WorldMorph or @parent?)\n        w.broken.push @visibleBounds().spread()\n      @parent.childChanged @  if @parent\n  \n  \n  # PenMorph display:\n  updateRendering: (facing) ->\n    #\n    #    my orientation can be overridden with the "facing" parameter to\n    #    implement Scratch-style rotation styles\n    #    \n    #\n    direction = facing or @heading\n    if @isWarped\n      @wantsRedraw = true\n      return\n    @image = newCanvas(@extent().scaleBy pixelRatio)\n    context = @image.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    len = @width() / 2\n    start = @center().subtract(@bounds.origin)\n\n    if @penPoint is "tip"\n      dest = start.distanceAngle(len * 0.75, direction - 180)\n      left = start.distanceAngle(len, direction + 195)\n      right = start.distanceAngle(len, direction - 195)\n    else # \'middle\'\n      dest = start.distanceAngle(len * 0.75, direction)\n      left = start.distanceAngle(len * 0.33, direction + 230)\n      right = start.distanceAngle(len * 0.33, direction - 230)\n\n    context.fillStyle = @color.toString()\n    context.beginPath()\n\n    context.moveTo start.x, start.y\n    context.lineTo left.x, left.y\n    context.lineTo dest.x, dest.y\n    context.lineTo right.x, right.y\n\n    context.closePath()\n    context.strokeStyle = "white"\n    context.lineWidth = 3\n    context.stroke()\n    context.strokeStyle = "black"\n    context.lineWidth = 1\n    context.stroke()\n    context.fill()\n    @wantsRedraw = false\n  \n  \n  # PenMorph access:\n  setHeading: (degrees) ->\n    @heading = parseFloat(degrees) % 360\n    @updateRendering()\n    @changed()\n  \n  \n  # PenMorph drawing:\n  drawLine: (start, dest) ->\n    context = @parent.penTrails().getContext("2d")\n    # by default penTrails() is to answer the normal\n    # morph image.\n    # The implication is that by default every Morph in the system\n    # (including the World) is able to act as turtle canvas and can\n    # display pen trails.\n    # BUT also this means that pen trails will be lost whenever\n    # the trail\'s morph (the pen\'s parent) performs a "drawNew()"\n    # operation. If you want to create your own pen trails canvas,\n    # you may wish to modify its **penTrails()** property, so that\n    # it keeps a separate offscreen canvas for pen trails\n    # (and doesn\'t lose these on redraw).\n\n    from = start.subtract(@parent.bounds.origin)\n    to = dest.subtract(@parent.bounds.origin)\n    if @isDown\n      context.lineWidth = @penSize\n      context.strokeStyle = @color.toString()\n      context.lineCap = "round"\n      context.lineJoin = "round"\n      context.beginPath()\n      context.moveTo from.x, from.y\n      context.lineTo to.x, to.y\n      context.stroke()\n      # unless we are the main desktop, then if the morph has no parent\n      # don\'t add the broken rect since the morph is not visible\n      if @isWarped is false and (@ instanceof WorldMorph or @parent?)\n        @world().broken.push start.rectangle(dest).expandBy(Math.max(@penSize / 2, 1)).intersect(@parent.visibleBounds()).spread()\n  \n  \n  # PenMorph turtle ops:\n  turn: (degrees) ->\n    @setHeading @heading + parseFloat(degrees)\n  \n  forward: (steps) ->\n    start = @center()\n    dist = parseFloat(steps)\n    if dist >= 0\n      dest = @position().distanceAngle(dist, @heading)\n    else\n      dest = @position().distanceAngle(Math.abs(dist), (@heading - 180))\n    @setPosition dest\n    @drawLine start, @center()\n  \n  down: ->\n    @isDown = true\n  \n  up: ->\n    @isDown = false\n  \n  clear: ->\n    @parent.updateRendering()\n    @parent.changed()\n  \n  \n  # PenMorph optimization for atomic recursion:\n  startWarp: ->\n    @wantsRedraw = false\n    @isWarped = true\n  \n  endWarp: ->\n    @isWarped = false\n    if @wantsRedraw\n      @updateRendering()\n      @wantsRedraw = false\n    @parent.changed()\n  \n  warp: (fun) ->\n    @startWarp()\n    fun.call @\n    @endWarp()\n  \n  warpOp: (selector, argsArray) ->\n    @startWarp()\n    @[selector].apply @, argsArray\n    @endWarp()\n  \n  \n  # PenMorph demo ops:\n  # try these with WARP eg.: this.warp(function () {tree(12, 120, 20)})\n  warpSierpinski: (length, min) ->\n    @warpOp "sierpinski", [length, min]\n  \n  sierpinski: (length, min) ->\n    if length > min\n      for i in [0...3]\n        @sierpinski length * 0.5, min\n        @turn 120\n        @forward length\n  \n  warpTree: (level, length, angle) ->\n    @warpOp "tree", [level, length, angle]\n  \n  tree: (level, length, angle) ->\n    if level > 0\n      @penSize = level\n      @forward length\n      @turn angle\n      @tree level - 1, length * 0.75, angle\n      @turn angle * -2\n      @tree level - 1, length * 0.75, angle\n      @turn angle\n      @forward -length';

  return PenMorph;

})(Morph);

Point2 = (function() {
  Point2.prototype.x = null;

  Point2.prototype.y = null;

  function Point2(x, y) {
    this.x = x != null ? x : 0;
    this.y = y != null ? y : 0;
  }

  Point2.prototype.toString = function() {
    return Math.round(this.x) + "@" + Math.round(this.y);
  };

  Point2.prototype.copy = function() {
    return new this.constructor(this.x, this.y);
  };

  Point2.prototype.eq = function(aPoint2) {
    return this.x === aPoint2.x && this.y === aPoint2.y;
  };

  Point2.prototype.lt = function(aPoint2) {
    return this.x < aPoint2.x && this.y < aPoint2.y;
  };

  Point2.prototype.gt = function(aPoint2) {
    return this.x > aPoint2.x && this.y > aPoint2.y;
  };

  Point2.prototype.ge = function(aPoint2) {
    return this.x >= aPoint2.x && this.y >= aPoint2.y;
  };

  Point2.prototype.le = function(aPoint2) {
    return this.x <= aPoint2.x && this.y <= aPoint2.y;
  };

  Point2.prototype.max = function(aPoint2) {
    this.x = Math.max(this.x, aPoint2.x);
    return this.y = Math.max(this.y, aPoint2.y);
  };

  Point2.prototype.min = function(aPoint2) {
    this.x = Math.min(this.x, aPoint2.x);
    return this.y = Math.min(this.y, aPoint2.y);
  };

  Point2.prototype.round = function() {
    this.x = Math.round(this.x);
    return this.y = Math.round(this.y);
  };

  Point2.prototype.abs = function() {
    this.x = Math.abs(this.x);
    return this.y = Math.abs(this.y);
  };

  Point2.prototype.neg = function() {
    this.x = -this.x;
    return this.y = -this.y;
  };

  Point2.prototype.mirror = function() {
    var tmpValueForSwappingXAndY;
    tmpValueForSwappingXAndY = this.x;
    this.x = this.y;
    return this.y = tmpValueForSwappingXAndY;
  };

  Point2.prototype.floor = function() {
    this.x = Math.max(Math.floor(this.x), 0);
    return this.y = Math.max(Math.floor(this.y), 0);
  };

  Point2.prototype.ceil = function() {
    this.x = Math.ceil(this.x);
    return this.y = Math.ceil(this.y);
  };

  Point2.prototype.add = function(other) {
    if (other instanceof Point2) {
      this.x = this.x + other.x;
      this.y = this.y + other.y;
      return;
    }
    this.x = this.x + other;
    return this.y = this.y + other;
  };

  Point2.prototype.subtract = function(other) {
    if (other instanceof Point2) {
      this.x = this.x - other.x;
      this.y = this.y - other.y;
      return;
    }
    this.x = this.x - other;
    return this.y = this.y - other;
  };

  Point2.prototype.multiplyBy = function(other) {
    if (other instanceof Point2) {
      this.x = this.x * other.x;
      this.y = this.y * other.y;
      return;
    }
    this.x = this.x * other;
    return this.y = this.y * other;
  };

  Point2.prototype.divideBy = function(other) {
    if (other instanceof Point2) {
      this.x = this.x / other.x;
      this.y = this.y / other.y;
      return;
    }
    this.x = this.x / other;
    return this.y = this.y / other;
  };

  Point2.prototype.floorDivideBy = function(other) {
    if (other instanceof Point2) {
      this.x = Math.floor(this.x / other.x);
      this.y = Math.floor(this.y / other.y);
      return;
    }
    this.x = Math.floor(this.x / other);
    return this.y = Math.floor(this.y / other);
  };

  Point2.prototype.r = function() {
    var t;
    t = this.copy();
    t.multiplyBy(t);
    return Math.sqrt(t.x + t.y);
  };

  Point2.prototype.degrees = function() {
    var tan, theta;
    if (this.x === 0) {
      if (this.y >= 0) {
        return 90;
      }
      return 270;
    }
    tan = this.y / this.x;
    theta = Math.atan(tan);
    if (this.x >= 0) {
      if (this.y >= 0) {
        return degrees(theta);
      }
      return 360 + (degrees(theta));
    }
    return 180 + degrees(theta);
  };

  Point2.prototype.theta = function() {
    var tan, theta;
    if (this.x === 0) {
      if (this.y >= 0) {
        return radians(90);
      }
      return radians(270);
    }
    tan = this.y / this.x;
    theta = Math.atan(tan);
    if (this.x >= 0) {
      if (this.y >= 0) {
        return theta;
      }
      return radians(360) + theta;
    }
    return radians(180) + theta;
  };

  Point2.prototype.distanceTo = function(aPoint2) {
    return (aPoint2.copy().subtract(this)).r();
  };

  Point2.prototype.rotate = function(direction, center) {
    var offset, tmpPointForRotate;
    offset = this.copy().subtract(center);
    if (direction === "right") {
      this.x = -offset.y + center.x;
      this.y = offset.y + center.y;
      return;
    }
    if (direction === "left") {
      this.x = offset.y + center.x;
      this.y = -offset.y + center.y;
      return;
    }
    tmpPointForRotate = center.copy().subtract(offset);
    this.x = tmpPointForRotate.x;
    return this.y = tmpPointForRotate.y;
  };

  Point2.prototype.flip = function(direction, center) {
    if (direction === "vertical") {
      this.y = center.y * 2 - this.y;
      return;
    }
    return this.x = center.x * 2 - this.x;
  };

  Point2.prototype.distanceAngle = function(dist, angle) {
    var deg, x, y;
    deg = angle;
    if (deg > 270) {
      deg = deg - 360;
    } else {
      if (deg < -270) {
        deg = deg + 360;
      }
    }
    if (-90 <= deg && deg <= 90) {
      x = Math.sin(radians(deg)) * dist;
      y = Math.sqrt((dist * dist) - (x * x));
      this.x = x + this.x;
      this.y = this.y - y;
      return;
    }
    x = Math.sin(radians(180 - deg)) * dist;
    y = Math.sqrt((dist * dist) - (x * x));
    this.x = x + this.x;
    return this.y = this.y + y;
  };

  Point2.prototype.scaleBy = function(scalePoint2) {
    return this.multiplyBy(scalePoint2);
  };

  Point2.prototype.translateBy = function(deltaPoint2) {
    return this.add(deltaPoint2);
  };

  Point2.prototype.rotateBy = function(angle, centerPoint2) {
    var center, p, r, theta;
    center = centerPoint2 || new this.constructor(0, 0);
    p = this.copy().subtract(center);
    r = p.r();
    theta = angle - p.theta();
    this.x = center.x + (r * Math.cos(theta));
    return this.y = center.y - (r * Math.sin(theta));
  };

  Point2.prototype.asArray = function() {
    return [this.x, this.y];
  };

  Point2.prototype.corner = function(cornerPoint2) {
    return new Rectangle(this.x, this.y, cornerPoint2.x, cornerPoint2.y);
  };

  Point2.prototype.rectangle = function(aPoint2) {
    var crn, org;
    org = this.copy().min(aPoint2);
    crn = this.copy().max(aPoint2);
    return new Rectangle(org.x, org.y, crn.x, crn.y);
  };

  Point2.prototype.extent = function(aPoint2) {
    var crn;
    crn = this.copy().add(aPoint2);
    return new Rectangle(this.x, this.y, crn.x, crn.y);
  };

  Point2.coffeeScriptSourceOfThisClass = '# Point2 //////////////////////////////////////////////////////////////\n# like Point, but it tries not to create new objects like there is\n# no tomorrow. Any operation that returned a new point now directly\n# modifies the current point.\n# Note that the arguments passed to any of these functions are never\n# modified.\n\nclass Point2\n\n  x: null\n  y: null\n   \n  constructor: (@x = 0, @y = 0) ->\n  \n  # Point2 string representation: e.g. \'12@68\'\n  toString: ->\n    Math.round(@x) + "@" + Math.round(@y)\n  \n  # Point2 copying:\n  copy: ->\n    new @constructor(@x, @y)\n  \n  # Point2 comparison:\n  eq: (aPoint2) ->\n    # ==\n    @x is aPoint2.x and @y is aPoint2.y\n  \n  lt: (aPoint2) ->\n    # <\n    @x < aPoint2.x and @y < aPoint2.y\n  \n  gt: (aPoint2) ->\n    # >\n    @x > aPoint2.x and @y > aPoint2.y\n  \n  ge: (aPoint2) ->\n    # >=\n    @x >= aPoint2.x and @y >= aPoint2.y\n  \n  le: (aPoint2) ->\n    # <=\n    @x <= aPoint2.x and @y <= aPoint2.y\n  \n  max: (aPoint2) ->\n    #new @constructor(Math.max(@x, aPoint2.x), Math.max(@y, aPoint2.y))\n    @x = Math.max(@x, aPoint2.x)\n    @y = Math.max(@y, aPoint2.y)\n  \n  min: (aPoint2) ->\n    #new @constructor(Math.min(@x, aPoint2.x), Math.min(@y, aPoint2.y))\n    @x = Math.min(@x, aPoint2.x)\n    @y = Math.min(@y, aPoint2.y)\n  \n  \n  # Point2 conversion:\n  round: ->\n    #new @constructor(Math.round(@x), Math.round(@y))\n    @x = Math.round(@x)\n    @y = Math.round(@y)\n  \n  abs: ->\n    #new @constructor(Math.abs(@x), Math.abs(@y))\n    @x = Math.abs(@x)\n    @y = Math.abs(@y)\n  \n  neg: ->\n    #new @constructor(-@x, -@y)\n    @x = -@x\n    @y = -@y\n  \n  mirror: ->\n    #new @constructor(@y, @x)\n    # note that coffeescript would allow [@x,@y] = [@y,@x]\n    # but we want to be faster here\n    tmpValueForSwappingXAndY = @x\n    @x = @y\n    @y = tmpValueForSwappingXAndY \n  \n  floor: ->\n    #new @constructor(Math.max(Math.floor(@x), 0), Math.max(Math.floor(@y), 0))\n    @x = Math.max(Math.floor(@x), 0)\n    @y = Math.max(Math.floor(@y), 0)\n  \n  ceil: ->\n    #new @constructor(Math.ceil(@x), Math.ceil(@y))\n    @x = Math.ceil(@x)\n    @y = Math.ceil(@y)\n  \n  \n  # Point2 arithmetic:\n  add: (other) ->\n    if other instanceof Point2\n      @x = @x + other.x\n      @y = @y + other.y\n      return\n    @x = @x + other\n    @y = @y + other\n  \n  subtract: (other) ->\n    if other instanceof Point2\n      @x = @x - other.x\n      @y = @y - other.y\n      return\n    @x = @x - other\n    @y = @y - other\n  \n  multiplyBy: (other) ->\n    if other instanceof Point2\n      @x = @x * other.x\n      @y = @y * other.y\n      return\n    @x = @x * other\n    @y = @y * other\n  \n  divideBy: (other) ->\n    if other instanceof Point2\n      @x = @x / other.x\n      @y = @y / other.y\n      return\n    @x = @x / other\n    @y = @y / other\n  \n  floorDivideBy: (other) ->\n    if other instanceof Point2\n      @x = Math.floor(@x / other.x)\n      @y = Math.floor(@y / other.y)\n      return\n    @x = Math.floor(@x / other)\n    @y = Math.floor(@y / other)\n  \n  \n  # Point2 polar coordinates:\n  # distance from the origin\n  r: ->\n    t = @copy()\n    t.multiplyBy(t)\n    Math.sqrt t.x + t.y\n  \n  degrees: ->\n    #\n    #    answer the angle I make with origin in degrees.\n    #    Right is 0, down is 90\n    #\n    if @x is 0\n      return 90  if @y >= 0\n      return 270\n    tan = @y / @x\n    theta = Math.atan(tan)\n    if @x >= 0\n      return degrees(theta)  if @y >= 0\n      return 360 + (degrees(theta))\n    180 + degrees(theta)\n  \n  theta: ->\n    #\n    #    answer the angle I make with origin in radians.\n    #    Right is 0, down is 90\n    #\n    if @x is 0\n      return radians(90)  if @y >= 0\n      return radians(270)\n    tan = @y / @x\n    theta = Math.atan(tan)\n    if @x >= 0\n      return theta  if @y >= 0\n      return radians(360) + theta\n    radians(180) + theta\n  \n  \n  # Point2 functions:\n    \n  distanceTo: (aPoint2) ->\n    (aPoint2.copy().subtract(@)).r()\n  \n  rotate: (direction, center) ->\n    # direction must be \'right\', \'left\' or \'pi\'\n    offset = @copy().subtract(center)\n    if direction is "right"\n      @x = -offset.y + center.x\n      @y = offset.y + center.y\n      return\n    if direction is "left"\n      @x = offset.y + center.x\n      @y = -offset.y + center.y\n      return\n    #\n    # direction === \'pi\'\n    tmpPointForRotate = center.copy().subtract offset\n    @x = tmpPointForRotate.x\n    @y = tmpPointForRotate.y\n  \n  flip: (direction, center) ->\n    # direction must be \'vertical\' or \'horizontal\'\n    if direction is "vertical"\n      @y = center.y * 2 - @y\n      return\n    #\n    # direction === \'horizontal\'\n    @x = center.x * 2 - @x\n  \n  distanceAngle: (dist, angle) ->\n    deg = angle\n    if deg > 270\n      deg = deg - 360\n    else deg = deg + 360  if deg < -270\n    if -90 <= deg and deg <= 90\n      x = Math.sin(radians(deg)) * dist\n      y = Math.sqrt((dist * dist) - (x * x))\n      @x = x + @x\n      @y = @y - y\n      return\n    x = Math.sin(radians(180 - deg)) * dist\n    y = Math.sqrt((dist * dist) - (x * x))\n    @x = x + @x\n    @y = @y + y\n  \n  \n  # Point2 transforming:\n  scaleBy: (scalePoint2) ->\n    @multiplyBy scalePoint2\n  \n  translateBy: (deltaPoint2) ->\n    @add deltaPoint2\n  \n  rotateBy: (angle, centerPoint2) ->\n    center = centerPoint2 or new @constructor(0, 0)\n    p = @copy().subtract(center)\n    r = p.r()\n    theta = angle - p.theta()\n    @x = center.x + (r * Math.cos(theta))\n    @y = center.y - (r * Math.sin(theta))\n  \n  \n  # Point2 conversion:\n  asArray: ->\n    [@x, @y]\n  \n  # creating Rectangle instances from Point2:\n  corner: (cornerPoint2) ->\n    # answer a new Rectangle\n    new Rectangle(@x, @y, cornerPoint2.x, cornerPoint2.y)\n  \n  rectangle: (aPoint2) ->\n    # answer a new Rectangle\n    org = @copy().min(aPoint2)\n    crn = @copy().max(aPoint2)\n    new Rectangle(org.x, org.y, crn.x, crn.y)\n  \n  extent: (aPoint2) ->\n    #answer a new Rectangle\n    crn = @copy().add(aPoint2)\n    new Rectangle(@x, @y, crn.x, crn.y)';

  return Point2;

})();

PreferencesAndSettings = (function() {
  PreferencesAndSettings.INPUT_MODE_MOUSE = 0;

  PreferencesAndSettings.INPUT_MODE_TOUCH = 1;

  PreferencesAndSettings.prototype.useBlurredShadows = null;

  PreferencesAndSettings.prototype.inputMode = null;

  PreferencesAndSettings.prototype.minimumFontHeight = null;

  PreferencesAndSettings.prototype.globalFontFamily = null;

  PreferencesAndSettings.prototype.menuFontName = null;

  PreferencesAndSettings.prototype.menuFontSize = null;

  PreferencesAndSettings.prototype.bubbleHelpFontSize = null;

  PreferencesAndSettings.prototype.prompterFontName = null;

  PreferencesAndSettings.prototype.prompterFontSize = null;

  PreferencesAndSettings.prototype.prompterSliderSize = null;

  PreferencesAndSettings.prototype.handleSize = null;

  PreferencesAndSettings.prototype.scrollBarSize = null;

  PreferencesAndSettings.prototype.mouseScrollAmount = null;

  PreferencesAndSettings.prototype.useSliderForInput = null;

  PreferencesAndSettings.prototype.useVirtualKeyboard = null;

  PreferencesAndSettings.prototype.isTouchDevice = null;

  PreferencesAndSettings.prototype.rasterizeSVGs = null;

  PreferencesAndSettings.prototype.isFlat = null;

  PreferencesAndSettings.prototype.printoutsReactiveValuesCode = true;

  function PreferencesAndSettings() {
    this.useBlurredShadows = getBlurredShadowSupport();
    this.setMouseInputMode();
    console.log("constructing PreferencesAndSettings");
  }

  PreferencesAndSettings.prototype.toggleBlurredShadows = function() {
    return this.useBlurredShadows = !this.useBlurredShadows;
  };

  PreferencesAndSettings.prototype.toggleInputMode = function() {
    if (this.inputMode === PreferencesAndSettings.INPUT_MODE_MOUSE) {
      return this.setTouchInputMode();
    } else {
      return this.setMouseInputMode();
    }
  };

  PreferencesAndSettings.prototype.setMouseInputMode = function() {
    this.inputMode = PreferencesAndSettings.INPUT_MODE_MOUSE;
    this.minimumFontHeight = getMinimumFontHeight();
    this.globalFontFamily = "";
    this.menuFontName = "sans-serif";
    this.menuFontSize = 12;
    this.bubbleHelpFontSize = 10;
    this.prompterFontName = "sans-serif";
    this.prompterFontSize = 12;
    this.prompterSliderSize = 10;
    this.handleSize = 15;
    this.scrollBarSize = 10;
    this.mouseScrollAmount = 40;
    this.useSliderForInput = false;
    this.useVirtualKeyboard = true;
    this.isTouchDevice = false;
    this.rasterizeSVGs = false;
    return this.isFlat = false;
  };

  PreferencesAndSettings.prototype.setTouchInputMode = function() {
    this.inputMode = PreferencesAndSettings.INPUT_MODE_TOUCH;
    this.minimumFontHeight = getMinimumFontHeight();
    this.globalFontFamily = "";
    this.menuFontName = "sans-serif";
    this.menuFontSize = 24;
    this.bubbleHelpFontSize = 18;
    this.prompterFontName = "sans-serif";
    this.prompterFontSize = 24;
    this.prompterSliderSize = 20;
    this.handleSize = 26;
    this.scrollBarSize = 24;
    this.mouseScrollAmount = 40;
    this.useSliderForInput = true;
    this.useVirtualKeyboard = true;
    this.isTouchDevice = false;
    this.rasterizeSVGs = false;
    return this.isFlat = false;
  };

  PreferencesAndSettings.coffeeScriptSourceOfThisClass = '# World-wide preferences and settings ///////////////////////////////////\n\n# Contains all possible preferences and settings for a World.\n# So it\'s World-wide values.\n# It belongs to a world, each world may have different settings.\n# this comment below is needed to figure our dependencies between classes\n# REQUIRES globalFunctions\n\nclass PreferencesAndSettings\n\n  @INPUT_MODE_MOUSE: 0\n  @INPUT_MODE_TOUCH: 1\n\n  useBlurredShadows: null\n  \n  # all these properties can be modified\n  # by the input mode.\n  inputMode: null\n  minimumFontHeight: null\n  globalFontFamily: null\n  menuFontName: null\n  menuFontSize: null\n  bubbleHelpFontSize: null\n  prompterFontName: null\n  prompterFontSize: null\n  prompterSliderSize: null\n  handleSize: null\n  scrollBarSize: null\n  mouseScrollAmount: null\n  useSliderForInput: null\n  useVirtualKeyboard: null\n  isTouchDevice: null\n  rasterizeSVGs: null\n  isFlat: null\n\n  printoutsReactiveValuesCode: true\n\n  constructor: ->\n    @useBlurredShadows = getBlurredShadowSupport() # check for Chrome-bug\n    @setMouseInputMode()\n    console.log("constructing PreferencesAndSettings")\n\n  toggleBlurredShadows: ->\n    @useBlurredShadows = not @useBlurredShadows\n\n  toggleInputMode: ->\n    if @inputMode == PreferencesAndSettings.INPUT_MODE_MOUSE\n      @setTouchInputMode()\n    else\n      @setMouseInputMode()\n\n  setMouseInputMode: ->\n    @inputMode = PreferencesAndSettings.INPUT_MODE_MOUSE\n    @minimumFontHeight = getMinimumFontHeight() # browser settings\n    @globalFontFamily = ""\n    @menuFontName = "sans-serif"\n    @menuFontSize = 12\n    @bubbleHelpFontSize = 10\n    @prompterFontName = "sans-serif"\n    @prompterFontSize = 12\n    @prompterSliderSize = 10\n    @handleSize = 15\n    @scrollBarSize = 10\n    @mouseScrollAmount = 40\n    @useSliderForInput = false\n    @useVirtualKeyboard = true\n    @isTouchDevice = false # turned on by touch events, don\'t set\n    @rasterizeSVGs = false\n    @isFlat = false\n\n  setTouchInputMode: ->\n    @inputMode = PreferencesAndSettings.INPUT_MODE_TOUCH\n    @minimumFontHeight = getMinimumFontHeight()\n    @globalFontFamily = ""\n    @menuFontName = "sans-serif"\n    @menuFontSize = 24\n    @bubbleHelpFontSize = 18\n    @prompterFontName = "sans-serif"\n    @prompterFontSize = 24\n    @prompterSliderSize = 20\n    @handleSize = 26\n    @scrollBarSize = 24\n    @mouseScrollAmount = 40\n    @useSliderForInput = true\n    @useVirtualKeyboard = true\n    @isTouchDevice = false\n    @rasterizeSVGs = false\n    @isFlat = false\n';

  return PreferencesAndSettings;

})();

ProfilingDataCollector = (function() {
  function ProfilingDataCollector() {}

  ProfilingDataCollector.shortSessionCumulativeNumberOfBrokenRects = 0;

  ProfilingDataCollector.shortSessionMaxNumberOfBrokenRects = 0;

  ProfilingDataCollector.shortSessionCumulativeNumberOfAllocatedCanvases = 0;

  ProfilingDataCollector.shortSessionMaxNumberOfAllocatedCanvases = 0;

  ProfilingDataCollector.shortSessionCumulativeSizeOfAllocatedCanvases = 0;

  ProfilingDataCollector.shortSessionCumulativeNumberOfBlitOperations = 0;

  ProfilingDataCollector.shortSessionMaxNumberOfBlits = 0;

  ProfilingDataCollector.shortSessionCumulativeAreaOfBlits = 0;

  ProfilingDataCollector.shortSessionMaxAreaOfBlits = 0;

  ProfilingDataCollector.shortSessionBiggestBlitArea = 0;

  ProfilingDataCollector.shortSessionCumulativeTimeSpentRedrawing = 0;

  ProfilingDataCollector.shortSessionMaxTimeSpentRedrawing = 0;

  ProfilingDataCollector.profileBrokenRects = function(numberOfBrokenRects) {
    this.shortSessionCumulativeNumberOfBrokenRects += numberOfBrokenRects;
    if (numberOfBrokenRects > this.shortSessionMaxNumberOfBrokenRects) {
      return this.shortSessionMaxNumberOfBrokenRects = numberOfBrokenRects;
    }
  };

  ProfilingDataCollector.coffeeScriptSourceOfThisClass = '# Data collected at run time ///////////////////////////////////\n\n\nclass ProfilingDataCollector\n\n  @shortSessionCumulativeNumberOfBrokenRects: 0\n  @shortSessionMaxNumberOfBrokenRects: 0\n\n  @shortSessionCumulativeNumberOfAllocatedCanvases: 0\n  @shortSessionMaxNumberOfAllocatedCanvases: 0\n\n  @shortSessionCumulativeSizeOfAllocatedCanvases: 0\n\n  @shortSessionCumulativeNumberOfBlitOperations: 0\n  @shortSessionMaxNumberOfBlits: 0\n\n  @shortSessionCumulativeAreaOfBlits: 0\n  @shortSessionMaxAreaOfBlits: 0\n\n  @shortSessionBiggestBlitArea: 0\n\n  @shortSessionCumulativeTimeSpentRedrawing: 0\n  @shortSessionMaxTimeSpentRedrawing: 0\n  \n\n  @profileBrokenRects: (numberOfBrokenRects) ->\n    @shortSessionCumulativeNumberOfBrokenRects += numberOfBrokenRects\n    if numberOfBrokenRects > @shortSessionMaxNumberOfBrokenRects\n      @shortSessionMaxNumberOfBrokenRects =\n        numberOfBrokenRects';

  return ProfilingDataCollector;

})();

ReactiveValuesTestsRectangleMorph = (function(_super) {
  __extends(ReactiveValuesTestsRectangleMorph, _super);

  ReactiveValuesTestsRectangleMorph.prototype.count = 1;

  ReactiveValuesTestsRectangleMorph.prototype.countVal = null;

  ReactiveValuesTestsRectangleMorph.prototype.countOfDirectRectangleChildren = null;

  function ReactiveValuesTestsRectangleMorph(extent, color) {
    var countOfDirectRectangleChildrenContent, countValContent, functionToRecalculate;
    ReactiveValuesTestsRectangleMorph.__super__.constructor.call(this);
    if (extent != null) {
      this.silentSetExtent(extent);
    }
    if (color != null) {
      this.color = color;
    }
    countValContent = {
      "content": this.count,
      "signature": hashCode(this.count + "")
    };
    this.countVal = new GroundVal("countVal", countValContent, this);
    countOfDirectRectangleChildrenContent = {
      "content": 0,
      "signature": hashCode(0 + "")
    };
    functionToRecalculate = function(argById, localArgByName, parentArgByName, childrenArgByName, childrenArgByNameCount) {
      var allCounts, theCount;
      theCount = 0;
      for (allCounts in childrenArgByName["countVal"]) {
        theCount++;
      }
      console.log("recalculating the number of rectangles to: " + theCount);
      return {
        "content": theCount,
        "signature": hashCode(theCount + "")
      };
    };
    this.countOfDirectRectangleChildren = new BasicCalculatedVal("countOfDirectRectangleChildren", functionToRecalculate, [], [], ["countVal"], this);
  }

  ReactiveValuesTestsRectangleMorph.coffeeScriptSourceOfThisClass = '# ReactiveValuesTestsRectangleMorph /////////////////////////////////\n\n\nclass ReactiveValuesTestsRectangleMorph extends Morph\n\n  count: 1\n  countVal: null\n  countOfDirectRectangleChildren: null\n\n  constructor: (extent, color) ->\n    super()\n    @silentSetExtent(extent) if extent?\n    @color = color if color?\n\n    countValContent = {"content": @count, "signature": hashCode(@count + "")}\n    @countVal = new GroundVal("countVal", countValContent, @)\n\n    countOfDirectRectangleChildrenContent = {"content": 0, "signature": hashCode(0 + "")}\n\n    functionToRecalculate = (argById, localArgByName, parentArgByName, childrenArgByName, childrenArgByNameCount) ->\n        theCount = 0\n        for allCounts of childrenArgByName["countVal"]\n            theCount++\n\n        console.log "recalculating the number of rectangles to: " + theCount\n\n        return {\n            "content": theCount,\n            "signature": hashCode(theCount + "")\n            }\n\n    #constructor: (@valName, @functionToRecalculate, @localInputVals, parentArgsNames, childrenArgsNames, @ownerMorph)\n    #debugger\n    @countOfDirectRectangleChildren = new BasicCalculatedVal("countOfDirectRectangleChildren", functionToRecalculate, [], [], ["countVal"], @)\n';

  return ReactiveValuesTestsRectangleMorph;

})(Morph);

ReactiveValuesTests = (function() {
  function ReactiveValuesTests() {}

  ReactiveValuesTests.runTests = function() {
    var firstReactValRect, secondReactValRect;
    firstReactValRect = new ReactiveValuesTestsRectangleMorph();
    if (ProfilerData.reactiveValues_createdGroundVals !== 1) {
      console.log("ERROR createdGroundVals should be 1 it's " + ProfilerData.reactiveValues_createdGroundVals);
    }
    if (ProfilerData.reactiveValues_createdBasicCalculatedValues !== 1) {
      console.log("ERROR createdBasicCalculatedValues should be 1 it's " + ProfilerData.reactiveValues_createdBasicCalculatedValues);
    }
    firstReactValRect.setPosition(new Point(10, 10));
    world.add(firstReactValRect);
    secondReactValRect = new ReactiveValuesTestsRectangleMorph();
    if (ProfilerData.reactiveValues_createdGroundVals !== 2) {
      console.log("ERROR createdGroundVals should be 2 it's " + ProfilerData.reactiveValues_createdGroundVals);
    }
    if (ProfilerData.reactiveValues_createdBasicCalculatedValues !== 2) {
      console.log("ERROR createdBasicCalculatedValues should be 2 it's " + ProfilerData.reactiveValues_createdBasicCalculatedValues);
    }
    secondReactValRect.setPosition(new Point(40, 40));
    world.add(secondReactValRect);
    if (firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContentMaybeOutdated !== true) {
      console.log("ERROR firstReactValRect.countOfDirectRectangleChildren should be dirty and it isn't");
    }
    firstReactValRect.add(secondReactValRect);
    if (firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContentMaybeOutdated !== true) {
      console.log("ERROR firstReactValRect.countOfDirectRectangleChildren should be dirty and it isn't");
    }
    firstReactValRect.countOfDirectRectangleChildren.fetchVal();
    if (firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContentMaybeOutdated !== false) {
      console.log("ERROR firstReactValRect.countOfDirectRectangleChildren should be clean and it isn't");
    }
    if (firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContent.content !== 1) {
      return console.log("ERROR firstReactValRect.countOfDirectRectangleChildren should contain 1 and it doesn't");
    }
  };

  ReactiveValuesTests.coffeeScriptSourceOfThisClass = '# A small harner to run tests around reactive values.\n# To run these, just open console and type\n#   ReactiveValuesTests.runTests()\n\n# REQUIRES ReactiveValuesTestsRectangleMorph\n\nclass ReactiveValuesTests\n  @runTests: ->\n\n    # create first rectangle\n    firstReactValRect = new ReactiveValuesTestsRectangleMorph()\n    if ProfilerData.reactiveValues_createdGroundVals != 1\n      console.log "ERROR createdGroundVals should be 1 it\'s " +\n        ProfilerData.reactiveValues_createdGroundVals\n    if ProfilerData.reactiveValues_createdBasicCalculatedValues != 1\n      console.log "ERROR createdBasicCalculatedValues should be 1 it\'s " +\n        ProfilerData.reactiveValues_createdBasicCalculatedValues\n    firstReactValRect.setPosition new Point(10, 10)\n    world.add firstReactValRect\n\n    # create second rectangle, slightly displaced to verlap\n    secondReactValRect = new ReactiveValuesTestsRectangleMorph()\n    if ProfilerData.reactiveValues_createdGroundVals != 2\n      console.log "ERROR createdGroundVals should be 2 it\'s " +\n        ProfilerData.reactiveValues_createdGroundVals\n    if ProfilerData.reactiveValues_createdBasicCalculatedValues != 2\n      console.log "ERROR createdBasicCalculatedValues should be 2 it\'s " +\n        ProfilerData.reactiveValues_createdBasicCalculatedValues\n    secondReactValRect.setPosition new Point(40, 40)\n    world.add secondReactValRect\n\n    if firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContentMaybeOutdated != true\n      console.log "ERROR firstReactValRect.countOfDirectRectangleChildren should be dirty and it isn\'t"\n\n    # now attach the second rectangle to the first\n    firstReactValRect.add secondReactValRect\n\n    if firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContentMaybeOutdated != true\n      console.log "ERROR firstReactValRect.countOfDirectRectangleChildren should be dirty and it isn\'t"\n\n    # now fetch the value of countOfDirectRectangleChildren in the\n    # first rectangle\n    firstReactValRect.countOfDirectRectangleChildren.fetchVal()\n\n    if firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContentMaybeOutdated != false\n      console.log "ERROR firstReactValRect.countOfDirectRectangleChildren should be clean and it isn\'t"\n\n    if firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContent.content != 1\n      console.log "ERROR firstReactValRect.countOfDirectRectangleChildren should contain 1 and it doesn\'t"\n\n    ';

  return ReactiveValuesTests;

})();

ShadowMorph = (function(_super) {
  __extends(ShadowMorph, _super);

  ShadowMorph.prototype.targetMorph = null;

  ShadowMorph.prototype.offset = null;

  ShadowMorph.prototype.alpha = 0;

  ShadowMorph.prototype.color = null;

  function ShadowMorph(targetMorph, offset, alpha, color) {
    this.targetMorph = targetMorph;
    ShadowMorph.__super__.constructor.call(this);
    this.offset = offset || new Point(7, 7);
    this.alpha = alpha || (alpha === 0 ? 0 : 0.2);
    this.color = color || new Color(0, 0, 0);
  }

  ShadowMorph.prototype.updateRendering = function() {
    var fb;
    fb = this.targetMorph.boundsIncludingChildren();
    this.silentSetExtent(fb.extent().add(this.targetMorph.shadowBlur * 2));
    if (WorldMorph.preferencesAndSettings.useBlurredShadows && !WorldMorph.preferencesAndSettings.isFlat) {
      this.image = this.targetMorph.shadowImageBlurred(this.offset, this.color);
      return this.setPosition(fb.origin.add(this.offset).subtract(this.targetMorph.shadowBlur));
    } else {
      this.image = this.targetMorph.shadowImage(this.offset, this.color);
      return this.setPosition(fb.origin.add(this.offset));
    }
  };

  ShadowMorph.coffeeScriptSourceOfThisClass = '# ShadowMorph /////////////////////////////////////////////////////////\n\nclass ShadowMorph extends Morph\n  targetMorph: null\n  offset: null\n  alpha: 0\n  color: null\n\n  constructor: (@targetMorph, offset, alpha, color) ->\n    # console.log "creating shadow morph"\n    super()\n    @offset = offset or new Point(7, 7)\n    @alpha = alpha or ((if (alpha is 0) then 0 else 0.2))\n    @color = color or new Color(0, 0, 0)\n \n  updateRendering: ->\n    # console.log "shadow morph update rendering"\n    fb = @targetMorph.boundsIncludingChildren()\n    @silentSetExtent fb.extent().add(@targetMorph.shadowBlur * 2)\n    if WorldMorph.preferencesAndSettings.useBlurredShadows and  !WorldMorph.preferencesAndSettings.isFlat\n      @image = @targetMorph.shadowImageBlurred(@offset, @color)\n      @setPosition fb.origin.add(@offset).subtract(@targetMorph.shadowBlur)\n    else\n      @image = @targetMorph.shadowImage(@offset, @color)\n      @setPosition fb.origin.add(@offset)\n    # console.log "shadow morph update rendering EXIT"';

  return ShadowMorph;

})(Morph);

SliderButtonMorph = (function(_super) {
  __extends(SliderButtonMorph, _super);

  SliderButtonMorph.prototype.highlightColor = new Color(90, 90, 140);

  SliderButtonMorph.prototype.pressColor = new Color(80, 80, 160);

  SliderButtonMorph.prototype.is3D = false;

  function SliderButtonMorph(orientation) {
    this.color = new Color(80, 80, 80);
    SliderButtonMorph.__super__.constructor.call(this, orientation);
  }

  SliderButtonMorph.prototype.autoOrientation = function() {
    return noOperation;
  };

  SliderButtonMorph.prototype.updateRendering = function() {
    var colorBak;
    colorBak = this.color.copy();
    SliderButtonMorph.__super__.updateRendering.call(this);
    this.normalImage = this.image;
    this.color = this.highlightColor.copy();
    SliderButtonMorph.__super__.updateRendering.call(this);
    this.highlightImage = this.image;
    this.color = this.pressColor.copy();
    SliderButtonMorph.__super__.updateRendering.call(this);
    this.pressImage = this.image;
    this.color = colorBak;
    return this.image = this.normalImage;
  };

  SliderButtonMorph.prototype.mouseEnter = function() {
    this.image = this.highlightImage;
    return this.changed();
  };

  SliderButtonMorph.prototype.mouseLeave = function() {
    this.image = this.normalImage;
    return this.changed();
  };

  SliderButtonMorph.prototype.mouseDownLeft = function(pos) {
    this.image = this.pressImage;
    this.changed();
    return this.escalateEvent("mouseDownLeft", pos);
  };

  SliderButtonMorph.prototype.mouseClickLeft = function() {
    this.image = this.highlightImage;
    return this.changed();
  };

  SliderButtonMorph.prototype.mouseMove = function() {
    return noOperation;
  };

  SliderButtonMorph.coffeeScriptSourceOfThisClass = '# SliderButtonMorph ///////////////////////////////////////////////////\n# This is the handle in the middle of any slider.\n# Sliders (and hence this button)\n# are also used in the ScrollMorphs.\n\n# this comment below is needed to figure our dependencies between classes\n# REQUIRES globalFunctions\n\nclass SliderButtonMorph extends CircleBoxMorph\n\n  # careful: this Color object is shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  highlightColor: new Color(90, 90, 140)\n  # careful: this Color object is shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  pressColor: new Color(80, 80, 160)\n  is3D: false\n\n  constructor: (orientation) ->\n    @color = new Color(80, 80, 80)\n    super orientation\n  \n  autoOrientation: ->\n      noOperation\n  \n  updateRendering: ->\n    colorBak = @color.copy()\n    super()\n    @normalImage = @image\n    @color = @highlightColor.copy()\n    super()\n    @highlightImage = @image\n    @color = @pressColor.copy()\n    super()\n    @pressImage = @image\n    @color = colorBak\n    @image = @normalImage\n    \n  \n  #SliderButtonMorph events:\n  mouseEnter: ->\n    @image = @highlightImage\n    @changed()\n  \n  mouseLeave: ->\n    @image = @normalImage\n    @changed()\n  \n  mouseDownLeft: (pos) ->\n    @image = @pressImage\n    @changed()\n    @escalateEvent "mouseDownLeft", pos\n  \n  mouseClickLeft: ->\n    @image = @highlightImage\n    @changed()\n  \n  # prevent my parent from getting picked up\n  mouseMove: ->\n      noOperation';

  return SliderButtonMorph;

})(CircleBoxMorph);

SliderMorph = (function(_super) {
  __extends(SliderMorph, _super);

  SliderMorph.augmentWith(ControllerMixin);

  SliderMorph.prototype.target = null;

  SliderMorph.prototype.action = null;

  SliderMorph.prototype.start = null;

  SliderMorph.prototype.stop = null;

  SliderMorph.prototype.value = null;

  SliderMorph.prototype.size = null;

  SliderMorph.prototype.offset = null;

  SliderMorph.prototype.button = null;

  SliderMorph.prototype.step = null;

  function SliderMorph(start, stop, value, size, orientation, color) {
    this.start = start != null ? start : 1;
    this.stop = stop != null ? stop : 100;
    this.value = value != null ? value : 50;
    this.size = size != null ? size : 10;
    this.button = new SliderButtonMorph();
    this.button.isDraggable = false;
    this.button.color = new Color(0, 0, 0);
    this.button.highlightColor = new Color(110, 110, 110);
    this.button.pressColor = new Color(100, 100, 100);
    this.button.alpha = 0.4;
    SliderMorph.__super__.constructor.call(this, orientation);
    this.add(this.button);
    this.alpha = 0.1;
    this.color = color || new Color(0, 0, 0);
    this.setExtent(new Point(20, 100));
  }

  SliderMorph.prototype.autoOrientation = function() {
    return noOperation;
  };

  SliderMorph.prototype.rangeSize = function() {
    return this.stop - this.start;
  };

  SliderMorph.prototype.ratio = function() {
    return this.size / this.rangeSize();
  };

  SliderMorph.prototype.unitSize = function() {
    if (this.orientation === "vertical") {
      return (this.height() - this.button.height()) / this.rangeSize();
    } else {
      return (this.width() - this.button.width()) / this.rangeSize();
    }
  };

  SliderMorph.prototype.updateRendering = function() {
    var bh, bw, posX, posY;
    SliderMorph.__super__.updateRendering.call(this);
    this.button.orientation = this.orientation;
    if (this.orientation === "vertical") {
      bw = this.width() - 2;
      bh = Math.max(bw, Math.round(this.height() * this.ratio()));
      this.button.silentSetExtent(new Point(bw, bh));
      posX = 1;
      posY = Math.min(Math.round((this.value - this.start) * this.unitSize()), this.height() - this.button.height());
    } else {
      bh = this.height() - 2;
      bw = Math.max(bh, Math.round(this.width() * this.ratio()));
      this.button.silentSetExtent(new Point(bw, bh));
      posY = 1;
      posX = Math.min(Math.round((this.value - this.start) * this.unitSize()), this.width() - this.button.width());
    }
    this.button.setPosition(new Point(posX, posY).add(this.bounds.origin));
    this.button.updateRendering();
    return this.button.changed();
  };

  SliderMorph.prototype.updateValue = function() {
    var relPos;
    if (this.orientation === "vertical") {
      relPos = this.button.top() - this.top();
    } else {
      relPos = this.button.left() - this.left();
    }
    this.value = Math.round(relPos / this.unitSize() + this.start);
    return this.updateTarget();
  };

  SliderMorph.prototype.updateTarget = function() {
    if (this.action) {
      if (typeof this.action === "function") {
        return this.action.call(this.target, this.value, this.target);
      } else {
        return this.target[this.action](this.value);
      }
    }
  };

  SliderMorph.prototype.developersMenu = function() {
    var menu;
    menu = SliderMorph.__super__.developersMenu.call(this);
    menu.addItem("show value", (function() {
      return this.showValue();
    }), "display a dialog box\nshowing the selected number");
    menu.addItem("floor...", (function() {
      return this.prompt(menu.title + "\nfloor:", this.setStart, this.start.toString(), null, 0, this.stop - this.size, true);
    }), "set the minimum value\nwhich can be selected");
    menu.addItem("ceiling...", (function() {
      return this.prompt(menu.title + "\nceiling:", this.setStop, this.stop.toString(), null, this.start + this.size, this.size * 100, true);
    }), "set the maximum value\nwhich can be selected");
    menu.addItem("button size...", (function() {
      return this.prompt(menu.title + "\nbutton size:", this.setSize, this.size.toString(), null, 1, this.stop - this.start, true);
    }), "set the range\ncovered by\nthe slider button");
    menu.addLine();
    menu.addItem("set target", (function() {
      return this.setTarget();
    }), "select another morph\nwhose numerical property\nwill be " + "controlled by this one");
    return menu;
  };

  SliderMorph.prototype.showValue = function() {
    return this.inform(this.value);
  };

  SliderMorph.prototype.userSetStart = function(num) {
    return this.start = Math.max(num, this.stop);
  };

  SliderMorph.prototype.setStart = function(numOrMorphGivingNum) {
    var newStart, num;
    if (numOrMorphGivingNum.getValue != null) {
      num = numOrMorphGivingNum.getValue();
    } else {
      num = numOrMorphGivingNum;
    }
    if (typeof num === "number") {
      this.start = Math.min(Math.max(num, 0), this.stop - this.size);
    } else {
      newStart = parseFloat(num);
      if (!isNaN(newStart)) {
        this.start = Math.min(Math.max(newStart, 0), this.stop - this.size);
      }
    }
    this.value = Math.max(this.value, this.start);
    this.updateTarget();
    this.updateRendering();
    return this.changed();
  };

  SliderMorph.prototype.setStop = function(numOrMorphGivingNum) {
    var newStop, num;
    if (numOrMorphGivingNum.getValue != null) {
      num = numOrMorphGivingNum.getValue();
    } else {
      num = numOrMorphGivingNum;
    }
    if (typeof num === "number") {
      this.stop = Math.max(num, this.start + this.size);
    } else {
      newStop = parseFloat(num);
      if (!isNaN(newStop)) {
        this.stop = Math.max(newStop, this.start + this.size);
      }
    }
    this.value = Math.min(this.value, this.stop);
    this.updateTarget();
    this.updateRendering();
    return this.changed();
  };

  SliderMorph.prototype.setSize = function(sizeOrMorphGivingSize) {
    var newSize, size;
    if (sizeOrMorphGivingSize.getValue != null) {
      size = sizeOrMorphGivingSize.getValue();
    } else {
      size = sizeOrMorphGivingSize;
    }
    if (typeof size === "number") {
      this.size = Math.min(Math.max(size, 1), this.stop - this.start);
    } else {
      newSize = parseFloat(size);
      if (!isNaN(newSize)) {
        this.size = Math.min(Math.max(newSize, 1), this.stop - this.start);
      }
    }
    this.value = Math.min(this.value, this.stop - this.size);
    this.updateTarget();
    this.updateRendering();
    return this.changed();
  };

  SliderMorph.prototype.setTargetSetter = function(theTarget) {
    var choices, menu;
    choices = theTarget.numericalSetters();
    menu = new MenuMorph(this, "choose target property:");
    choices.forEach((function(_this) {
      return function(each) {
        return menu.addItem(each, function() {
          _this.target = theTarget;
          return _this.action = each;
        });
      };
    })(this));
    if (choices.length === 0) {
      menu = new MenuMorph(this, "no target properties available");
    }
    return menu.popUpAtHand();
  };

  SliderMorph.prototype.numericalSetters = function() {
    var list;
    list = SliderMorph.__super__.numericalSetters.call(this);
    list.push("setStart", "setStop", "setSize");
    return list;
  };

  SliderMorph.prototype.mouseDownLeft = function(pos) {
    var world;
    if (!this.button.bounds.containsPoint(pos)) {
      this.offset = new Point();
    } else {
      this.offset = pos.subtract(this.button.bounds.origin);
    }
    world = this.root();
    return this.step = (function(_this) {
      return function() {
        var mousePos, newX, newY;
        if (world.hand.mouseButton && _this.isVisible) {
          mousePos = world.hand.bounds.origin;
          if (_this.orientation === "vertical") {
            newX = _this.button.bounds.origin.x;
            newY = Math.max(Math.min(mousePos.y - _this.offset.y, _this.bottom() - _this.button.height()), _this.top());
          } else {
            newY = _this.button.bounds.origin.y;
            newX = Math.max(Math.min(mousePos.x - _this.offset.x, _this.right() - _this.button.width()), _this.left());
          }
          _this.button.setPosition(new Point(newX, newY));
          return _this.updateValue();
        } else {
          return _this.step = null;
        }
      };
    })(this);
  };

  SliderMorph.coffeeScriptSourceOfThisClass = '# SliderMorph ///////////////////////////////////////////////////\n# Sliders (and hence slider button morphs)\n# are also used in the ScrollMorphs .\n\n# this comment below is needed to figure our dependencies between classes\n# REQUIRES globalFunctions\n# REQUIRES ControllerMixin\n\nclass SliderMorph extends CircleBoxMorph\n  @augmentWith ControllerMixin\n\n  target: null\n  action: null\n  start: null\n  stop: null\n  value: null\n  size: null\n  offset: null\n  button: null\n  step: null\n\n  constructor: (@start = 1, @stop = 100, @value = 50, @size = 10, orientation, color) ->\n    @button = new SliderButtonMorph()\n    @button.isDraggable = false\n    @button.color = new Color(0, 0, 0)\n    @button.highlightColor = new Color(110, 110, 110)\n    @button.pressColor = new Color(100, 100, 100)\n    @button.alpha = 0.4\n    super orientation # if null, then a vertical one will be created\n    @add @button\n    @alpha = 0.1\n    @color = color or new Color(0, 0, 0)\n    @setExtent new Point(20, 100)\n  \n  # this.updateRendering();\n  autoOrientation: ->\n      noOperation\n  \n  rangeSize: ->\n    @stop - @start\n  \n  ratio: ->\n    @size / @rangeSize()\n  \n  unitSize: ->\n    if @orientation is "vertical"\n      return (@height() - @button.height()) / @rangeSize()\n    else\n      return (@width() - @button.width()) / @rangeSize()\n  \n  updateRendering: ->\n    super()\n    @button.orientation = @orientation\n    if @orientation is "vertical"\n      bw = @width() - 2\n      bh = Math.max(bw, Math.round(@height() * @ratio()))\n      @button.silentSetExtent new Point(bw, bh)\n      posX = 1\n      posY = Math.min(\n        Math.round((@value - @start) * @unitSize()),\n        @height() - @button.height())\n    else\n      bh = @height() - 2\n      bw = Math.max(bh, Math.round(@width() * @ratio()))\n      @button.silentSetExtent new Point(bw, bh)\n      posY = 1\n      posX = Math.min(\n        Math.round((@value - @start) * @unitSize()),\n        @width() - @button.width())\n    @button.setPosition new Point(posX, posY).add(@bounds.origin)\n    @button.updateRendering()\n    @button.changed()\n  \n  updateValue: ->\n    if @orientation is "vertical"\n      relPos = @button.top() - @top()\n    else\n      relPos = @button.left() - @left()\n    @value = Math.round(relPos / @unitSize() + @start)\n    @updateTarget()\n  \n  updateTarget: ->\n    if @action\n      if typeof @action is "function"\n        @action.call @target, @value, @target\n      else # assume it\'s a String\n        @target[@action] @value\n    \n  \n  # SliderMorph menu:\n  developersMenu: ->\n    menu = super()\n    menu.addItem "show value", (->@showValue()), "display a dialog box\nshowing the selected number"\n    menu.addItem "floor...", (->\n      @prompt menu.title + "\nfloor:",\n        @setStart,\n        @start.toString(),\n        null,\n        0,\n        @stop - @size,\n        true\n    ), "set the minimum value\nwhich can be selected"\n    menu.addItem "ceiling...", (->\n      @prompt menu.title + "\nceiling:",\n        @setStop,\n        @stop.toString(),\n        null,\n        @start + @size,\n        @size * 100,\n        true\n    ), "set the maximum value\nwhich can be selected"\n    menu.addItem "button size...", (->\n      @prompt menu.title + "\nbutton size:",\n        @setSize,\n        @size.toString(),\n        null,\n        1,\n        @stop - @start,\n        true\n    ), "set the range\ncovered by\nthe slider button"\n    menu.addLine()\n    menu.addItem "set target", (->@setTarget()), "select another morph\nwhose numerical property\nwill be " + "controlled by this one"\n    menu\n  \n  showValue: ->\n    @inform @value\n  \n  userSetStart: (num) ->\n    # for context menu demo purposes\n    @start = Math.max(num, @stop)\n  \n  setStart: (numOrMorphGivingNum) ->\n\n    if numOrMorphGivingNum.getValue?\n      num = numOrMorphGivingNum.getValue()\n    else\n      num = numOrMorphGivingNum\n\n    # for context menu demo purposes\n    if typeof num is "number"\n      @start = Math.min(Math.max(num, 0), @stop - @size)\n    else\n      newStart = parseFloat(num)\n      @start = Math.min(Math.max(newStart, 0), @stop - @size)  unless isNaN(newStart)\n    @value = Math.max(@value, @start)\n    @updateTarget()\n    @updateRendering()\n    @changed()\n  \n  setStop: (numOrMorphGivingNum) ->\n\n    if numOrMorphGivingNum.getValue?\n      num = numOrMorphGivingNum.getValue()\n    else\n      num = numOrMorphGivingNum\n\n    # for context menu demo purposes\n    if typeof num is "number"\n      @stop = Math.max(num, @start + @size)\n    else\n      newStop = parseFloat(num)\n      @stop = Math.max(newStop, @start + @size)  unless isNaN(newStop)\n    @value = Math.min(@value, @stop)\n    @updateTarget()\n    @updateRendering()\n    @changed()\n  \n  setSize: (sizeOrMorphGivingSize) ->\n    if sizeOrMorphGivingSize.getValue?\n      size = sizeOrMorphGivingSize.getValue()\n    else\n      size = sizeOrMorphGivingSize\n\n    # for context menu demo purposes\n    if typeof size is "number"\n      @size = Math.min(Math.max(size, 1), @stop - @start)\n    else\n      newSize = parseFloat(size)\n      @size = Math.min(Math.max(newSize, 1), @stop - @start)  unless isNaN(newSize)\n    @value = Math.min(@value, @stop - @size)\n    @updateTarget()\n    @updateRendering()\n    @changed()\n  \n  # setTarget: -> taken form the ControllerMixin\n  \n  setTargetSetter: (theTarget) ->\n    choices = theTarget.numericalSetters()\n    menu = new MenuMorph(@, "choose target property:")\n    choices.forEach (each) =>\n      menu.addItem each, =>\n        @target = theTarget\n        @action = each\n    if choices.length == 0\n      menu = new MenuMorph(@, "no target properties available")\n    menu.popUpAtHand()\n\n  \n  numericalSetters: ->\n    # for context menu demo purposes\n    list = super()\n    list.push "setStart", "setStop", "setSize"\n    list\n  \n  \n  # SliderMorph stepping:\n  mouseDownLeft: (pos) ->\n    unless @button.bounds.containsPoint(pos)\n      @offset = new Point() # return null;\n    else\n      @offset = pos.subtract(@button.bounds.origin)\n    world = @root()\n    # this is to create the "drag the slider" effect\n    # basically if the mouse is pressing within the boundaries\n    # then in the next step you remember to check again where the mouse\n    # is and update the scrollbar. As soon as the mouse is unpressed\n    # then the step function is set to null to save cycles.\n    @step = =>\n      if world.hand.mouseButton and @isVisible\n        mousePos = world.hand.bounds.origin\n        if @orientation is "vertical"\n          newX = @button.bounds.origin.x\n          newY = Math.max(\n            Math.min(mousePos.y - @offset.y,\n            @bottom() - @button.height()), @top())\n        else\n          newY = @button.bounds.origin.y\n          newX = Math.max(\n            Math.min(mousePos.x - @offset.x,\n            @right() - @button.width()), @left())\n        @button.setPosition new Point(newX, newY)\n        @updateValue()\n      else\n        @step = null';

  return SliderMorph;

})(CircleBoxMorph);

SpeechBubbleMorph = (function(_super) {
  __extends(SpeechBubbleMorph, _super);

  SpeechBubbleMorph.prototype.isPointingRight = true;

  SpeechBubbleMorph.prototype.contents = null;

  SpeechBubbleMorph.prototype.padding = null;

  SpeechBubbleMorph.prototype.isThought = null;

  SpeechBubbleMorph.prototype.isClickable = false;

  SpeechBubbleMorph.prototype.morphInvokingThis = null;

  function SpeechBubbleMorph(contents, morphInvokingThis, color, edge, border, borderColor, padding, isThought) {
    this.contents = contents != null ? contents : "";
    this.morphInvokingThis = morphInvokingThis;
    this.padding = padding != null ? padding : 0;
    this.isThought = isThought != null ? isThought : false;
    this.color = color || new Color(230, 230, 230);
    SpeechBubbleMorph.__super__.constructor.call(this, edge || 6, border || (border === 0 ? 0 : 1), borderColor || new Color(140, 140, 140));
  }

  SpeechBubbleMorph.createBubbleHelpIfHandStillOnMorph = function(contents, morphInvokingThis) {
    var theBubble;
    if ((morphInvokingThis.world() != null) && morphInvokingThis.bounds.containsPoint(morphInvokingThis.world().hand.position())) {
      theBubble = new this(localize(contents), morphInvokingThis, null, null, 1);
      return theBubble.popUp(theBubble.morphInvokingThis.rightCenter().add(new Point(-8, 0)));
    }
  };

  SpeechBubbleMorph.createInAWhileIfHandStillContainedInMorph = function(morphInvokingThis, contents, delay) {
    if (delay == null) {
      delay = 500;
    }
    if (SystemTestsRecorderAndPlayer.animationsPacingControl && SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.IDLE) {
      return this.createBubbleHelpIfHandStillOnMorph(contents, morphInvokingThis);
    } else {
      return setTimeout(((function(_this) {
        return function() {
          return _this.createBubbleHelpIfHandStillOnMorph(contents, morphInvokingThis);
        };
      })(this)), delay);
    }
  };

  SpeechBubbleMorph.prototype.popUp = function(pos, isClickable) {
    var world;
    world = this.morphInvokingThis.world();
    this.setPosition(pos.subtract(new Point(0, this.height())));
    this.keepWithin(world);
    this.buildAndConnectChildren();
    world.add(this);
    this.addShadow(new Point(2, 2), 80);
    this.fullChanged();
    world.hand.destroyTemporaries();
    world.hand.temporaries.push(this);
    if (isClickable) {
      return this.mouseEnter = function() {
        return this.destroy();
      };
    } else {
      return this.isClickable = false;
    }
  };

  SpeechBubbleMorph.prototype.buildAndConnectChildren = function() {
    if (this.contentsMorph) {
      this.contentsMorph = this.contentsMorph.destroy();
    }
    if (this.contents instanceof Morph) {
      this.contentsMorph = this.contents;
    } else if (isString(this.contents)) {
      this.contentsMorph = new TextMorph(this.contents, WorldMorph.preferencesAndSettings.bubbleHelpFontSize, null, false, true, "center");
    } else if (this.contents instanceof HTMLCanvasElement) {
      this.contentsMorph = new Morph();
      this.contentsMorph.silentSetWidth(this.contents.width);
      this.contentsMorph.silentSetHeight(this.contents.height);
      this.contentsMorph.image = this.contents;
    } else {
      this.contentsMorph = new TextMorph(this.contents.toString(), WorldMorph.preferencesAndSettings.bubbleHelpFontSize, null, false, true, "center");
    }
    this.add(this.contentsMorph);
    this.silentSetWidth(this.contentsMorph.width() + (this.padding ? this.padding * 2 : this.edge * 2));
    this.silentSetHeight(this.contentsMorph.height() + this.edge + this.border * 2 + this.padding * 2 + 2);
    return this.contentsMorph.setPosition(this.position().add(new Point(this.padding || this.edge, this.border + this.padding + 1)));
  };

  SpeechBubbleMorph.prototype.updateRendering = function() {
    return SpeechBubbleMorph.__super__.updateRendering.call(this);
  };

  SpeechBubbleMorph.prototype.outlinePath = function(context, radius, inset) {
    var circle, h, offset, rad, w;
    circle = function(x, y, r) {
      context.moveTo(x + r, y);
      return context.arc(x, y, r, radians(0), radians(360));
    };
    offset = radius + inset;
    w = this.width();
    h = this.height();
    context.arc(offset, offset, radius, radians(-180), radians(-90), false);
    context.arc(w - offset, offset, radius, radians(-90), radians(-0), false);
    context.arc(w - offset, h - offset - radius, radius, radians(0), radians(90), false);
    if (!this.isThought) {
      if (this.isPointingRight) {
        context.lineTo(offset + radius, h - offset);
        context.lineTo(radius / 2 + inset, h - inset);
      } else {
        context.lineTo(w - (radius / 2 + inset), h - inset);
        context.lineTo(w - (offset + radius), h - offset);
      }
    }
    context.arc(offset, h - offset - radius, radius, radians(90), radians(180), false);
    if (this.isThought) {
      context.lineTo(inset, offset);
      if (this.isPointingRight) {
        rad = radius / 4;
        circle(rad + inset, h - rad - inset, rad);
        rad = radius / 3.2;
        circle(rad * 2 + inset, h - rad - inset * 2, rad);
        rad = radius / 2.8;
        return circle(rad * 3 + inset * 2, h - rad - inset * 4, rad);
      } else {
        rad = radius / 4;
        circle(w - (rad + inset), h - rad - inset, rad);
        rad = radius / 3.2;
        circle(w - (rad * 2 + inset), h - rad - inset * 2, rad);
        rad = radius / 2.8;
        return circle(w - (rad * 3 + inset * 2), h - rad - inset * 4, rad);
      }
    }
  };

  SpeechBubbleMorph.prototype.shadowImage = function(off_, color) {
    var clr, ctx, fb, img, offset, outline, sha;
    fb = void 0;
    img = void 0;
    outline = void 0;
    sha = void 0;
    ctx = void 0;
    offset = off_ || new Point(7, 7);
    clr = color || new Color(0, 0, 0);
    fb = this.extent();
    img = this.image;
    outline = newCanvas(fb.scaleBy(pixelRatio));
    ctx = outline.getContext("2d");
    ctx.drawImage(img, 0, 0);
    ctx.globalCompositeOperation = "destination-out";
    ctx.drawImage(img, -offset.x * pixelRatio, -offset.y * pixelRatio);
    sha = newCanvas(fb.scaleBy(pixelRatio));
    ctx = sha.getContext("2d");
    ctx.drawImage(outline, 0, 0);
    ctx.globalCompositeOperation = "source-atop";
    ctx.fillStyle = clr.toString();
    ctx.fillRect(0, 0, fb.x * pixelRatio, fb.y * pixelRatio);
    return sha;
  };

  SpeechBubbleMorph.prototype.shadowImageBlurred = function(off_, color) {
    var blur, clr, ctx, fb, img, offset, sha;
    fb = void 0;
    img = void 0;
    sha = void 0;
    ctx = void 0;
    offset = off_ || new Point(7, 7);
    blur = this.shadowBlur;
    clr = color || new Color(0, 0, 0);
    fb = this.extent().add(blur * 2);
    img = this.image;
    sha = newCanvas(fb.scaleBy(pixelRatio));
    ctx = sha.getContext("2d");
    ctx.shadowOffsetX = offset.x * pixelRatio;
    ctx.shadowOffsetY = offset.y * pixelRatio;
    ctx.shadowBlur = blur * pixelRatio;
    ctx.shadowColor = clr.toString();
    ctx.drawImage(img, (blur - offset.x) * pixelRatio, (blur - offset.y) * pixelRatio);
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.shadowBlur = 0;
    ctx.globalCompositeOperation = "destination-out";
    ctx.drawImage(img, (blur - offset.x) * pixelRatio, (blur - offset.y) * pixelRatio);
    return sha;
  };

  SpeechBubbleMorph.prototype.layoutSubmorphs = function() {};

  SpeechBubbleMorph.coffeeScriptSourceOfThisClass = '# SpeechBubbleMorph ///////////////////////////////////////////////////\n\n#\n#	I am a comic-style speech bubble that can display either a string,\n#	a Morph, a Canvas or a toString() representation of anything else.\n#	If I am invoked using popUp() I behave like a tool tip.\n#\n\nclass SpeechBubbleMorph extends BoxMorph\n\n  isPointingRight: true # orientation of text\n  contents: null\n  padding: null # additional vertical pixels\n  isThought: null # draw "think" bubble\n  isClickable: false\n  morphInvokingThis: null\n\n  constructor: (\n    @contents="",\n    @morphInvokingThis,\n    color,\n    edge,\n    border,\n    borderColor,\n    @padding = 0,\n    @isThought = false) ->\n      # console.log "bubble super"\n      @color = color or new Color(230, 230, 230)\n      super edge or 6, border or ((if (border is 0) then 0 else 1)), borderColor or new Color(140, 140, 140)\n      # console.log @color\n  \n  @createBubbleHelpIfHandStillOnMorph: (contents, morphInvokingThis) ->\n    # console.log "bubble createBubbleHelpIfHandStillOnMorph"\n    # let\'s check that the item that the\n    # bubble is about is still actually there\n    # and the mouse is still over it, otherwise\n    # do nothing.\n    if morphInvokingThis.world()? and morphInvokingThis.bounds.containsPoint(morphInvokingThis.world().hand.position())\n      theBubble = new @(localize(contents), morphInvokingThis, null, null, 1)\n      theBubble.popUp theBubble.morphInvokingThis.rightCenter().add(new Point(-8, 0))\n\n  @createInAWhileIfHandStillContainedInMorph: (morphInvokingThis, contents, delay = 500) ->\n    # console.log "bubble createInAWhileIfHandStillContainedInMorph"\n    if SystemTestsRecorderAndPlayer.animationsPacingControl and\n     SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.IDLE\n        @createBubbleHelpIfHandStillOnMorph contents, morphInvokingThis\n    else\n      setTimeout (=>\n        @createBubbleHelpIfHandStillOnMorph contents, morphInvokingThis\n        )\n        , delay\n  \n  # SpeechBubbleMorph invoking:\n  popUp: (pos, isClickable) ->\n    # console.log "bubble popup"\n    world = @morphInvokingThis.world()\n    @setPosition pos.subtract(new Point(0, @height()))\n    @keepWithin world\n\n    @buildAndConnectChildren()\n\n    world.add @\n    @addShadow new Point(2, 2), 80\n    @fullChanged()\n    world.hand.destroyTemporaries()\n    world.hand.temporaries.push @\n    if isClickable\n      @mouseEnter = ->\n        @destroy()\n    else\n      @isClickable = false\n    \n  buildAndConnectChildren: ->\n    # console.log "bubble buildAndConnectChildren"\n    # re-build my contents\n    if @contentsMorph\n      @contentsMorph = @contentsMorph.destroy()\n    if @contents instanceof Morph\n      @contentsMorph = @contents\n    else if isString(@contents)\n      @contentsMorph = new TextMorph(\n        @contents,\n        WorldMorph.preferencesAndSettings.bubbleHelpFontSize,\n        null,\n        false,\n        true,\n        "center")\n    else if @contents instanceof HTMLCanvasElement\n      @contentsMorph = new Morph()\n      @contentsMorph.silentSetWidth @contents.width\n      @contentsMorph.silentSetHeight @contents.height\n      @contentsMorph.image = @contents\n    else\n      @contentsMorph = new TextMorph(\n        @contents.toString(),\n        WorldMorph.preferencesAndSettings.bubbleHelpFontSize,\n        null,\n        false,\n        true,\n        "center")\n    @add @contentsMorph\n    #\n    # adjust my layout\n    @silentSetWidth @contentsMorph.width() + ((if @padding then @padding * 2 else @edge * 2))\n    @silentSetHeight @contentsMorph.height() + @edge + @border * 2 + @padding * 2 + 2\n    #\n    # draw my outline\n    #super()\n    #\n    # position my contents\n    @contentsMorph.setPosition @position().add(\n      new Point(@padding or @edge, @border + @padding + 1))\n\n  \n  # SpeechBubbleMorph drawing:\n  updateRendering: ->\n    super()\n\n  \n  outlinePath: (context, radius, inset) ->\n    # console.log "bubble outlinePath"\n    circle = (x, y, r) ->\n      context.moveTo x + r, y\n      context.arc x, y, r, radians(0), radians(360)\n    offset = radius + inset\n    w = @width()\n    h = @height()\n    #\n    # top left:\n    context.arc offset, offset, radius, radians(-180), radians(-90), false\n    #\n    # top right:\n    context.arc w - offset, offset, radius, radians(-90), radians(-0), false\n    #\n    # bottom right:\n    context.arc w - offset, h - offset - radius, radius, radians(0), radians(90), false\n    unless @isThought # draw speech bubble hook\n      if @isPointingRight\n        context.lineTo offset + radius, h - offset\n        context.lineTo radius / 2 + inset, h - inset\n      else # pointing left\n        context.lineTo w - (radius / 2 + inset), h - inset\n        context.lineTo w - (offset + radius), h - offset\n    #\n    # bottom left:\n    context.arc offset, h - offset - radius, radius, radians(90), radians(180), false\n    if @isThought\n      #\n      # close large bubble:\n      context.lineTo inset, offset\n      #\n      # draw thought bubbles:\n      if @isPointingRight\n        #\n        # tip bubble:\n        rad = radius / 4\n        circle rad + inset, h - rad - inset, rad\n        #\n        # middle bubble:\n        rad = radius / 3.2\n        circle rad * 2 + inset, h - rad - inset * 2, rad\n        #\n        # top bubble:\n        rad = radius / 2.8\n        circle rad * 3 + inset * 2, h - rad - inset * 4, rad\n      else # pointing left\n        # tip bubble:\n        rad = radius / 4\n        circle w - (rad + inset), h - rad - inset, rad\n        #\n        # middle bubble:\n        rad = radius / 3.2\n        circle w - (rad * 2 + inset), h - rad - inset * 2, rad\n        #\n        # top bubble:\n        rad = radius / 2.8\n        circle w - (rad * 3 + inset * 2), h - rad - inset * 4, rad\n\n  # SpeechBubbleMorph shadow\n  #\n  #    only take the \'plain\' image, so the box rounding and the\n  #    shadow doesn\'t become conflicted by embedded scrolling panes\n  #\n  shadowImage: (off_, color) ->\n    # console.log "bubble shadowImage"\n    # fallback for Windows Chrome-Shadow bug\n    fb = undefined\n    img = undefined\n    outline = undefined\n    sha = undefined\n    ctx = undefined\n    offset = off_ or new Point(7, 7)\n    clr = color or new Color(0, 0, 0)\n    fb = @extent()\n    img = @image\n    outline = newCanvas(fb.scaleBy pixelRatio)\n    ctx = outline.getContext("2d")\n    #ctx.scale pixelRatio, pixelRatio\n    ctx.drawImage img, 0, 0\n    ctx.globalCompositeOperation = "destination-out"\n    ctx.drawImage img, -offset.x * pixelRatio, -offset.y * pixelRatio\n    sha = newCanvas(fb.scaleBy pixelRatio)\n    ctx = sha.getContext("2d")\n    #ctx.scale pixelRatio, pixelRatio\n    ctx.drawImage outline, 0, 0\n    ctx.globalCompositeOperation = "source-atop"\n    ctx.fillStyle = clr.toString()\n    ctx.fillRect 0, 0, fb.x * pixelRatio, fb.y * pixelRatio\n    sha\n\n  shadowImageBlurred: (off_, color) ->\n    # console.log "bubble shadowImageBlurred"\n    fb = undefined\n    img = undefined\n    sha = undefined\n    ctx = undefined\n    offset = off_ or new Point(7, 7)\n    blur = @shadowBlur\n    clr = color or new Color(0, 0, 0)\n    fb = @extent().add(blur * 2)\n    img = @image\n    sha = newCanvas(fb.scaleBy pixelRatio)\n    ctx = sha.getContext("2d")\n    #ctx.scale pixelRatio, pixelRatio\n    ctx.shadowOffsetX = offset.x * pixelRatio\n    ctx.shadowOffsetY = offset.y * pixelRatio\n    ctx.shadowBlur = blur * pixelRatio\n    ctx.shadowColor = clr.toString()\n    ctx.drawImage img, (blur - offset.x) * pixelRatio, (blur - offset.y) * pixelRatio\n    ctx.shadowOffsetX = 0\n    ctx.shadowOffsetY = 0\n    ctx.shadowBlur = 0\n    ctx.globalCompositeOperation = "destination-out"\n    ctx.drawImage img, (blur - offset.x) * pixelRatio, (blur - offset.y) * pixelRatio\n    sha\n\n  # SpeechBubbleMorph resizing\n  # invoked by HandleMorph\n  layoutSubmorphs: ->\n    # console.log "bubble layoutSubmorphs"\n    #@removeShadow()\n    #@updateRendering()\n    #@addShadow new Point(2, 2), 80';

  return SpeechBubbleMorph;

})(BoxMorph);

StringFieldMorph = (function(_super) {
  __extends(StringFieldMorph, _super);

  StringFieldMorph.prototype.defaultContents = null;

  StringFieldMorph.prototype.minWidth = null;

  StringFieldMorph.prototype.fontSize = null;

  StringFieldMorph.prototype.fontStyle = null;

  StringFieldMorph.prototype.isBold = null;

  StringFieldMorph.prototype.isItalic = null;

  StringFieldMorph.prototype.isNumeric = null;

  StringFieldMorph.prototype.text = null;

  StringFieldMorph.prototype.isEditable = true;

  function StringFieldMorph(defaultContents, minWidth, fontSize, fontStyle, isBold, isItalic, isNumeric) {
    this.defaultContents = defaultContents != null ? defaultContents : "";
    this.minWidth = minWidth != null ? minWidth : 100;
    this.fontSize = fontSize != null ? fontSize : 12;
    this.fontStyle = fontStyle != null ? fontStyle : "sans-serif";
    this.isBold = isBold != null ? isBold : false;
    this.isItalic = isItalic != null ? isItalic : false;
    this.isNumeric = isNumeric != null ? isNumeric : false;
    StringFieldMorph.__super__.constructor.call(this);
    this.color = new Color(255, 255, 255);
  }

  StringFieldMorph.prototype.updateRendering = function() {
    var txt;
    txt = (this.text ? this.getValue() : this.defaultContents);
    this.text = null;
    this.destroyAll();
    this.children = [];
    this.text = new StringMorph(txt, this.fontSize, this.fontStyle, this.isBold, this.isItalic, this.isNumeric);
    this.text.isNumeric = this.isNumeric;
    this.text.setPosition(this.bounds.origin.copy());
    this.text.isEditable = this.isEditable;
    this.text.isDraggable = false;
    this.text.enableSelecting();
    this.silentSetExtent(new Point(Math.max(this.width(), this.minWidth), this.text.height()));
    StringFieldMorph.__super__.updateRendering.call(this);
    return this.add(this.text);
  };

  StringFieldMorph.prototype.getValue = function() {
    return this.text.text;
  };

  StringFieldMorph.prototype.mouseClickLeft = function(pos) {
    if (this.isEditable) {
      return this.text.edit();
    } else {
      return this.escalateEvent('mouseClickLeft', pos);
    }
  };

  StringFieldMorph.coffeeScriptSourceOfThisClass = '# StringFieldMorph ////////////////////////////////////////////////////\n\nclass StringFieldMorph extends FrameMorph\n\n  defaultContents: null\n  minWidth: null\n  fontSize: null\n  fontStyle: null\n  isBold: null\n  isItalic: null\n  isNumeric: null\n  text: null\n  isEditable: true\n\n  constructor: (\n      @defaultContents = "",\n      @minWidth = 100,\n      @fontSize = 12,\n      @fontStyle = "sans-serif",\n      @isBold = false,\n      @isItalic = false,\n      @isNumeric = false\n      ) ->\n    super()\n    @color = new Color(255, 255, 255)\n  \n  updateRendering: ->\n    txt = (if @text then @getValue() else @defaultContents)\n    @text = null\n    @destroyAll()\n    #\n    @children = []\n    @text = new StringMorph(txt, @fontSize, @fontStyle, @isBold, @isItalic, @isNumeric)\n    @text.isNumeric = @isNumeric # for whichever reason...\n    @text.setPosition @bounds.origin.copy()\n    @text.isEditable = @isEditable\n    @text.isDraggable = false\n    @text.enableSelecting()\n    @silentSetExtent new Point(Math.max(@width(), @minWidth), @text.height())\n    super()\n    @add @text\n  \n  getValue: ->\n    @text.text\n  \n  mouseClickLeft: (pos)->\n    if @isEditable\n      @text.edit()\n    else\n      @escalateEvent \'mouseClickLeft\', pos\n  ';

  return StringFieldMorph;

})(FrameMorph);

WorldMorph = (function(_super) {
  __extends(WorldMorph, _super);

  WorldMorph.prototype.dblclickEventListener = null;

  WorldMorph.prototype.mousedownEventListener = null;

  WorldMorph.prototype.touchstartEventListener = null;

  WorldMorph.prototype.mouseupEventListener = null;

  WorldMorph.prototype.touchendEventListener = null;

  WorldMorph.prototype.mousemoveEventListener = null;

  WorldMorph.prototype.touchmoveEventListener = null;

  WorldMorph.prototype.gesturestartEventListener = null;

  WorldMorph.prototype.gesturechangeEventListener = null;

  WorldMorph.prototype.contextmenuEventListener = null;

  WorldMorph.prototype.keydownEventListener = null;

  WorldMorph.prototype.keyupEventListener = null;

  WorldMorph.prototype.keypressEventListener = null;

  WorldMorph.prototype.mousewheelEventListener = null;

  WorldMorph.prototype.DOMMouseScrollEventListener = null;

  WorldMorph.prototype.copyEventListener = null;

  WorldMorph.prototype.pasteEventListener = null;

  WorldMorph.prototype.inputDOMElementForVirtualKeyboardKeydownEventListener = null;

  WorldMorph.prototype.inputDOMElementForVirtualKeyboardKeyupEventListener = null;

  WorldMorph.prototype.inputDOMElementForVirtualKeyboardKeypressEventListener = null;

  WorldMorph.prototype.keyComboResetWorldEventListener = null;

  WorldMorph.prototype.keyComboTurnOnAnimationsPacingControl = null;

  WorldMorph.prototype.keyComboTurnOffAnimationsPacingControl = null;

  WorldMorph.prototype.keyComboTakeScreenshotEventListener = null;

  WorldMorph.prototype.keyComboStopTestRecordingEventListener = null;

  WorldMorph.prototype.keyComboTakeScreenshotEventListener = null;

  WorldMorph.prototype.keyComboCheckStringsOfItemsInMenuOrderImportant = null;

  WorldMorph.prototype.keyComboCheckStringsOfItemsInMenuOrderUnimportant = null;

  WorldMorph.prototype.keyComboAddTestCommentEventListener = null;

  WorldMorph.prototype.keyComboCheckNumberOfMenuItemsEventListener = null;

  WorldMorph.prototype.dragoverEventListener = null;

  WorldMorph.prototype.dropEventListener = null;

  WorldMorph.prototype.resizeEventListener = null;

  WorldMorph.prototype.otherTasksToBeRunOnStep = [];

  WorldMorph.preferencesAndSettings = null;

  WorldMorph.currentTime = null;

  WorldMorph.prototype.showRedraws = false;

  WorldMorph.prototype.systemTestsRecorderAndPlayer = null;

  WorldMorph.prototype.worldCanvas = null;

  WorldMorph.prototype.automaticallyAdjustToFillEntireBrowserAlsoOnResize = true;

  WorldMorph.KEYPAD_TAB_mappedToThaiKeyboard_A = "ฟ";

  WorldMorph.KEYPAD_SLASH_mappedToThaiKeyboard_B = "ิ";

  WorldMorph.KEYPAD_MULTIPLY_mappedToThaiKeyboard_C = "แ";

  WorldMorph.KEYPAD_DELETE_mappedToThaiKeyboard_D = "ก";

  WorldMorph.KEYPAD_7_mappedToThaiKeyboard_E = "ำ";

  WorldMorph.KEYPAD_8_mappedToThaiKeyboard_F = "ด";

  WorldMorph.KEYPAD_9_mappedToThaiKeyboard_G = "เ";

  WorldMorph.KEYPAD_MINUS_mappedToThaiKeyboard_H = "้";

  WorldMorph.KEYPAD_4_mappedToThaiKeyboard_I = "ร";

  WorldMorph.KEYPAD_5_mappedToThaiKeyboard_J = "่";

  WorldMorph.KEYPAD_6_mappedToThaiKeyboard_K = "า";

  WorldMorph.KEYPAD_PLUS_mappedToThaiKeyboard_L = "ส";

  WorldMorph.KEYPAD_1_mappedToThaiKeyboard_M = "ท";

  WorldMorph.KEYPAD_2_mappedToThaiKeyboard_N = "ท";

  WorldMorph.KEYPAD_3_mappedToThaiKeyboard_O = "ื";

  WorldMorph.KEYPAD_ENTER_mappedToThaiKeyboard_P = "น";

  WorldMorph.KEYPAD_0_mappedToThaiKeyboard_Q = "ย";

  WorldMorph.KEYPAD_DOT_mappedToThaiKeyboard_R = "พ";

  function WorldMorph(worldCanvas, automaticallyAdjustToFillEntireBrowserAlsoOnResize) {
    var colorName, colorValue, _ref;
    this.worldCanvas = worldCanvas;
    this.automaticallyAdjustToFillEntireBrowserAlsoOnResize = automaticallyAdjustToFillEntireBrowserAlsoOnResize != null ? automaticallyAdjustToFillEntireBrowserAlsoOnResize : true;
    _ref = Color.colourNamesValues;
    for (colorName in _ref) {
      colorValue = _ref[colorName];
      Color["" + colorName] = new Color(colorValue[0], colorValue[1], colorValue[2]);
    }
    delete Color.colourNamesValues;
    WorldMorph.__super__.constructor.call(this);
    WorldMorph.preferencesAndSettings = new PreferencesAndSettings();
    console.log(WorldMorph.preferencesAndSettings.menuFontName);
    this.color = new Color(205, 205, 205);
    this.alpha = 1;
    this.isMinimised = false;
    this.isDraggable = false;
    this.stamp = Date.now();
    this.isDevMode = false;
    this.broken = [];
    this.hand = new HandMorph(this);
    this.keyboardEventsReceiver = null;
    this.lastEditedText = null;
    this.caret = null;
    this.activeMenu = null;
    this.activeHandle = null;
    this.inputDOMElementForVirtualKeyboard = null;
    if (this.automaticallyAdjustToFillEntireBrowserAlsoOnResize) {
      this.stretchWorldToFillEntirePage();
    }
    this.bounds = new Rectangle(0, 0, this.worldCanvas.width / pixelRatio, this.worldCanvas.height / pixelRatio);
    this.initEventListeners();
    this.systemTestsRecorderAndPlayer = new SystemTestsRecorderAndPlayer(this, this.hand);
    this.changed();
    this.updateRendering();
  }

  WorldMorph.prototype.alignIDsOfNextMorphsInSystemTests = function() {
    var eachMorphClass, listOfMorphsClasses, theWordMorph, _i, _len, _results;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.IDLE) {
      theWordMorph = "Morph";
      listOfMorphsClasses = (Object.keys(window)).filter(function(i) {
        return i.indexOf(theWordMorph, i.length - theWordMorph.length) !== -1;
      });
      _results = [];
      for (_i = 0, _len = listOfMorphsClasses.length; _i < _len; _i++) {
        eachMorphClass = listOfMorphsClasses[_i];
        console.log("bumping up ID of class: " + eachMorphClass);
        if (window[eachMorphClass].roundNumericIDsToNextThousand != null) {
          _results.push(window[eachMorphClass].roundNumericIDsToNextThousand());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  WorldMorph.prototype.brokenFor = function(aMorph) {
    var fb;
    fb = aMorph.boundsIncludingChildren();
    return this.broken.filter(function(rect) {
      return rect.intersects(fb);
    });
  };

  WorldMorph.prototype.recursivelyBlit = function(aCanvas, aRect) {
    WorldMorph.__super__.recursivelyBlit.call(this, aCanvas, aRect);
    return this.hand.recursivelyBlit(aCanvas, aRect);
  };

  WorldMorph.prototype.updateBroken = function() {
    ProfilingDataCollector.profileBrokenRects(this.broken.length);
    this.broken.forEach((function(_this) {
      return function(rect) {
        if (rect.isNotEmpty()) {
          return _this.recursivelyBlit(_this.worldCanvas, rect);
        }
      };
    })(this));
    return this.broken = [];
  };

  WorldMorph.prototype.doOneCycle = function() {
    WorldMorph.currentTime = Date.now();
    this.runOtherTasksStepFunction();
    this.runChildrensStepFunction();
    return this.updateBroken();
  };

  WorldMorph.prototype.runOtherTasksStepFunction = function() {
    var task, _i, _len, _ref, _results;
    _ref = this.otherTasksToBeRunOnStep;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      task = _ref[_i];
      _results.push(task());
    }
    return _results;
  };

  WorldMorph.prototype.stretchWorldToFillEntirePage = function() {
    var clientHeight, clientWidth, pos;
    pos = getDocumentPositionOf(this.worldCanvas);
    clientHeight = window.innerHeight;
    clientWidth = window.innerWidth;
    if (pos.x > 0) {
      this.worldCanvas.style.position = "absolute";
      this.worldCanvas.style.left = "0px";
      pos.x = 0;
    }
    if (pos.y > 0) {
      this.worldCanvas.style.position = "absolute";
      this.worldCanvas.style.top = "0px";
      pos.y = 0;
    }
    if (document.body.scrollTop) {
      clientHeight = document.documentElement.clientHeight;
    }
    if (document.body.scrollLeft) {
      clientWidth = document.documentElement.clientWidth;
    }
    if (this.worldCanvas.width !== clientWidth) {
      this.worldCanvas.width = clientWidth;
      this.setWidth(clientWidth);
    }
    if (this.worldCanvas.height !== clientHeight) {
      this.worldCanvas.height = clientHeight;
      this.setHeight(clientHeight);
    }
    return this.children.forEach((function(_this) {
      return function(child) {
        if (child.reactToWorldResize) {
          return child.reactToWorldResize(_this.bounds.copy());
        }
      };
    })(this));
  };

  WorldMorph.prototype.getGlobalPixelColor = function(point) {
    var dta;
    dta = this.worldCanvas.getContext("2d").getImageData(point.x, point.y, 1, 1).data;
    return new Color(dta[0], dta[1], dta[2]);
  };

  WorldMorph.prototype.initVirtualKeyboard = function() {
    if (this.inputDOMElementForVirtualKeyboard) {
      document.body.removeChild(this.inputDOMElementForVirtualKeyboard);
      this.inputDOMElementForVirtualKeyboard = null;
    }
    if (!(WorldMorph.preferencesAndSettings.isTouchDevice && WorldMorph.preferencesAndSettings.useVirtualKeyboard)) {
      return;
    }
    this.inputDOMElementForVirtualKeyboard = document.createElement("input");
    this.inputDOMElementForVirtualKeyboard.type = "text";
    this.inputDOMElementForVirtualKeyboard.style.color = "transparent";
    this.inputDOMElementForVirtualKeyboard.style.backgroundColor = "transparent";
    this.inputDOMElementForVirtualKeyboard.style.border = "none";
    this.inputDOMElementForVirtualKeyboard.style.outline = "none";
    this.inputDOMElementForVirtualKeyboard.style.position = "absolute";
    this.inputDOMElementForVirtualKeyboard.style.top = "0px";
    this.inputDOMElementForVirtualKeyboard.style.left = "0px";
    this.inputDOMElementForVirtualKeyboard.style.width = "0px";
    this.inputDOMElementForVirtualKeyboard.style.height = "0px";
    this.inputDOMElementForVirtualKeyboard.autocapitalize = "none";
    document.body.appendChild(this.inputDOMElementForVirtualKeyboard);
    this.inputDOMElementForVirtualKeyboardKeydownEventListener = (function(_this) {
      return function(event) {
        if (_this.keyboardEventsReceiver) {
          _this.keyboardEventsReceiver.processKeyDown(event);
        }
        if (event.keyIdentifier === "U+0008" || event.keyIdentifier === "Backspace") {
          event.preventDefault();
        }
        if (event.keyIdentifier === "U+0009" || event.keyIdentifier === "Tab") {
          if (_this.keyboardEventsReceiver) {
            _this.keyboardEventsReceiver.processKeyPress(event);
          }
          return event.preventDefault();
        }
      };
    })(this);
    this.inputDOMElementForVirtualKeyboard.addEventListener("keydown", this.inputDOMElementForVirtualKeyboardKeydownEventListener, false);
    this.inputDOMElementForVirtualKeyboardKeyupEventListener = (function(_this) {
      return function(event) {
        if (_this.keyboardEventsReceiver) {
          if (_this.keyboardEventsReceiver.processKeyUp) {
            _this.keyboardEventsReceiver.processKeyUp(event);
          }
        }
        return event.preventDefault();
      };
    })(this);
    this.inputDOMElementForVirtualKeyboard.addEventListener("keyup", this.inputDOMElementForVirtualKeyboardKeyupEventListener, false);
    this.inputDOMElementForVirtualKeyboardKeypressEventListener = (function(_this) {
      return function(event) {
        if (_this.keyboardEventsReceiver) {
          _this.keyboardEventsReceiver.processKeyPress(event);
        }
        return event.preventDefault();
      };
    })(this);
    return this.inputDOMElementForVirtualKeyboard.addEventListener("keypress", this.inputDOMElementForVirtualKeyboardKeypressEventListener, false);
  };

  WorldMorph.prototype.processMouseDown = function(button, ctrlKey) {
    this.systemTestsRecorderAndPlayer.addMouseDownCommand(button, ctrlKey);
    return this.hand.processMouseDown(button, ctrlKey);
  };

  WorldMorph.prototype.processMouseUp = function(button) {
    this.systemTestsRecorderAndPlayer.addMouseUpCommand();
    return this.hand.processMouseUp(button);
  };

  WorldMorph.prototype.processMouseMove = function(pageX, pageY) {
    this.systemTestsRecorderAndPlayer.addMouseMoveCommand(pageX, pageY);
    return this.hand.processMouseMove(pageX, pageY);
  };

  WorldMorph.prototype.getChar = function(event) {
    if (event.which == null) {
      return String.fromCharCode(event.keyCode);
    } else if (event.which !== 0 && event.charCode !== 0) {
      return String.fromCharCode(event.which);
    } else {
      return null;
    }
  };

  WorldMorph.prototype.processKeydown = function(event, scanCode, shiftKey, ctrlKey, altKey, metaKey) {
    this.systemTestsRecorderAndPlayer.addKeyDownCommand(scanCode, shiftKey, ctrlKey, altKey, metaKey);
    if (this.keyboardEventsReceiver) {
      this.keyboardEventsReceiver.processKeyDown(scanCode, shiftKey, ctrlKey, altKey, metaKey);
    }
    if ((event != null) && scanCode === 8) {
      event.preventDefault();
    }
    if ((event != null) && scanCode === 9) {
      if (this.keyboardEventsReceiver) {
        this.keyboardEventsReceiver.processKeyPress(scanCode, "\t", shiftKey, ctrlKey, altKey, metaKey);
      }
      return event.preventDefault();
    }
  };

  WorldMorph.prototype.processKeyup = function(event, scanCode, shiftKey, ctrlKey, altKey, metaKey) {
    this.systemTestsRecorderAndPlayer.addKeyUpCommand(scanCode, shiftKey, ctrlKey, altKey, metaKey);
    if (this.keyboardEventsReceiver) {
      if (this.keyboardEventsReceiver.processKeyUp) {
        this.keyboardEventsReceiver.processKeyUp(scanCode, shiftKey, ctrlKey, altKey, metaKey);
      }
    }
    if (event != null) {
      return event.preventDefault();
    }
  };

  WorldMorph.prototype.processKeypress = function(event, charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) {
    this.systemTestsRecorderAndPlayer.addKeyPressCommand(charCode, symbol, shiftKey, ctrlKey, altKey, metaKey);
    if (event != null) {
      if (symbol === this.constructor.KEYPAD_0_mappedToThaiKeyboard_Q) {
        if (this.doublePressOfZeroKeypadKey == null) {
          this.doublePressOfZeroKeypadKey = 1;
          setTimeout(((function(_this) {
            return function() {
              if (_this.doublePressOfZeroKeypadKey === 1) {
                console.log("single keypress");
              }
              _this.doublePressOfZeroKeypadKey = null;
              event.keyCode = 0;
              return false;
            };
          })(this)), 300);
        } else {
          this.doublePressOfZeroKeypadKey = null;
          console.log("double keypress");
          event.keyCode = 0;
        }
        return false;
      }
    }
    if (this.keyboardEventsReceiver) {
      this.keyboardEventsReceiver.processKeyPress(charCode, symbol, shiftKey, ctrlKey, altKey, metaKey);
    }
    if (event != null) {
      return event.preventDefault();
    }
  };

  WorldMorph.prototype.processCopy = function(event) {
    var selectedText, setStatus;
    this.systemTestsRecorderAndPlayer.addCopyCommand;
    console.log("processing copy");
    if (this.caret) {
      selectedText = this.caret.target.selection();
      if (event.clipboardData) {
        event.preventDefault();
        setStatus = event.clipboardData.setData("text/plain", selectedText);
      }
      if (window.clipboardData) {
        event.returnValue = false;
        return setStatus = window.clipboardData.setData("Text", selectedText);
      }
    }
  };

  WorldMorph.prototype.processPaste = function(event, text) {
    if (this.caret) {
      if (event != null) {
        if (event.clipboardData) {
          text = event.clipboardData.getData("text/plain");
        }
        if (window.clipboardData) {
          text = window.clipboardData.getData("Text");
        }
      }
      console.log("about to insert text: " + text);
      this.systemTestsRecorderAndPlayer.addPasteCommand(text);
      return window.setTimeout(((function(_this) {
        return function() {
          return _this.caret.insert(text);
        };
      })(this)), 50, true);
    }
  };

  WorldMorph.prototype.initEventListeners = function() {
    var canvas;
    canvas = this.worldCanvas;
    this.dblclickEventListener = (function(_this) {
      return function(event) {
        event.preventDefault();
        return _this.hand.processDoubleClick(event);
      };
    })(this);
    canvas.addEventListener("dblclick", this.dblclickEventListener, false);
    this.mousedownEventListener = (function(_this) {
      return function(event) {
        return _this.processMouseDown(event.button, event.ctrlKey);
      };
    })(this);
    canvas.addEventListener("mousedown", this.mousedownEventListener, false);
    this.touchstartEventListener = (function(_this) {
      return function(event) {
        return _this.hand.processTouchStart(event);
      };
    })(this);
    canvas.addEventListener("touchstart", this.touchstartEventListener, false);
    this.mouseupEventListener = (function(_this) {
      return function(event) {
        return _this.processMouseUp(event.button);
      };
    })(this);
    canvas.addEventListener("mouseup", this.mouseupEventListener, false);
    this.touchendEventListener = (function(_this) {
      return function(event) {
        return _this.hand.processTouchEnd(event);
      };
    })(this);
    canvas.addEventListener("touchend", this.touchendEventListener, false);
    this.mousemoveEventListener = (function(_this) {
      return function(event) {
        return _this.processMouseMove(event.pageX, event.pageY);
      };
    })(this);
    canvas.addEventListener("mousemove", this.mousemoveEventListener, false);
    this.touchmoveEventListener = (function(_this) {
      return function(event) {
        return _this.hand.processTouchMove(event);
      };
    })(this);
    canvas.addEventListener("touchmove", this.touchmoveEventListener, false);
    this.gesturestartEventListener = (function(_this) {
      return function(event) {
        return event.preventDefault();
      };
    })(this);
    canvas.addEventListener("gesturestart", this.gesturestartEventListener, false);
    this.gesturechangeEventListener = (function(_this) {
      return function(event) {
        return event.preventDefault();
      };
    })(this);
    canvas.addEventListener("gesturechange", this.gesturechangeEventListener, false);
    this.contextmenuEventListener = function(event) {
      return event.preventDefault();
    };
    canvas.addEventListener("contextmenu", this.contextmenuEventListener, false);
    this.keydownEventListener = (function(_this) {
      return function(event) {
        return _this.processKeydown(event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey);
      };
    })(this);
    canvas.addEventListener("keydown", this.keydownEventListener, false);
    this.keyupEventListener = (function(_this) {
      return function(event) {
        return _this.processKeyup(event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey);
      };
    })(this);
    canvas.addEventListener("keyup", this.keyupEventListener, false);
    ({
      doublePressOfZeroKeypadKey: null
    });
    this.keypressEventListener = (function(_this) {
      return function(event) {
        return _this.processKeypress(event, event.keyCode, _this.getChar(event), event.shiftKey, event.ctrlKey, event.altKey, event.metaKey);
      };
    })(this);
    canvas.addEventListener("keypress", this.keypressEventListener, false);
    this.mousewheelEventListener = (function(_this) {
      return function(event) {
        _this.hand.processMouseScroll(event);
        return event.preventDefault();
      };
    })(this);
    canvas.addEventListener("mousewheel", this.mousewheelEventListener, false);
    this.DOMMouseScrollEventListener = (function(_this) {
      return function(event) {
        _this.hand.processMouseScroll(event);
        return event.preventDefault();
      };
    })(this);
    canvas.addEventListener("DOMMouseScroll", this.DOMMouseScrollEventListener, false);
    this.copyEventListener = (function(_this) {
      return function(event) {
        return _this.processCopy(event);
      };
    })(this);
    document.body.addEventListener("copy", this.copyEventListener, false);
    this.pasteEventListener = (function(_this) {
      return function(event) {
        return _this.processPaste(event);
      };
    })(this);
    document.body.addEventListener("paste", this.pasteEventListener, false);
    this.keyComboResetWorldEventListener = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.resetWorld();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+d"], this.keyComboResetWorldEventListener);
    this.keyComboTurnOnAnimationsPacingControl = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.turnOnAnimationsPacingControl();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+e"], this.keyComboTurnOnAnimationsPacingControl);
    this.keyComboTurnOffAnimationsPacingControl = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+u"], this.keyComboTurnOffAnimationsPacingControl);
    this.keyComboTakeScreenshotEventListener = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.takeScreenshot();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+c"], this.keyComboTakeScreenshotEventListener);
    this.keyComboStopTestRecordingEventListener = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.stopTestRecording();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+t"], this.keyComboStopTestRecordingEventListener);
    this.keyComboAddTestCommentEventListener = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.addTestComment();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+m"], this.keyComboAddTestCommentEventListener);
    this.keyComboCheckNumberOfMenuItemsEventListener = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.checkNumberOfItemsInMenu();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+k"], this.keyComboCheckNumberOfMenuItemsEventListener);
    this.keyComboCheckStringsOfItemsInMenuOrderImportant = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderImportant();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+a"], this.keyComboCheckStringsOfItemsInMenuOrderImportant);
    this.keyComboCheckStringsOfItemsInMenuOrderUnimportant = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderUnimportant();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+z"], this.keyComboCheckStringsOfItemsInMenuOrderUnimportant);
    this.dragoverEventListener = function(event) {
      return event.preventDefault();
    };
    window.addEventListener("dragover", this.dragoverEventListener, false);
    this.dropEventListener = (function(_this) {
      return function(event) {
        _this.hand.processDrop(event);
        return event.preventDefault();
      };
    })(this);
    window.addEventListener("drop", this.dropEventListener, false);
    this.resizeEventListener = (function(_this) {
      return function() {
        if (_this.automaticallyAdjustToFillEntireBrowserAlsoOnResize) {
          return _this.stretchWorldToFillEntirePage();
        }
      };
    })(this);
    window.addEventListener("resize", this.resizeEventListener, false);
    return window.onbeforeunload = function(evt) {
      var e, msg;
      e = evt || window.event;
      msg = "Are you sure you want to leave?";
      if (e) {
        e.returnValue = msg;
      }
      return msg;
    };
  };

  WorldMorph.prototype.removeEventListeners = function() {
    var canvas;
    canvas = this.worldCanvas;
    canvas.removeEventListener('dblclick', this.dblclickEventListener);
    canvas.removeEventListener('mousedown', this.mousedownEventListener);
    canvas.removeEventListener('touchstart', this.touchstartEventListener);
    canvas.removeEventListener('mouseup', this.mouseupEventListener);
    canvas.removeEventListener('touchend', this.touchendEventListener);
    canvas.removeEventListener('mousemove', this.mousemoveEventListener);
    canvas.removeEventListener('touchmove', this.touchmoveEventListener);
    canvas.removeEventListener('gesturestart', this.gesturestartEventListener);
    canvas.removeEventListener('gesturechange', this.gesturechangeEventListener);
    canvas.removeEventListener('contextmenu', this.contextmenuEventListener);
    canvas.removeEventListener('keydown', this.keydownEventListener);
    canvas.removeEventListener('keyup', this.keyupEventListener);
    canvas.removeEventListener('keypress', this.keypressEventListener);
    canvas.removeEventListener('mousewheel', this.mousewheelEventListener);
    canvas.removeEventListener('DOMMouseScroll', this.DOMMouseScrollEventListener);
    canvas.removeEventListener('copy', this.copyEventListener);
    canvas.removeEventListener('paste', this.pasteEventListener);
    Mousetrap.reset();
    canvas.removeEventListener('dragover', this.dragoverEventListener);
    canvas.removeEventListener('drop', this.dropEventListener);
    return canvas.removeEventListener('resize', this.resizeEventListener);
  };

  WorldMorph.prototype.mouseDownLeft = function() {
    return noOperation;
  };

  WorldMorph.prototype.mouseClickLeft = function() {
    return noOperation;
  };

  WorldMorph.prototype.mouseDownRight = function() {
    return noOperation;
  };

  WorldMorph.prototype.mouseClickRight = function() {
    return noOperation;
  };

  WorldMorph.prototype.wantsDropOf = function() {
    return this.acceptsDrops;
  };

  WorldMorph.prototype.droppedImage = function() {
    return null;
  };

  WorldMorph.prototype.droppedSVG = function() {
    return null;
  };

  WorldMorph.prototype.nextTab = function(editField) {
    var next;
    next = this.nextEntryField(editField);
    if (next) {
      editField.clearSelection();
      next.selectAll();
      return next.edit();
    }
  };

  WorldMorph.prototype.previousTab = function(editField) {
    var prev;
    prev = this.previousEntryField(editField);
    if (prev) {
      editField.clearSelection();
      prev.selectAll();
      return prev.edit();
    }
  };

  WorldMorph.prototype.resetWorld = function() {
    this.destroyAll();
    return this.setColor(new Color(205, 205, 205));
  };

  WorldMorph.prototype.destroyAll = function() {
    var ListOfMorphs, eachMorphClass, theWordMorph, _i, _len;
    theWordMorph = "Morph";
    ListOfMorphs = (Object.keys(window)).filter(function(i) {
      return i.indexOf(theWordMorph, i.length - theWordMorph.length) !== -1;
    });
    for (_i = 0, _len = ListOfMorphs.length; _i < _len; _i++) {
      eachMorphClass = ListOfMorphs[_i];
      if (eachMorphClass !== "WorldMorph") {
        console.log("resetting " + eachMorphClass + " from " + window[eachMorphClass].instancesCounter);
        window[eachMorphClass].lastBuiltInstanceNumericID = 0;
      }
    }
    window.world.systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl();
    window.world.systemTestsRecorderAndPlayer.turnOffAlignmentOfMorphIDsMechanism();
    window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsGeometryInfoInLabels();
    window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsContentExtractInLabels();
    window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsNumberIDInLabels();
    return WorldMorph.__super__.destroyAll.call(this);
  };

  WorldMorph.prototype.unfocusMenu = function(menuToBeUnfocuses) {
    if (this.activeMenu === menuToBeUnfocuses) {
      return this.activeMenu = null;
    }
  };

  WorldMorph.prototype.contextMenu = function() {
    var menu;
    if (this.isDevMode) {
      menu = new MenuMorph(this, this.constructor.name || this.constructor.toString().split(" ")[1].split("(")[0]);
    } else {
      menu = new MenuMorph(this, "Morphic");
    }
    if (this.isDevMode) {
      menu.addItem("demo...", (function() {
        return this.popUpDemoMenu();
      }), "sample morphs");
      menu.addLine();
      menu.addItem("show all", (function() {
        return this.showAllMinimised();
      }));
      menu.addItem("hide all", (function() {
        return this.minimiseAll();
      }));
      menu.addItem("delete all", (function() {
        return this.destroyAll();
      }));
      menu.addItem("move all inside", (function() {
        return this.keepAllSubmorphsWithin();
      }), "keep all submorphs\nwithin and visible");
      menu.addItem("inspect", (function() {
        return this.inspect();
      }), "open a window on\nall properties");
      menu.addLine();
      menu.addItem("restore display", (function() {
        return this.changed();
      }), "redraw the\nscreen once");
      menu.addItem("fit whole page", (function() {
        return this.stretchWorldToFillEntirePage();
      }), "let the World automatically\nadjust to browser resizings");
      menu.addItem("color...", (function() {
        return this.pickColor(menu.title + "\ncolor:", this.setColor, this.color);
      }), "choose the World's\nbackground color");
      if (WorldMorph.preferencesAndSettings.inputMode === PreferencesAndSettings.INPUT_MODE_MOUSE) {
        menu.addItem("touch screen settings", (function() {
          return WorldMorph.preferencesAndSettings.toggleInputMode();
        }), "bigger menu fonts\nand sliders");
      } else {
        menu.addItem("standard settings", (function() {
          return WorldMorph.preferencesAndSettings.toggleInputMode();
        }), "smaller menu fonts\nand sliders");
      }
      menu.addLine();
    }
    if (window.location.href.indexOf("worldWithSystemTestHarness") !== -1) {
      menu.addItem("system tests...", (function() {
        return this.popUpSystemTestsMenu();
      }), "");
    }
    if (this.isDevMode) {
      menu.addItem("switch to user mode", (function() {
        return this.toggleDevMode();
      }), "disable developers'\ncontext menus");
    } else {
      menu.addItem("switch to dev mode", (function() {
        return this.toggleDevMode();
      }));
    }
    menu.addItem("about Zombie Kernel...", (function() {
      return this.about();
    }));
    return menu;
  };

  WorldMorph.prototype.popUpSystemTestsMenu = function() {
    var create, menu;
    create = (function(_this) {
      return function(aMorph) {
        aMorph.isDraggable = true;
        return aMorph.pickUp();
      };
    })(this);
    menu = new MenuMorph(this, "system tests");
    menu.addItem("run system tests", (function() {
      return this.systemTestsRecorderAndPlayer.runAllSystemTests();
    }), "runs all the system tests");
    menu.addItem("start test recording", (function() {
      return this.systemTestsRecorderAndPlayer.startTestRecording();
    }), "start recording a test");
    menu.addItem("stop test recording", (function() {
      return this.systemTestsRecorderAndPlayer.stopTestRecording();
    }), "stop recording the test");
    menu.addItem("(re)play recorded test", (function() {
      return this.systemTestsRecorderAndPlayer.startTestPlaying();
    }), "start playing the test");
    menu.addItem("show test source", (function() {
      return this.systemTestsRecorderAndPlayer.showTestSource();
    }), "opens a window with the source of the latest test");
    menu.addItem("save recorded test", (function() {
      return this.systemTestsRecorderAndPlayer.saveTest();
    }), "save the recorded test");
    menu.addItem("save failed screenshots test", (function() {
      return this.systemTestsRecorderAndPlayer.saveFailedScreenshots();
    }), "save failed screenshots test");
    return menu.popUpAtHand();
  };

  WorldMorph.prototype.popUpDemoMenu = function() {
    var create, menu;
    create = (function(_this) {
      return function(aMorph) {
        aMorph.isDraggable = true;
        return aMorph.pickUp();
      };
    })(this);
    menu = new MenuMorph(this, "make a morph");
    menu.addItem("rectangle", function() {
      return create(new RectangleMorph());
    });
    menu.addItem("box", function() {
      return create(new BoxMorph());
    });
    menu.addItem("circle box", function() {
      return create(new CircleBoxMorph());
    });
    menu.addLine();
    menu.addItem("slider", function() {
      return create(new SliderMorph());
    });
    menu.addItem("frame", function() {
      var newMorph;
      newMorph = new FrameMorph();
      newMorph.setExtent(new Point(350, 250));
      return create(newMorph);
    });
    menu.addItem("scroll frame", function() {
      var newMorph;
      newMorph = new ScrollFrameMorph();
      newMorph.contents.acceptsDrops = true;
      newMorph.contents.adjustBounds();
      newMorph.setExtent(new Point(350, 250));
      return create(newMorph);
    });
    menu.addItem("handle", function() {
      return create(new HandleMorph());
    });
    menu.addLine();
    menu.addItem("string", function() {
      var newMorph;
      newMorph = new StringMorph("Hello, World!");
      newMorph.isEditable = true;
      return create(newMorph);
    });
    menu.addItem("text", function() {
      var newMorph;
      newMorph = new TextMorph("Ich weiß nicht, was soll es bedeuten, dass ich so " + "traurig bin, ein Märchen aus uralten Zeiten, das " + "kommt mir nicht aus dem Sinn. Die Luft ist kühl " + "und es dunkelt, und ruhig fließt der Rhein; der " + "Gipfel des Berges funkelt im Abendsonnenschein. " + "Die schönste Jungfrau sitzet dort oben wunderbar, " + "ihr gold'nes Geschmeide blitzet, sie kämmt ihr " + "goldenes Haar, sie kämmt es mit goldenem Kamme, " + "und singt ein Lied dabei; das hat eine wundersame, " + "gewalt'ge Melodei. Den Schiffer im kleinen " + "Schiffe, ergreift es mit wildem Weh; er schaut " + "nicht die Felsenriffe, er schaut nur hinauf in " + "die Höh'. Ich glaube, die Wellen verschlingen " + "am Ende Schiffer und Kahn, und das hat mit ihrem " + "Singen, die Loreley getan.");
      newMorph.isEditable = true;
      newMorph.maxWidth = 300;
      return create(newMorph);
    });
    menu.addItem("speech bubble", function() {
      var newMorph;
      newMorph = new SpeechBubbleMorph("Hello, World!");
      return create(newMorph);
    });
    menu.addLine();
    menu.addItem("gray scale palette", function() {
      return create(new GrayPaletteMorph());
    });
    menu.addItem("color palette", function() {
      return create(new ColorPaletteMorph());
    });
    menu.addItem("color picker", function() {
      return create(new ColorPickerMorph());
    });
    menu.addLine();
    menu.addItem("sensor demo", function() {
      var newMorph;
      newMorph = new MouseSensorMorph();
      newMorph.setColor(new Color(230, 200, 100));
      newMorph.edge = 35;
      newMorph.border = 15;
      newMorph.borderColor = new Color(200, 100, 50);
      newMorph.alpha = 0.2;
      newMorph.setExtent(new Point(100, 100));
      return create(newMorph);
    });
    menu.addItem("animation demo", function() {
      var bar, baz, foo, fred, garply;
      foo = new BouncerMorph();
      foo.setPosition(new Point(50, 20));
      foo.setExtent(new Point(300, 200));
      foo.alpha = 0.9;
      foo.speed = 3;
      bar = new BouncerMorph();
      bar.setColor(new Color(50, 50, 50));
      bar.setPosition(new Point(80, 80));
      bar.setExtent(new Point(80, 250));
      bar.type = "horizontal";
      bar.direction = "right";
      bar.alpha = 0.9;
      bar.speed = 5;
      baz = new BouncerMorph();
      baz.setColor(new Color(20, 20, 20));
      baz.setPosition(new Point(90, 140));
      baz.setExtent(new Point(40, 30));
      baz.type = "horizontal";
      baz.direction = "right";
      baz.speed = 3;
      garply = new BouncerMorph();
      garply.setColor(new Color(200, 20, 20));
      garply.setPosition(new Point(90, 140));
      garply.setExtent(new Point(20, 20));
      garply.type = "vertical";
      garply.direction = "up";
      garply.speed = 8;
      fred = new BouncerMorph();
      fred.setColor(new Color(20, 200, 20));
      fred.setPosition(new Point(120, 140));
      fred.setExtent(new Point(20, 20));
      fred.type = "vertical";
      fred.direction = "down";
      fred.speed = 4;
      bar.add(garply);
      bar.add(baz);
      foo.add(fred);
      foo.add(bar);
      return create(foo);
    });
    menu.addItem("pen", function() {
      return create(new PenMorph());
    });
    menu.addLine();
    menu.addItem("Layout tests", (function() {
      return this.layoutTestsMenu();
    }), "sample morphs");
    menu.addLine();
    menu.addItem("view all...", function() {
      var newMorph;
      newMorph = new MorphsListMorph();
      return create(newMorph);
    });
    menu.addItem("closing window", function() {
      var newMorph;
      newMorph = new WorkspaceMorph();
      return create(newMorph);
    });
    if (this.customMorphs) {
      menu.addLine();
      this.customMorphs().forEach(function(morph) {
        return menu.addItem(morph.toString(), function() {
          return create(morph);
        });
      });
    }
    return menu.popUpAtHand();
  };

  WorldMorph.prototype.layoutTestsMenu = function() {
    var create, menu;
    create = (function(_this) {
      return function(aMorph) {
        aMorph.isDraggable = true;
        return aMorph.pickUp();
      };
    })(this);
    menu = new MenuMorph(this, "Layout tests");
    menu.addItem("test1", function() {
      return LayoutMorph.test1();
    });
    menu.addItem("test2", function() {
      return LayoutMorph.test2();
    });
    menu.addItem("test3", function() {
      return LayoutMorph.test3();
    });
    menu.addItem("test4", function() {
      return LayoutMorph.test4();
    });
    return menu.popUpAtHand();
  };

  WorldMorph.prototype.toggleDevMode = function() {
    return this.isDevMode = !this.isDevMode;
  };

  WorldMorph.prototype.minimiseAll = function() {
    return this.children.forEach(function(child) {
      return child.minimise();
    });
  };

  WorldMorph.prototype.showAllMinimised = function() {
    return this.forAllChildrenBottomToTop(function(child) {
      if (child.isMinimised) {
        return child.unminimise();
      }
    });
  };

  WorldMorph.prototype.about = function() {
    return this.inform("Zombie Kernel\n\n" + "a lively Web GUI\ninspired by Squeak\n" + morphicVersion + "\n\nby Davide Della Casa" + "\n\nbased on morphic.js by" + "\nJens Mönig (jens@moenig.org)");
  };

  WorldMorph.prototype.edit = function(aStringMorphOrTextMorph) {
    var pos;
    if (this.caret) {
      this.lastEditedText = this.caret.target;
      if (this.lastEditedText) {
        this.lastEditedText.clearSelection();
      }
      this.caret = this.caret.destroy();
    }
    this.caret = new CaretMorph(aStringMorphOrTextMorph);
    aStringMorphOrTextMorph.parent.add(this.caret);
    this.keyboardEventsReceiver = this.caret;
    if (WorldMorph.preferencesAndSettings.isTouchDevice && WorldMorph.preferencesAndSettings.useVirtualKeyboard) {
      this.initVirtualKeyboard();
      pos = getDocumentPositionOf(this.worldCanvas);
      this.inputDOMElementForVirtualKeyboard.style.top = this.caret.top() + pos.y + "px";
      this.inputDOMElementForVirtualKeyboard.style.left = this.caret.left() + pos.x + "px";
      this.inputDOMElementForVirtualKeyboard.focus();
    }
    if (WorldMorph.preferencesAndSettings.useSliderForInput) {
      if (!aStringMorphOrTextMorph.parentThatIsA(MenuMorph)) {
        return this.slide(aStringMorphOrTextMorph);
      }
    }
  };

  WorldMorph.prototype.stopEditing = function() {
    if (this.caret) {
      this.lastEditedText = this.caret.target;
      this.lastEditedText.clearSelection();
      this.lastEditedText.escalateEvent("reactToEdit", this.lastEditedText);
      this.caret = this.caret.destroy();
    }
    this.keyboardEventsReceiver = null;
    if (this.inputDOMElementForVirtualKeyboard) {
      this.inputDOMElementForVirtualKeyboard.blur();
      document.body.removeChild(this.inputDOMElementForVirtualKeyboard);
      this.inputDOMElementForVirtualKeyboard = null;
    }
    return this.worldCanvas.focus();
  };

  WorldMorph.prototype.slide = function(aStringMorphOrTextMorph) {
    var menu, slider, val;
    val = parseFloat(aStringMorphOrTextMorph.text);
    if (isNaN(val)) {
      val = 0;
    }
    menu = new MenuMorph();
    slider = new SliderMorph(val - 25, val + 25, val, 10, "horizontal");
    slider.alpha = 1;
    slider.color = new Color(225, 225, 225);
    slider.button.color = menu.borderColor;
    slider.button.highlightColor = slider.button.color.copy();
    slider.button.highlightColor.b += 100;
    slider.button.pressColor = slider.button.color.copy();
    slider.button.pressColor.b += 150;
    slider.silentSetHeight(WorldMorph.preferencesAndSettings.scrollBarSize);
    slider.silentSetWidth(WorldMorph.preferencesAndSettings.menuFontSize * 10);
    slider.updateRendering();
    slider.action = function(num) {
      aStringMorphOrTextMorph.changed();
      aStringMorphOrTextMorph.text = Math.round(num).toString();
      aStringMorphOrTextMorph.updateRendering();
      aStringMorphOrTextMorph.changed();
      return aStringMorphOrTextMorph.escalateEvent('reactToSliderEdit', aStringMorphOrTextMorph);
    };
    menu.items.push(slider);
    return menu.popup(this, aStringMorphOrTextMorph.bottomLeft().add(new Point(0, 5)));
  };

  WorldMorph.coffeeScriptSourceOfThisClass = '# WorldMorph //////////////////////////////////////////////////////////\n\n# these comments below needed to figure our dependencies between classes\n# REQUIRES globalFunctions\n# REQUIRES PreferencesAndSettings\n# REQUIRES Color\n# REQUIRES ProfilingDataCollector\n\n# The WorldMorph takes over the canvas on the page\nclass WorldMorph extends FrameMorph\n\n  # We need to add and remove\n  # the event listeners so we are\n  # going to put them all in properties\n  # here.\n  dblclickEventListener: null\n  mousedownEventListener: null\n  touchstartEventListener: null\n  mouseupEventListener: null\n  touchendEventListener: null\n  mousemoveEventListener: null\n  touchmoveEventListener: null\n  gesturestartEventListener: null\n  gesturechangeEventListener: null\n  contextmenuEventListener: null\n  # Note how there can be two handlers for\n  # keyboard events.\n  # This one is attached\n  # to the canvas and reaches the currently\n  # blinking caret if there is one.\n  # See below for the other potential\n  # handler. See "initVirtualKeyboard"\n  # method to see where and when this input and\n  # these handlers are set up.\n  keydownEventListener: null\n  keyupEventListener: null\n  keypressEventListener: null\n  mousewheelEventListener: null\n  DOMMouseScrollEventListener: null\n  copyEventListener: null\n  pasteEventListener: null\n\n  # Note how there can be two handlers\n  # for keyboard events. This one is\n  # attached to a hidden\n  # "input" div which keeps track of the\n  # text that is being input.\n  inputDOMElementForVirtualKeyboardKeydownEventListener: null\n  inputDOMElementForVirtualKeyboardKeyupEventListener: null\n  inputDOMElementForVirtualKeyboardKeypressEventListener: null\n\n  keyComboResetWorldEventListener: null\n  keyComboTurnOnAnimationsPacingControl: null\n  keyComboTurnOffAnimationsPacingControl: null\n  keyComboTakeScreenshotEventListener: null\n  keyComboStopTestRecordingEventListener: null\n  keyComboTakeScreenshotEventListener: null\n  keyComboCheckStringsOfItemsInMenuOrderImportant: null\n  keyComboCheckStringsOfItemsInMenuOrderUnimportant: null\n  keyComboAddTestCommentEventListener: null\n  keyComboCheckNumberOfMenuItemsEventListener: null\n\n  dragoverEventListener: null\n  dropEventListener: null\n  resizeEventListener: null\n  otherTasksToBeRunOnStep: []\n\n  # these variables shouldn\'t be static to the WorldMorph, because\n  # in pure theory you could have multiple worlds in the same\n  # page with different settings\n  # (but anyways, it was global before, so it\'s not any worse than before)\n  @preferencesAndSettings: null\n  @currentTime: null\n  showRedraws: false\n  systemTestsRecorderAndPlayer: null\n\n  # this is the actual reference to the canvas\n  # on the html page, where the world is\n  # finally painted to.\n  worldCanvas: null\n\n  # By default the world will always fill\n  # the entire page, also when browser window\n  # is resized.\n  # When this flag is set, the onResize callback\n  # automatically adjusts the world size.\n  automaticallyAdjustToFillEntireBrowserAlsoOnResize: true\n\n  # keypad keys map to special characters\n  # so we can trigger test actions\n  # see more comments below\n  @KEYPAD_TAB_mappedToThaiKeyboard_A: "ฟ"\n  @KEYPAD_SLASH_mappedToThaiKeyboard_B: "ิ"\n  @KEYPAD_MULTIPLY_mappedToThaiKeyboard_C: "แ"\n  @KEYPAD_DELETE_mappedToThaiKeyboard_D: "ก"\n  @KEYPAD_7_mappedToThaiKeyboard_E: "ำ"\n  @KEYPAD_8_mappedToThaiKeyboard_F: "ด"\n  @KEYPAD_9_mappedToThaiKeyboard_G: "เ"\n  @KEYPAD_MINUS_mappedToThaiKeyboard_H: "้"\n  @KEYPAD_4_mappedToThaiKeyboard_I: "ร"\n  @KEYPAD_5_mappedToThaiKeyboard_J: "่" # looks like empty string but isn\'t :-)\n  @KEYPAD_6_mappedToThaiKeyboard_K: "า"\n  @KEYPAD_PLUS_mappedToThaiKeyboard_L: "ส" \n  @KEYPAD_1_mappedToThaiKeyboard_M: "ท"\n  @KEYPAD_2_mappedToThaiKeyboard_N: "ท"\n  @KEYPAD_3_mappedToThaiKeyboard_O: "ื"\n  @KEYPAD_ENTER_mappedToThaiKeyboard_P: "น"\n  @KEYPAD_0_mappedToThaiKeyboard_Q: "ย"\n  @KEYPAD_DOT_mappedToThaiKeyboard_R: "พ"\n\n  constructor: (\n      @worldCanvas,\n      @automaticallyAdjustToFillEntireBrowserAlsoOnResize = true\n      ) ->\n\n    # The WorldMorph is the very first morph to\n    # be created.\n\n    # We first need to initialise\n    # some Color constants, like\n    #   Color.red\n    # See the comment at the beginning of the\n    # color class on why this piece of code\n    # is here instead of somewhere else.\n    for colorName, colorValue of Color.colourNamesValues\n      Color["#{colorName}"] = new Color(colorValue[0],colorValue[1], colorValue[2])\n    # The colourNamesValues data structure is\n    # redundant at this point.\n    delete Color.colourNamesValues\n\n    super()\n    WorldMorph.preferencesAndSettings = new PreferencesAndSettings()\n    console.log WorldMorph.preferencesAndSettings.menuFontName\n    @color = new Color(205, 205, 205) # (130, 130, 130)\n    @alpha = 1\n    @isMinimised = false\n    @isDraggable = false\n\n    # additional properties:\n    @stamp = Date.now() # reference in multi-world setups\n    @isDevMode = false\n    @broken = []\n    @hand = new HandMorph(@)\n    @keyboardEventsReceiver = null\n    @lastEditedText = null\n    @caret = null\n    @activeMenu = null\n    @activeHandle = null\n    @inputDOMElementForVirtualKeyboard = null\n\n    if @automaticallyAdjustToFillEntireBrowserAlsoOnResize\n      @stretchWorldToFillEntirePage()\n\n    # @worldCanvas.width and height here are in phisical pixels\n    # so we want to bring them back to logical pixels\n    @bounds = new Rectangle(0, 0, @worldCanvas.width / pixelRatio, @worldCanvas.height / pixelRatio)\n\n    @initEventListeners()\n    @systemTestsRecorderAndPlayer = new SystemTestsRecorderAndPlayer(@, @hand)\n\n    @changed()\n    @updateRendering()\n\n  # see roundNumericIDsToNextThousand method in\n  # Morph for an explanation of why we need this\n  # method.\n  alignIDsOfNextMorphsInSystemTests: ->\n    if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.IDLE\n      # Check which objects end with the word Morph\n      theWordMorph = "Morph"\n      listOfMorphsClasses = (Object.keys(window)).filter (i) ->\n        i.indexOf(theWordMorph, i.length - theWordMorph.length) isnt -1\n      for eachMorphClass in listOfMorphsClasses\n        console.log "bumping up ID of class: " + eachMorphClass\n        if window[eachMorphClass].roundNumericIDsToNextThousand?\n          window[eachMorphClass].roundNumericIDsToNextThousand()\n\n  \n  # World Morph display:\n  brokenFor: (aMorph) ->\n    # private\n    fb = aMorph.boundsIncludingChildren()\n    @broken.filter (rect) ->\n      rect.intersects fb\n  \n  \n  # recursivelyBlit results into actual blittings of pices of\n  # morphs done\n  # by the blit function.\n  # The blit function is defined in Morph and is not overriden by\n  # any morph.\n  recursivelyBlit: (aCanvas, aRect) ->\n    # invokes the Morph\'s recursivelyBlit, which has only three implementations:\n    #  * the default one by Morph which just invokes the blit of all children\n    #  * the interesting one in FrameMorph which a) narrows the dirty\n    #    rectangle (intersecting it with its border\n    #    since the FrameMorph clips at its border) and b) stops recursion on all\n    #    the children that are outside such intersection.\n    #  * this implementation which just takes into account that the hand\n    #    (which could contain a Morph being dragged)\n    #    is painted on top of everything.\n    super aCanvas, aRect\n    # the mouse cursor is always drawn on top of everything\n    # and it\'s not attached to the WorldMorph.\n    @hand.recursivelyBlit aCanvas, aRect\n  \n  updateBroken: ->\n    #console.log "number of broken rectangles: " + @broken.length\n    ProfilingDataCollector.profileBrokenRects @broken.length\n\n    # each broken rectangle requires traversing the scenegraph to\n    # redraw what\'s overlapping it. Not all Morphs are traversed\n    # in particular the following can stop the recursion:\n    #  - invisible Morphs\n    #  - FrameMorphs that don\'t overlap the broken rectangle\n    # Since potentially there is a lot of traversal ongoin for\n    # each broken rectangle, one might want to consolidate overlapping\n    # and nearby rectangles.\n\n    @broken.forEach (rect) =>\n      @recursivelyBlit @worldCanvas, rect  if rect.isNotEmpty()\n    @broken = []\n  \n  doOneCycle: ->\n    WorldMorph.currentTime = Date.now();\n    # console.log TextMorph.instancesCounter + " " + StringMorph.instancesCounter\n    @runOtherTasksStepFunction()\n    @runChildrensStepFunction()\n    @updateBroken()\n  \n  runOtherTasksStepFunction : ->\n    for task in @otherTasksToBeRunOnStep\n      #console.log "running a task: " + task\n      task()\n\n  stretchWorldToFillEntirePage: ->\n    pos = getDocumentPositionOf(@worldCanvas)\n    clientHeight = window.innerHeight\n    clientWidth = window.innerWidth\n    if pos.x > 0\n      @worldCanvas.style.position = "absolute"\n      @worldCanvas.style.left = "0px"\n      pos.x = 0\n    if pos.y > 0\n      @worldCanvas.style.position = "absolute"\n      @worldCanvas.style.top = "0px"\n      pos.y = 0\n    # scrolled down b/c of viewport scaling\n    clientHeight = document.documentElement.clientHeight  if document.body.scrollTop\n    # scrolled left b/c of viewport scaling\n    clientWidth = document.documentElement.clientWidth  if document.body.scrollLeft\n    if @worldCanvas.width isnt clientWidth\n      @worldCanvas.width = clientWidth\n      @setWidth clientWidth\n    if @worldCanvas.height isnt clientHeight\n      @worldCanvas.height = clientHeight\n      @setHeight clientHeight\n    @children.forEach (child) =>\n      child.reactToWorldResize @bounds.copy()  if child.reactToWorldResize\n  \n  \n  \n  # WorldMorph global pixel access:\n  getGlobalPixelColor: (point) ->\n    \n    #\n    #	answer the color at the given point.\n    #\n    #	Note: for some strange reason this method works fine if the page is\n    #	opened via HTTP, but *not*, if it is opened from a local uri\n    #	(e.g. from a directory), in which case it\'s always null.\n    #\n    #	This behavior is consistent throughout several browsers. I have no\n    #	clue what\'s behind this, apparently the imageData attribute of\n    #	canvas context only gets filled with meaningful data if transferred\n    #	via HTTP ???\n    #\n    #	This is somewhat of a showstopper for color detection in a planned\n    #	offline version of Snap.\n    #\n    #	The issue has also been discussed at: (join lines before pasting)\n    #	http://stackoverflow.com/questions/4069400/\n    #	canvas-getimagedata-doesnt-work-when-running-locally-on-windows-\n    #	security-excep\n    #\n    #	The suggestion solution appears to work, since the settings are\n    #	applied globally.\n    #\n    dta = @worldCanvas.getContext("2d").getImageData(point.x, point.y, 1, 1).data\n    new Color(dta[0], dta[1], dta[2])\n  \n  \n  # WorldMorph events:\n  initVirtualKeyboard: ->\n    if @inputDOMElementForVirtualKeyboard\n      document.body.removeChild @inputDOMElementForVirtualKeyboard\n      @inputDOMElementForVirtualKeyboard = null\n    unless (WorldMorph.preferencesAndSettings.isTouchDevice and WorldMorph.preferencesAndSettings.useVirtualKeyboard)\n      return\n    @inputDOMElementForVirtualKeyboard = document.createElement("input")\n    @inputDOMElementForVirtualKeyboard.type = "text"\n    @inputDOMElementForVirtualKeyboard.style.color = "transparent"\n    @inputDOMElementForVirtualKeyboard.style.backgroundColor = "transparent"\n    @inputDOMElementForVirtualKeyboard.style.border = "none"\n    @inputDOMElementForVirtualKeyboard.style.outline = "none"\n    @inputDOMElementForVirtualKeyboard.style.position = "absolute"\n    @inputDOMElementForVirtualKeyboard.style.top = "0px"\n    @inputDOMElementForVirtualKeyboard.style.left = "0px"\n    @inputDOMElementForVirtualKeyboard.style.width = "0px"\n    @inputDOMElementForVirtualKeyboard.style.height = "0px"\n    @inputDOMElementForVirtualKeyboard.autocapitalize = "none" # iOS specific\n    document.body.appendChild @inputDOMElementForVirtualKeyboard\n\n    @inputDOMElementForVirtualKeyboardKeydownEventListener = (event) =>\n\n      @keyboardEventsReceiver.processKeyDown event  if @keyboardEventsReceiver\n\n      # Default in several browsers\n      # is for the backspace button to trigger\n      # the "back button", so we prevent that\n      # default here.\n      if event.keyIdentifier is "U+0008" or event.keyIdentifier is "Backspace"\n        event.preventDefault()  \n\n      # suppress tab override and make sure tab gets\n      # received by all browsers\n      if event.keyIdentifier is "U+0009" or event.keyIdentifier is "Tab"\n        @keyboardEventsReceiver.processKeyPress event  if @keyboardEventsReceiver\n        event.preventDefault()\n\n    @inputDOMElementForVirtualKeyboard.addEventListener "keydown",\n      @inputDOMElementForVirtualKeyboardKeydownEventListener, false\n\n    @inputDOMElementForVirtualKeyboardKeyupEventListener = (event) =>\n      # dispatch to keyboard receiver\n      if @keyboardEventsReceiver\n        # so far the caret is the only keyboard\n        # event handler and it has no keyup\n        # handler\n        if @keyboardEventsReceiver.processKeyUp\n          @keyboardEventsReceiver.processKeyUp event  \n      event.preventDefault()\n\n    @inputDOMElementForVirtualKeyboard.addEventListener "keyup",\n      @inputDOMElementForVirtualKeyboardKeyupEventListener, false\n\n    @inputDOMElementForVirtualKeyboardKeypressEventListener = (event) =>\n      @keyboardEventsReceiver.processKeyPress event  if @keyboardEventsReceiver\n      event.preventDefault()\n\n    @inputDOMElementForVirtualKeyboard.addEventListener "keypress",\n      @inputDOMElementForVirtualKeyboardKeypressEventListener, false\n\n  processMouseDown: (button, ctrlKey) ->\n    # the recording of the test command (in case we are\n    # recording a test) is handled inside the function\n    # here below.\n    # This is different from the other methods similar\n    # to this one but there is a little bit of\n    # logic we apply in case there is a right-click,\n    # or user left or right-clicks on a menu,\n    # in which case we record a more specific test\n    # commands.\n\n    # we might eliminate this command afterwards if\n    # we find out user is clicking on a menu item\n    # or right-clicking on a morph\n    @systemTestsRecorderAndPlayer.addMouseDownCommand(button, ctrlKey)\n\n    @hand.processMouseDown button, ctrlKey\n\n  processMouseUp: (button) ->\n    # event.preventDefault()\n\n    # we might eliminate this command afterwards if\n    # we find out user is clicking on a menu item\n    # or right-clicking on a morph\n    @systemTestsRecorderAndPlayer.addMouseUpCommand()\n\n    @hand.processMouseUp button\n\n  processMouseMove: (pageX, pageY) ->\n    @systemTestsRecorderAndPlayer.addMouseMoveCommand(pageX, pageY)\n    @hand.processMouseMove  pageX, pageY\n\n  # event.type must be keypress\n  getChar: (event) ->\n    unless event.which?\n      String.fromCharCode event.keyCode # IE\n    else if event.which isnt 0 and event.charCode isnt 0\n      String.fromCharCode event.which # the rest\n    else\n      null # special key\n\n  processKeydown: (event, scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    @systemTestsRecorderAndPlayer.addKeyDownCommand scanCode, shiftKey, ctrlKey, altKey, metaKey\n    if @keyboardEventsReceiver\n      @keyboardEventsReceiver.processKeyDown scanCode, shiftKey, ctrlKey, altKey, metaKey\n\n    # suppress backspace override\n    if event? and scanCode is 8\n      event.preventDefault()\n\n    # suppress tab override and make sure tab gets\n    # received by all browsers\n    if event? and scanCode is 9\n      if @keyboardEventsReceiver\n        @keyboardEventsReceiver.processKeyPress scanCode, "\t", shiftKey, ctrlKey, altKey, metaKey\n      event.preventDefault()\n\n  processKeyup: (event, scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    @systemTestsRecorderAndPlayer.addKeyUpCommand scanCode, shiftKey, ctrlKey, altKey, metaKey\n    # dispatch to keyboard receiver\n    if @keyboardEventsReceiver\n      # so far the caret is the only keyboard\n      # event handler and it has no keyup\n      # handler\n      if @keyboardEventsReceiver.processKeyUp\n        @keyboardEventsReceiver.processKeyUp scanCode, shiftKey, ctrlKey, altKey, metaKey    \n    if event?\n      event.preventDefault()\n\n  processKeypress: (event, charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) ->\n    @systemTestsRecorderAndPlayer.addKeyPressCommand charCode, symbol, shiftKey, ctrlKey, altKey, metaKey\n    # This if block adapted from:\n    # http://stackoverflow.com/a/16033129\n    # it rejects the\n    # characters from the special\n    # test-command-triggering external\n    # keypad. Also there is a "00" key\n    # in such keypads which is implemented\n    # buy just a double-press of the zero.\n    # We manage that case - if that key is\n    # pressed twice we understand that it\'s\n    # that particular key. Managing this\n    # special case within Zombie Kernel\n    # is not best, but there aren\'t any\n    # good alternatives.\n    if event?\n      # don\'t manage external keypad if we are playing back\n      # the tests (i.e. when event is null)\n      if symbol == @constructor.KEYPAD_0_mappedToThaiKeyboard_Q\n        unless @doublePressOfZeroKeypadKey?\n          @doublePressOfZeroKeypadKey = 1\n          setTimeout (=>\n            if @doublePressOfZeroKeypadKey is 1\n              console.log "single keypress"\n            @doublePressOfZeroKeypadKey = null\n            event.keyCode = 0\n            return false\n          ), 300\n        else\n          @doublePressOfZeroKeypadKey = null\n          console.log "double keypress"\n          event.keyCode = 0\n        return false\n\n    if @keyboardEventsReceiver\n      @keyboardEventsReceiver.processKeyPress charCode, symbol, shiftKey, ctrlKey, altKey, metaKey\n    if event?\n      event.preventDefault()\n\n  processCopy: (event) ->\n    @systemTestsRecorderAndPlayer.addCopyCommand\n    console.log "processing copy"\n    if @caret\n      selectedText = @caret.target.selection()\n      if event.clipboardData\n        event.preventDefault()\n        setStatus = event.clipboardData.setData("text/plain", selectedText)\n\n      if window.clipboardData\n        event.returnValue = false\n        setStatus = window.clipboardData.setData "Text", selectedText\n\n  processPaste: (event, text) ->\n    if @caret\n      if event?\n        if event.clipboardData\n          # Look for access to data if types array is missing\n          text = event.clipboardData.getData("text/plain")\n          #url = event.clipboardData.getData("text/uri-list")\n          #html = event.clipboardData.getData("text/html")\n          #custom = event.clipboardData.getData("text/xcustom")\n        # IE event is attached to the window object\n        if window.clipboardData\n          # The schema is fixed\n          text = window.clipboardData.getData("Text")\n          #url = window.clipboardData.getData("URL")\n      \n      # Needs a few msec to execute paste\n      console.log "about to insert text: " + text\n      @systemTestsRecorderAndPlayer.addPasteCommand text\n      window.setTimeout ( => (@caret.insert text)), 50, true\n\n\n  initEventListeners: ->\n    canvas = @worldCanvas\n\n    @dblclickEventListener = (event) =>\n      event.preventDefault()\n      @hand.processDoubleClick event\n    canvas.addEventListener "dblclick", @dblclickEventListener, false\n\n    @mousedownEventListener = (event) =>\n      @processMouseDown event.button, event.ctrlKey\n    canvas.addEventListener "mousedown", @mousedownEventListener, false\n\n    @touchstartEventListener = (event) =>\n      @hand.processTouchStart event\n    canvas.addEventListener "touchstart", @touchstartEventListener , false\n    \n    @mouseupEventListener = (event) =>\n      @processMouseUp event.button\n    canvas.addEventListener "mouseup", @mouseupEventListener, false\n    \n    @touchendEventListener = (event) =>\n      @hand.processTouchEnd event\n    canvas.addEventListener "touchend", @touchendEventListener, false\n    \n    @mousemoveEventListener = (event) =>\n      @processMouseMove  event.pageX, event.pageY\n    canvas.addEventListener "mousemove", @mousemoveEventListener, false\n    \n    @touchmoveEventListener = (event) =>\n      @hand.processTouchMove event\n    canvas.addEventListener "touchmove", @touchmoveEventListener, false\n    \n    @gesturestartEventListener = (event) =>\n      # Disable browser zoom\n      event.preventDefault()\n    canvas.addEventListener "gesturestart", @gesturestartEventListener, false\n    \n    @gesturechangeEventListener = (event) =>\n      # Disable browser zoom\n      event.preventDefault()\n    canvas.addEventListener "gesturechange", @gesturechangeEventListener, false\n    \n    @contextmenuEventListener = (event) ->\n      # suppress context menu for Mac-Firefox\n      event.preventDefault()\n    canvas.addEventListener "contextmenu", @contextmenuEventListener, false\n    \n    @keydownEventListener = (event) =>\n      @processKeydown event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey\n    canvas.addEventListener "keydown", @keydownEventListener, false\n\n    @keyupEventListener = (event) =>\n      @processKeyup event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey\n    canvas.addEventListener "keyup", @keyupEventListener, false\n\n    # This method also handles keypresses from a special\n    # external keypad which is used to\n    # record tests commands (such as capture screen, etc.).\n    # These external keypads are inexpensive\n    # so they are a good device for this kind\n    # of stuff.\n    # http://www.amazon.co.uk/Perixx-PERIPAD-201PLUS-Numeric-Keypad-Laptop/dp/B001R6FZLU/\n    # They keypad is mapped\n    # to Thai keyboard characters via an OSX app\n    # called keyremap4macbook (also one needs to add the\n    # Thai keyboard, which is just a click from System Preferences)\n    # Those Thai characters are used to trigger test\n    # commands. The only added complexity is about\n    # the "00" key of such keypads - see\n    # note below.\n    doublePressOfZeroKeypadKey: null\n    \n    @keypressEventListener = (event) =>\n      @processKeypress event, event.keyCode, @getChar(event), event.shiftKey, event.ctrlKey, event.altKey, event.metaKey\n    canvas.addEventListener "keypress", @keypressEventListener, false\n\n    # Safari, Chrome\n    \n    @mousewheelEventListener = (event) =>\n      @hand.processMouseScroll event\n      event.preventDefault()\n    canvas.addEventListener "mousewheel", @mousewheelEventListener, false\n    # Firefox\n    \n    @DOMMouseScrollEventListener = (event) =>\n      @hand.processMouseScroll event\n      event.preventDefault()\n    canvas.addEventListener "DOMMouseScroll", @DOMMouseScrollEventListener, false\n\n    # in theory there should be no scroll event on the page\n    # window.addEventListener "scroll", ((event) =>\n    #  nop # nothing to do, I just need this to set an interrupt point.\n    # ), false\n\n    # snippets of clipboard-handling code taken from\n    # http://codebits.glennjones.net/editing/setclipboarddata.htm\n    # Note that this works only in Chrome. Firefox and Safari need a piece of\n    # text to be selected in order to even trigger the copy event. Chrome does\n    # enable clipboard access instead even if nothing is selected.\n    # There are a couple of solutions to this - one is to keep a hidden textfield that\n    # handles all copy/paste operations.\n    # Another one is to not use a clipboard, but rather an internal string as\n    # local memory. So the OS clipboard wouldn\'t be used, but at least there would\n    # be some copy/paste working. Also one would need to intercept the copy/paste\n    # key combinations manually instead of from the copy/paste events.\n    \n    @copyEventListener = (event) =>\n      @processCopy event\n    document.body.addEventListener "copy", @copyEventListener, false\n\n    @pasteEventListener = (event) =>\n      @processPaste event\n    document.body.addEventListener "paste", @pasteEventListener, false\n\n    #console.log "binding via mousetrap"\n\n    @keyComboResetWorldEventListener = (event) =>\n      @systemTestsRecorderAndPlayer.resetWorld()\n      false\n    Mousetrap.bind ["alt+d"], @keyComboResetWorldEventListener\n\n    @keyComboTurnOnAnimationsPacingControl = (event) =>\n      @systemTestsRecorderAndPlayer.turnOnAnimationsPacingControl()\n      false\n    Mousetrap.bind ["alt+e"], @keyComboTurnOnAnimationsPacingControl\n\n    @keyComboTurnOffAnimationsPacingControl = (event) =>\n      @systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl()\n      false\n    Mousetrap.bind ["alt+u"], @keyComboTurnOffAnimationsPacingControl\n\n    @keyComboTakeScreenshotEventListener = (event) =>\n      @systemTestsRecorderAndPlayer.takeScreenshot()\n      false\n    Mousetrap.bind ["alt+c"], @keyComboTakeScreenshotEventListener\n\n    @keyComboStopTestRecordingEventListener = (event) =>\n      @systemTestsRecorderAndPlayer.stopTestRecording()\n      false\n    Mousetrap.bind ["alt+t"], @keyComboStopTestRecordingEventListener\n\n    @keyComboAddTestCommentEventListener = (event) =>\n      @systemTestsRecorderAndPlayer.addTestComment()\n      false\n    Mousetrap.bind ["alt+m"], @keyComboAddTestCommentEventListener\n\n    @keyComboCheckNumberOfMenuItemsEventListener = (event) =>\n      @systemTestsRecorderAndPlayer.checkNumberOfItemsInMenu()\n      false\n    Mousetrap.bind ["alt+k"], @keyComboCheckNumberOfMenuItemsEventListener\n\n    @keyComboCheckStringsOfItemsInMenuOrderImportant = (event) =>\n      @systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderImportant()\n      false\n    Mousetrap.bind ["alt+a"], @keyComboCheckStringsOfItemsInMenuOrderImportant\n\n    @keyComboCheckStringsOfItemsInMenuOrderUnimportant = (event) =>\n      @systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderUnimportant()\n      false\n    Mousetrap.bind ["alt+z"], @keyComboCheckStringsOfItemsInMenuOrderUnimportant\n\n    @dragoverEventListener = (event) ->\n      event.preventDefault()\n    window.addEventListener "dragover", @dragoverEventListener, false\n    \n    @dropEventListener = (event) =>\n      @hand.processDrop event\n      event.preventDefault()\n    window.addEventListener "drop", @dropEventListener, false\n    \n    @resizeEventListener = =>\n      @stretchWorldToFillEntirePage()  if @automaticallyAdjustToFillEntireBrowserAlsoOnResize\n    window.addEventListener "resize", @resizeEventListener, false\n    \n    window.onbeforeunload = (evt) ->\n      e = evt or window.event\n      msg = "Are you sure you want to leave?"\n      #\n      # For IE and Firefox\n      e.returnValue = msg  if e\n      #\n      # For Safari / chrome\n      msg\n  \n  removeEventListeners: ->\n    canvas = @worldCanvas\n    canvas.removeEventListener \'dblclick\', @dblclickEventListener\n    canvas.removeEventListener \'mousedown\', @mousedownEventListener\n    canvas.removeEventListener \'touchstart\', @touchstartEventListener\n    canvas.removeEventListener \'mouseup\', @mouseupEventListener\n    canvas.removeEventListener \'touchend\', @touchendEventListener\n    canvas.removeEventListener \'mousemove\', @mousemoveEventListener\n    canvas.removeEventListener \'touchmove\', @touchmoveEventListener\n    canvas.removeEventListener \'gesturestart\', @gesturestartEventListener\n    canvas.removeEventListener \'gesturechange\', @gesturechangeEventListener\n    canvas.removeEventListener \'contextmenu\', @contextmenuEventListener\n    canvas.removeEventListener \'keydown\', @keydownEventListener\n    canvas.removeEventListener \'keyup\', @keyupEventListener\n    canvas.removeEventListener \'keypress\', @keypressEventListener\n    canvas.removeEventListener \'mousewheel\', @mousewheelEventListener\n    canvas.removeEventListener \'DOMMouseScroll\', @DOMMouseScrollEventListener\n    canvas.removeEventListener \'copy\', @copyEventListener\n    canvas.removeEventListener \'paste\', @pasteEventListener\n    Mousetrap.reset()\n    canvas.removeEventListener \'dragover\', @dragoverEventListener\n    canvas.removeEventListener \'drop\', @dropEventListener\n    canvas.removeEventListener \'resize\', @resizeEventListener\n  \n  mouseDownLeft: ->\n    noOperation\n  \n  mouseClickLeft: ->\n    noOperation\n  \n  mouseDownRight: ->\n    noOperation\n  \n  mouseClickRight: ->\n    noOperation\n  \n  wantsDropOf: ->\n    # allow handle drops if any drops are allowed\n    @acceptsDrops\n  \n  droppedImage: ->\n    null\n\n  droppedSVG: ->\n    null  \n\n  # WorldMorph text field tabbing:\n  nextTab: (editField) ->\n    next = @nextEntryField(editField)\n    if next\n      editField.clearSelection()\n      next.selectAll()\n      next.edit()\n  \n  previousTab: (editField) ->\n    prev = @previousEntryField(editField)\n    if prev\n      editField.clearSelection()\n      prev.selectAll()\n      prev.edit()\n\n  resetWorld: ->\n    @destroyAll()\n    # some tests might change the background\n    # color of the world so let\'s reset it.\n    @setColor(new Color(205, 205, 205))\n  \n  # There is something special that the\n  # "world" version of destroyAll does:\n  # it resets the counter used to count\n  # how many morphs exist of each Morph class.\n  # That counter is also used to determine the\n  # unique ID of a Morph. So, destroying\n  # all morphs from the world causes the\n  # counts and IDs of all the subsequent\n  # morphs to start from scratch again.\n  destroyAll: ->\n    # Check which objects end with the word Morph\n    theWordMorph = "Morph"\n    ListOfMorphs = (Object.keys(window)).filter (i) ->\n      i.indexOf(theWordMorph, i.length - theWordMorph.length) isnt -1\n    for eachMorphClass in ListOfMorphs\n      if eachMorphClass != "WorldMorph"\n        console.log "resetting " + eachMorphClass + " from " + window[eachMorphClass].instancesCounter\n        # the actual count is in another variable "instancesCounter"\n        # but all labels are built using instanceNumericID\n        # which is set based on lastBuiltInstanceNumericID\n        window[eachMorphClass].lastBuiltInstanceNumericID = 0\n\n    window.world.systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl()\n    window.world.systemTestsRecorderAndPlayer.turnOffAlignmentOfMorphIDsMechanism()\n    window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsGeometryInfoInLabels()\n    window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsContentExtractInLabels()\n    window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsNumberIDInLabels()\n\n    super()\n\n\n  # WorldMorph menu:\n  unfocusMenu: (menuToBeUnfocuses) ->\n    # there might be another menu\n    # being spawned already has a\n    # menu entry was selected so\n    # let\'s check before setting\n    # that there is no active menu\n    if @activeMenu == menuToBeUnfocuses\n      @activeMenu = null\n\n\n  contextMenu: ->\n    if @isDevMode\n      menu = new MenuMorph(\n        @, @constructor.name or @constructor.toString().split(" ")[1].split("(")[0])\n    else\n      menu = new MenuMorph(@, "Morphic")\n    if @isDevMode\n      menu.addItem "demo...", (->@popUpDemoMenu()), "sample morphs"\n      menu.addLine()\n      menu.addItem "show all", (->@showAllMinimised())\n      menu.addItem "hide all", (->@minimiseAll())\n      menu.addItem "delete all", (->@destroyAll())\n      menu.addItem "move all inside", (->@keepAllSubmorphsWithin()), "keep all submorphs\nwithin and visible"\n      menu.addItem "inspect", (->@inspect()), "open a window on\nall properties"\n      menu.addLine()\n      menu.addItem "restore display", (->@changed()), "redraw the\nscreen once"\n      menu.addItem "fit whole page", (->@stretchWorldToFillEntirePage()), "let the World automatically\nadjust to browser resizings"\n      menu.addItem "color...", (->\n        @pickColor menu.title + "\ncolor:", @setColor, @color\n      ), "choose the World\'s\nbackground color"\n      if WorldMorph.preferencesAndSettings.inputMode is PreferencesAndSettings.INPUT_MODE_MOUSE\n        menu.addItem "touch screen settings", (->WorldMorph.preferencesAndSettings.toggleInputMode()), "bigger menu fonts\nand sliders"\n      else\n        menu.addItem "standard settings", (->WorldMorph.preferencesAndSettings.toggleInputMode()), "smaller menu fonts\nand sliders"\n      menu.addLine()\n    \n    if window.location.href.indexOf("worldWithSystemTestHarness") != -1\n      menu.addItem "system tests...",  (->@popUpSystemTestsMenu()), ""\n    if @isDevMode\n      menu.addItem "switch to user mode", (->@toggleDevMode()), "disable developers\'\ncontext menus"\n    else\n      menu.addItem "switch to dev mode", (->@toggleDevMode())\n    menu.addItem "about Zombie Kernel...", (->@about())\n    menu\n\n  popUpSystemTestsMenu: ->\n    create = (aMorph) =>\n      aMorph.isDraggable = true\n      aMorph.pickUp()\n    menu = new MenuMorph(@, "system tests")\n\n    menu.addItem "run system tests",  (->@systemTestsRecorderAndPlayer.runAllSystemTests()), "runs all the system tests"\n    menu.addItem "start test recording",  (->@systemTestsRecorderAndPlayer.startTestRecording()), "start recording a test"\n    menu.addItem "stop test recording",  (->@systemTestsRecorderAndPlayer.stopTestRecording()), "stop recording the test"\n    menu.addItem "(re)play recorded test",  (->@systemTestsRecorderAndPlayer.startTestPlaying()), "start playing the test"\n    menu.addItem "show test source",  (->@systemTestsRecorderAndPlayer.showTestSource()), "opens a window with the source of the latest test"\n    menu.addItem "save recorded test",  (->@systemTestsRecorderAndPlayer.saveTest()), "save the recorded test"\n    menu.addItem "save failed screenshots test",  (->@systemTestsRecorderAndPlayer.saveFailedScreenshots()), "save failed screenshots test"\n\n    menu.popUpAtHand()\n\n  popUpDemoMenu: ->\n    create = (aMorph) =>\n      aMorph.isDraggable = true\n      aMorph.pickUp()\n    menu = new MenuMorph(@, "make a morph")\n    menu.addItem "rectangle", ->\n      create new RectangleMorph()\n    \n    menu.addItem "box", ->\n      create new BoxMorph()\n    \n    menu.addItem "circle box", ->\n      create new CircleBoxMorph()\n    \n    menu.addLine()\n    menu.addItem "slider", ->\n      create new SliderMorph()\n    \n    menu.addItem "frame", ->\n      newMorph = new FrameMorph()\n      newMorph.setExtent new Point(350, 250)\n      create newMorph\n    \n    menu.addItem "scroll frame", ->\n      newMorph = new ScrollFrameMorph()\n      newMorph.contents.acceptsDrops = true\n      newMorph.contents.adjustBounds()\n      newMorph.setExtent new Point(350, 250)\n      create newMorph\n    \n    menu.addItem "handle", ->\n      create new HandleMorph()\n    \n    menu.addLine()\n    menu.addItem "string", ->\n      newMorph = new StringMorph("Hello, World!")\n      newMorph.isEditable = true\n      create newMorph\n    \n    # this is "The Lorelei" poem (From German).\n    # see translation here:\n    # http://poemsintranslation.blogspot.co.uk/2009/11/heinrich-heine-lorelei-from-german.html\n    menu.addItem "text", ->\n      newMorph = new TextMorph("Ich weiß nicht, was soll es bedeuten, dass ich so " +\n        "traurig bin, ein Märchen aus uralten Zeiten, das " +\n        "kommt mir nicht aus dem Sinn. Die Luft ist kühl " +\n        "und es dunkelt, und ruhig fließt der Rhein; der " +\n        "Gipfel des Berges funkelt im Abendsonnenschein. " +\n        "Die schönste Jungfrau sitzet dort oben wunderbar, " +\n        "ihr gold\'nes Geschmeide blitzet, sie kämmt ihr " +\n        "goldenes Haar, sie kämmt es mit goldenem Kamme, " +\n        "und singt ein Lied dabei; das hat eine wundersame, " +\n        "gewalt\'ge Melodei. Den Schiffer im kleinen " +\n        "Schiffe, ergreift es mit wildem Weh; er schaut " +\n        "nicht die Felsenriffe, er schaut nur hinauf in " +\n        "die Höh\'. Ich glaube, die Wellen verschlingen " +\n        "am Ende Schiffer und Kahn, und das hat mit ihrem " +\n        "Singen, die Loreley getan.")\n      newMorph.isEditable = true\n      newMorph.maxWidth = 300\n      create newMorph\n    \n    menu.addItem "speech bubble", ->\n      newMorph = new SpeechBubbleMorph("Hello, World!")\n      create newMorph\n    \n    menu.addLine()\n    menu.addItem "gray scale palette", ->\n      create new GrayPaletteMorph()\n    \n    menu.addItem "color palette", ->\n      create new ColorPaletteMorph()\n    \n    menu.addItem "color picker", ->\n      create new ColorPickerMorph()\n    \n    menu.addLine()\n    menu.addItem "sensor demo", ->\n      newMorph = new MouseSensorMorph()\n      newMorph.setColor new Color(230, 200, 100)\n      newMorph.edge = 35\n      newMorph.border = 15\n      newMorph.borderColor = new Color(200, 100, 50)\n      newMorph.alpha = 0.2\n      newMorph.setExtent new Point(100, 100)\n      create newMorph\n    \n    menu.addItem "animation demo", ->\n      foo = new BouncerMorph()\n      foo.setPosition new Point(50, 20)\n      foo.setExtent new Point(300, 200)\n      foo.alpha = 0.9\n      foo.speed = 3\n      bar = new BouncerMorph()\n      bar.setColor new Color(50, 50, 50)\n      bar.setPosition new Point(80, 80)\n      bar.setExtent new Point(80, 250)\n      bar.type = "horizontal"\n      bar.direction = "right"\n      bar.alpha = 0.9\n      bar.speed = 5\n      baz = new BouncerMorph()\n      baz.setColor new Color(20, 20, 20)\n      baz.setPosition new Point(90, 140)\n      baz.setExtent new Point(40, 30)\n      baz.type = "horizontal"\n      baz.direction = "right"\n      baz.speed = 3\n      garply = new BouncerMorph()\n      garply.setColor new Color(200, 20, 20)\n      garply.setPosition new Point(90, 140)\n      garply.setExtent new Point(20, 20)\n      garply.type = "vertical"\n      garply.direction = "up"\n      garply.speed = 8\n      fred = new BouncerMorph()\n      fred.setColor new Color(20, 200, 20)\n      fred.setPosition new Point(120, 140)\n      fred.setExtent new Point(20, 20)\n      fred.type = "vertical"\n      fred.direction = "down"\n      fred.speed = 4\n      bar.add garply\n      bar.add baz\n      foo.add fred\n      foo.add bar\n      create foo\n    \n    menu.addItem "pen", ->\n      create new PenMorph()\n    menu.addLine()\n    menu.addItem "Layout tests", (->@layoutTestsMenu()), "sample morphs"\n    menu.addLine()\n    menu.addItem "view all...", ->\n      newMorph = new MorphsListMorph()\n      create newMorph\n    menu.addItem "closing window", ->\n      newMorph = new WorkspaceMorph()\n      create newMorph\n\n    if @customMorphs\n      menu.addLine()\n      @customMorphs().forEach (morph) ->\n        menu.addItem morph.toString(), ->\n          create morph\n    \n    menu.popUpAtHand()\n\n  layoutTestsMenu: ->\n    create = (aMorph) =>\n      aMorph.isDraggable = true\n      aMorph.pickUp()\n    menu = new MenuMorph(@, "Layout tests")\n    menu.addItem "test1", ->\n      LayoutMorph.test1()\n    menu.addItem "test2", ->\n      LayoutMorph.test2()\n    menu.addItem "test3", ->\n      LayoutMorph.test3()\n    menu.addItem "test4", ->\n      LayoutMorph.test4()\n    menu.popUpAtHand()\n    \n  \n  toggleDevMode: ->\n    @isDevMode = not @isDevMode\n  \n  minimiseAll: ->\n    @children.forEach (child) ->\n      child.minimise()\n  \n  showAllMinimised: ->\n    @forAllChildrenBottomToTop (child) ->\n      child.unminimise() if child.isMinimised\n  \n  about: ->\n    @inform "Zombie Kernel\n\n" +\n      "a lively Web GUI\ninspired by Squeak\n" +\n      morphicVersion +\n      "\n\nby Davide Della Casa" +\n      "\n\nbased on morphic.js by" +\n      "\nJens Mönig (jens@moenig.org)"\n  \n  edit: (aStringMorphOrTextMorph) ->\n    # first off, if the Morph is not editable\n    # then there is nothing to do\n    # return null  unless aStringMorphOrTextMorph.isEditable\n\n    # there is only one caret in the World, so destroy\n    # the previous one if there was one.\n    if @caret\n      # empty the previously ongoing selection\n      # if there was one.\n      @lastEditedText = @caret.target\n      @lastEditedText.clearSelection()  if @lastEditedText\n      @caret = @caret.destroy()\n\n    # create the new Caret\n    @caret = new CaretMorph(aStringMorphOrTextMorph)\n    aStringMorphOrTextMorph.parent.add @caret\n    # this is the only place where the @keyboardEventsReceiver is set\n    @keyboardEventsReceiver = @caret\n\n    if WorldMorph.preferencesAndSettings.isTouchDevice and WorldMorph.preferencesAndSettings.useVirtualKeyboard\n      @initVirtualKeyboard()\n      # For touch devices, giving focus on the textbox causes\n      # the keyboard to slide up, and since the page viewport\n      # shrinks, the page is scrolled to where the texbox is.\n      # So, it is important to position the textbox around\n      # where the caret is, so that the changed text is going to\n      # be visible rather than out of the viewport.\n      pos = getDocumentPositionOf(@worldCanvas)\n      @inputDOMElementForVirtualKeyboard.style.top = @caret.top() + pos.y + "px"\n      @inputDOMElementForVirtualKeyboard.style.left = @caret.left() + pos.x + "px"\n      @inputDOMElementForVirtualKeyboard.focus()\n    if WorldMorph.preferencesAndSettings.useSliderForInput\n      if !aStringMorphOrTextMorph.parentThatIsA(MenuMorph)\n        @slide aStringMorphOrTextMorph\n  \n  # Editing can stop because of three reasons:\n  #   cancel (user hits ESC)\n  #   accept (on stringmorph, user hits enter)\n  #   user clicks/drags another morph\n  stopEditing: ->\n    if @caret\n      @lastEditedText = @caret.target\n      @lastEditedText.clearSelection()\n      @lastEditedText.escalateEvent "reactToEdit", @lastEditedText\n      @caret = @caret.destroy()\n    # the only place where the @keyboardEventsReceiver is unset\n    # (and the hidden input is removed)\n    @keyboardEventsReceiver = null\n    if @inputDOMElementForVirtualKeyboard\n      @inputDOMElementForVirtualKeyboard.blur()\n      document.body.removeChild @inputDOMElementForVirtualKeyboard\n      @inputDOMElementForVirtualKeyboard = null\n    @worldCanvas.focus()\n  \n  slide: (aStringMorphOrTextMorph) ->\n    # display a slider for numeric text entries\n    val = parseFloat(aStringMorphOrTextMorph.text)\n    val = 0  if isNaN(val)\n    menu = new MenuMorph()\n    slider = new SliderMorph(val - 25, val + 25, val, 10, "horizontal")\n    slider.alpha = 1\n    slider.color = new Color(225, 225, 225)\n    slider.button.color = menu.borderColor\n    slider.button.highlightColor = slider.button.color.copy()\n    slider.button.highlightColor.b += 100\n    slider.button.pressColor = slider.button.color.copy()\n    slider.button.pressColor.b += 150\n    slider.silentSetHeight WorldMorph.preferencesAndSettings.scrollBarSize\n    slider.silentSetWidth WorldMorph.preferencesAndSettings.menuFontSize * 10\n    slider.updateRendering()\n    slider.action = (num) ->\n      aStringMorphOrTextMorph.changed()\n      aStringMorphOrTextMorph.text = Math.round(num).toString()\n      aStringMorphOrTextMorph.updateRendering()\n      aStringMorphOrTextMorph.changed()\n      aStringMorphOrTextMorph.escalateEvent(\n          \'reactToSliderEdit\',\n          aStringMorphOrTextMorph\n      )\n    #\n    menu.items.push slider\n    menu.popup @, aStringMorphOrTextMorph.bottomLeft().add(new Point(0, 5))\n  \n  ';

  return WorldMorph;

})(FrameMorph);

StringMorph = (function(_super) {
  __extends(StringMorph, _super);

  StringMorph.prototype.text = null;

  StringMorph.prototype.fontSize = null;

  StringMorph.prototype.fontName = null;

  StringMorph.prototype.fontStyle = null;

  StringMorph.prototype.isBold = null;

  StringMorph.prototype.isItalic = null;

  StringMorph.prototype.isEditable = false;

  StringMorph.prototype.isNumeric = null;

  StringMorph.prototype.isPassword = false;

  StringMorph.prototype.shadowOffset = null;

  StringMorph.prototype.shadowColor = null;

  StringMorph.prototype.isShowingBlanks = false;

  StringMorph.prototype.blanksColor = new Color(180, 140, 140);

  StringMorph.prototype.isScrollable = true;

  StringMorph.prototype.currentlySelecting = false;

  StringMorph.prototype.startMark = null;

  StringMorph.prototype.endMark = null;

  StringMorph.prototype.markedTextColor = new Color(255, 255, 255);

  StringMorph.prototype.markedBackgoundColor = new Color(60, 60, 120);

  function StringMorph(text, fontSize, fontStyle, isBold, isItalic, isNumeric, shadowOffset, shadowColor, color, fontName) {
    this.fontSize = fontSize != null ? fontSize : 12;
    this.fontStyle = fontStyle != null ? fontStyle : "sans-serif";
    this.isBold = isBold != null ? isBold : false;
    this.isItalic = isItalic != null ? isItalic : false;
    this.isNumeric = isNumeric != null ? isNumeric : false;
    this.shadowColor = shadowColor;
    this.text = text || (text === "" ? "" : "StringMorph");
    this.fontName = fontName || WorldMorph.preferencesAndSettings.globalFontFamily;
    this.shadowOffset = shadowOffset || new Point(0, 0);
    StringMorph.__super__.constructor.call(this);
    this.color = color || new Color(0, 0, 0);
    this.noticesTransparentClick = true;
  }

  StringMorph.prototype.toString = function() {
    var firstPart;
    firstPart = StringMorph.__super__.toString.call(this);
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.IDLE && SystemTestsRecorderAndPlayer.hidingOfMorphsContentExtractInLabels) {
      return firstPart;
    } else {
      return firstPart + " (\"" + this.text.slice(0, 30) + "...\")";
    }
  };

  StringMorph.prototype.password = function(letter, length) {
    var ans, _i;
    ans = "";
    for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
      ans += letter;
    }
    return ans;
  };

  StringMorph.prototype.font = function() {
    var font;
    font = "";
    if (this.isBold) {
      font = font + "bold ";
    }
    if (this.isItalic) {
      font = font + "italic ";
    }
    return font + this.fontSize + "px " + (this.fontName ? this.fontName + ", " : "") + this.fontStyle;
  };

  StringMorph.prototype.updateRendering = function() {
    var c, context, p, start, stop, text, width, x, y, _i, _results;
    text = (this.isPassword ? this.password("*", this.text.length) : this.text);
    this.image = newCanvas();
    context = this.image.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    context.font = this.font();
    context.textAlign = "left";
    context.textBaseline = "bottom";
    width = Math.max(context.measureText(text).width + Math.abs(this.shadowOffset.x), 1);
    this.bounds.corner = this.bounds.origin.add(new Point(width, fontHeight(this.fontSize) + Math.abs(this.shadowOffset.y)));
    this.image.width = width * pixelRatio;
    this.image.height = this.height() * pixelRatio;
    context.scale(pixelRatio, pixelRatio);
    context.font = this.font();
    context.textAlign = "left";
    context.textBaseline = "bottom";
    if (this.shadowColor) {
      x = Math.max(this.shadowOffset.x, 0);
      y = Math.max(this.shadowOffset.y, 0);
      context.fillStyle = this.shadowColor.toString();
      context.fillText(text, x, fontHeight(this.fontSize) + y);
    }
    x = Math.abs(Math.min(this.shadowOffset.x, 0));
    y = Math.abs(Math.min(this.shadowOffset.y, 0));
    context.fillStyle = this.color.toString();
    if (this.isShowingBlanks) {
      this.renderWithBlanks(context, x, fontHeight(this.fontSize) + y);
    } else {
      context.fillText(text, x, fontHeight(this.fontSize) + y);
    }
    start = Math.min(this.startMark, this.endMark);
    stop = Math.max(this.startMark, this.endMark);
    _results = [];
    for (i = _i = start; start <= stop ? _i < stop : _i > stop; i = start <= stop ? ++_i : --_i) {
      p = this.slotCoordinates(i).subtract(this.position());
      c = text.charAt(i);
      context.fillStyle = this.markedBackgoundColor.toString();
      context.fillRect(p.x, p.y, context.measureText(c).width + 1 + x, fontHeight(this.fontSize) + y);
      context.fillStyle = this.markedTextColor.toString();
      _results.push(context.fillText(c, p.x + x, fontHeight(this.fontSize) + y));
    }
    return _results;
  };

  StringMorph.prototype.renderWithBlanks = function(context, startX, y) {
    var blank, ctx, drawBlank, isFirst, space, words, x;
    drawBlank = function() {
      context.drawImage(blank, Math.round(x), 0);
      return x += space;
    };
    space = context.measureText(" ").width;
    blank = newCanvas(new Point(space, this.height()).scaleBy(pixelRatio));
    ctx = blank.getContext("2d");
    words = this.text.split(" ");
    x = startX || 0;
    isFirst = true;
    ctx.fillStyle = this.blanksColor.toString();
    ctx.arc(space / 2, blank.height / 2, space / 2, radians(0), radians(360));
    ctx.fill();
    return words.forEach(function(word) {
      if (!isFirst) {
        drawBlank();
      }
      isFirst = false;
      if (word !== "") {
        context.fillText(word, x, y);
        return x += context.measureText(word).width;
      }
    });
  };

  StringMorph.prototype.slotCoordinates = function(slot) {
    var context, dest, text, x, xOffset, y;
    text = (this.isPassword ? this.password("*", this.text.length) : this.text);
    dest = Math.min(Math.max(slot, 0), text.length);
    context = this.image.getContext("2d");
    xOffset = context.measureText(text.substring(0, dest)).width;
    this.pos = dest;
    x = this.left() + xOffset;
    y = this.top();
    return new Point(x, y);
  };

  StringMorph.prototype.slotAt = function(aPoint) {
    var charX, context, idx, text;
    text = (this.isPassword ? this.password("*", this.text.length) : this.text);
    idx = 0;
    charX = 0;
    context = this.image.getContext("2d");
    while (aPoint.x - this.left() > charX) {
      charX += context.measureText(text[idx]).width;
      idx += 1;
      if (idx === text.length) {
        if ((context.measureText(text).width - (context.measureText(text[idx - 1]).width / 2)) < (aPoint.x - this.left())) {
          return idx;
        }
      }
    }
    return idx - 1;
  };

  StringMorph.prototype.upFrom = function(slot) {
    return slot;
  };

  StringMorph.prototype.downFrom = function(slot) {
    return slot;
  };

  StringMorph.prototype.startOfLine = function() {
    return 0;
  };

  StringMorph.prototype.endOfLine = function() {
    return this.text.length;
  };

  StringMorph.prototype.rawHeight = function() {
    return this.height() / 1.2;
  };

  StringMorph.prototype.developersMenu = function() {
    var menu;
    menu = StringMorph.__super__.developersMenu.call(this);
    menu.addLine();
    menu.addItem("edit", (function() {
      return this.edit();
    }));
    menu.addItem("font size...", (function() {
      return this.prompt(menu.title + "\nfont\nsize:", this.setFontSize, this.fontSize.toString(), null, 6, 500, true);
    }), "set this String's\nfont point size");
    if (this.fontStyle !== "serif") {
      menu.addItem("serif", (function() {
        return this.setSerif();
      }));
    }
    if (this.fontStyle !== "sans-serif") {
      menu.addItem("sans-serif", (function() {
        return this.setSansSerif();
      }));
    }
    if (this.isBold) {
      menu.addItem("normal weight", (function() {
        return this.toggleWeight();
      }));
    } else {
      menu.addItem("bold", (function() {
        return this.toggleWeight();
      }));
    }
    if (this.isItalic) {
      menu.addItem("normal style", (function() {
        return this.toggleItalic();
      }));
    } else {
      menu.addItem("italic", (function() {
        return this.toggleItalic();
      }));
    }
    if (this.isShowingBlanks) {
      menu.addItem("hide blanks", (function() {
        return this.toggleShowBlanks();
      }));
    } else {
      menu.addItem("show blanks", (function() {
        return this.toggleShowBlanks();
      }));
    }
    if (this.isPassword) {
      menu.addItem("show characters", (function() {
        return this.toggleIsPassword();
      }));
    } else {
      menu.addItem("hide characters", (function() {
        return this.toggleIsPassword();
      }));
    }
    return menu;
  };

  StringMorph.prototype.toggleIsDraggable = function() {
    this.isDraggable = !this.isDraggable;
    if (this.isDraggable) {
      return this.disableSelecting();
    } else {
      return this.enableSelecting();
    }
  };

  StringMorph.prototype.toggleShowBlanks = function() {
    this.isShowingBlanks = !this.isShowingBlanks;
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.toggleWeight = function() {
    this.isBold = !this.isBold;
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.toggleItalic = function() {
    this.isItalic = !this.isItalic;
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.toggleIsPassword = function() {
    this.isPassword = !this.isPassword;
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.setSerif = function() {
    this.fontStyle = "serif";
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.setSansSerif = function() {
    this.fontStyle = "sans-serif";
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.setFontSize = function(sizeOrMorphGivingSize) {
    var newSize, size;
    if (sizeOrMorphGivingSize.getValue != null) {
      size = sizeOrMorphGivingSize.getValue();
    } else {
      size = sizeOrMorphGivingSize;
    }
    if (typeof size === "number") {
      this.fontSize = Math.round(Math.min(Math.max(size, 4), 500));
    } else {
      newSize = parseFloat(size);
      if (!isNaN(newSize)) {
        this.fontSize = Math.round(Math.min(Math.max(newSize, 4), 500));
      }
    }
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.setText = function(size) {
    this.text = Math.round(size).toString();
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.numericalSetters = function() {
    return ["setLeft", "setTop", "setAlphaScaled", "setFontSize", "setText"];
  };

  StringMorph.prototype.edit = function() {
    return this.root().edit(this);
  };

  StringMorph.prototype.editViaMenu = function() {
    return this.root().editViaMenu(this);
  };

  StringMorph.prototype.selection = function() {
    var start, stop;
    start = Math.min(this.startMark, this.endMark);
    stop = Math.max(this.startMark, this.endMark);
    return this.text.slice(start, stop);
  };

  StringMorph.prototype.selectionStartSlot = function() {
    return Math.min(this.startMark, this.endMark);
  };

  StringMorph.prototype.clearSelection = function() {
    this.currentlySelecting = false;
    this.startMark = null;
    this.endMark = null;
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.deleteSelection = function() {
    var start, stop, text;
    text = this.text;
    start = Math.min(this.startMark, this.endMark);
    stop = Math.max(this.startMark, this.endMark);
    this.text = text.slice(0, start) + text.slice(stop);
    this.changed();
    return this.clearSelection();
  };

  StringMorph.prototype.selectAll = function() {
    this.startMark = 0;
    this.endMark = this.text.length;
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.mouseDownLeft = function(pos) {
    if (this.isEditable) {
      return this.clearSelection();
    } else {
      return this.escalateEvent("mouseDownLeft", pos);
    }
  };

  StringMorph.prototype.mouseClickLeft = function(pos) {
    var caret;
    caret = this.root().caret;
    if (this.isEditable) {
      if (!this.currentlySelecting) {
        this.edit();
      }
      if (caret) {
        caret.gotoPos(pos);
      }
      this.root().caret.gotoPos(pos);
      return this.currentlySelecting = true;
    } else {
      return this.escalateEvent("mouseClickLeft", pos);
    }
  };

  StringMorph.prototype.enableSelecting = function() {
    this.mouseDownLeft = function(pos) {
      this.clearSelection();
      if (this.isEditable && (!this.isDraggable)) {
        this.edit();
        this.root().caret.gotoPos(pos);
        this.startMark = this.slotAt(pos);
        this.endMark = this.startMark;
        return this.currentlySelecting = true;
      }
    };
    return this.mouseMove = function(pos) {
      var newMark;
      if (this.isEditable && this.currentlySelecting && (!this.isDraggable)) {
        newMark = this.slotAt(pos);
        if (newMark !== this.endMark) {
          this.endMark = newMark;
          this.updateRendering();
          return this.changed();
        }
      }
    };
  };

  StringMorph.prototype.disableSelecting = function() {
    this.mouseDownLeft = StringMorph.prototype.mouseDownLeft;
    return delete this.mouseMove;
  };

  StringMorph.coffeeScriptSourceOfThisClass = '# StringMorph /////////////////////////////////////////////////////////\n\n# A StringMorph is a single line of text. It can only be left-aligned.\n# REQUIRES WorldMorph\n\nclass StringMorph extends Morph\n\n  text: null\n  fontSize: null\n  fontName: null\n  fontStyle: null\n  isBold: null\n  isItalic: null\n  isEditable: false\n  isNumeric: null\n  isPassword: false\n  shadowOffset: null\n  shadowColor: null\n  isShowingBlanks: false\n  # careful: this Color object is shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  blanksColor: new Color(180, 140, 140)\n  #\n  # Properties for text-editing\n  isScrollable: true\n  currentlySelecting: false\n  startMark: null\n  endMark: null\n  # careful: this Color object is shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  markedTextColor: new Color(255, 255, 255)\n  # careful: this Color object is shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  markedBackgoundColor: new Color(60, 60, 120)\n\n  constructor: (\n      text,\n      @fontSize = 12,\n      @fontStyle = "sans-serif",\n      @isBold = false,\n      @isItalic = false,\n      @isNumeric = false,\n      shadowOffset,\n      @shadowColor,\n      color,\n      fontName\n      ) ->\n    # additional properties:\n    @text = text or ((if (text is "") then "" else "StringMorph"))\n    @fontName = fontName or WorldMorph.preferencesAndSettings.globalFontFamily\n    @shadowOffset = shadowOffset or new Point(0, 0)\n    #\n    super()\n    #\n    # override inherited properites:\n    @color = color or new Color(0, 0, 0)\n    @noticesTransparentClick = true\n  \n  toString: ->\n    # e.g. \'a StringMorph("Hello World")\'\n    firstPart = super()\n    if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.IDLE and SystemTestsRecorderAndPlayer.hidingOfMorphsContentExtractInLabels\n      return firstPart\n    else\n      return firstPart + " (\"" + @text.slice(0, 30) + "...\")"\n  \n  password: (letter, length) ->\n    ans = ""\n    for i in [0...length]\n      ans += letter\n    ans\n\n  font: ->\n    # answer a font string, e.g. \'bold italic 12px sans-serif\'\n    font = ""\n    font = font + "bold "  if @isBold\n    font = font + "italic "  if @isItalic\n    font + @fontSize + "px " + ((if @fontName then @fontName + ", " else "")) + @fontStyle\n  \n  updateRendering: ->\n    text = (if @isPassword then @password("*", @text.length) else @text)\n    # initialize my surface property\n    @image = newCanvas()\n    context = @image.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    context.font = @font()\n    context.textAlign = "left"\n    context.textBaseline = "bottom"\n\n    # set my extent based on the size of the text\n    width = Math.max(context.measureText(text).width + Math.abs(@shadowOffset.x), 1)\n    @bounds.corner = @bounds.origin.add(new Point(\n      width, fontHeight(@fontSize) + Math.abs(@shadowOffset.y)))\n    @image.width = width * pixelRatio\n    @image.height = @height() * pixelRatio\n\n    # changing the canvas size resets many of\n    # the properties of the canvas, so we need to\n    # re-initialise the font and alignments here\n    context.scale pixelRatio, pixelRatio\n    context.font = @font()\n    context.textAlign = "left"\n    context.textBaseline = "bottom"\n\n    # first draw the shadow, if any\n    if @shadowColor\n      x = Math.max(@shadowOffset.x, 0)\n      y = Math.max(@shadowOffset.y, 0)\n      context.fillStyle = @shadowColor.toString()\n      context.fillText text, x, fontHeight(@fontSize) + y\n    #\n    # now draw the actual text\n    x = Math.abs(Math.min(@shadowOffset.x, 0))\n    y = Math.abs(Math.min(@shadowOffset.y, 0))\n    context.fillStyle = @color.toString()\n    if @isShowingBlanks\n      @renderWithBlanks context, x, fontHeight(@fontSize) + y\n    else\n      context.fillText text, x, fontHeight(@fontSize) + y\n    #\n    # draw the selection\n    start = Math.min(@startMark, @endMark)\n    stop = Math.max(@startMark, @endMark)\n    for i in [start...stop]\n      p = @slotCoordinates(i).subtract(@position())\n      c = text.charAt(i)\n      context.fillStyle = @markedBackgoundColor.toString()\n      context.fillRect p.x, p.y, context.measureText(c).width + 1 + x,\n        fontHeight(@fontSize) + y\n      context.fillStyle = @markedTextColor.toString()\n      context.fillText c, p.x + x, fontHeight(@fontSize) + y\n    #\n    # notify my parent of layout change\n    # @parent.layoutSubmorphs()  if @parent.layoutSubmorphs  if @parent\n  \n  renderWithBlanks: (context, startX, y) ->\n    # create the blank form\n    drawBlank = ->\n      context.drawImage blank, Math.round(x), 0\n      x += space\n    space = context.measureText(" ").width\n    blank = newCanvas(new Point(space, @height()).scaleBy pixelRatio)\n    ctx = blank.getContext("2d")\n    words = @text.split(" ")\n    x = startX or 0\n    isFirst = true\n    ctx.fillStyle = @blanksColor.toString()\n    ctx.arc space / 2, blank.height / 2, space / 2, radians(0), radians(360)\n    ctx.fill()\n    #\n    # render my text inserting blanks\n    words.forEach (word) ->\n      drawBlank()  unless isFirst\n      isFirst = false\n      if word isnt ""\n        context.fillText word, x, y\n        x += context.measureText(word).width\n  \n  \n  # StringMorph mesuring:\n  slotCoordinates: (slot) ->\n    # answer the position point of the given index ("slot")\n    # where the caret should be placed\n    text = (if @isPassword then @password("*", @text.length) else @text)\n    dest = Math.min(Math.max(slot, 0), text.length)\n    context = @image.getContext("2d")\n    xOffset = context.measureText(text.substring(0,dest)).width\n    @pos = dest\n    x = @left() + xOffset\n    y = @top()\n    new Point(x, y)\n  \n  slotAt: (aPoint) ->\n    # answer the slot (index) closest to the given point\n    # so the caret can be moved accordingly\n    text = (if @isPassword then @password("*", @text.length) else @text)\n    idx = 0\n    charX = 0\n    context = @image.getContext("2d")\n\n    while aPoint.x - @left() > charX\n      charX += context.measureText(text[idx]).width\n      idx += 1\n      if idx is text.length\n        if (context.measureText(text).width - (context.measureText(text[idx - 1]).width / 2)) < (aPoint.x - @left())  \n          return idx\n    idx - 1\n  \n  upFrom: (slot) ->\n    # answer the slot above the given one\n    slot\n  \n  downFrom: (slot) ->\n    # answer the slot below the given one\n    slot\n  \n  startOfLine: ->\n    # answer the first slot (index) of the line for the given slot\n    0\n  \n  endOfLine: ->\n    # answer the slot (index) indicating the EOL for the given slot\n    @text.length\n\n  rawHeight: ->\n    # answer my corrected fontSize\n    @height() / 1.2\n    \n  # StringMorph menus:\n  developersMenu: ->\n    menu = super()\n    menu.addLine()\n    menu.addItem "edit", (->\n      @edit()\n    )\n    menu.addItem "font size...", (->\n      @prompt menu.title + "\nfont\nsize:",\n        @setFontSize, @fontSize.toString(), null, 6, 500, true\n    ), "set this String\'s\nfont point size"\n    menu.addItem "serif", (->@setSerif())  if @fontStyle isnt "serif"\n    menu.addItem "sans-serif", (->@setSansSerif())  if @fontStyle isnt "sans-serif"\n\n    if @isBold\n      menu.addItem "normal weight", (->@toggleWeight())\n    else\n      menu.addItem "bold", (->@toggleWeight())\n\n    if @isItalic\n      menu.addItem "normal style", (->@toggleItalic())\n    else\n      menu.addItem "italic", (->@toggleItalic())\n\n    if @isShowingBlanks\n      menu.addItem "hide blanks", (->@toggleShowBlanks())\n    else\n      menu.addItem "show blanks", (->@toggleShowBlanks())\n\n    if @isPassword\n      menu.addItem "show characters", (->@toggleIsPassword())\n    else\n      menu.addItem "hide characters", (->@toggleIsPassword())\n\n    menu\n  \n  toggleIsDraggable: ->\n    # for context menu demo purposes\n    @isDraggable = not @isDraggable\n    if @isDraggable\n      @disableSelecting()\n    else\n      @enableSelecting()\n  \n  toggleShowBlanks: ->\n    @isShowingBlanks = not @isShowingBlanks\n    @changed()\n    @updateRendering()\n    @changed()\n  \n  toggleWeight: ->\n    @isBold = not @isBold\n    @changed()\n    @updateRendering()\n    @changed()\n  \n  toggleItalic: ->\n    @isItalic = not @isItalic\n    @changed()\n    @updateRendering()\n    @changed()\n  \n  toggleIsPassword: ->\n    @isPassword = not @isPassword\n    @changed()\n    @updateRendering()\n    @changed()\n  \n  setSerif: ->\n    @fontStyle = "serif"\n    @changed()\n    @updateRendering()\n    @changed()\n  \n  setSansSerif: ->\n    @fontStyle = "sans-serif"\n    @changed()\n    @updateRendering()\n    @changed()\n  \n  setFontSize: (sizeOrMorphGivingSize) ->\n    if sizeOrMorphGivingSize.getValue?\n      size = sizeOrMorphGivingSize.getValue()\n    else\n      size = sizeOrMorphGivingSize\n\n    # for context menu demo purposes\n    if typeof size is "number"\n      @fontSize = Math.round(Math.min(Math.max(size, 4), 500))\n    else\n      newSize = parseFloat(size)\n      @fontSize = Math.round(Math.min(Math.max(newSize, 4), 500))  unless isNaN(newSize)\n    @changed()\n    @updateRendering()\n    @changed()\n  \n  setText: (size) ->\n    # for context menu demo purposes\n    @text = Math.round(size).toString()\n    @changed()\n    @updateRendering()\n    @changed()\n  \n  numericalSetters: ->\n    # for context menu demo purposes\n    ["setLeft", "setTop", "setAlphaScaled", "setFontSize", "setText"]\n  \n  \n  # StringMorph editing:\n  edit: ->\n    @root().edit @\n\n  editViaMenu: ->\n    @root().editViaMenu @\n  \n  selection: ->\n    start = Math.min(@startMark, @endMark)\n    stop = Math.max(@startMark, @endMark)\n    @text.slice start, stop\n  \n  selectionStartSlot: ->\n    Math.min @startMark, @endMark\n  \n  clearSelection: ->\n    @currentlySelecting = false\n    @startMark = null\n    @endMark = null\n    @changed()\n    @updateRendering()\n    @changed()\n  \n  deleteSelection: ->\n    text = @text\n    start = Math.min(@startMark, @endMark)\n    stop = Math.max(@startMark, @endMark)\n    @text = text.slice(0, start) + text.slice(stop)\n    @changed()\n    @clearSelection()\n  \n  selectAll: ->\n    @startMark = 0\n    @endMark = @text.length\n    @updateRendering()\n    @changed()\n\n  mouseDownLeft: (pos) ->\n    if @isEditable\n      @clearSelection()\n    else\n      @escalateEvent "mouseDownLeft", pos\n\n  # Every time the user clicks on the text, a new edit()\n  # is triggered, which creates a new caret.\n  mouseClickLeft: (pos) ->\n    caret = @root().caret;\n    if @isEditable\n      @edit()  unless @currentlySelecting\n      if caret then caret.gotoPos pos\n      @root().caret.gotoPos pos\n      @currentlySelecting = true\n    else\n      @escalateEvent "mouseClickLeft", pos\n  \n  #mouseDoubleClick: ->\n  #  alert "mouseDoubleClick!"\n\n  enableSelecting: ->\n    @mouseDownLeft = (pos) ->\n      @clearSelection()\n      if @isEditable and (not @isDraggable)\n        @edit()\n        @root().caret.gotoPos pos\n        @startMark = @slotAt(pos)\n        @endMark = @startMark\n        @currentlySelecting = true\n    \n    @mouseMove = (pos) ->\n      if @isEditable and @currentlySelecting and (not @isDraggable)\n        newMark = @slotAt(pos)\n        if newMark isnt @endMark\n          @endMark = newMark\n          @updateRendering()\n          @changed()\n  \n  disableSelecting: ->\n    # re-establish the original definition of the method\n    @mouseDownLeft = StringMorph::mouseDownLeft\n    delete @mouseMove';

  return StringMorph;

})(Morph);

SystemInfo = (function() {
  SystemInfo.prototype.userAgent = null;

  SystemInfo.prototype.screenWidth = null;

  SystemInfo.prototype.screenHeight = null;

  SystemInfo.prototype.screenColorDepth = null;

  SystemInfo.prototype.screenPixelRatio = null;

  SystemInfo.prototype.appCodeName = null;

  SystemInfo.prototype.appName = null;

  SystemInfo.prototype.appVersion = null;

  SystemInfo.prototype.cookieEnabled = null;

  SystemInfo.prototype.platform = null;

  SystemInfo.prototype.systemLanguage = null;

  SystemInfo.prototype.browser = null;

  SystemInfo.prototype.browserVersion = null;

  SystemInfo.prototype.mobile = null;

  SystemInfo.prototype.os = null;

  SystemInfo.prototype.osVersion = null;

  SystemInfo.prototype.cookies = null;

  function SystemInfo() {
    var browser, clientStrings, cookieEnabled, cs, id, ix, majorVersion, mobile, nAgt, nVer, nameOffset, os, osVersion, unknown, verOffset, version;
    this.userAgent = navigator.userAgent;
    this.screenWidth = window.screen.width;
    this.screenHeight = window.screen.height;
    this.screenColorDepth = window.screen.colorDepth;
    this.screenPixelRatio = window.devicePixelRatio;
    this.appCodeName = navigator.appCodeName;
    this.appName = navigator.appName;
    this.appVersion = navigator.appVersion;
    this.cookieEnabled = navigator.cookieEnabled;
    this.platform = navigator.platform;
    this.systemLanguage = navigator.systemLanguage;

    /**
     * code here is from "JavaScript Client Detection"
     * (C) viazenetti GmbH (Christian Ludwig)
     */
    unknown = '-';
    nVer = navigator.appVersion;
    nAgt = navigator.userAgent;
    browser = navigator.appName;
    version = '' + parseFloat(navigator.appVersion);
    majorVersion = parseInt(navigator.appVersion, 10);
    nameOffset = void 0;
    verOffset = void 0;
    ix = void 0;
    if ((verOffset = nAgt.indexOf('Opera')) !== -1) {
      browser = 'Opera';
      version = nAgt.substring(verOffset + 6);
      if ((verOffset = nAgt.indexOf('Version')) !== -1) {
        version = nAgt.substring(verOffset + 8);
      }
    } else if ((verOffset = nAgt.indexOf('MSIE')) !== -1) {
      browser = 'Microsoft Internet Explorer';
      version = nAgt.substring(verOffset + 5);
    } else if ((verOffset = nAgt.indexOf('Chrome')) !== -1) {
      browser = 'Chrome';
      version = nAgt.substring(verOffset + 7);
    } else if ((verOffset = nAgt.indexOf('Safari')) !== -1) {
      browser = 'Safari';
      version = nAgt.substring(verOffset + 7);
      if ((verOffset = nAgt.indexOf('Version')) !== -1) {
        version = nAgt.substring(verOffset + 8);
      }
    } else if ((verOffset = nAgt.indexOf('Firefox')) !== -1) {
      browser = 'Firefox';
      version = nAgt.substring(verOffset + 8);
    } else if (nAgt.indexOf('Trident/') !== -1) {
      browser = 'Microsoft Internet Explorer';
      version = nAgt.substring(nAgt.indexOf('rv:') + 3);
    } else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {
      browser = nAgt.substring(nameOffset, verOffset);
      version = nAgt.substring(verOffset + 1);
      if (browser.toLowerCase() === browser.toUpperCase()) {
        browser = navigator.appName;
      }
    }
    if ((ix = version.indexOf(';')) !== -1) {
      version = version.substring(0, ix);
    }
    if ((ix = version.indexOf(' ')) !== -1) {
      version = version.substring(0, ix);
    }
    if ((ix = version.indexOf(')')) !== -1) {
      version = version.substring(0, ix);
    }
    majorVersion = parseInt('' + version, 10);
    if (isNaN(majorVersion)) {
      version = '' + parseFloat(navigator.appVersion);
      majorVersion = parseInt(navigator.appVersion, 10);
    }
    mobile = /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(nVer);
    cookieEnabled = navigator.cookieEnabled ? true : false;
    if (typeof navigator.cookieEnabled === 'undefined' && !cookieEnabled) {
      document.cookie = 'testcookie';
      cookieEnabled = document.cookie.indexOf('testcookie') !== -1 ? true : false;
    }
    os = unknown;
    clientStrings = [
      {
        s: 'Windows 3.11',
        r: /Win16/
      }, {
        s: 'Windows 95',
        r: /(Windows 95|Win95|Windows_95)/
      }, {
        s: 'Windows ME',
        r: /(Win 9x 4.90|Windows ME)/
      }, {
        s: 'Windows 98',
        r: /(Windows 98|Win98)/
      }, {
        s: 'Windows CE',
        r: /Windows CE/
      }, {
        s: 'Windows 2000',
        r: /(Windows NT 5.0|Windows 2000)/
      }, {
        s: 'Windows XP',
        r: /(Windows NT 5.1|Windows XP)/
      }, {
        s: 'Windows Server 2003',
        r: /Windows NT 5.2/
      }, {
        s: 'Windows Vista',
        r: /Windows NT 6.0/
      }, {
        s: 'Windows 7',
        r: /(Windows 7|Windows NT 6.1)/
      }, {
        s: 'Windows 8.1',
        r: /(Windows 8.1|Windows NT 6.3)/
      }, {
        s: 'Windows 8',
        r: /(Windows 8|Windows NT 6.2)/
      }, {
        s: 'Windows NT 4.0',
        r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/
      }, {
        s: 'Windows ME',
        r: /Windows ME/
      }, {
        s: 'Android',
        r: /Android/
      }, {
        s: 'Open BSD',
        r: /OpenBSD/
      }, {
        s: 'Sun OS',
        r: /SunOS/
      }, {
        s: 'Linux',
        r: /(Linux|X11)/
      }, {
        s: 'iOS',
        r: /(iPhone|iPad|iPod)/
      }, {
        s: 'Mac OS X',
        r: /Mac OS X/
      }, {
        s: 'Mac OS',
        r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/
      }, {
        s: 'QNX',
        r: /QNX/
      }, {
        s: 'UNIX',
        r: /UNIX/
      }, {
        s: 'BeOS',
        r: /BeOS/
      }, {
        s: 'OS/2',
        r: /OS\/2/
      }, {
        s: 'Search Bot',
        r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/
      }
    ];
    for (id in clientStrings) {
      cs = clientStrings[id];
      if (cs.r.test(nAgt)) {
        os = cs.s;
        break;
      }
    }
    osVersion = unknown;
    if (/Windows/.test(os)) {
      osVersion = /Windows (.*)/.exec(os)[1];
      os = 'Windows';
    }
    switch (os) {
      case 'Mac OS X':
        osVersion = /Mac OS X (10[\.\_\d]+)/.exec(nAgt)[1];
        break;
      case 'Android':
        osVersion = /Android ([\.\_\d]+)/.exec(nAgt)[1];
        break;
      case 'iOS':
        osVersion = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer);
        osVersion = osVersion[1] + '.' + osVersion[2] + '.' + (osVersion[3] | 0);
    }
    this.browser = browser;
    this.browserVersion = version;
    this.mobile = mobile;
    this.os = os;
    this.osVersion = osVersion;
    this.cookies = cookieEnabled;
  }

  SystemInfo.coffeeScriptSourceOfThisClass = '# Holds information about browser and machine\n# Note that some of these could\n# change during user session.\n\nclass SystemInfo\n\n  userAgent: null\n  screenWidth: null\n  screenHeight: null\n  screenColorDepth: null\n  screenPixelRatio: null\n  appCodeName: null\n  appName: null\n  appVersion: null\n  cookieEnabled: null\n  platform: null\n  systemLanguage: null\n\n  browser: null\n  browserVersion: null\n  mobile: null\n  os: null\n  osVersion: null\n  cookies: null\n\n  constructor: ->\n    @userAgent = navigator.userAgent\n    @screenWidth = window.screen.width\n    @screenHeight = window.screen.height\n    @screenColorDepth = window.screen.colorDepth\n    @screenPixelRatio = window.devicePixelRatio\n    @appCodeName = navigator.appCodeName\n    @appName = navigator.appName\n    @appVersion = navigator.appVersion\n    @cookieEnabled = navigator.cookieEnabled\n    @platform = navigator.platform\n    @systemLanguage = navigator.systemLanguage\n\n    ###*\n    # code here is from "JavaScript Client Detection"\n    # (C) viazenetti GmbH (Christian Ludwig)\n    ###\n\n    unknown = \'-\'\n    #browser\n    nVer = navigator.appVersion\n    nAgt = navigator.userAgent\n    browser = navigator.appName\n    version = \'\' + parseFloat(navigator.appVersion)\n    majorVersion = parseInt(navigator.appVersion, 10)\n    nameOffset = undefined\n    verOffset = undefined\n    ix = undefined\n    # Opera\n    if (verOffset = nAgt.indexOf(\'Opera\')) != -1\n      browser = \'Opera\'\n      version = nAgt.substring(verOffset + 6)\n      if (verOffset = nAgt.indexOf(\'Version\')) != -1\n        version = nAgt.substring(verOffset + 8)\n    else if (verOffset = nAgt.indexOf(\'MSIE\')) != -1\n      browser = \'Microsoft Internet Explorer\'\n      version = nAgt.substring(verOffset + 5)\n    else if (verOffset = nAgt.indexOf(\'Chrome\')) != -1\n      browser = \'Chrome\'\n      version = nAgt.substring(verOffset + 7)\n    else if (verOffset = nAgt.indexOf(\'Safari\')) != -1\n      browser = \'Safari\'\n      version = nAgt.substring(verOffset + 7)\n      if (verOffset = nAgt.indexOf(\'Version\')) != -1\n        version = nAgt.substring(verOffset + 8)\n    else if (verOffset = nAgt.indexOf(\'Firefox\')) != -1\n      browser = \'Firefox\'\n      version = nAgt.substring(verOffset + 8)\n    else if nAgt.indexOf(\'Trident/\') != -1\n      browser = \'Microsoft Internet Explorer\'\n      version = nAgt.substring(nAgt.indexOf(\'rv:\') + 3)\n    else if (nameOffset = nAgt.lastIndexOf(\' \') + 1) < (verOffset = nAgt.lastIndexOf(\'/\'))\n      browser = nAgt.substring(nameOffset, verOffset)\n      version = nAgt.substring(verOffset + 1)\n      if browser.toLowerCase() == browser.toUpperCase()\n        browser = navigator.appName\n    # trim the version string\n    if (ix = version.indexOf(\';\')) != -1\n      version = version.substring(0, ix)\n    if (ix = version.indexOf(\' \')) != -1\n      version = version.substring(0, ix)\n    if (ix = version.indexOf(\')\')) != -1\n      version = version.substring(0, ix)\n    majorVersion = parseInt(\'\' + version, 10)\n    if isNaN(majorVersion)\n      version = \'\' + parseFloat(navigator.appVersion)\n      majorVersion = parseInt(navigator.appVersion, 10)\n    # mobile version\n    mobile = /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(nVer)\n    # cookie\n    cookieEnabled = if navigator.cookieEnabled then true else false\n    if typeof navigator.cookieEnabled == \'undefined\' and !cookieEnabled\n      document.cookie = \'testcookie\'\n      cookieEnabled = if document.cookie.indexOf(\'testcookie\') != -1 then true else false\n    # system\n    os = unknown\n    clientStrings = [\n      {\n        s: \'Windows 3.11\'\n        r: /Win16/\n      }\n      {\n        s: \'Windows 95\'\n        r: /(Windows 95|Win95|Windows_95)/\n      }\n      {\n        s: \'Windows ME\'\n        r: /(Win 9x 4.90|Windows ME)/\n      }\n      {\n        s: \'Windows 98\'\n        r: /(Windows 98|Win98)/\n      }\n      {\n        s: \'Windows CE\'\n        r: /Windows CE/\n      }\n      {\n        s: \'Windows 2000\'\n        r: /(Windows NT 5.0|Windows 2000)/\n      }\n      {\n        s: \'Windows XP\'\n        r: /(Windows NT 5.1|Windows XP)/\n      }\n      {\n        s: \'Windows Server 2003\'\n        r: /Windows NT 5.2/\n      }\n      {\n        s: \'Windows Vista\'\n        r: /Windows NT 6.0/\n      }\n      {\n        s: \'Windows 7\'\n        r: /(Windows 7|Windows NT 6.1)/\n      }\n      {\n        s: \'Windows 8.1\'\n        r: /(Windows 8.1|Windows NT 6.3)/\n      }\n      {\n        s: \'Windows 8\'\n        r: /(Windows 8|Windows NT 6.2)/\n      }\n      {\n        s: \'Windows NT 4.0\'\n        r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/\n      }\n      {\n        s: \'Windows ME\'\n        r: /Windows ME/\n      }\n      {\n        s: \'Android\'\n        r: /Android/\n      }\n      {\n        s: \'Open BSD\'\n        r: /OpenBSD/\n      }\n      {\n        s: \'Sun OS\'\n        r: /SunOS/\n      }\n      {\n        s: \'Linux\'\n        r: /(Linux|X11)/\n      }\n      {\n        s: \'iOS\'\n        r: /(iPhone|iPad|iPod)/\n      }\n      {\n        s: \'Mac OS X\'\n        r: /Mac OS X/\n      }\n      {\n        s: \'Mac OS\'\n        r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/\n      }\n      {\n        s: \'QNX\'\n        r: /QNX/\n      }\n      {\n        s: \'UNIX\'\n        r: /UNIX/\n      }\n      {\n        s: \'BeOS\'\n        r: /BeOS/\n      }\n      {\n        s: \'OS/2\'\n        r: /OS\/2/\n      }\n      {\n        s: \'Search Bot\'\n        r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/\n      }\n    ]\n    for id of clientStrings\n      cs = clientStrings[id]\n      if cs.r.test(nAgt)\n        os = cs.s\n        break\n    osVersion = unknown\n    if /Windows/.test(os)\n      osVersion = /Windows (.*)/.exec(os)[1]\n      os = \'Windows\'\n    switch os\n      when \'Mac OS X\'\n        osVersion = /Mac OS X (10[\.\_\d]+)/.exec(nAgt)[1]\n      when \'Android\'\n        osVersion = /Android ([\.\_\d]+)/.exec(nAgt)[1]\n      when \'iOS\'\n        osVersion = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer)\n        osVersion = osVersion[1] + \'.\' + osVersion[2] + \'.\' + (osVersion[3] | 0)\n\n    @browser = browser\n    @browserVersion = version\n    @mobile = mobile\n    @os = os\n    @osVersion = osVersion\n    @cookies = cookieEnabled';

  return SystemInfo;

})();

SystemTestsCommand = (function() {
  SystemTestsCommand.prototype.testCommandName = '';

  SystemTestsCommand.prototype.millisecondsSincePreviousCommand = 0;

  function SystemTestsCommand(systemTestsRecorderAndPlayer) {
    this.millisecondsSincePreviousCommand = (new Date().getTime()) - systemTestsRecorderAndPlayer.timeOfPreviouslyRecordedCommand;
  }

  SystemTestsCommand.coffeeScriptSourceOfThisClass = '# The SystemTests recorder collects a number\n# of commands from the user and puts them in a\n# queue. This is the superclass of all the\n# possible commands.\n\n\nclass SystemTestsCommand\n  testCommandName: \'\'\n  millisecondsSincePreviousCommand: 0\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    @millisecondsSincePreviousCommand = (new Date().getTime()) - systemTestsRecorderAndPlayer.timeOfPreviouslyRecordedCommand';

  return SystemTestsCommand;

})();

SystemTestsCommandCheckNumberOfItemsInMenu = (function(_super) {
  __extends(SystemTestsCommandCheckNumberOfItemsInMenu, _super);

  SystemTestsCommandCheckNumberOfItemsInMenu.prototype.numberOfItemsInMenu = 0;

  SystemTestsCommandCheckNumberOfItemsInMenu.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.checkNumberOfItemsInMenu(commandBeingPlayed.numberOfItemsInMenu);
  };

  function SystemTestsCommandCheckNumberOfItemsInMenu(numberOfItemsInMenu, systemTestsRecorderAndPlayer) {
    this.numberOfItemsInMenu = numberOfItemsInMenu;
    SystemTestsCommandCheckNumberOfItemsInMenu.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandCheckNumberOfItemsInMenu";
  }

  SystemTestsCommandCheckNumberOfItemsInMenu.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandCheckNumberOfItemsInMenu extends SystemTestsCommand\n  numberOfItemsInMenu: 0\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.checkNumberOfItemsInMenu(commandBeingPlayed.numberOfItemsInMenu)\n\n  constructor: (@numberOfItemsInMenu, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandCheckNumberOfItemsInMenu"';

  return SystemTestsCommandCheckNumberOfItemsInMenu;

})(SystemTestsCommand);

SystemTestsCommandCheckStringsOfItemsInMenuOrderImportant = (function(_super) {
  __extends(SystemTestsCommandCheckStringsOfItemsInMenuOrderImportant, _super);

  SystemTestsCommandCheckStringsOfItemsInMenuOrderImportant.prototype.stringOfItemsInMenuInOriginalOrder = [];

  SystemTestsCommandCheckStringsOfItemsInMenuOrderImportant.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderImportant(commandBeingPlayed.stringOfItemsInMenuInOriginalOrder);
  };

  function SystemTestsCommandCheckStringsOfItemsInMenuOrderImportant(stringOfItemsInMenuInOriginalOrder, systemTestsRecorderAndPlayer) {
    this.stringOfItemsInMenuInOriginalOrder = stringOfItemsInMenuInOriginalOrder;
    SystemTestsCommandCheckStringsOfItemsInMenuOrderImportant.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandCheckStringsOfItemsInMenuOrderImportant";
  }

  SystemTestsCommandCheckStringsOfItemsInMenuOrderImportant.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandCheckStringsOfItemsInMenuOrderImportant extends SystemTestsCommand\n  stringOfItemsInMenuInOriginalOrder: []\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderImportant(commandBeingPlayed.stringOfItemsInMenuInOriginalOrder)\n\n  constructor: (@stringOfItemsInMenuInOriginalOrder, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandCheckStringsOfItemsInMenuOrderImportant"';

  return SystemTestsCommandCheckStringsOfItemsInMenuOrderImportant;

})(SystemTestsCommand);

SystemTestsCommandCheckStringsOfItemsInMenuOrderUnimportant = (function(_super) {
  __extends(SystemTestsCommandCheckStringsOfItemsInMenuOrderUnimportant, _super);

  SystemTestsCommandCheckStringsOfItemsInMenuOrderUnimportant.prototype.stringOfItemsInMenuInOriginalOrder = [];

  SystemTestsCommandCheckStringsOfItemsInMenuOrderUnimportant.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderUnimportant(commandBeingPlayed.stringOfItemsInMenuInOriginalOrder);
  };

  function SystemTestsCommandCheckStringsOfItemsInMenuOrderUnimportant(stringOfItemsInMenuInOriginalOrder, systemTestsRecorderAndPlayer) {
    this.stringOfItemsInMenuInOriginalOrder = stringOfItemsInMenuInOriginalOrder;
    SystemTestsCommandCheckStringsOfItemsInMenuOrderUnimportant.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandCheckStringsOfItemsInMenuOrderUnimportant";
  }

  SystemTestsCommandCheckStringsOfItemsInMenuOrderUnimportant.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandCheckStringsOfItemsInMenuOrderUnimportant extends SystemTestsCommand\n  stringOfItemsInMenuInOriginalOrder: []\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderUnimportant(commandBeingPlayed.stringOfItemsInMenuInOriginalOrder)\n\n  constructor: (@stringOfItemsInMenuInOriginalOrder, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandCheckStringsOfItemsInMenuOrderUnimportant"';

  return SystemTestsCommandCheckStringsOfItemsInMenuOrderUnimportant;

})(SystemTestsCommand);

SystemTestsCommandCopy = (function(_super) {
  __extends(SystemTestsCommandCopy, _super);

  SystemTestsCommandCopy.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.worldMorph.processCopy(null);
  };

  function SystemTestsCommandCopy(clipboardText, systemTestsRecorderAndPlayer) {
    this.clipboardText = clipboardText;
    SystemTestsCommandCopy.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandCopy";
  }

  SystemTestsCommandCopy.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandCopy extends SystemTestsCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.worldMorph.processCopy null\n\n  constructor: (@clipboardText, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandCopy"  ';

  return SystemTestsCommandCopy;

})(SystemTestsCommand);

SystemTestsCommandDoNothing = (function(_super) {
  __extends(SystemTestsCommandDoNothing, _super);

  SystemTestsCommandDoNothing.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {};

  function SystemTestsCommandDoNothing(systemTestsRecorderAndPlayer) {
    SystemTestsCommandDoNothing.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandDoNothing";
  }

  SystemTestsCommandDoNothing.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandDoNothing extends SystemTestsCommand\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandDoNothing"';

  return SystemTestsCommandDoNothing;

})(SystemTestsCommand);

SystemTestsCommandKeyDown = (function(_super) {
  __extends(SystemTestsCommandKeyDown, _super);

  SystemTestsCommandKeyDown.prototype.scanCode = null;

  SystemTestsCommandKeyDown.prototype.shiftKey = null;

  SystemTestsCommandKeyDown.prototype.ctrlKey = null;

  SystemTestsCommandKeyDown.prototype.altKey = null;

  SystemTestsCommandKeyDown.prototype.metaKey = null;

  SystemTestsCommandKeyDown.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    console.log("replaying key");
    return systemTestsRecorderAndPlayer.worldMorph.processKeydown(null, commandBeingPlayed.scanCode, commandBeingPlayed.shiftKey, commandBeingPlayed.ctrlKey, commandBeingPlayed.altKey, commandBeingPlayed.metaKey);
  };

  function SystemTestsCommandKeyDown(scanCode, shiftKey, ctrlKey, altKey, metaKey, systemTestsRecorderAndPlayer) {
    this.scanCode = scanCode;
    this.shiftKey = shiftKey;
    this.ctrlKey = ctrlKey;
    this.altKey = altKey;
    this.metaKey = metaKey;
    SystemTestsCommandKeyDown.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandKeyDown";
  }

  SystemTestsCommandKeyDown.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandKeyDown extends SystemTestsCommand\n  scanCode: null\n  shiftKey: null\n  ctrlKey: null\n  altKey: null\n  metaKey: null\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    console.log "replaying key"\n    systemTestsRecorderAndPlayer.worldMorph.processKeydown null, commandBeingPlayed.scanCode, commandBeingPlayed.shiftKey, commandBeingPlayed.ctrlKey, commandBeingPlayed.altKey, commandBeingPlayed.metaKey\n\n\n  constructor: (@scanCode, @shiftKey, @ctrlKey, @altKey, @metaKey, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandKeyDown"  ';

  return SystemTestsCommandKeyDown;

})(SystemTestsCommand);

SystemTestsCommandKeyPress = (function(_super) {
  __extends(SystemTestsCommandKeyPress, _super);

  SystemTestsCommandKeyPress.prototype.charCode = null;

  SystemTestsCommandKeyPress.prototype.symbol = null;

  SystemTestsCommandKeyPress.prototype.shiftKey = null;

  SystemTestsCommandKeyPress.prototype.ctrlKey = null;

  SystemTestsCommandKeyPress.prototype.altKey = null;

  SystemTestsCommandKeyPress.prototype.metaKey = null;

  SystemTestsCommandKeyPress.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    console.log("replaying key");
    return systemTestsRecorderAndPlayer.worldMorph.processKeypress(null, commandBeingPlayed.charCode, commandBeingPlayed.symbol, commandBeingPlayed.shiftKey, commandBeingPlayed.ctrlKey, commandBeingPlayed.altKey, commandBeingPlayed.metaKey);
  };

  function SystemTestsCommandKeyPress(charCode, symbol, shiftKey, ctrlKey, altKey, metaKey, systemTestsRecorderAndPlayer) {
    this.charCode = charCode;
    this.symbol = symbol;
    this.shiftKey = shiftKey;
    this.ctrlKey = ctrlKey;
    this.altKey = altKey;
    this.metaKey = metaKey;
    SystemTestsCommandKeyPress.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandKeyPress";
  }

  SystemTestsCommandKeyPress.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandKeyPress extends SystemTestsCommand\n  charCode: null\n  symbol: null\n  shiftKey: null\n  ctrlKey: null\n  altKey: null\n  metaKey: null\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    console.log "replaying key"\n    systemTestsRecorderAndPlayer.worldMorph.processKeypress null, commandBeingPlayed.charCode, commandBeingPlayed.symbol, commandBeingPlayed.shiftKey, commandBeingPlayed.ctrlKey, commandBeingPlayed.altKey, commandBeingPlayed.metaKey\n\n\n  constructor: (@charCode, @symbol, @shiftKey, @ctrlKey, @altKey, @metaKey, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandKeyPress"';

  return SystemTestsCommandKeyPress;

})(SystemTestsCommand);

SystemTestsCommandKeyUp = (function(_super) {
  __extends(SystemTestsCommandKeyUp, _super);

  SystemTestsCommandKeyUp.prototype.scanCode = null;

  SystemTestsCommandKeyUp.prototype.shiftKey = null;

  SystemTestsCommandKeyUp.prototype.ctrlKey = null;

  SystemTestsCommandKeyUp.prototype.altKey = null;

  SystemTestsCommandKeyUp.prototype.metaKey = null;

  SystemTestsCommandKeyUp.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    console.log("replaying key");
    return systemTestsRecorderAndPlayer.worldMorph.processKeyup(null, commandBeingPlayed.scanCode, commandBeingPlayed.shiftKey, commandBeingPlayed.ctrlKey, commandBeingPlayed.altKey, commandBeingPlayed.metaKey);
  };

  function SystemTestsCommandKeyUp(scanCode, shiftKey, ctrlKey, altKey, metaKey, systemTestsRecorderAndPlayer) {
    this.scanCode = scanCode;
    this.shiftKey = shiftKey;
    this.ctrlKey = ctrlKey;
    this.altKey = altKey;
    this.metaKey = metaKey;
    SystemTestsCommandKeyUp.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandKeyUp";
  }

  SystemTestsCommandKeyUp.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandKeyUp extends SystemTestsCommand\n  scanCode: null\n  shiftKey: null\n  ctrlKey: null\n  altKey: null\n  metaKey: null\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    console.log "replaying key"\n    systemTestsRecorderAndPlayer.worldMorph.processKeyup null, commandBeingPlayed.scanCode, commandBeingPlayed.shiftKey, commandBeingPlayed.ctrlKey, commandBeingPlayed.altKey, commandBeingPlayed.metaKey\n\n\n  constructor: (@scanCode, @shiftKey, @ctrlKey, @altKey, @metaKey, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandKeyUp"';

  return SystemTestsCommandKeyUp;

})(SystemTestsCommand);

SystemTestsCommandLeftOrRightClickOnMenuItem = (function(_super) {
  var whichMouseButtonPressed;

  __extends(SystemTestsCommandLeftOrRightClickOnMenuItem, _super);

  whichMouseButtonPressed = "";

  SystemTestsCommandLeftOrRightClickOnMenuItem.prototype.textLabelOfClickedItem = 0;

  SystemTestsCommandLeftOrRightClickOnMenuItem.prototype.textLabelOccurrenceNumber = 0;

  SystemTestsCommandLeftOrRightClickOnMenuItem.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.handMorph.leftOrRightClickOnMenuItemWithText(commandBeingPlayed.whichMouseButtonPressed, commandBeingPlayed.textLabelOfClickedItem, commandBeingPlayed.textLabelOccurrenceNumber);
  };

  function SystemTestsCommandLeftOrRightClickOnMenuItem(whichMouseButtonPressed, textLabelOfClickedItem, textLabelOccurrenceNumber, systemTestsRecorderAndPlayer) {
    this.whichMouseButtonPressed = whichMouseButtonPressed;
    this.textLabelOfClickedItem = textLabelOfClickedItem;
    this.textLabelOccurrenceNumber = textLabelOccurrenceNumber;
    SystemTestsCommandLeftOrRightClickOnMenuItem.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandLeftOrRightClickOnMenuItem";
  }

  SystemTestsCommandLeftOrRightClickOnMenuItem.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandLeftOrRightClickOnMenuItem extends SystemTestsCommand\n  whichMouseButtonPressed = ""\n  textLabelOfClickedItem: 0\n  # there might be multiple instances of\n  # the same text label so we count\n  # which one it is\n  textLabelOccurrenceNumber: 0\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.handMorph.leftOrRightClickOnMenuItemWithText(commandBeingPlayed.whichMouseButtonPressed, commandBeingPlayed.textLabelOfClickedItem, commandBeingPlayed.textLabelOccurrenceNumber)\n\n  constructor: (@whichMouseButtonPressed, @textLabelOfClickedItem, @textLabelOccurrenceNumber, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandLeftOrRightClickOnMenuItem"';

  return SystemTestsCommandLeftOrRightClickOnMenuItem;

})(SystemTestsCommand);

SystemTestsCommandMouseDown = (function(_super) {
  __extends(SystemTestsCommandMouseDown, _super);

  SystemTestsCommandMouseDown.prototype.button = null;

  SystemTestsCommandMouseDown.prototype.ctrlKey = null;

  SystemTestsCommandMouseDown.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.handMorph.processMouseDown(commandBeingPlayed.button, commandBeingPlayed.ctrlKey);
  };

  SystemTestsCommandMouseDown.prototype.transformIntoDoNothingCommand = function() {
    return this.testCommandName = "SystemTestsCommandDoNothing";
  };

  function SystemTestsCommandMouseDown(button, ctrlKey, systemTestsRecorderAndPlayer) {
    this.button = button;
    this.ctrlKey = ctrlKey;
    SystemTestsCommandMouseDown.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandMouseDown";
  }

  SystemTestsCommandMouseDown.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandMouseDown extends SystemTestsCommand\n  button: null\n  ctrlKey: null\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.handMorph.processMouseDown(commandBeingPlayed.button, commandBeingPlayed.ctrlKey)\n\n  transformIntoDoNothingCommand: ->\n    @testCommandName = "SystemTestsCommandDoNothing"\n\n  constructor: (@button, @ctrlKey, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandMouseDown"';

  return SystemTestsCommandMouseDown;

})(SystemTestsCommand);

SystemTestsCommandMouseMove = (function(_super) {
  __extends(SystemTestsCommandMouseMove, _super);

  SystemTestsCommandMouseMove.prototype.mouseX = null;

  SystemTestsCommandMouseMove.prototype.mouseY = null;

  SystemTestsCommandMouseMove.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.handMorph.processMouseMove(commandBeingPlayed.mouseX, commandBeingPlayed.mouseY);
  };

  function SystemTestsCommandMouseMove(mouseX, mouseY, systemTestsRecorderAndPlayer) {
    this.mouseX = mouseX;
    this.mouseY = mouseY;
    SystemTestsCommandMouseMove.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandMouseMove";
  }

  SystemTestsCommandMouseMove.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandMouseMove extends SystemTestsCommand\n  mouseX: null\n  mouseY: null\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.handMorph.processMouseMove(commandBeingPlayed.mouseX, commandBeingPlayed.mouseY)\n\n  constructor: (@mouseX, @mouseY, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandMouseMove"';

  return SystemTestsCommandMouseMove;

})(SystemTestsCommand);

SystemTestsCommandMouseUp = (function(_super) {
  __extends(SystemTestsCommandMouseUp, _super);

  SystemTestsCommandMouseUp.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.handMorph.processMouseUp();
  };

  SystemTestsCommandMouseUp.prototype.transformIntoDoNothingCommand = function() {
    return this.testCommandName = "SystemTestsCommandDoNothing";
  };

  function SystemTestsCommandMouseUp(systemTestsRecorderAndPlayer) {
    SystemTestsCommandMouseUp.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandMouseUp";
  }

  SystemTestsCommandMouseUp.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandMouseUp extends SystemTestsCommand\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.handMorph.processMouseUp()\n\n  transformIntoDoNothingCommand: ->\n    @testCommandName = "SystemTestsCommandDoNothing"\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandMouseUp"';

  return SystemTestsCommandMouseUp;

})(SystemTestsCommand);

SystemTestsCommandOpenContextMenu = (function(_super) {
  __extends(SystemTestsCommandOpenContextMenu, _super);

  SystemTestsCommandOpenContextMenu.prototype.morphToOpenContextMenuAgainst_UniqueIDString = null;

  SystemTestsCommandOpenContextMenu.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.handMorph.openContextMenuAtPointer(Morph.morphFromUniqueIDString(commandBeingPlayed.morphToOpenContextMenuAgainst_UniqueIDString));
  };

  function SystemTestsCommandOpenContextMenu(morphToOpenContextMenuAgainst_UniqueIDString, systemTestsRecorderAndPlayer) {
    this.morphToOpenContextMenuAgainst_UniqueIDString = morphToOpenContextMenuAgainst_UniqueIDString;
    SystemTestsCommandOpenContextMenu.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandOpenContextMenu";
  }

  SystemTestsCommandOpenContextMenu.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandOpenContextMenu extends SystemTestsCommand\n  morphToOpenContextMenuAgainst_UniqueIDString: null\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.handMorph.openContextMenuAtPointer (Morph.morphFromUniqueIDString commandBeingPlayed.morphToOpenContextMenuAgainst_UniqueIDString)\n\n\n  constructor: (@morphToOpenContextMenuAgainst_UniqueIDString, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandOpenContextMenu"';

  return SystemTestsCommandOpenContextMenu;

})(SystemTestsCommand);

SystemTestsCommandPaste = (function(_super) {
  __extends(SystemTestsCommandPaste, _super);

  SystemTestsCommandPaste.prototype.clipboardText = null;

  SystemTestsCommandPaste.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    console.log("test player inserting text: " + commandBeingPlayed.clipboardText);
    return systemTestsRecorderAndPlayer.worldMorph.processPaste(null, commandBeingPlayed.clipboardText);
  };

  function SystemTestsCommandPaste(clipboardText, systemTestsRecorderAndPlayer) {
    this.clipboardText = clipboardText;
    SystemTestsCommandPaste.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandPaste";
  }

  SystemTestsCommandPaste.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandPaste extends SystemTestsCommand\n  clipboardText: null\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    console.log "test player inserting text: " + commandBeingPlayed.clipboardText\n    systemTestsRecorderAndPlayer.worldMorph.processPaste null, commandBeingPlayed.clipboardText\n\n\n  constructor: (@clipboardText, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandPaste"  ';

  return SystemTestsCommandPaste;

})(SystemTestsCommand);

SystemTestsCommandResetWorld = (function(_super) {
  __extends(SystemTestsCommandResetWorld, _super);

  SystemTestsCommandResetWorld.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.worldMorph.resetWorld();
  };

  function SystemTestsCommandResetWorld(systemTestsRecorderAndPlayer) {
    SystemTestsCommandResetWorld.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandResetWorld";
  }

  SystemTestsCommandResetWorld.coffeeScriptSourceOfThisClass = '# \n\nclass SystemTestsCommandResetWorld extends SystemTestsCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.worldMorph.resetWorld()\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandResetWorld"';

  return SystemTestsCommandResetWorld;

})(SystemTestsCommand);

SystemTestsCommandScreenshot = (function(_super) {
  __extends(SystemTestsCommandScreenshot, _super);

  SystemTestsCommandScreenshot.prototype.screenShotImageName = null;

  SystemTestsCommandScreenshot.prototype.screenshotTakenOfAParticularMorph = false;

  SystemTestsCommandScreenshot.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.compareScreenshots(commandBeingPlayed.screenShotImageName, commandBeingPlayed.screenshotTakenOfAParticularMorph);
  };

  function SystemTestsCommandScreenshot(screenShotImageName, systemTestsRecorderAndPlayer, screenshotTakenOfAParticularMorph) {
    this.screenShotImageName = screenShotImageName;
    this.screenshotTakenOfAParticularMorph = screenshotTakenOfAParticularMorph != null ? screenshotTakenOfAParticularMorph : false;
    SystemTestsCommandScreenshot.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandScreenshot";
  }

  SystemTestsCommandScreenshot.coffeeScriptSourceOfThisClass = '#\n\n\nclass SystemTestsCommandScreenshot extends SystemTestsCommand\n  screenShotImageName: null\n  # The screenshot can be of the entire\n  # world or of a particular morph (through\n  # the "take pic" menu entry.\n  # The screenshotTakenOfAParticularMorph flag\n  # remembers which case we are in.\n  # In the case that the screenshot is\n  # of a particular morph, the comparison\n  # will have to wait for the world\n  # to provide the image data (the take pic command\n  # will do it)\n  screenshotTakenOfAParticularMorph: false\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.compareScreenshots(commandBeingPlayed.screenShotImageName, commandBeingPlayed.screenshotTakenOfAParticularMorph)\n\n\n  constructor: (@screenShotImageName, systemTestsRecorderAndPlayer, @screenshotTakenOfAParticularMorph = false ) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandScreenshot"';

  return SystemTestsCommandScreenshot;

})(SystemTestsCommand);

SystemTestsCommandShowComment = (function(_super) {
  __extends(SystemTestsCommandShowComment, _super);

  SystemTestsCommandShowComment.prototype.message = "";

  SystemTestsCommandShowComment.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return SystemTestsControlPanelUpdater.addMessageToTestCommentsConsole(commandBeingPlayed.message);
  };

  function SystemTestsCommandShowComment(message, systemTestsRecorderAndPlayer) {
    this.message = message;
    SystemTestsCommandShowComment.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandShowComment";
  }

  SystemTestsCommandShowComment.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandShowComment extends SystemTestsCommand\n  message: ""\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    SystemTestsControlPanelUpdater.addMessageToTestCommentsConsole commandBeingPlayed.message\n\n  constructor: (@message, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandShowComment"';

  return SystemTestsCommandShowComment;

})(SystemTestsCommand);

SystemTestsCommandTurnOffAlignmentOfMorphIDsMechanism = (function(_super) {
  __extends(SystemTestsCommandTurnOffAlignmentOfMorphIDsMechanism, _super);

  SystemTestsCommandTurnOffAlignmentOfMorphIDsMechanism.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOffAlignmentOfMorphIDsMechanism();
  };

  function SystemTestsCommandTurnOffAlignmentOfMorphIDsMechanism(systemTestsRecorderAndPlayer) {
    SystemTestsCommandTurnOffAlignmentOfMorphIDsMechanism.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandTurnOffAlignmentOfMorphIDsMechanism";
  }

  SystemTestsCommandTurnOffAlignmentOfMorphIDsMechanism.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandTurnOffAlignmentOfMorphIDsMechanism extends SystemTestsCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOffAlignmentOfMorphIDsMechanism()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandTurnOffAlignmentOfMorphIDsMechanism"';

  return SystemTestsCommandTurnOffAlignmentOfMorphIDsMechanism;

})(SystemTestsCommand);

SystemTestsCommandTurnOffAnimationsPacingControl = (function(_super) {
  __extends(SystemTestsCommandTurnOffAnimationsPacingControl, _super);

  SystemTestsCommandTurnOffAnimationsPacingControl.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl();
  };

  function SystemTestsCommandTurnOffAnimationsPacingControl(systemTestsRecorderAndPlayer) {
    SystemTestsCommandTurnOffAnimationsPacingControl.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandTurnOffAnimationsPacingControl";
  }

  SystemTestsCommandTurnOffAnimationsPacingControl.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandTurnOffAnimationsPacingControl extends SystemTestsCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandTurnOffAnimationsPacingControl"';

  return SystemTestsCommandTurnOffAnimationsPacingControl;

})(SystemTestsCommand);

SystemTestsCommandTurnOffHidingOfMorphsContentExtractInLabels = (function(_super) {
  __extends(SystemTestsCommandTurnOffHidingOfMorphsContentExtractInLabels, _super);

  SystemTestsCommandTurnOffHidingOfMorphsContentExtractInLabels.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOffHidingOfMorphsContentExtractInLabels();
  };

  function SystemTestsCommandTurnOffHidingOfMorphsContentExtractInLabels(systemTestsRecorderAndPlayer) {
    SystemTestsCommandTurnOffHidingOfMorphsContentExtractInLabels.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandTurnOffHidingOfMorphsContentExtractInLabels";
  }

  SystemTestsCommandTurnOffHidingOfMorphsContentExtractInLabels.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandTurnOffHidingOfMorphsContentExtractInLabels extends SystemTestsCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOffHidingOfMorphsContentExtractInLabels()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandTurnOffHidingOfMorphsContentExtractInLabels"';

  return SystemTestsCommandTurnOffHidingOfMorphsContentExtractInLabels;

})(SystemTestsCommand);

SystemTestsCommandTurnOffHidingOfMorphsGeometryInfoInLabels = (function(_super) {
  __extends(SystemTestsCommandTurnOffHidingOfMorphsGeometryInfoInLabels, _super);

  SystemTestsCommandTurnOffHidingOfMorphsGeometryInfoInLabels.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOffHidingOfMorphsGeometryInfoInLabels();
  };

  function SystemTestsCommandTurnOffHidingOfMorphsGeometryInfoInLabels(systemTestsRecorderAndPlayer) {
    SystemTestsCommandTurnOffHidingOfMorphsGeometryInfoInLabels.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandTurnOffHidingOfMorphsGeometryInfoInLabels";
  }

  SystemTestsCommandTurnOffHidingOfMorphsGeometryInfoInLabels.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandTurnOffHidingOfMorphsGeometryInfoInLabels extends SystemTestsCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOffHidingOfMorphsGeometryInfoInLabels()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandTurnOffHidingOfMorphsGeometryInfoInLabels"';

  return SystemTestsCommandTurnOffHidingOfMorphsGeometryInfoInLabels;

})(SystemTestsCommand);

SystemTestsCommandTurnOffHidingOfMorphsNumberIDInLabels = (function(_super) {
  __extends(SystemTestsCommandTurnOffHidingOfMorphsNumberIDInLabels, _super);

  SystemTestsCommandTurnOffHidingOfMorphsNumberIDInLabels.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOffHidingOfMorphsNumberIDInLabels();
  };

  function SystemTestsCommandTurnOffHidingOfMorphsNumberIDInLabels(systemTestsRecorderAndPlayer) {
    SystemTestsCommandTurnOffHidingOfMorphsNumberIDInLabels.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandTurnOffHidingOfMorphsNumberIDInLabels";
  }

  SystemTestsCommandTurnOffHidingOfMorphsNumberIDInLabels.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandTurnOffHidingOfMorphsNumberIDInLabels extends SystemTestsCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOffHidingOfMorphsNumberIDInLabels()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandTurnOffHidingOfMorphsNumberIDInLabels"';

  return SystemTestsCommandTurnOffHidingOfMorphsNumberIDInLabels;

})(SystemTestsCommand);

SystemTestsCommandTurnOnAlignmentOfMorphIDsMechanism = (function(_super) {
  __extends(SystemTestsCommandTurnOnAlignmentOfMorphIDsMechanism, _super);

  SystemTestsCommandTurnOnAlignmentOfMorphIDsMechanism.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOnAlignmentOfMorphIDsMechanism();
  };

  function SystemTestsCommandTurnOnAlignmentOfMorphIDsMechanism(systemTestsRecorderAndPlayer) {
    SystemTestsCommandTurnOnAlignmentOfMorphIDsMechanism.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandTurnOnAlignmentOfMorphIDsMechanism";
  }

  SystemTestsCommandTurnOnAlignmentOfMorphIDsMechanism.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandTurnOnAlignmentOfMorphIDsMechanism extends SystemTestsCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOnAlignmentOfMorphIDsMechanism()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandTurnOnAlignmentOfMorphIDsMechanism"';

  return SystemTestsCommandTurnOnAlignmentOfMorphIDsMechanism;

})(SystemTestsCommand);

SystemTestsCommandTurnOnAnimationsPacingControl = (function(_super) {
  __extends(SystemTestsCommandTurnOnAnimationsPacingControl, _super);

  SystemTestsCommandTurnOnAnimationsPacingControl.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOnAnimationsPacingControl();
  };

  function SystemTestsCommandTurnOnAnimationsPacingControl(systemTestsRecorderAndPlayer) {
    SystemTestsCommandTurnOnAnimationsPacingControl.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandTurnOnAnimationsPacingControl";
  }

  SystemTestsCommandTurnOnAnimationsPacingControl.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandTurnOnAnimationsPacingControl extends SystemTestsCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOnAnimationsPacingControl()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandTurnOnAnimationsPacingControl"';

  return SystemTestsCommandTurnOnAnimationsPacingControl;

})(SystemTestsCommand);

SystemTestsCommandTurnOnHidingOfMorphsContentExtractInLabels = (function(_super) {
  __extends(SystemTestsCommandTurnOnHidingOfMorphsContentExtractInLabels, _super);

  SystemTestsCommandTurnOnHidingOfMorphsContentExtractInLabels.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOnHidingOfMorphsContentExtractInLabels();
  };

  function SystemTestsCommandTurnOnHidingOfMorphsContentExtractInLabels(systemTestsRecorderAndPlayer) {
    SystemTestsCommandTurnOnHidingOfMorphsContentExtractInLabels.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandTurnOnHidingOfMorphsContentExtractInLabels";
  }

  SystemTestsCommandTurnOnHidingOfMorphsContentExtractInLabels.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandTurnOnHidingOfMorphsContentExtractInLabels extends SystemTestsCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOnHidingOfMorphsContentExtractInLabels()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandTurnOnHidingOfMorphsContentExtractInLabels"';

  return SystemTestsCommandTurnOnHidingOfMorphsContentExtractInLabels;

})(SystemTestsCommand);

SystemTestsCommandTurnOnHidingOfMorphsGeometryInfoInLabels = (function(_super) {
  __extends(SystemTestsCommandTurnOnHidingOfMorphsGeometryInfoInLabels, _super);

  SystemTestsCommandTurnOnHidingOfMorphsGeometryInfoInLabels.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOnHidingOfMorphsGeometryInfoInLabels();
  };

  function SystemTestsCommandTurnOnHidingOfMorphsGeometryInfoInLabels(systemTestsRecorderAndPlayer) {
    SystemTestsCommandTurnOnHidingOfMorphsGeometryInfoInLabels.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandTurnOnHidingOfMorphsGeometryInfoInLabels";
  }

  SystemTestsCommandTurnOnHidingOfMorphsGeometryInfoInLabels.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandTurnOnHidingOfMorphsGeometryInfoInLabels extends SystemTestsCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOnHidingOfMorphsGeometryInfoInLabels()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandTurnOnHidingOfMorphsGeometryInfoInLabels"';

  return SystemTestsCommandTurnOnHidingOfMorphsGeometryInfoInLabels;

})(SystemTestsCommand);

SystemTestsCommandTurnOnHidingOfMorphsNumberIDInLabels = (function(_super) {
  __extends(SystemTestsCommandTurnOnHidingOfMorphsNumberIDInLabels, _super);

  SystemTestsCommandTurnOnHidingOfMorphsNumberIDInLabels.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOnHidingOfMorphsNumberIDInLabels();
  };

  function SystemTestsCommandTurnOnHidingOfMorphsNumberIDInLabels(systemTestsRecorderAndPlayer) {
    SystemTestsCommandTurnOnHidingOfMorphsNumberIDInLabels.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.testCommandName = "SystemTestsCommandTurnOnHidingOfMorphsNumberIDInLabels";
  }

  SystemTestsCommandTurnOnHidingOfMorphsNumberIDInLabels.coffeeScriptSourceOfThisClass = '# \n\n\nclass SystemTestsCommandTurnOnHidingOfMorphsNumberIDInLabels extends SystemTestsCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOnHidingOfMorphsNumberIDInLabels()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @testCommandName = "SystemTestsCommandTurnOnHidingOfMorphsNumberIDInLabels"';

  return SystemTestsCommandTurnOnHidingOfMorphsNumberIDInLabels;

})(SystemTestsCommand);

SystemTestsControlPanelUpdater = (function() {
  SystemTestsControlPanelUpdater.prototype.SystemTestsControlPanelDiv = null;

  SystemTestsControlPanelUpdater.SystemTestsControlPanelOutputConsoleDiv = null;

  SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole = function(theText) {
    return SystemTestsControlPanelUpdater.SystemTestsControlPanelOutputConsoleDiv.innerHTML = SystemTestsControlPanelUpdater.SystemTestsControlPanelOutputConsoleDiv.innerHTML + theText + "</br>";
  };

  SystemTestsControlPanelUpdater.addMessageToTestCommentsConsole = function(theText) {
    return SystemTestsControlPanelUpdater.SystemTestsControlPanelTestCommentsOutputConsoleDiv.innerHTML = SystemTestsControlPanelUpdater.SystemTestsControlPanelTestCommentsOutputConsoleDiv.innerHTML + theText + "</br>";
  };

  SystemTestsControlPanelUpdater.prototype.addLink = function(theText, theFunction) {
    var aTag, br;
    aTag = document.createElement("a");
    aTag.setAttribute("href", "#");
    aTag.innerHTML = theText;
    aTag.onclick = theFunction;
    this.SystemTestsControlPanelDiv.appendChild(aTag);
    br = document.createElement('br');
    return this.SystemTestsControlPanelDiv.appendChild(br);
  };

  SystemTestsControlPanelUpdater.prototype.addOnOffSwitchLink = function(theText, onShortcut, offShortcut, onAction, offAction) {
    var aLittleSpacerSpan, aLittleSpan, br, offLinkElement, onLinkElement;
    aLittleSpan = document.createElement("span");
    aLittleSpan.innerHTML = theText + " ";
    aLittleSpacerSpan = document.createElement("span");
    aLittleSpacerSpan.innerHTML = " ";
    onLinkElement = document.createElement("a");
    onLinkElement.setAttribute("href", "#");
    onLinkElement.innerHTML = "on:" + onShortcut;
    onLinkElement.onclick = onAction;
    offLinkElement = document.createElement("a");
    offLinkElement.setAttribute("href", "#");
    offLinkElement.innerHTML = "off:" + offShortcut;
    offLinkElement.onclick = offAction;
    this.SystemTestsControlPanelDiv.appendChild(aLittleSpan);
    this.SystemTestsControlPanelDiv.appendChild(onLinkElement);
    this.SystemTestsControlPanelDiv.appendChild(aLittleSpacerSpan);
    this.SystemTestsControlPanelDiv.appendChild(offLinkElement);
    br = document.createElement('br');
    return this.SystemTestsControlPanelDiv.appendChild(br);
  };

  SystemTestsControlPanelUpdater.prototype.addOutputPanel = function(nameOfPanel) {
    SystemTestsControlPanelUpdater[nameOfPanel] = document.createElement('div');
    SystemTestsControlPanelUpdater[nameOfPanel].id = nameOfPanel;
    SystemTestsControlPanelUpdater[nameOfPanel].style.cssText = 'height: 150px; border: 1px solid red; overflow: hidden; overflow-y: scroll;';
    return document.body.appendChild(SystemTestsControlPanelUpdater[nameOfPanel]);
  };

  function SystemTestsControlPanelUpdater() {
    var theCanvasDiv;
    this.SystemTestsControlPanelDiv = document.createElement('div');
    this.SystemTestsControlPanelDiv.id = "SystemTestsControlPanel";
    this.SystemTestsControlPanelDiv.style.cssText = 'border: 1px solid green; overflow: hidden;';
    document.body.appendChild(this.SystemTestsControlPanelDiv);
    this.addOutputPanel("SystemTestsControlPanelOutputConsoleDiv");
    this.addOutputPanel("SystemTestsControlPanelTestCommentsOutputConsoleDiv");
    theCanvasDiv = document.getElementById('world');
    theCanvasDiv.style.styleFloat = 'left';
    theCanvasDiv.style.cssFloat = 'left';
    this.addLink("alt+d: reset world", (function() {
      return window.world.systemTestsRecorderAndPlayer.resetWorld();
    }));
    this.addOnOffSwitchLink("tie animations to test step", "alt+e", "alt+u", (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOnAnimationsPacingControl();
    }), (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl();
    }));
    this.addOnOffSwitchLink("periodically align Morph IDs", "-", "-", (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOnAlignmentOfMorphIDsMechanism();
    }), (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOffAlignmentOfMorphIDsMechanism();
    }));
    this.addOnOffSwitchLink("hide Morph geometry in labels", "-", "-", (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOnHidingOfMorphsGeometryInfoInLabels();
    }), (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsGeometryInfoInLabels();
    }));
    this.addOnOffSwitchLink("hide Morph content extract in labels", "-", "-", (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOnHidingOfMorphsContentExtractInLabels();
    }), (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsContentExtractInLabels();
    }));
    this.addOnOffSwitchLink("hide Morph number ID in labels", "-", "-", (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOnHidingOfMorphsNumberIDInLabels();
    }), (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsNumberIDInLabels();
    }));
    this.addLink("alt+c: take screenshot", (function() {
      return window.world.systemTestsRecorderAndPlayer.takeScreenshot();
    }));
    this.addLink("alt+k: check number of items in menu", (function() {
      return window.world.systemTestsRecorderAndPlayer.checkNumberOfItemsInMenu();
    }));
    this.addLink("alt+a: check menu entries (in order)", (function() {
      return window.world.systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderImportant();
    }));
    this.addLink("alt+z: check menu entries (any order)", (function() {
      return window.world.systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderUnimportant();
    }));
    this.addLink("alt+m: add test comment", (function() {
      return window.world.systemTestsRecorderAndPlayer.addTestComment();
    }));
    this.addLink("alt+t: stop test recording", (function() {
      return window.world.systemTestsRecorderAndPlayer.stopTestRecording();
    }));
  }

  SystemTestsControlPanelUpdater.coffeeScriptSourceOfThisClass = '# Manages the controls of the System Tests\n# e.g. all the links/buttons to trigger commands\n# when recording tests such as\n#  - start recording tests\n#  - stop recording tests\n#  - take screenshot\n#  - save test files\n#  - place the mouse over a morph with particular ID...\n\n\nclass SystemTestsControlPanelUpdater\n\n  # Create the div where the controls will go\n  # and make it float to the right of the canvas.\n  # This requires tweaking the css of the canvas\n  # as well.\n\n  SystemTestsControlPanelDiv: null\n  @SystemTestsControlPanelOutputConsoleDiv: null\n\n  @addMessageToSystemTestsConsole: (theText) ->\n    SystemTestsControlPanelUpdater.SystemTestsControlPanelOutputConsoleDiv.innerHTML = SystemTestsControlPanelUpdater.SystemTestsControlPanelOutputConsoleDiv.innerHTML + theText + "</br>";\n\n  @addMessageToTestCommentsConsole: (theText) ->\n    SystemTestsControlPanelUpdater.SystemTestsControlPanelTestCommentsOutputConsoleDiv.innerHTML = SystemTestsControlPanelUpdater.SystemTestsControlPanelTestCommentsOutputConsoleDiv.innerHTML + theText + "</br>";\n\n  addLink: (theText, theFunction) ->\n    aTag = document.createElement("a")\n    aTag.setAttribute "href", "#"\n    aTag.innerHTML = theText\n    aTag.onclick = theFunction\n    @SystemTestsControlPanelDiv.appendChild aTag\n    br = document.createElement(\'br\')\n    @SystemTestsControlPanelDiv.appendChild(br);\n\n  addOnOffSwitchLink: (theText, onShortcut, offShortcut, onAction, offAction) ->\n    #aLittleDiv = document.createElement("div")\n    \n    aLittleSpan = document.createElement("span")\n    aLittleSpan.innerHTML = theText + " "\n\n    aLittleSpacerSpan = document.createElement("span")\n    aLittleSpacerSpan.innerHTML = " "\n\n    onLinkElement = document.createElement("a")\n    onLinkElement.setAttribute "href", "#"\n    onLinkElement.innerHTML = "on:"+onShortcut\n    onLinkElement.onclick = onAction\n\n    offLinkElement = document.createElement("a")\n    offLinkElement.setAttribute "href", "#"\n    offLinkElement.innerHTML = "off:"+offShortcut\n    offLinkElement.onclick = offAction\n\n    @SystemTestsControlPanelDiv.appendChild aLittleSpan\n    @SystemTestsControlPanelDiv.appendChild onLinkElement\n    @SystemTestsControlPanelDiv.appendChild aLittleSpacerSpan\n    @SystemTestsControlPanelDiv.appendChild offLinkElement\n\n    br = document.createElement(\'br\')\n    @SystemTestsControlPanelDiv.appendChild(br);\n\n  addOutputPanel: (nameOfPanel) ->\n    SystemTestsControlPanelUpdater[nameOfPanel] = document.createElement(\'div\')\n    SystemTestsControlPanelUpdater[nameOfPanel].id = nameOfPanel\n    SystemTestsControlPanelUpdater[nameOfPanel].style.cssText = \'height: 150px; border: 1px solid red; overflow: hidden; overflow-y: scroll;\'\n    document.body.appendChild(SystemTestsControlPanelUpdater[nameOfPanel])\n\n  constructor: ->\n    @SystemTestsControlPanelDiv = document.createElement(\'div\')\n    @SystemTestsControlPanelDiv.id = "SystemTestsControlPanel"\n    @SystemTestsControlPanelDiv.style.cssText = \'border: 1px solid green; overflow: hidden;\'\n    document.body.appendChild(@SystemTestsControlPanelDiv)\n\n    @addOutputPanel "SystemTestsControlPanelOutputConsoleDiv"\n    @addOutputPanel "SystemTestsControlPanelTestCommentsOutputConsoleDiv"\n\n    theCanvasDiv = document.getElementById(\'world\')\n    # one of these is for IE and the other one\n    # for everybody else\n    theCanvasDiv.style.styleFloat = \'left\';\n    theCanvasDiv.style.cssFloat = \'left\';\n\n    # The spirit of these links is that it would\n    # be really inconvenient to trigger\n    # these commands using menus during the test.\n    # For example it would be inconvenient to stop\n    # the tests recording by selecting the command\n    # via e menu: a bunch of mouse actions would be\n    # recorded, exposing as well to the risk of the\n    # menu items changing.\n    @addLink "alt+d: reset world", (-> window.world.systemTestsRecorderAndPlayer.resetWorld())\n    @addOnOffSwitchLink "tie animations to test step", "alt+e", "alt+u", (-> window.world.systemTestsRecorderAndPlayer.turnOnAnimationsPacingControl()), (-> window.world.systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl())\n    @addOnOffSwitchLink "periodically align Morph IDs", "-", "-", (-> window.world.systemTestsRecorderAndPlayer.turnOnAlignmentOfMorphIDsMechanism()), (-> window.world.systemTestsRecorderAndPlayer.turnOffAlignmentOfMorphIDsMechanism())\n    @addOnOffSwitchLink "hide Morph geometry in labels", "-", "-", (-> window.world.systemTestsRecorderAndPlayer.turnOnHidingOfMorphsGeometryInfoInLabels()), (-> window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsGeometryInfoInLabels())\n\n    @addOnOffSwitchLink "hide Morph content extract in labels", "-", "-", (-> window.world.systemTestsRecorderAndPlayer.turnOnHidingOfMorphsContentExtractInLabels()), (-> window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsContentExtractInLabels())\n\n    @addOnOffSwitchLink "hide Morph number ID in labels", "-", "-", (-> window.world.systemTestsRecorderAndPlayer.turnOnHidingOfMorphsNumberIDInLabels()), (-> window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsNumberIDInLabels())\n\n    @addLink "alt+c: take screenshot", (-> window.world.systemTestsRecorderAndPlayer.takeScreenshot())\n    @addLink "alt+k: check number of items in menu", (-> window.world.systemTestsRecorderAndPlayer.checkNumberOfItemsInMenu())\n    @addLink "alt+a: check menu entries (in order)", (-> window.world.systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderImportant())\n    @addLink "alt+z: check menu entries (any order)", (-> window.world.systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderUnimportant())\n    @addLink "alt+m: add test comment", (-> window.world.systemTestsRecorderAndPlayer.addTestComment())\n    @addLink "alt+t: stop test recording", (-> window.world.systemTestsRecorderAndPlayer.stopTestRecording())\n    \n\n\n\n    ';

  return SystemTestsControlPanelUpdater;

})();

SystemTestsReferenceImage = (function() {
  var fileName;

  SystemTestsReferenceImage.prototype.imageName = '';

  SystemTestsReferenceImage.prototype.imageData = '';

  SystemTestsReferenceImage.prototype.systemInfo = null;

  SystemTestsReferenceImage.prototype.hashOfData = 0;

  SystemTestsReferenceImage.prototype.hashOfSystemInfo = 0;

  fileName = '';

  function SystemTestsReferenceImage(imageName, imageData, systemInfo) {
    this.imageName = imageName;
    this.imageData = imageData;
    this.systemInfo = systemInfo;
    this.hashOfData = HashCalculator.calculateHash(this.imageData);
    this.hashOfSystemInfo = HashCalculator.calculateHash(JSON.stringify(this.systemInfo));
    this.fileName = this.imageName + "-systemInfoHash" + this.hashOfSystemInfo + "-dataHash" + this.hashOfData;
  }

  SystemTestsReferenceImage.prototype.createJSContent = function() {
    return "if (!SystemTestsRecorderAndPlayer.loadedImages.hasOwnProperty('" + this.imageName + "')) { " + "SystemTestsRecorderAndPlayer.loadedImages." + this.imageName + ' = []; } ' + "SystemTestsRecorderAndPlayer.loadedImages." + this.imageName + '.push(' + JSON.stringify(this) + ');';
  };

  SystemTestsReferenceImage.prototype.addToZipAsJS = function(zip) {
    return zip.file(this.fileName + ".js", this.createJSContent());
  };

  SystemTestsReferenceImage.prototype.addToZipAsJSIgnoringItsAnObtained = function(zip) {
    return zip.file(this.fileName + ".js", this.createJSContent().replace(/obtained-/g, ""));
  };

  SystemTestsReferenceImage.prototype.addToZipAsPNG = function(zip) {
    return zip.file(this.fileName + ".png", this.imageData.replace(/^data:image\/png;base64,/, ""), {
      base64: true
    });
  };

  SystemTestsReferenceImage.coffeeScriptSourceOfThisClass = '# Holds image data and metadata.\n# These images are saved as javascript files\n# and are used to test the actual rendering\n# on screen (or parts of it)\n\n# REQUIRES HashCalculator\n\nclass SystemTestsReferenceImage\n  imageName: \'\'\n  # the image data as string, like\n  # e.g. "data:image/png;base64,iVBORw0KGgoAA..."\n  imageData: \'\'\n  systemInfo: null\n  hashOfData: 0\n  hashOfSystemInfo: 0\n  fileName = \'\'\n\n  constructor: (@imageName, @imageData, @systemInfo) ->\n    @hashOfData = HashCalculator.calculateHash(@imageData)\n    @hashOfSystemInfo = HashCalculator.calculateHash(JSON.stringify(@systemInfo))\n\n    # The filenames contain the test name and the image "number"\n    # AND hashes of data and metadata. This is because the same\n    # test/step might have different images for different\n    # OSs/browsers, so they all must be different files.\n    # The js files contain directly the code to load the image.\n    # There can be multiple files for the same image, since\n    # the images vary according to OS and Browser, so for\n    # each image of each test there is an array of files.\n    # No extension added, cause we are going to\n    # generate both png and js files.\n    @fileName = @imageName + "-systemInfoHash" + @hashOfSystemInfo + "-dataHash" + @hashOfData\n\n  createJSContent: ->\n  	  return "if (!SystemTestsRecorderAndPlayer.loadedImages.hasOwnProperty(\'" + @imageName + "\')) { " + "SystemTestsRecorderAndPlayer.loadedImages." + @imageName + \' = []; } \' + "SystemTestsRecorderAndPlayer.loadedImages." + @imageName + \'.push(\' + JSON.stringify(@) + \');\'\n\n  addToZipAsJS: (zip) ->\n  	zip.file(\n  	  @fileName + ".js",\n  	  @createJSContent()\n  	)\n\n  # This method does the same of the one above\n  # but it eliminates the "obtained-" text everywhere\n  # in the content. In this way, the file can just\n  # be renamed and can be added to the tests together\n  # with all the other "good screenshots"\n  # right away withouth having to open it and doing\n  # the change manually.\n  addToZipAsJSIgnoringItsAnObtained: (zip) ->\n  	zip.file(\n  	  @fileName + ".js",\n  	  @createJSContent().replace(/obtained-/g,"")\n  	)\n\n  addToZipAsPNG: (zip) ->\n    # the imageData string contains a little bit of string\n    # that we need to strip out before the base64-encoded png data\n    zip.file(\n      @fileName + ".png",\n      @imageData.replace(/^data:image\/png;base64,/, ""), {base64: true}\n    )';

  return SystemTestsReferenceImage;

})();

SystemTestsSystemInfo = (function(_super) {
  __extends(SystemTestsSystemInfo, _super);

  SystemTestsSystemInfo.prototype.SystemTestsHarnessVersionMajor = null;

  SystemTestsSystemInfo.prototype.SystemTestsHarnessVersionMinor = null;

  SystemTestsSystemInfo.prototype.SystemTestsHarnessVersionRelease = null;

  function SystemTestsSystemInfo() {
    SystemTestsSystemInfo.__super__.constructor.call(this);
    this.SystemTestsHarnessVersionMajor = 0;
    this.SystemTestsHarnessVersionMinor = 1;
    this.SystemTestsHarnessVersionRelease = 0;
  }

  SystemTestsSystemInfo.coffeeScriptSourceOfThisClass = '# Holds information about browser and machine\n# Note that some of these could\n# change during user session.\n\nclass SystemTestsSystemInfo extends SystemInfo\n  # cannot just initialise the numbers here\n  # cause we are going to make a JSON\n  # out of this and these would not\n  # be picked up.\n  SystemTestsHarnessVersionMajor: null\n  SystemTestsHarnessVersionMinor: null\n  SystemTestsHarnessVersionRelease: null\n\n  constructor: ->\n    super()\n    @SystemTestsHarnessVersionMajor = 0\n    @SystemTestsHarnessVersionMinor = 1\n    @SystemTestsHarnessVersionRelease = 0';

  return SystemTestsSystemInfo;

})(SystemInfo);

SystemTestsRecorderAndPlayer = (function() {
  SystemTestsRecorderAndPlayer.prototype.testCommandsSequence = [];

  SystemTestsRecorderAndPlayer.RECORDING = 0;

  SystemTestsRecorderAndPlayer.PLAYING = 1;

  SystemTestsRecorderAndPlayer.IDLE = 2;

  SystemTestsRecorderAndPlayer.state = 2;

  SystemTestsRecorderAndPlayer.prototype.playingAllSystemTests = false;

  SystemTestsRecorderAndPlayer.prototype.indexOfSystemTestBeingPlayed = 0;

  SystemTestsRecorderAndPlayer.prototype.timeOfPreviouslyRecordedCommand = null;

  SystemTestsRecorderAndPlayer.prototype.handMorph = null;

  SystemTestsRecorderAndPlayer.prototype.worldMorph = null;

  SystemTestsRecorderAndPlayer.prototype.collectedImages = [];

  SystemTestsRecorderAndPlayer.prototype.collectedFailureImages = [];

  SystemTestsRecorderAndPlayer.prototype.testName = '';

  SystemTestsRecorderAndPlayer.prototype.testDescription = 'no description';

  SystemTestsRecorderAndPlayer.loadedImages = {};

  SystemTestsRecorderAndPlayer.prototype.ongoingTestPlayingTask = null;

  SystemTestsRecorderAndPlayer.prototype.timeOfPreviouslyPlayedCommand = 0;

  SystemTestsRecorderAndPlayer.prototype.indexOfTestCommandBeingPlayedFromSequence = 0;

  SystemTestsRecorderAndPlayer.animationsPacingControl = false;

  SystemTestsRecorderAndPlayer.alignmentOfMorphIDsMechanism = false;

  SystemTestsRecorderAndPlayer.hidingOfMorphsGeometryInfoInLabels = false;

  SystemTestsRecorderAndPlayer.hidingOfMorphsNumberIDInLabels = false;

  SystemTestsRecorderAndPlayer.hidingOfMorphsContentExtractInLabels = false;

  SystemTestsRecorderAndPlayer.prototype.imageDataOfAParticularMorph = null;

  SystemTestsRecorderAndPlayer.prototype.lastMouseDownCommand = null;

  SystemTestsRecorderAndPlayer.prototype.lastMouseUpCommand = null;

  function SystemTestsRecorderAndPlayer(worldMorph, handMorph) {
    this.worldMorph = worldMorph;
    this.handMorph = handMorph;
  }

  SystemTestsRecorderAndPlayer.prototype.clearAnyDataRelatedToTest = function(testName) {
    var imageNumber, _i;
    for (imageNumber = _i = 0; _i < 100; imageNumber = ++_i) {
      console.log("deleting SystemTest_" + this.testName + "_image_" + imageNumber);
      delete SystemTestsRecorderAndPlayer.loadedImages["SystemTest_" + this.testName + "_image_" + imageNumber];
    }
    console.log("deleting SystemTest_" + this.testName);
    return delete window["SystemTest_" + this.testName];
  };

  SystemTestsRecorderAndPlayer.prototype.startTestRecording = function(testName, testDescription) {
    this.testName = testName;
    this.testDescription = testDescription;
    if (this.testName == null) {
      this.testName = prompt("Please enter a test name", "test1");
    }
    if (this.testDescription == null) {
      this.testDescription = prompt("Please enter a test description", "no description");
    }
    this.clearAnyDataRelatedToTest(this.testName);
    this.testCommandsSequence = [];
    this.timeOfPreviouslyRecordedCommand = new Date().getTime();
    return SystemTestsRecorderAndPlayer.state = SystemTestsRecorderAndPlayer.RECORDING;
  };

  SystemTestsRecorderAndPlayer.prototype.stopTestRecording = function() {
    return SystemTestsRecorderAndPlayer.state = SystemTestsRecorderAndPlayer.IDLE;
  };

  SystemTestsRecorderAndPlayer.prototype.stopTestPlaying = function() {
    var indexOfTask;
    console.log("wrapping up the playing of the test");
    SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole("test complete");
    SystemTestsRecorderAndPlayer.state = SystemTestsRecorderAndPlayer.IDLE;
    indexOfTask = this.worldMorph.otherTasksToBeRunOnStep.indexOf(this.ongoingTestPlayingTask);
    this.worldMorph.otherTasksToBeRunOnStep.splice(indexOfTask, 1);
    this.worldMorph.initEventListeners();
    this.indexOfTestCommandBeingPlayedFromSequence = 0;
    if (this.playingAllSystemTests) {
      return this.runNextSystemTest();
    }
  };

  SystemTestsRecorderAndPlayer.prototype.showTestSource = function() {
    return window.open("data:text/text;charset=utf-8," + encodeURIComponent(JSON.stringify(this.testCommandsSequence, null, 4)));
  };

  SystemTestsRecorderAndPlayer.prototype.turnOnAnimationsPacingControl = function() {
    var systemTestCommand;
    this.constructor.animationsPacingControl = true;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandTurnOnAnimationsPacingControl(this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.turnOffAnimationsPacingControl = function() {
    var systemTestCommand;
    this.constructor.animationsPacingControl = false;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandTurnOffAnimationsPacingControl(this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.turnOnAlignmentOfMorphIDsMechanism = function() {
    var systemTestCommand;
    this.constructor.alignmentOfMorphIDsMechanism = true;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandTurnOnAlignmentOfMorphIDsMechanism(this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.turnOffAlignmentOfMorphIDsMechanism = function() {
    var systemTestCommand;
    this.constructor.alignmentOfMorphIDsMechanism = false;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandTurnOffAlignmentOfMorphIDsMechanism(this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.turnOnHidingOfMorphsGeometryInfoInLabels = function() {
    var systemTestCommand;
    this.constructor.hidingOfMorphsGeometryInfoInLabels = true;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandTurnOnHidingOfMorphsGeometryInfoInLabels(this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.turnOffHidingOfMorphsGeometryInfoInLabels = function() {
    var systemTestCommand;
    this.constructor.hidingOfMorphsGeometryInfoInLabels = false;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandTurnOffHidingOfMorphsGeometryInfoInLabels(this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.turnOnHidingOfMorphsContentExtractInLabels = function() {
    var systemTestCommand;
    this.constructor.hidingOfMorphsContentExtractInLabels = true;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandTurnOnHidingOfMorphsContentExtractInLabels(this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.turnOffHidingOfMorphsContentExtractInLabels = function() {
    var systemTestCommand;
    this.constructor.hidingOfMorphsContentExtractInLabels = false;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandTurnOffHidingOfMorphsContentExtractInLabels(this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.turnOnHidingOfMorphsNumberIDInLabels = function() {
    var systemTestCommand;
    this.constructor.hidingOfMorphsNumberIDInLabels = true;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandTurnOnHidingOfMorphsNumberIDInLabels(this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.turnOffHidingOfMorphsNumberIDInLabels = function() {
    var systemTestCommand;
    this.constructor.hidingOfMorphsNumberIDInLabels = false;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandTurnOffHidingOfMorphsNumberIDInLabels(this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.addMouseMoveCommand = function(pageX, pageY) {
    var systemTestCommand;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandMouseMove(pageX, pageY, this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.addMouseDownCommand = function(button, ctrlKey) {
    var systemTestCommand;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandMouseDown(button, ctrlKey, this);
    this.lastMouseDownCommand = systemTestCommand;
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.addOpenContextMenuCommand = function(context) {
    var systemTestCommand;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    this.removeLastMouseUpAndMouseDownCommands();
    systemTestCommand = new SystemTestsCommandOpenContextMenu(context, this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.addCommandLeftOrRightClickOnMenuItem = function(mouseButton, labelString, occurrenceNumber) {
    var systemTestCommand;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    this.removeLastMouseUpAndMouseDownCommands();
    systemTestCommand = new SystemTestsCommandLeftOrRightClickOnMenuItem(mouseButton, labelString, occurrenceNumber, this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.addMouseUpCommand = function() {
    var systemTestCommand;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandMouseUp(this);
    this.lastMouseUpCommand = systemTestCommand;
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.removeLastMouseUpAndMouseDownCommands = function() {
    this.lastMouseDownCommand.transformIntoDoNothingCommand();
    return this.lastMouseUpCommand.transformIntoDoNothingCommand();
  };

  SystemTestsRecorderAndPlayer.prototype.addKeyPressCommand = function(charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) {
    var systemTestCommand;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandKeyPress(charCode, symbol, shiftKey, ctrlKey, altKey, metaKey, this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.addKeyDownCommand = function(scanCode, shiftKey, ctrlKey, altKey, metaKey) {
    var systemTestCommand;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandKeyDown(scanCode, shiftKey, ctrlKey, altKey, metaKey, this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.addKeyUpCommand = function(scanCode, shiftKey, ctrlKey, altKey, metaKey) {
    var systemTestCommand;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandKeyUp(scanCode, shiftKey, ctrlKey, altKey, metaKey, this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.addCopyCommand = function() {
    var systemTestCommand;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandCopy(this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.addPasteCommand = function(clipboardText) {
    var systemTestCommand;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandPaste(clipboardText, this);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.resetWorld = function() {
    var systemTestCommand;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new SystemTestsCommandResetWorld(this);
    window[systemTestCommand.testCommandName].replayFunction(this, null);
    this.testCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  SystemTestsRecorderAndPlayer.prototype.addTestComment = function() {
    var comment, systemTestCommand;
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return;
    }
    this.timeOfPreviouslyRecordedCommand = new Date().getTime();
    comment = prompt("enter comment", "your comment here");
    systemTestCommand = new SystemTestsCommandShowComment(comment, this);
    return this.testCommandsSequence.push(systemTestCommand);
  };

  SystemTestsRecorderAndPlayer.prototype.checkStringsOfItemsInMenuOrderImportant = function(stringOfItemsInMenuInOriginalOrder) {
    return this.checkStringsOfItemsInMenu(stringOfItemsInMenuInOriginalOrder, true);
  };

  SystemTestsRecorderAndPlayer.prototype.checkStringsOfItemsInMenuOrderUnimportant = function(stringOfItemsInMenuInOriginalOrder) {
    return this.checkStringsOfItemsInMenu(stringOfItemsInMenuInOriginalOrder, false);
  };

  SystemTestsRecorderAndPlayer.prototype.checkStringsOfItemsInMenu = function(stringOfItemsInMenuInOriginalOrder, orderMatters) {
    var copyOfstringOfItemsInMenuInOriginalOrder, eachMenuItem, giveError, giveSuccess, itemNumber, menuAtPointer, menuListIsSame, stringOfItemsInCurrentMenuInOriginalOrder, systemTestCommand, _i, _j, _len, _ref, _ref1;
    console.log("checkStringsOfItemsInMenu");
    menuAtPointer = this.handMorph.menuAtPointer();
    console.log(menuAtPointer);
    stringOfItemsInCurrentMenuInOriginalOrder = [];
    if (menuAtPointer != null) {
      _ref = menuAtPointer.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        eachMenuItem = _ref[_i];
        stringOfItemsInCurrentMenuInOriginalOrder.push(eachMenuItem[0]);
      }
    } else {
      console.log("FAIL was expecting a menu under the pointer");
      if (SystemTestsControlPanelUpdater != null) {
        SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole(errorMessage);
      }
      this.stopTestPlaying();
    }
    if (SystemTestsRecorderAndPlayer.state === SystemTestsRecorderAndPlayer.RECORDING) {
      if (orderMatters) {
        systemTestCommand = new SystemTestsCommandCheckStringsOfItemsInMenuOrderImportant(stringOfItemsInCurrentMenuInOriginalOrder, this);
      } else {
        systemTestCommand = new SystemTestsCommandCheckStringsOfItemsInMenuOrderUnimportant(stringOfItemsInCurrentMenuInOriginalOrder, this);
      }
      this.testCommandsSequence.push(systemTestCommand);
      return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
    } else if (SystemTestsRecorderAndPlayer.state === SystemTestsRecorderAndPlayer.PLAYING) {
      giveSuccess = (function(_this) {
        return function() {
          var message;
          if (orderMatters) {
            message = "PASS Strings in menu are same and in same order";
          } else {
            message = "PASS Strings in menu are same (not considering order)";
          }
          if (SystemTestsControlPanelUpdater != null) {
            return SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole(message);
          }
        };
      })(this);
      giveError = (function(_this) {
        return function() {
          var errorMessage;
          if (orderMatters) {
            errorMessage = "FAIL Strings in menu doesn't match or order is incorrect. Was expecting: " + stringOfItemsInMenuInOriginalOrder + " found: " + stringOfItemsInCurrentMenuInOriginalOrder;
          } else {
            errorMessage = "FAIL Strings in menu doesn't match (even not considering order). Was expecting: " + stringOfItemsInMenuInOriginalOrder + " found: " + stringOfItemsInCurrentMenuInOriginalOrder;
          }
          if (SystemTestsControlPanelUpdater != null) {
            SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole(errorMessage);
          }
          return _this.stopTestPlaying();
        };
      })(this);
      menuListIsSame = true;
      copyOfstringOfItemsInMenuInOriginalOrder = arrayShallowCopy(stringOfItemsInMenuInOriginalOrder);
      if (!orderMatters) {
        stringOfItemsInCurrentMenuInOriginalOrder.sort();
        copyOfstringOfItemsInMenuInOriginalOrder.sort();
      }
      if (stringOfItemsInCurrentMenuInOriginalOrder.length === copyOfstringOfItemsInMenuInOriginalOrder.length) {
        for (itemNumber = _j = 0, _ref1 = copyOfstringOfItemsInMenuInOriginalOrder.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; itemNumber = 0 <= _ref1 ? ++_j : --_j) {
          if (copyOfstringOfItemsInMenuInOriginalOrder[itemNumber] !== stringOfItemsInCurrentMenuInOriginalOrder[itemNumber]) {
            menuListIsSame = false;
            console.log(copyOfstringOfItemsInMenuInOriginalOrder[itemNumber] + " != " + stringOfItemsInCurrentMenuInOriginalOrder[itemNumber] + " at " + itemNumber);
          }
        }
      } else {
        menuListIsSame = false;
      }
      if (menuListIsSame) {
        return giveSuccess();
      } else {
        return giveError();
      }
    }
  };

  SystemTestsRecorderAndPlayer.prototype.checkNumberOfItemsInMenu = function(numberOfItems) {
    var giveError, giveSuccess, menuAtPointer, systemTestCommand;
    if (SystemTestsRecorderAndPlayer.state === SystemTestsRecorderAndPlayer.RECORDING) {
      menuAtPointer = this.handMorph.menuAtPointer();
      console.log(menuAtPointer);
      if (menuAtPointer != null) {
        numberOfItems = menuAtPointer.items.length;
        console.log("found " + numberOfItems + " number of items ");
      } else {
        console.log("was expecting a menu under the pointer");
        numberOfItems = 0;
      }
      systemTestCommand = new SystemTestsCommandCheckNumberOfItemsInMenu(numberOfItems, this);
      this.testCommandsSequence.push(systemTestCommand);
      return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
    } else if (SystemTestsRecorderAndPlayer.state === SystemTestsRecorderAndPlayer.PLAYING) {
      menuAtPointer = this.handMorph.menuAtPointer();
      giveSuccess = (function(_this) {
        return function() {
          var message;
          message = "PASS Number of items in menu matches. Note that count includes line separators. Found: " + menuAtPointer.items.length;
          if (SystemTestsControlPanelUpdater != null) {
            return SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole(message);
          }
        };
      })(this);
      giveError = (function(_this) {
        return function() {
          var errorMessage;
          errorMessage = "FAIL Number of items in menu doesn't match. Note that count includes line separators. Was expecting: " + numberOfItems + " found: " + menuAtPointer.items.length;
          if (SystemTestsControlPanelUpdater != null) {
            SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole(errorMessage);
          }
          return _this.stopTestPlaying();
        };
      })(this);
      if (menuAtPointer != null) {
        if (numberOfItems !== menuAtPointer.items.length) {
          return giveError();
        } else {
          return giveSuccess();
        }
      } else {
        return giveError();
      }
    }
  };

  SystemTestsRecorderAndPlayer.prototype.takeScreenshot = function(whichMorph) {
    var destCanvas, destCtx, fullExtentOfMorph, imageData, imageName, systemTestCommand, takenScreenshot;
    if (whichMorph == null) {
      whichMorph = this.worldMorph;
    }
    console.log("taking screenshot");
    imageName = "SystemTest_" + this.testName + "_image_" + (this.collectedImages.length + 1);
    systemTestCommand = new SystemTestsCommandScreenshot(imageName, this, whichMorph !== this.worldMorph);
    if (whichMorph === this.worldMorph) {
      imageData = world.worldCanvas.toDataURL("image/png");
    } else {
      fullExtentOfMorph = whichMorph.boundsIncludingChildren();
      destCanvas = newCanvas(fullExtentOfMorph.extent().scaleBy(pixelRatio));
      destCtx = destCanvas.getContext('2d');
      destCtx.drawImage(world.worldCanvas, fullExtentOfMorph.topLeft().x * pixelRatio, fullExtentOfMorph.topLeft().y * pixelRatio, fullExtentOfMorph.width() * pixelRatio, fullExtentOfMorph.height() * pixelRatio, 0, 0, fullExtentOfMorph.width() * pixelRatio, fullExtentOfMorph.height() * pixelRatio);
      imageData = destCanvas.toDataURL("image/png");
    }
    takenScreenshot = new SystemTestsReferenceImage(imageName, imageData, new SystemTestsSystemInfo());
    if (SystemTestsRecorderAndPlayer.loadedImages["" + imageName] == null) {
      SystemTestsRecorderAndPlayer.loadedImages["" + imageName] = [];
    }
    SystemTestsRecorderAndPlayer.loadedImages["" + imageName].push(takenScreenshot);
    this.collectedImages.push(takenScreenshot);
    this.testCommandsSequence.push(systemTestCommand);
    this.timeOfPreviouslyRecordedCommand = new Date().getTime();
    if (SystemTestsRecorderAndPlayer.state !== SystemTestsRecorderAndPlayer.RECORDING) {
      return systemTestCommand;
    }
  };

  SystemTestsRecorderAndPlayer.prototype.subtractScreenshots = function(expected, obtained, andThen) {
    var expectedCanvas, expectedImage;
    console.log("subtractScreenshots");
    expectedCanvas = document.createElement("canvas");
    expectedImage = new Image;
    expectedImage.onload = (function(_this) {
      return function() {
        var expectedCanvasContext, expectedImageData, obtainedCanvas, obtainedImage;
        console.log("expectedCanvas.imageData: " + expectedCanvas.imageData);
        expectedCanvas.width = expectedImage.width;
        expectedCanvas.height = expectedImage.height;
        expectedCanvasContext = expectedCanvas.getContext("2d");
        console.log("expectedCanvas.width: " + expectedCanvas.width);
        console.log("expectedCanvas.height: " + expectedCanvas.height);
        expectedCanvasContext.drawImage(expectedImage, 0, 0);
        expectedImageData = expectedCanvasContext.getImageData(0, 0, expectedCanvas.width, expectedCanvas.height);
        obtainedCanvas = document.createElement("canvas");
        obtainedImage = new Image;
        obtainedImage.onload = function() {
          var differentPixels, equalPixels, obtainedCanvasContext, obtainedImageData, subtractionCanvas, subtractionCanvasContext, subtractionImageData;
          obtainedCanvas.width = obtainedImage.width;
          obtainedCanvas.height = obtainedImage.height;
          obtainedCanvasContext = obtainedCanvas.getContext("2d");
          obtainedCanvasContext.drawImage(obtainedImage, 0, 0);
          obtainedImageData = obtainedCanvasContext.getImageData(0, 0, obtainedCanvas.width, obtainedCanvas.height);
          subtractionCanvas = document.createElement("canvas");
          subtractionCanvas.width = obtainedImage.width;
          subtractionCanvas.height = obtainedImage.height;
          subtractionCanvasContext = subtractionCanvas.getContext("2d");
          subtractionCanvasContext.drawImage(obtainedImage, 0, 0);
          subtractionImageData = subtractionCanvasContext.getImageData(0, 0, subtractionCanvas.width, subtractionCanvas.height);
          i = 0;
          equalPixels = 0;
          differentPixels = 0;
          while (i < subtractionImageData.data.length) {
            if (obtainedImageData.data[i] !== expectedImageData.data[i] || obtainedImageData.data[i + 1] !== expectedImageData.data[i + 1] || obtainedImageData.data[i + 2] !== expectedImageData.data[i + 2]) {
              subtractionImageData.data[i] = 255;
              subtractionImageData.data[i + 1] = 0;
              subtractionImageData.data[i + 2] = 0;
              differentPixels++;
            } else {
              equalPixels++;
            }
            i += 4;
          }
          console.log("equalPixels: " + equalPixels);
          console.log("differentPixels: " + differentPixels);
          subtractionCanvasContext.putImageData(subtractionImageData, 0, 0);
          return andThen(subtractionCanvas, expected);
        };
        return obtainedImage.src = obtained.imageData;
      };
    })(this);
    return expectedImage.src = expected.imageData;
  };

  SystemTestsRecorderAndPlayer.prototype.compareScreenshots = function(testNameWithImageNumber, screenshotTakenOfAParticularMorph) {
    var eachImage, message, obtainedImage, obtainedImageName, screenshotObtained, _i, _len, _ref;
    if (screenshotTakenOfAParticularMorph == null) {
      screenshotTakenOfAParticularMorph = false;
    }
    if (screenshotTakenOfAParticularMorph) {
      console.log("comparing pic of a particular morph");
      screenshotObtained = this.imageDataOfAParticularMorph;
      this.imageDataOfAParticularMorph = null;
    } else {
      console.log("comparing pic of whole desktop");
      screenshotObtained = this.worldMorph.fullImageData();
    }
    console.log("trying to match screenshot: " + testNameWithImageNumber);
    console.log("length of obtained: " + screenshotObtained.length);
    _ref = SystemTestsRecorderAndPlayer.loadedImages["" + testNameWithImageNumber];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      eachImage = _ref[_i];
      console.log("length of obtained: " + eachImage.imageData.length);
      if (eachImage.imageData === screenshotObtained) {
        message = "PASS - screenshot " + eachImage.fileName + " matched";
        console.log(message);
        if (SystemTestsControlPanelUpdater != null) {
          SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole(message);
        }
        return;
      }
    }
    message = "FAIL - no screenshots like this one";
    console.log(message);
    if (SystemTestsControlPanelUpdater != null) {
      SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole(message);
    }
    obtainedImageName = "obtained-" + eachImage.imageName;
    obtainedImage = new SystemTestsReferenceImage(obtainedImageName, screenshotObtained, new SystemTestsSystemInfo());
    return this.collectedFailureImages.push(obtainedImage);
  };

  SystemTestsRecorderAndPlayer.prototype.replayTestCommands = function() {
    var commandToBePlayed, timeNow, timeUntilNextCommand;
    timeNow = (new Date()).getTime();
    commandToBePlayed = this.testCommandsSequence[this.indexOfTestCommandBeingPlayedFromSequence];
    timeUntilNextCommand = commandToBePlayed.millisecondsSincePreviousCommand || 0;
    if (commandToBePlayed.testCommandName === "SystemTestsCommandScreenshot" && commandToBePlayed.screenshotTakenOfAParticularMorph) {
      if (this.imageDataOfAParticularMorph == null) {
        return;
      }
    }
    if (timeNow - this.timeOfPreviouslyPlayedCommand >= timeUntilNextCommand) {
      console.log("running command: " + commandToBePlayed.testCommandName + " " + this.indexOfTestCommandBeingPlayedFromSequence + " / " + this.testCommandsSequence.length);
      window[commandToBePlayed.testCommandName].replayFunction.call(this, this, commandToBePlayed);
      this.timeOfPreviouslyPlayedCommand = timeNow;
      this.indexOfTestCommandBeingPlayedFromSequence++;
      if (this.indexOfTestCommandBeingPlayedFromSequence === this.testCommandsSequence.length) {
        console.log("stopping the test player");
        return this.stopTestPlaying();
      }
    }
  };

  SystemTestsRecorderAndPlayer.prototype.startTestPlaying = function() {
    SystemTestsRecorderAndPlayer.state = SystemTestsRecorderAndPlayer.PLAYING;
    this.constructor.animationsPacingControl = true;
    this.worldMorph.removeEventListeners();
    this.ongoingTestPlayingTask = ((function(_this) {
      return function() {
        return _this.replayTestCommands();
      };
    })(this));
    return this.worldMorph.otherTasksToBeRunOnStep.push(this.ongoingTestPlayingTask);
  };

  SystemTestsRecorderAndPlayer.prototype.testFileContentCreator = function(commands) {
    var testToBeSerialised;
    testToBeSerialised = {};
    testToBeSerialised.timeRecorded = new Date();
    testToBeSerialised.description = this.testDescription;
    testToBeSerialised.testGroup = "00: current tests / 00: unused / 00: unused";
    testToBeSerialised.systemInfo = new SystemTestsSystemInfo();
    testToBeSerialised.testCommandsSequence = commands;
    return "// This system test is automatically\n// created.\n// This test (and related reference images)\n// can be copied in the /src/tests folder\n// to make them available in the testing\n// environment.\nvar SystemTest_" + this.testName + ";\n\nSystemTest_" + this.testName + " = " + (JSON.stringify(testToBeSerialised, null, 4)) + ";";
  };

  SystemTestsRecorderAndPlayer.prototype.saveFailedScreenshots = function() {
    var aGoodImage, aGoodImageName, failedImage, image, setOfGoodImages, zip, _i, _j, _len, _ref, _ref1;
    zip = new JSZip();
    _ref = this.collectedFailureImages;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      image = _ref[_i];
      image.addToZipAsJSIgnoringItsAnObtained(zip);
      image.addToZipAsPNG(zip);
    }
    for (i = _j = 0, _ref1 = this.collectedFailureImages.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      failedImage = this.collectedFailureImages[i];
      aGoodImageName = failedImage.imageName.replace("obtained-", "");
      setOfGoodImages = SystemTestsRecorderAndPlayer.loadedImages[aGoodImageName];
      aGoodImage = setOfGoodImages[0];
      this.subtractScreenshots(failedImage, aGoodImage, function(subtractionCanvas, failedImage) {
        console.log("zipping diff file:" + "diff-" + failedImage.imageName + ".png");
        return zip.file("diff-" + failedImage.imageName + ".png", subtractionCanvas.toDataURL().replace(/^data:image\/png;base64,/, ""), {
          base64: true
        });
      });
    }
    return setTimeout((function(_this) {
      return function() {
        var content;
        console.log("saving failed screenshots");
        if (navigator.userAgent.search("Safari") >= 0 && navigator.userAgent.search("Chrome") < 0) {
          return location.href = "data:application/zip;base64," + zip.generate({
            type: "base64"
          });
        } else {
          console.log("not safari");
          content = zip.generate({
            type: "blob"
          });
          return saveAs(content, "SystemTest_" + _this.testName + "_failedScreenshots.zip");
        }
      };
    })(this), (this.collectedFailureImages.length + 1) * 200);
  };

  SystemTestsRecorderAndPlayer.prototype.saveTest = function() {
    var blob, content, image, zip, _i, _len, _ref;
    blob = this.testFileContentCreator(window.world.systemTestsRecorderAndPlayer.testCommandsSequence);
    zip = new JSZip();
    zip.file("SystemTest_" + this.testName + ".js", blob);
    _ref = this.collectedImages;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      image = _ref[_i];
      image.addToZipAsJS(zip);
      image.addToZipAsPNG(zip);
    }
    if (navigator.userAgent.search("Safari") >= 0 && navigator.userAgent.search("Chrome") < 0) {
      console.log("safari");
      return location.href = "data:application/zip;base64," + zip.generate({
        type: "base64"
      });
    } else {
      console.log("not safari");
      content = zip.generate({
        type: "blob"
      });
      return saveAs(content, "SystemTest_" + this.testName + ".zip");
    }
  };

  SystemTestsRecorderAndPlayer.prototype.loadTest = function(testNumber, andThenDoThis) {
    var script;
    script = document.createElement('script');
    script.src = "js/tests/" + this.testsList()[testNumber] + ".js";
    script.onload = (function(_this) {
      return function() {
        return _this.loadImagesOfTest(andThenDoThis);
      };
    })(this);
    return document.head.appendChild(script);
  };

  SystemTestsRecorderAndPlayer.prototype.loadImagesOfTest = function(andThenDoThis) {
    var eachAssetInManifest, eachCommand, pureImageName, script, _i, _j, _len, _len1, _ref, _ref1;
    _ref = window[this.testsList()[this.indexOfSystemTestBeingPlayed]].testCommandsSequence;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      eachCommand = _ref[_i];
      if (eachCommand.screenShotImageName != null) {
        pureImageName = eachCommand.screenShotImageName;
        _ref1 = SystemTestsRecorderAndPlayer.testsAssetsManifest;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          eachAssetInManifest = _ref1[_j];
          if (eachAssetInManifest.indexOf(pureImageName) !== -1) {
            script = document.createElement('script');

            /*
            systemInfo = new SystemTestsSystemInfo()
             * some devices have non-integer pixel ratios so
             * let's handle the dot there.
            pixelRatioString = (""+pixelRatio).replace(/\.+/g, "_")
            alert "js/tests/assets/" +
              systemInfo.os.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +
              systemInfo.osVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +
              systemInfo.browser.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +
              systemInfo.browserVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +
              "devicePixelRatio_" + pixelRatioString + "/" +
              eachAssetInManifest +
              ".js"
             */
            script.src = "js/tests/assets/" + eachAssetInManifest + ".js";
            document.head.appendChild(script);
          }
        }
      }
    }
    return setTimeout((function(_this) {
      return function() {
        return andThenDoThis();
      };
    })(this), 1000);
  };

  SystemTestsRecorderAndPlayer.prototype.testsList = function() {
    return SystemTestsRecorderAndPlayer.testsManifest;
  };

  SystemTestsRecorderAndPlayer.prototype.runNextSystemTest = function() {
    this.indexOfSystemTestBeingPlayed++;
    if (this.indexOfSystemTestBeingPlayed >= this.testsList().length) {
      SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole("finished all tests");
      return;
    }
    return this.loadTest(this.indexOfSystemTestBeingPlayed, (function(_this) {
      return function() {
        SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole("playing test: " + _this.testsList()[_this.indexOfSystemTestBeingPlayed]);
        _this.testCommandsSequence = window[_this.testsList()[_this.indexOfSystemTestBeingPlayed]].testCommandsSequence;
        return _this.startTestPlaying();
      };
    })(this));
  };

  SystemTestsRecorderAndPlayer.prototype.runAllSystemTests = function() {
    console.log("System tests: " + this.testsList());
    this.playingAllSystemTests = true;
    this.indexOfSystemTestBeingPlayed = -1;
    return this.runNextSystemTest();
  };

  SystemTestsRecorderAndPlayer.coffeeScriptSourceOfThisClass = '# REQUIRES SystemTestsReferenceImage\n# REQUIRES SystemTestsSystemInfo\n\n# How to load/play a test:\n# from the Chrome console (Option-Command-J) OR Safari console (Option-Command-C):\n# window.world.systemTestsRecorderAndPlayer.testCommandsSequence = NAMEOFTHETEST.testCommandsSequence\n# (e.g. window.world.systemTestsRecorderAndPlayer.testCommandsSequence = SystemTest_attachRectangleToPartsOfInspector.testCommandsSequence )\n# window.world.systemTestsRecorderAndPlayer.startTestPlaying()\n\n# How to inspect the screenshot differences:\n# after having playes a test with some failing screenshots\n# comparisons:\n# from the Chrome console (Option-Command-J) OR Safari console (Option-Command-C):\n# window.world.systemTestsRecorderAndPlayer.saveFailedScreenshots()\n# it will save a zip file containing three files for each failure:\n# 1) the png of the obtained screenshot (different from the expected)\n# 2) the .js file containing the data for the obtained screenshot\n# (in case it\'s OK and should be added to the "good screenshots")\n# 3) a .png file highlighting the differences in red.\n\n# How to record a test:\n# window.world.systemTestsRecorderAndPlayer.startTestRecording(\'nameOfTheTest\')\n# ...do the test...\n# window.world.systemTestsRecorderAndPlayer.stopTestRecording()\n# if you want to verify the test on the spot:\n# window.world.systemTestsRecorderAndPlayer.startTestPlaying()\n\n# For recording screenshot data at any time -\n# can be used for screenshot comparisons during the test:\n# window.world.systemTestsRecorderAndPlayer.takeScreenshot()\n\n# How to save the test:\n# window.world.systemTestsRecorderAndPlayer.saveTest()\n# The created zip will contain both the test and the\n# related reference images.\n\n# What to do with the saved zip file:\n# These files inside the zip package need to be added\n# to the\n#   ./src/tests directory\n# Then the project will need to be recompiled.\n# At this point the\n#   ./build/indexWithTests.html\n# page will automatically load all the tests and\n# images. See "how to load/play a test" above\n# to read how to load and play a test.\n\nclass SystemTestsRecorderAndPlayer\n  testCommandsSequence: []\n  @RECORDING: 0\n  @PLAYING: 1\n  @IDLE: 2\n  @state: 2\n  playingAllSystemTests: false\n  indexOfSystemTestBeingPlayed: 0\n  timeOfPreviouslyRecordedCommand: null\n  handMorph: null\n  worldMorph: null\n  collectedImages: [] # array of SystemTestsReferenceImage\n  collectedFailureImages: [] # array of SystemTestsReferenceImage\n  testName: \'\'\n  testDescription: \'no description\'\n  @loadedImages: {}\n  ongoingTestPlayingTask: null\n  timeOfPreviouslyPlayedCommand: 0\n  indexOfTestCommandBeingPlayedFromSequence: 0\n\n  @animationsPacingControl: false\n  @alignmentOfMorphIDsMechanism: false\n  @hidingOfMorphsGeometryInfoInLabels: false\n  @hidingOfMorphsNumberIDInLabels: false\n  @hidingOfMorphsContentExtractInLabels: false\n\n  # this is a special place where the\n  # "take pic" command places the image\n  # data of a morph.\n  # the test player will wait for this data\n  # before doing the comparison.\n  imageDataOfAParticularMorph: null\n  lastMouseDownCommand: null\n  lastMouseUpCommand: null\n\n\n  constructor: (@worldMorph, @handMorph) ->\n\n  # clear any test with the same name\n  # that might be loaded\n  # and all the images related to it\n  clearAnyDataRelatedToTest: (testName) ->\n    # we assume that no-one is going to\n    # write a tests with more than\n    # 100 reference images/screenshots\n    for imageNumber in [0...100]\n      # each of these is an array that could contain\n      # multiple screenshots for different browser/os\n      # configuration, we are clearing the variable\n      # containing the array\n      console.log "deleting SystemTest_#{@testName}_image_#{imageNumber}"\n      delete SystemTestsRecorderAndPlayer.loadedImages["SystemTest_#{@testName}_image_#{imageNumber}"]\n    console.log "deleting SystemTest_#{@testName}"\n    delete window["SystemTest_#{@testName}"]\n  \n  startTestRecording: (@testName, @testDescription) ->\n\n    # if test name not provided, then\n    # prompt the user for it\n    if not @testName?\n      @testName = prompt("Please enter a test name", "test1")\n    if not @testDescription?\n      @testDescription = prompt("Please enter a test description", "no description")\n\n    # if you choose the same name\n    # of a previously loaded tests,\n    # confusing things might happen such\n    # as comparison with loaded screenshots\n    # so we want to clear the data related\n    # to the chosen name\n    @clearAnyDataRelatedToTest @testName\n\n    @testCommandsSequence = []\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n    SystemTestsRecorderAndPlayer.state = SystemTestsRecorderAndPlayer.RECORDING\n\n  stopTestRecording: ->\n    SystemTestsRecorderAndPlayer.state = SystemTestsRecorderAndPlayer.IDLE\n\n\n  # gonna use this in a callback so need\n  # to make this one a double-arrow\n  stopTestPlaying: ->\n    console.log "wrapping up the playing of the test"\n    SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole "test complete"\n    SystemTestsRecorderAndPlayer.state = SystemTestsRecorderAndPlayer.IDLE\n    \n    # There is a background interval that polls\n    # to check whether it\'s time/condition to play\n    # the next queued command. Remove it.\n    indexOfTask = @worldMorph.otherTasksToBeRunOnStep.indexOf(@ongoingTestPlayingTask)\n    @worldMorph.otherTasksToBeRunOnStep.splice(indexOfTask, 1)\n    @worldMorph.initEventListeners()\n    \n    @indexOfTestCommandBeingPlayedFromSequence = 0\n\n    if @playingAllSystemTests\n      @runNextSystemTest()\n\n  showTestSource: ->\n    window.open("data:text/text;charset=utf-8," + encodeURIComponent(JSON.stringify( @testCommandsSequence, null, 4 )))\n\n  turnOnAnimationsPacingControl: ->\n    @constructor.animationsPacingControl = true\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandTurnOnAnimationsPacingControl @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOffAnimationsPacingControl: ->\n    @constructor.animationsPacingControl = false\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandTurnOffAnimationsPacingControl @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOnAlignmentOfMorphIDsMechanism: ->\n    @constructor.alignmentOfMorphIDsMechanism = true\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandTurnOnAlignmentOfMorphIDsMechanism @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOffAlignmentOfMorphIDsMechanism: ->\n    @constructor.alignmentOfMorphIDsMechanism = false\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandTurnOffAlignmentOfMorphIDsMechanism @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOnHidingOfMorphsGeometryInfoInLabels: ->\n    @constructor.hidingOfMorphsGeometryInfoInLabels = true\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandTurnOnHidingOfMorphsGeometryInfoInLabels @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOffHidingOfMorphsGeometryInfoInLabels: ->\n    @constructor.hidingOfMorphsGeometryInfoInLabels = false\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandTurnOffHidingOfMorphsGeometryInfoInLabels @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOnHidingOfMorphsContentExtractInLabels: ->\n    @constructor.hidingOfMorphsContentExtractInLabels = true\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandTurnOnHidingOfMorphsContentExtractInLabels @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOffHidingOfMorphsContentExtractInLabels: ->\n    @constructor.hidingOfMorphsContentExtractInLabels = false\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandTurnOffHidingOfMorphsContentExtractInLabels @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOnHidingOfMorphsNumberIDInLabels: ->\n    @constructor.hidingOfMorphsNumberIDInLabels = true\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandTurnOnHidingOfMorphsNumberIDInLabels @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOffHidingOfMorphsNumberIDInLabels: ->\n    @constructor.hidingOfMorphsNumberIDInLabels = false\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandTurnOffHidingOfMorphsNumberIDInLabels @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n\n  addMouseMoveCommand: (pageX, pageY) ->\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandMouseMove pageX, pageY, @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addMouseDownCommand: (button, ctrlKey) ->\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandMouseDown button, ctrlKey, @\n    @lastMouseDownCommand = systemTestCommand\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addOpenContextMenuCommand: (context) ->\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    @removeLastMouseUpAndMouseDownCommands()\n    systemTestCommand = new SystemTestsCommandOpenContextMenu context, @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addCommandLeftOrRightClickOnMenuItem: (mouseButton, labelString, occurrenceNumber) ->\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    @removeLastMouseUpAndMouseDownCommands()\n    systemTestCommand = new SystemTestsCommandLeftOrRightClickOnMenuItem mouseButton, labelString, occurrenceNumber, @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addMouseUpCommand: ->\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandMouseUp @\n    @lastMouseUpCommand = systemTestCommand\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n  \n  # doesn\'t *actually* remove the command\n  # because you do need to wait the time.\n  # because for example the bubbles pop-up\n  # after some time.\n  # You could remove the commands and note down\n  # how much was the wait on each and charge it to\n  # the next command but that would be very messy.\n  removeLastMouseUpAndMouseDownCommands: ->\n    @lastMouseDownCommand.transformIntoDoNothingCommand()\n    @lastMouseUpCommand.transformIntoDoNothingCommand()\n\n  addKeyPressCommand: (charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) ->\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandKeyPress charCode, symbol, shiftKey, ctrlKey, altKey, metaKey, @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addKeyDownCommand: (scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandKeyDown scanCode, shiftKey, ctrlKey, altKey, metaKey, @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addKeyUpCommand: (scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandKeyUp scanCode, shiftKey, ctrlKey, altKey, metaKey, @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addCopyCommand: () ->\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandCopy @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addPasteCommand: (clipboardText) ->\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandPaste clipboardText, @\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n\n  resetWorld: ->\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    systemTestCommand = new SystemTestsCommandResetWorld @\n    window[systemTestCommand.testCommandName].replayFunction @, null\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addTestComment: ->\n    return if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n    # note how we take the time before we prompt the\n    # user so we can show the message sooner when playing\n    # the test - i.e. the message will appear at the time\n    # the user got the prompt window rather than when she\n    # actually wrote the message...\n    # So we anticipate the message so the user can actually have\n    # the time to read it before the test moves on with the\n    # next steps.\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n    comment = prompt("enter comment", "your comment here")\n    systemTestCommand = new SystemTestsCommandShowComment comment, @\n    @testCommandsSequence.push systemTestCommand\n\n  checkStringsOfItemsInMenuOrderImportant: (stringOfItemsInMenuInOriginalOrder) ->\n    @checkStringsOfItemsInMenu(stringOfItemsInMenuInOriginalOrder, true)\n\n  checkStringsOfItemsInMenuOrderUnimportant: (stringOfItemsInMenuInOriginalOrder) ->\n    @checkStringsOfItemsInMenu(stringOfItemsInMenuInOriginalOrder, false)\n\n  checkStringsOfItemsInMenu: (stringOfItemsInMenuInOriginalOrder, orderMatters) ->\n    console.log "checkStringsOfItemsInMenu"\n    menuAtPointer = @handMorph.menuAtPointer()\n    console.log menuAtPointer\n\n    stringOfItemsInCurrentMenuInOriginalOrder = []\n\n    if menuAtPointer?\n      for eachMenuItem in menuAtPointer.items\n        stringOfItemsInCurrentMenuInOriginalOrder.push eachMenuItem[0]\n    else\n      console.log "FAIL was expecting a menu under the pointer"\n      if SystemTestsControlPanelUpdater?\n        SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole errorMessage\n      @stopTestPlaying()\n\n    if SystemTestsRecorderAndPlayer.state == SystemTestsRecorderAndPlayer.RECORDING\n      if orderMatters\n        systemTestCommand = new SystemTestsCommandCheckStringsOfItemsInMenuOrderImportant stringOfItemsInCurrentMenuInOriginalOrder, @\n      else\n        systemTestCommand = new SystemTestsCommandCheckStringsOfItemsInMenuOrderUnimportant stringOfItemsInCurrentMenuInOriginalOrder, @\n\n      @testCommandsSequence.push systemTestCommand\n      @timeOfPreviouslyRecordedCommand = new Date().getTime()\n    else if SystemTestsRecorderAndPlayer.state == SystemTestsRecorderAndPlayer.PLAYING\n      giveSuccess = =>\n        if orderMatters\n          message = "PASS Strings in menu are same and in same order"\n        else\n          message = "PASS Strings in menu are same (not considering order)"\n        if SystemTestsControlPanelUpdater?\n          SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole message\n      giveError = =>\n        if orderMatters\n          errorMessage = "FAIL Strings in menu doesn\'t match or order is incorrect. Was expecting: " + stringOfItemsInMenuInOriginalOrder + " found: " + stringOfItemsInCurrentMenuInOriginalOrder\n        else\n          errorMessage = "FAIL Strings in menu doesn\'t match (even not considering order). Was expecting: " + stringOfItemsInMenuInOriginalOrder + " found: " + stringOfItemsInCurrentMenuInOriginalOrder\n        if SystemTestsControlPanelUpdater?\n          SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole errorMessage\n        @stopTestPlaying()\n      \n      menuListIsSame = true\n\n      # the reason why we make a copy here is the following:\n      # if you kept the original array then this could happen:\n      # you record a test and then you play it back and then you save it\n      # the array is always the same and could get mutated during the play\n      # (because it could be sorted). So when you save the test, you\n      # save the ordered array instead of the original.\n      copyOfstringOfItemsInMenuInOriginalOrder = arrayShallowCopy(stringOfItemsInMenuInOriginalOrder)\n\n      # if the order doesn\'t matter then we need to\n      # sort the strings first so we compare regardless\n      # of the original order\n      if !orderMatters\n        stringOfItemsInCurrentMenuInOriginalOrder.sort()\n        copyOfstringOfItemsInMenuInOriginalOrder.sort()\n\n      if stringOfItemsInCurrentMenuInOriginalOrder.length == copyOfstringOfItemsInMenuInOriginalOrder.length\n        for itemNumber in [0...copyOfstringOfItemsInMenuInOriginalOrder.length]\n          if copyOfstringOfItemsInMenuInOriginalOrder[itemNumber] != stringOfItemsInCurrentMenuInOriginalOrder[itemNumber]\n            menuListIsSame = false\n            console.log copyOfstringOfItemsInMenuInOriginalOrder[itemNumber] + " != " + stringOfItemsInCurrentMenuInOriginalOrder[itemNumber] + " at " + itemNumber\n      else\n        menuListIsSame = false\n\n      if menuListIsSame\n        giveSuccess()\n      else\n        giveError()\n\n  checkNumberOfItemsInMenu: (numberOfItems) ->\n    if SystemTestsRecorderAndPlayer.state == SystemTestsRecorderAndPlayer.RECORDING\n      menuAtPointer = @handMorph.menuAtPointer()\n      console.log menuAtPointer\n      if menuAtPointer?\n        numberOfItems = menuAtPointer.items.length\n        console.log "found " + numberOfItems + " number of items "\n      else\n        console.log "was expecting a menu under the pointer"\n        numberOfItems = 0\n      systemTestCommand = new SystemTestsCommandCheckNumberOfItemsInMenu numberOfItems, @\n      @testCommandsSequence.push systemTestCommand\n      @timeOfPreviouslyRecordedCommand = new Date().getTime()\n    else if SystemTestsRecorderAndPlayer.state == SystemTestsRecorderAndPlayer.PLAYING\n      menuAtPointer = @handMorph.menuAtPointer()\n      giveSuccess = =>\n        message = "PASS Number of items in menu matches. Note that count includes line separators. Found: " + menuAtPointer.items.length\n        if SystemTestsControlPanelUpdater?\n          SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole message\n      giveError = =>\n        errorMessage = "FAIL Number of items in menu doesn\'t match. Note that count includes line separators. Was expecting: " + numberOfItems + " found: " + menuAtPointer.items.length\n        if SystemTestsControlPanelUpdater?\n          SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole errorMessage\n        @stopTestPlaying()\n      if menuAtPointer?\n        if numberOfItems != menuAtPointer.items.length\n          giveError()\n        else\n          giveSuccess()\n      else\n          giveError()\n\n  takeScreenshot: (whichMorph = @worldMorph) ->\n    console.log "taking screenshot"\n    imageName = "SystemTest_"+@testName+"_image_" + (@collectedImages.length + 1)\n    systemTestCommand = new SystemTestsCommandScreenshot imageName, @, whichMorph != @worldMorph\n\n    # the way we take a picture here is different\n    # than the way we usually take a picture.\n    # Usually we ask the morph and submorphs to\n    # paint themselves anew into a new canvas.\n    # This is different: we take the area of the\n    # screen *as it is* and we crop the part of\n    # interest where the extent of our selected\n    # morph is. This means that the morph might\n    # be occluded by other things.\n    # The advantage here is that we capture\n    # the screen absolutely as is, without\n    # causing any repaints. If streaks are on the\n    # screen due to bad painting, we capture them\n    # exactly as the user sees them.\n    if whichMorph == @worldMorph\n      imageData = world.worldCanvas.toDataURL("image/png")\n    else\n      # you can take the sceen copy for a single Morph\n      # only while recording (or playing) a test by\n      # choosing the "take pic" action... which otherwise\n      # would usually open a new tab with the picture\n      # of the "painted" morph (not sceen-copied, see\n      # explanation of the differene here above)\n      fullExtentOfMorph = whichMorph.boundsIncludingChildren()\n      destCanvas = newCanvas fullExtentOfMorph.extent().scaleBy pixelRatio\n      destCtx = destCanvas.getContext \'2d\'\n      destCtx.drawImage world.worldCanvas,\n        fullExtentOfMorph.topLeft().x * pixelRatio,\n        fullExtentOfMorph.topLeft().y * pixelRatio,\n        fullExtentOfMorph.width() * pixelRatio,\n        fullExtentOfMorph.height() * pixelRatio,\n        0,\n        0,\n        fullExtentOfMorph.width() * pixelRatio,\n        fullExtentOfMorph.height() * pixelRatio,\n\n      imageData = destCanvas.toDataURL "image/png"\n\n    takenScreenshot = new SystemTestsReferenceImage(imageName,imageData, new SystemTestsSystemInfo())\n    unless SystemTestsRecorderAndPlayer.loadedImages["#{imageName}"]?\n      SystemTestsRecorderAndPlayer.loadedImages["#{imageName}"] = []\n    SystemTestsRecorderAndPlayer.loadedImages["#{imageName}"].push takenScreenshot\n    @collectedImages.push takenScreenshot\n    @testCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n    if SystemTestsRecorderAndPlayer.state != SystemTestsRecorderAndPlayer.RECORDING\n      return systemTestCommand\n\n  # a lenghty method because there\n  # is a lot of API dancing, but the\n  # concept is really easy: return\n  # a new canvas with an image that is\n  # red in all areas where the\n  # "expected" and "obtained" images\n  # are different.\n  # So it neatly highlights where the differences\n  # are.\n  subtractScreenshots: (expected, obtained, andThen) ->\n    console.log "subtractScreenshots"\n    expectedCanvas = document.createElement "canvas"\n    expectedImage = new Image\n    # unfortunately the operation of loading\n    # the base64 data into the image is asynchronous\n    # (seems to work immediately in Chrome but it\'s\n    # recommended to consider it asynchronous)\n    # so here we need to chain two callbacks\n    # to make it all work, as we need to load\n    # two such images.\n    expectedImage.onload = =>\n      console.log "expectedCanvas.imageData: " + expectedCanvas.imageData\n      expectedCanvas.width = expectedImage.width\n      expectedCanvas.height = expectedImage.height\n      expectedCanvasContext = expectedCanvas.getContext "2d"\n      console.log "expectedCanvas.width: " + expectedCanvas.width\n      console.log "expectedCanvas.height: " + expectedCanvas.height\n      expectedCanvasContext.drawImage(expectedImage,0,0)\n      expectedImageData = expectedCanvasContext.getImageData(0, 0, expectedCanvas.width, expectedCanvas.height)\n\n      obtainedCanvas = document.createElement "canvas"\n      obtainedImage = new Image\n      obtainedImage.onload = =>\n        obtainedCanvas.width = obtainedImage.width\n        obtainedCanvas.height = obtainedImage.height\n        obtainedCanvasContext = obtainedCanvas.getContext "2d"\n        obtainedCanvasContext.drawImage(obtainedImage,0,0)\n        obtainedImageData = obtainedCanvasContext.getImageData(0, 0, obtainedCanvas.width, obtainedCanvas.height)\n\n        subtractionCanvas = document.createElement "canvas"\n        subtractionCanvas.width = obtainedImage.width\n        subtractionCanvas.height = obtainedImage.height\n        subtractionCanvasContext = subtractionCanvas.getContext("2d")\n        subtractionCanvasContext.drawImage(obtainedImage,0,0)\n        subtractionImageData = subtractionCanvasContext.getImageData(0, 0, subtractionCanvas.width, subtractionCanvas.height)\n\n        i = 0\n        equalPixels = 0\n        differentPixels = 0\n\n        while i < subtractionImageData.data.length\n          if obtainedImageData.data[i] != expectedImageData.data[i] or\n             obtainedImageData.data[i+1] != expectedImageData.data[i+1] or\n             obtainedImageData.data[i+2] != expectedImageData.data[i+2]\n            subtractionImageData.data[i] = 255\n            subtractionImageData.data[i+1] = 0\n            subtractionImageData.data[i+2] = 0\n            differentPixels++\n          else\n            equalPixels++\n          i += 4\n        console.log "equalPixels: " + equalPixels\n        console.log "differentPixels: " + differentPixels\n        subtractionCanvasContext.putImageData subtractionImageData, 0, 0\n        andThen subtractionCanvas, expected\n\n      obtainedImage.src = obtained.imageData\n\n    expectedImage.src = expected.imageData\n\n  compareScreenshots: (testNameWithImageNumber, screenshotTakenOfAParticularMorph = false) ->\n   if screenshotTakenOfAParticularMorph\n     console.log "comparing pic of a particular morph"\n     screenshotObtained = @imageDataOfAParticularMorph\n     @imageDataOfAParticularMorph = null\n   else\n     console.log "comparing pic of whole desktop"\n     screenshotObtained = @worldMorph.fullImageData()\n   \n   console.log "trying to match screenshot: " + testNameWithImageNumber\n   console.log "length of obtained: " + screenshotObtained.length\n\n   # There can be multiple files for the same image, since\n   # the images vary according to OS and Browser, so for\n   # each image of each test there is an array of candidates\n   # to be checked. If any of them mathes in terms of pixel data,\n   # then fine, otherwise complain...\n   for eachImage in SystemTestsRecorderAndPlayer.loadedImages["#{testNameWithImageNumber}"]\n     console.log "length of obtained: " + eachImage.imageData.length\n     if eachImage.imageData == screenshotObtained\n      message = "PASS - screenshot " + eachImage.fileName + " matched"\n      console.log message\n      if SystemTestsControlPanelUpdater?\n        SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole message\n      return\n   # OK none of the images we loaded matches the one we\n   # just takes. Hence create a SystemTestsReferenceImage\n   # that we can let the user download - it will contain\n   # the image actually obtained (rather than the one\n   # we should have seen)\n   message = "FAIL - no screenshots like this one"\n   console.log message\n   if SystemTestsControlPanelUpdater?\n     SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole message\n   obtainedImageName = "obtained-" + eachImage.imageName\n   obtainedImage = new SystemTestsReferenceImage(obtainedImageName,screenshotObtained, new SystemTestsSystemInfo())\n   @collectedFailureImages.push obtainedImage\n\n  replayTestCommands: ->\n   timeNow = (new Date()).getTime()\n   commandToBePlayed = @testCommandsSequence[@indexOfTestCommandBeingPlayedFromSequence]\n   # console.log "examining command: " + commandToBePlayed.testCommandName + " at: " + commandToBePlayed.millisecondsSincePreviousCommand +\n   #   " time now: " + timeNow + " we are at: " + (timeNow - @timeOfPreviouslyPlayedCommand)\n   timeUntilNextCommand = commandToBePlayed.millisecondsSincePreviousCommand or 0\n   # for the screenshot, the replay is going\n   # to consist in comparing the image data.\n   # in case the screenshot is made of the entire world\n   # then the comparison can happen now.\n   # in case the screenshot is made of a particular\n   # morph then we want to wait that the world\n   # has taken that screenshot image data and put\n   # it in here.\n   # search for imageDataOfAParticularMorph everywhere\n   # to see where the image data is created and\n   # put there.\n   if commandToBePlayed.testCommandName == "SystemTestsCommandScreenshot" and commandToBePlayed.screenshotTakenOfAParticularMorph\n     if not @imageDataOfAParticularMorph?\n       # no image data of morph, so just wait\n       return\n   if timeNow - @timeOfPreviouslyPlayedCommand >= timeUntilNextCommand\n     console.log "running command: " + commandToBePlayed.testCommandName + " " + @indexOfTestCommandBeingPlayedFromSequence + " / " + @testCommandsSequence.length\n     window[commandToBePlayed.testCommandName].replayFunction.call @,@,commandToBePlayed\n     @timeOfPreviouslyPlayedCommand = timeNow\n     @indexOfTestCommandBeingPlayedFromSequence++\n     if @indexOfTestCommandBeingPlayedFromSequence == @testCommandsSequence.length\n       console.log "stopping the test player"\n       @stopTestPlaying()\n\n  startTestPlaying: ->\n    SystemTestsRecorderAndPlayer.state = SystemTestsRecorderAndPlayer.PLAYING\n    @constructor.animationsPacingControl = true\n    @worldMorph.removeEventListeners()\n    @ongoingTestPlayingTask = (=> @replayTestCommands())\n    @worldMorph.otherTasksToBeRunOnStep.push @ongoingTestPlayingTask\n\n\n  testFileContentCreator: (commands) ->\n    # these here below is just one string\n    # spanning multiple lines, which\n    # includes the testName and commands\n    # in the right places.\n\n    testToBeSerialised = {}\n    testToBeSerialised.timeRecorded = new Date()\n    testToBeSerialised.description = @testDescription\n    # A string that can be used to group\n    # tests together, imagine for example they\n    # could be visualised in a tree structure of\n    # some sort.\n    # to begin with, it will be sorted\n    # alphabetically so at the top we put the\n    # "topical" tests that we just want run\n    # quickly cause they are about stuff\n    # we are working on right now.\n    testToBeSerialised.testGroup = "00: current tests / 00: unused / 00: unused"\n    testToBeSerialised.systemInfo = new SystemTestsSystemInfo()\n    testToBeSerialised.testCommandsSequence = commands\n\n    """\n  // This system test is automatically\n  // created.\n  // This test (and related reference images)\n  // can be copied in the /src/tests folder\n  // to make them available in the testing\n  // environment.\n  var SystemTest_#{@testName};\n\n  SystemTest_#{@testName} = #{JSON.stringify(testToBeSerialised, null, 4)};\n    """\n\n  saveFailedScreenshots: ->\n    zip = new JSZip()\n    \n    # debugger\n    # save all the images, each as a .png and .js file\n    # the png is for quick browsing, while the js contains\n    # the pixel data and the metadata of which configuration\n    # the picture was recorded with.\n    # (we expect the screenshots to be different across\n    # browsers and OSs)\n    # Note that the .js files are saved so the content\n    # doesn\'t contain "obtained-" anywhere in metadata\n    # (as it should, in theory) so that, if the\n    # screenshot is good, the file can just be\n    # renamed and moved together with the "good"\n    # screenshots.\n    for image in @collectedFailureImages\n      image.addToZipAsJSIgnoringItsAnObtained zip\n      \n      # let\'s also save the png file so it\'s easier to browse the data\n      # note that these png files are not copied over into the\n      # build directory.\n      image.addToZipAsPNG zip\n\n    # create and save all diff .png images\n    # the diff images just highlight in red\n    # the parts that differ from any one\n    # of the "good" screenshots\n    # (remember, there can be more than one\n    # good screenshot, we pick the first one\n    # we find)\n    for i in [0...@collectedFailureImages.length]\n      failedImage = @collectedFailureImages[i]\n      aGoodImageName = (failedImage).imageName.replace("obtained-", "")\n      setOfGoodImages = SystemTestsRecorderAndPlayer.loadedImages[aGoodImageName]\n      aGoodImage = setOfGoodImages[0]\n      # note the asynchronous operation here - this is because\n      # the subtractScreenshots needs to create some Images and\n      # load them with data from base64 string. The operation\n      # of loading the data is asynchronous...\n      @subtractScreenshots failedImage, aGoodImage, (subtractionCanvas, failedImage) ->\n        console.log "zipping diff file:" + "diff-"+failedImage.imageName+".png"\n        zip.file("diff-"+failedImage.imageName+".png", subtractionCanvas.toDataURL().replace(/^data:image\/png;base64,/, ""), {base64: true});\n\n    # OK the images are all put in the zip\n    # asynchronously. So, in theory what we should do is to\n    # check that we have all the image packed\n    # and then save the zip. In practice we just wait\n    # some time (200ms for each image)\n    # and then save the zip.\n    setTimeout =>\n        console.log "saving failed screenshots"\n        if navigator.userAgent.search("Safari") >= 0 and navigator.userAgent.search("Chrome") < 0\n          # Safari can\'t save blobs nicely with a nice\n          # file name, see\n          # http://stuk.github.io/jszip/documentation/howto/write_zip.html\n          # so what this does is it saves a file "Unknown". User\n          # then has to rename it and open it.\n          location.href="data:application/zip;base64," + zip.generate({type:"base64"})\n        else\n          console.log "not safari"\n          content = zip.generate({type:"blob"})\n          saveAs(content, "SystemTest_#{@testName}_failedScreenshots.zip")        \n      , (@collectedFailureImages.length+1) * 200 \n\n\n\n  saveTest: ->\n    blob = @testFileContentCreator window.world.systemTestsRecorderAndPlayer.testCommandsSequence\n    zip = new JSZip()\n    zip.file("SystemTest_#{@testName}.js", blob);\n    \n    # save all the images, each as a .png and .js file\n    # the png is for quick browsing, while the js contains\n    # the pixel data and the metadata of which configuration\n    # the picture was recorded with.\n    # (we expect the screenshots to be different across\n    # browsers and OSs)\n    for image in @collectedImages\n      image.addToZipAsJS zip\n      \n      # let\'s also save the png file so it\'s easier to browse the data\n      # note that these png files are not copied over into the\n      # build directory.\n      image.addToZipAsPNG zip\n    \n\n    if navigator.userAgent.search("Safari") >= 0 and navigator.userAgent.search("Chrome") < 0\n      # Safari can\'t save blobs nicely with a nice\n      # file name, see\n      # http://stuk.github.io/jszip/documentation/howto/write_zip.html\n      # so what this does is it saves a file "Unknown". User\n      # then has to rename it and open it.\n      console.log "safari"\n      location.href="data:application/zip;base64," + zip.generate({type:"base64"})\n    else\n      console.log "not safari"\n      content = zip.generate({type:"blob"})\n      saveAs(content, "SystemTest_#{@testName}.zip")    \n\n  loadTest: (testNumber, andThenDoThis)->\n    script = document.createElement(\'script\')\n    script.src = "js/tests/"+@testsList()[testNumber] + ".js"\n\n    script.onload = =>\n      @loadImagesOfTest andThenDoThis\n\n    document.head.appendChild script\n\n  loadImagesOfTest: (andThenDoThis)->\n\n    for eachCommand in window[@testsList()[@indexOfSystemTestBeingPlayed]].testCommandsSequence\n      if eachCommand.screenShotImageName?\n        pureImageName = eachCommand.screenShotImageName\n        for eachAssetInManifest in SystemTestsRecorderAndPlayer.testsAssetsManifest\n          if eachAssetInManifest.indexOf(pureImageName) != -1         \n            script = document.createElement(\'script\')\n            ###\n            systemInfo = new SystemTestsSystemInfo()\n            # some devices have non-integer pixel ratios so\n            # let\'s handle the dot there.\n            pixelRatioString = (""+pixelRatio).replace(/\.+/g, "_")\n            alert "js/tests/assets/" +\n              systemInfo.os.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              systemInfo.osVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              systemInfo.browser.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              systemInfo.browserVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              "devicePixelRatio_" + pixelRatioString + "/" +\n              eachAssetInManifest +\n              ".js"\n            ###\n            script.src = "js/tests/assets/"+ eachAssetInManifest + ".js"\n            document.head.appendChild script\n\n    setTimeout =>\n        andThenDoThis()\n      , 1000\n\n\n  testsList: ->\n    return SystemTestsRecorderAndPlayer.testsManifest\n\n  runNextSystemTest: ->\n    @indexOfSystemTestBeingPlayed++\n    if @indexOfSystemTestBeingPlayed >= @testsList().length\n      SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole "finished all tests"\n      return\n    @loadTest @indexOfSystemTestBeingPlayed, =>\n      SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole "playing test: " + @testsList()[@indexOfSystemTestBeingPlayed]\n      @testCommandsSequence = window[@testsList()[@indexOfSystemTestBeingPlayed]].testCommandsSequence\n      @startTestPlaying()\n\n  runAllSystemTests: ->\n    console.log "System tests: " + @testsList()\n    @playingAllSystemTests = true\n    @indexOfSystemTestBeingPlayed = -1\n    @runNextSystemTest()';

  return SystemTestsRecorderAndPlayer;

})();

TextMorph = (function(_super) {
  __extends(TextMorph, _super);

  TextMorph.prototype.words = [];

  TextMorph.prototype.lines = [];

  TextMorph.prototype.lineSlots = [];

  TextMorph.prototype.alignment = null;

  TextMorph.prototype.maxWidth = null;

  TextMorph.prototype.maxLineWidth = 0;

  TextMorph.prototype.backgroundColor = null;

  TextMorph.prototype.receiver = null;

  function TextMorph(text, fontSize, fontStyle, isBold, isItalic, alignment, maxWidth, fontName, shadowOffset, shadowColor) {
    this.fontSize = fontSize != null ? fontSize : 12;
    this.fontStyle = fontStyle != null ? fontStyle : "sans-serif";
    this.isBold = isBold != null ? isBold : false;
    this.isItalic = isItalic != null ? isItalic : false;
    this.alignment = alignment != null ? alignment : "left";
    this.maxWidth = maxWidth != null ? maxWidth : 0;
    this.shadowColor = shadowColor != null ? shadowColor : null;
    TextMorph.__super__.constructor.call(this, text, this.fontSize, this.fontStyle, this.isBold, this.isItalic, null, shadowOffset, this.shadowColor, null, fontName);
    this.markedTextColor = new Color(255, 255, 255);
    this.markedBackgoundColor = new Color(60, 60, 120);
    this.text = text || (text === "" ? text : "TextMorph");
    this.fontName = fontName || WorldMorph.preferencesAndSettings.globalFontFamily;
    this.shadowOffset = shadowOffset || new Point(0, 0);
    this.color = new Color(0, 0, 0);
    this.noticesTransparentClick = true;
  }

  TextMorph.prototype.breakTextIntoLines = function() {
    var canvas, context, currentLine, paragraphs, slot;
    paragraphs = this.text.split("\n");
    canvas = newCanvas();
    context = canvas.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    currentLine = "";
    slot = 0;
    context.font = this.font();
    this.maxLineWidth = 0;
    this.lines = [];
    this.lineSlots = [0];
    this.words = [];
    paragraphs.forEach((function(_this) {
      return function(p) {
        _this.words = _this.words.concat(p.split(" "));
        return _this.words.push("\n");
      };
    })(this));
    return this.words.forEach((function(_this) {
      return function(word) {
        var lineForOverflowTest, w;
        if (word === "\n") {
          _this.lines.push(currentLine);
          _this.lineSlots.push(slot);
          _this.maxLineWidth = Math.max(_this.maxLineWidth, context.measureText(currentLine).width);
          return currentLine = "";
        } else {
          if (_this.maxWidth > 0) {
            lineForOverflowTest = currentLine + word + " ";
            w = context.measureText(lineForOverflowTest).width;
            if (w > _this.maxWidth) {
              _this.lines.push(currentLine);
              _this.lineSlots.push(slot);
              _this.maxLineWidth = Math.max(_this.maxLineWidth, context.measureText(currentLine).width);
              currentLine = word + " ";
            } else {
              currentLine = lineForOverflowTest;
            }
          } else {
            currentLine = currentLine + word + " ";
          }
          return slot += word.length + 1;
        }
      };
    })(this));
  };

  TextMorph.prototype.updateRendering = function() {
    var c, context, height, line, offx, offy, p, shadowHeight, shadowWidth, start, stop, width, x, y, _i, _j, _k, _len, _len1, _ref, _ref1;
    this.image = newCanvas();
    context = this.image.getContext("2d");
    context.font = this.font();
    this.breakTextIntoLines();
    shadowWidth = Math.abs(this.shadowOffset.x);
    shadowHeight = Math.abs(this.shadowOffset.y);
    height = this.lines.length * (fontHeight(this.fontSize) + shadowHeight);
    if (this.maxWidth === 0) {
      this.bounds = this.bounds.origin.extent(new Point(this.maxLineWidth + shadowWidth, height));
    } else {
      this.bounds = this.bounds.origin.extent(new Point(this.maxWidth + shadowWidth, height));
    }
    this.image.width = this.width() * pixelRatio;
    this.image.height = this.height() * pixelRatio;
    context.scale(pixelRatio, pixelRatio);
    context.font = this.font();
    context.textAlign = "left";
    context.textBaseline = "bottom";
    if (this.backgroundColor) {
      context.fillStyle = this.backgroundColor.toString();
      context.fillRect(0, 0, this.width(), this.height());
    }
    if (this.shadowColor) {
      offx = Math.max(this.shadowOffset.x, 0);
      offy = Math.max(this.shadowOffset.y, 0);
      context.fillStyle = this.shadowColor.toString();
      i = 0;
      _ref = this.lines;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        width = context.measureText(line).width + shadowWidth;
        if (this.alignment === "right") {
          x = this.width() - width;
        } else if (this.alignment === "center") {
          x = (this.width() - width) / 2;
        } else {
          x = 0;
        }
        y = (i + 1) * (fontHeight(this.fontSize) + shadowHeight) - shadowHeight;
        i++;
        context.fillText(line, x + offx, y + offy);
      }
    }
    offx = Math.abs(Math.min(this.shadowOffset.x, 0));
    offy = Math.abs(Math.min(this.shadowOffset.y, 0));
    context.fillStyle = this.color.toString();
    i = 0;
    _ref1 = this.lines;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      line = _ref1[_j];
      width = context.measureText(line).width + shadowWidth;
      if (this.alignment === "right") {
        x = this.width() - width;
      } else if (this.alignment === "center") {
        x = (this.width() - width) / 2;
      } else {
        x = 0;
      }
      y = (i + 1) * (fontHeight(this.fontSize) + shadowHeight) - shadowHeight;
      i++;
      context.fillText(line, x + offx, y + offy);
    }
    start = Math.min(this.startMark, this.endMark);
    stop = Math.max(this.startMark, this.endMark);
    for (i = _k = start; start <= stop ? _k < stop : _k > stop; i = start <= stop ? ++_k : --_k) {
      p = this.slotCoordinates(i).subtract(this.position());
      c = this.text.charAt(i);
      context.fillStyle = this.markedBackgoundColor.toString();
      context.fillRect(p.x, p.y, context.measureText(c).width + 1, fontHeight(this.fontSize));
      context.fillStyle = this.markedTextColor.toString();
      context.fillText(c, p.x, p.y + fontHeight(this.fontSize));
    }
    if (this.parent) {
      if (this.parent.layoutChanged) {
        return this.parent.layoutChanged();
      }
    }
  };

  TextMorph.prototype.setExtent = function(aPoint) {
    this.maxWidth = Math.max(aPoint.x, 0);
    this.changed();
    return this.updateRendering();
  };

  TextMorph.prototype.slotRowAndColumn = function(slot) {
    var col, idx, row, _i, _j, _ref, _ref1;
    idx = 0;
    for (row = _i = 0, _ref = this.lines.length; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
      idx = this.lineSlots[row];
      for (col = _j = 0, _ref1 = this.lines[row].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
        if (idx === slot) {
          return [row, col];
        }
        idx += 1;
      }
    }
    return [this.lines.length - 1, this.lines[this.lines.length - 1].length - 1];
  };

  TextMorph.prototype.slotCoordinates = function(slot) {
    var context, shadowHeight, slotColumn, slotRow, x, xOffset, y, yOffset, _ref;
    _ref = this.slotRowAndColumn(slot), slotRow = _ref[0], slotColumn = _ref[1];
    context = this.image.getContext("2d");
    shadowHeight = Math.abs(this.shadowOffset.y);
    yOffset = slotRow * (fontHeight(this.fontSize) + shadowHeight);
    xOffset = context.measureText(this.lines[slotRow].substring(0, slotColumn)).width;
    x = this.left() + xOffset;
    y = this.top() + yOffset;
    return new Point(x, y);
  };

  TextMorph.prototype.slotAt = function(aPoint) {
    var charX, col, context, row, shadowHeight;
    charX = 0;
    row = 0;
    col = 0;
    shadowHeight = Math.abs(this.shadowOffset.y);
    context = this.image.getContext("2d");
    while (aPoint.y - this.top() > ((fontHeight(this.fontSize) + shadowHeight) * row)) {
      row += 1;
    }
    row = Math.max(row, 1);
    while (aPoint.x - this.left() > charX) {
      charX += context.measureText(this.lines[row - 1][col]).width;
      col += 1;
    }
    return this.lineSlots[Math.max(row - 1, 0)] + col - 1;
  };

  TextMorph.prototype.upFrom = function(slot) {
    var above, slotColumn, slotRow, _ref;
    _ref = this.slotRowAndColumn(slot), slotRow = _ref[0], slotColumn = _ref[1];
    if (slotRow < 1) {
      return slot;
    }
    above = this.lines[slotRow - 1];
    if (above.length < slotColumn - 1) {
      return this.lineSlots[slotRow - 1] + above.length;
    }
    return this.lineSlots[slotRow - 1] + slotColumn;
  };

  TextMorph.prototype.downFrom = function(slot) {
    var below, slotColumn, slotRow, _ref;
    _ref = this.slotRowAndColumn(slot), slotRow = _ref[0], slotColumn = _ref[1];
    if (slotRow > this.lines.length - 2) {
      return slot;
    }
    below = this.lines[slotRow + 1];
    if (below.length < slotColumn - 1) {
      return this.lineSlots[slotRow + 1] + below.length;
    }
    return this.lineSlots[slotRow + 1] + slotColumn;
  };

  TextMorph.prototype.startOfLine = function(slot) {
    return this.lineSlots[this.slotRowAndColumn(slot).y];
  };

  TextMorph.prototype.endOfLine = function(slot) {
    return this.startOfLine(slot) + this.lines[this.slotRowAndColumn(slot).y].length - 1;
  };

  TextMorph.prototype.developersMenu = function() {
    var menu;
    menu = TextMorph.__super__.developersMenu.call(this);
    menu.addLine();
    if (this.alignment !== "left") {
      menu.addItem("align left", (function() {
        return this.setAlignmentToLeft();
      }));
    }
    if (this.alignment !== "right") {
      menu.addItem("align right", (function() {
        return this.setAlignmentToRight();
      }));
    }
    if (this.alignment !== "center") {
      menu.addItem("align center", (function() {
        return this.setAlignmentToCenter();
      }));
    }
    menu.addItem("run contents", (function() {
      return this.doContents();
    }));
    return menu;
  };

  TextMorph.prototype.setAlignmentToLeft = function() {
    this.alignment = "left";
    this.updateRendering();
    return this.changed();
  };

  TextMorph.prototype.setAlignmentToRight = function() {
    this.alignment = "right";
    this.updateRendering();
    return this.changed();
  };

  TextMorph.prototype.setAlignmentToCenter = function() {
    this.alignment = "center";
    this.updateRendering();
    return this.changed();
  };

  TextMorph.prototype.evaluationMenu = function() {
    var menu;
    menu = this.hierarchyMenu();
    if (this.text.length > 0) {
      menu.prependLine();
      menu.prependItem("select all", (function() {
        return this.selectAllAndEdit();
      }));
    }
    if (this.selection().replace(/^\s\s*/, '').replace(/\s\s*$/, '') !== '') {
      menu.prependLine();
      menu.prependItem("inspect selection", (function() {
        return this.inspectSelection();
      }), "evaluate the\nselected expression\nand inspect the result");
      menu.prependItem("show selection", (function() {
        return this.showSelection();
      }), "evaluate the\nselected expression\nand show the result");
      menu.prependItem("do selection", (function() {
        return this.doSelection();
      }), "evaluate the\nselected expression");
    }
    return menu;
  };

  TextMorph.prototype.selectAllAndEdit = function() {
    this.edit();
    return this.selectAll();
  };

  TextMorph.prototype.setReceiver = function(obj) {
    this.receiver = obj;
    return this.customContextMenu = this.evaluationMenu;
  };

  TextMorph.prototype.doSelection = function() {
    this.receiver.evaluateString(this.selection());
    return this.edit();
  };

  TextMorph.prototype.doContents = function() {
    if (this.receiver != null) {
      return this.receiver.evaluateString(this.text);
    } else {
      return this.evaluateString(this.text);
    }
  };

  TextMorph.prototype.showSelection = function() {
    var result;
    result = this.receiver.evaluateString(this.selection());
    if (result != null) {
      return this.inform(result);
    }
  };

  TextMorph.prototype.inspectSelection = function() {
    var result;
    result = this.receiver.evaluateString(this.selection());
    if (result != null) {
      return this.spawnInspector(result);
    }
  };

  TextMorph.coffeeScriptSourceOfThisClass = '# TextMorph ///////////////////////////////////////////////////////////\n\n# I am a multi-line, word-wrapping String\n\n# Note that in the original Jens\' Morphic.js version he\n# has made this quasi-inheriting from StringMorph i.e. he is copying\n# over manually the following methods like so:\n#\n#  TextMorph::font = StringMorph::font\n#  TextMorph::edit = StringMorph::edit\n#  TextMorph::selection = StringMorph::selection\n#  TextMorph::selectionStartSlot = StringMorph::selectionStartSlot\n#  TextMorph::clearSelection = StringMorph::clearSelection\n#  TextMorph::deleteSelection = StringMorph::deleteSelection\n#  TextMorph::selectAll = StringMorph::selectAll\n#  TextMorph::mouseClickLeft = StringMorph::mouseClickLeft\n#  TextMorph::enableSelecting = StringMorph::enableSelecting \n#  TextMorph::disableSelecting = StringMorph::disableSelecting\n#  TextMorph::toggleIsDraggable = StringMorph::toggleIsDraggable\n#  TextMorph::toggleWeight = StringMorph::toggleWeight\n#  TextMorph::toggleItalic = StringMorph::toggleItalic\n#  TextMorph::setSerif = StringMorph::setSerif\n#  TextMorph::setSansSerif = StringMorph::setSansSerif\n#  TextMorph::setText = StringMorph::setText\n#  TextMorph::setFontSize = StringMorph::setFontSize\n#  TextMorph::numericalSetters = StringMorph::numericalSetters\n\n\nclass TextMorph extends StringMorph\n\n  words: []\n  lines: []\n  lineSlots: []\n  alignment: null\n  maxWidth: null\n  maxLineWidth: 0\n  backgroundColor: null\n\n  #additional properties for ad-hoc evaluation:\n  receiver: null\n\n  constructor: (\n    text, @fontSize = 12, @fontStyle = "sans-serif", @isBold = false,\n    @isItalic = false, @alignment = "left", @maxWidth = 0, fontName, shadowOffset,\n    @shadowColor = null\n    ) ->\n\n      super(text, @fontSize, @fontStyle, @isBold, @isItalic, null, shadowOffset, @shadowColor,null,fontName)\n      # override inherited properites:\n      @markedTextColor = new Color(255, 255, 255)\n      @markedBackgoundColor = new Color(60, 60, 120)\n      @text = text or ((if text is "" then text else "TextMorph"))\n      @fontName = fontName or WorldMorph.preferencesAndSettings.globalFontFamily\n      @shadowOffset = shadowOffset or new Point(0, 0)\n      @color = new Color(0, 0, 0)\n      @noticesTransparentClick = true\n  \n  breakTextIntoLines: ->\n    paragraphs = @text.split("\n")\n    canvas = newCanvas()\n    context = canvas.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    currentLine = ""\n    slot = 0\n    context.font = @font()\n    @maxLineWidth = 0\n    @lines = []\n    @lineSlots = [0]\n    @words = []\n    \n    # put all the text in an array, word by word\n    paragraphs.forEach (p) =>\n      @words = @words.concat(p.split(" "))\n      @words.push "\n"\n\n    # takes the text, word by word, and re-flows\n    # it according to the available width for the\n    # text (if there is such limit).\n    # The end result is an array of lines\n    # called @lines, which contains the string for\n    # each line (excluding the end of lines).\n    # Also another array is created, called\n    # @lineSlots, which memorises how many characters\n    # of the text have been consumed up to each line\n    #  example: original text: "Hello\nWorld"\n    # then @lines[0] = "Hello" @lines[1] = "World"\n    # and @lineSlots[0] = 6, @lineSlots[1] = 11\n    # Note that this algorithm doesn\'t work in case\n    # of single non-spaced words that are longer than\n    # the allowed width.\n    @words.forEach (word) =>\n      if word is "\n"\n        # we reached the end of the line in the\n        # original text, so push the line and the\n        # slots count in the arrays\n        @lines.push currentLine\n        @lineSlots.push slot\n        @maxLineWidth = Math.max(@maxLineWidth, context.measureText(currentLine).width)\n        currentLine = ""\n      else\n        if @maxWidth > 0\n          # there is a width limit, so we need\n          # to check whether we overflowed it. So create\n          # a prospective line and then check its width.\n          lineForOverflowTest = currentLine + word + " "\n          w = context.measureText(lineForOverflowTest).width\n          if w > @maxWidth\n            # ok we just overflowed the available space,\n            # so we need to push the old line and its\n            # "slot" number to the respective arrays.\n            # the new line is going to only contain the\n            # word that has caused the overflow.\n            @lines.push currentLine\n            @lineSlots.push slot\n            @maxLineWidth = Math.max(@maxLineWidth, context.measureText(currentLine).width)\n            currentLine = word + " "\n          else\n            # no overflow happened, so just proceed as normal\n            currentLine = lineForOverflowTest\n        else\n          currentLine = currentLine + word + " "\n        slot += word.length + 1\n  \n  \n  updateRendering: ->\n    @image = newCanvas()\n    context = @image.getContext("2d")\n    context.font = @font()\n    @breakTextIntoLines()\n\n    # set my extent\n    shadowWidth = Math.abs(@shadowOffset.x)\n    shadowHeight = Math.abs(@shadowOffset.y)\n    height = @lines.length * (fontHeight(@fontSize) + shadowHeight)\n    if @maxWidth is 0\n      @bounds = @bounds.origin.extent(new Point(@maxLineWidth + shadowWidth, height))\n    else\n      @bounds = @bounds.origin.extent(new Point(@maxWidth + shadowWidth, height))\n    @image.width = @width() * pixelRatio\n    @image.height = @height() * pixelRatio\n\n    # changing the canvas size resets many of\n    # the properties of the canvas, so we need to\n    # re-initialise the font and alignments here\n    context.scale pixelRatio, pixelRatio\n    context.font = @font()\n    context.textAlign = "left"\n    context.textBaseline = "bottom"\n\n    # fill the background, if desired\n    if @backgroundColor\n      context.fillStyle = @backgroundColor.toString()\n      context.fillRect 0, 0, @width(), @height()\n    #\n    # draw the shadow, if any\n    if @shadowColor\n      offx = Math.max(@shadowOffset.x, 0)\n      offy = Math.max(@shadowOffset.y, 0)\n      #console.log \'shadow x: \' + offx + " y: " + offy\n      context.fillStyle = @shadowColor.toString()\n      i = 0\n      for line in @lines\n        width = context.measureText(line).width + shadowWidth\n        if @alignment is "right"\n          x = @width() - width\n        else if @alignment is "center"\n          x = (@width() - width) / 2\n        else # \'left\'\n          x = 0\n        y = (i + 1) * (fontHeight(@fontSize) + shadowHeight) - shadowHeight\n        i++\n        context.fillText line, x + offx, y + offy\n    #\n    # now draw the actual text\n    offx = Math.abs(Math.min(@shadowOffset.x, 0))\n    offy = Math.abs(Math.min(@shadowOffset.y, 0))\n    #console.log \'maintext x: \' + offx + " y: " + offy\n    context.fillStyle = @color.toString()\n    i = 0\n    for line in @lines\n      width = context.measureText(line).width + shadowWidth\n      if @alignment is "right"\n        x = @width() - width\n      else if @alignment is "center"\n        x = (@width() - width) / 2\n      else # \'left\'\n        x = 0\n      y = (i + 1) * (fontHeight(@fontSize) + shadowHeight) - shadowHeight\n      i++\n      context.fillText line, x + offx, y + offy\n\n    # Draw the selection. This is done by re-drawing the\n    # selected text, one character at the time, just with\n    # a background rectangle.\n    start = Math.min(@startMark, @endMark)\n    stop = Math.max(@startMark, @endMark)\n    for i in [start...stop]\n      p = @slotCoordinates(i).subtract(@position())\n      c = @text.charAt(i)\n      context.fillStyle = @markedBackgoundColor.toString()\n      context.fillRect p.x, p.y, context.measureText(c).width + 1, fontHeight(@fontSize)\n      context.fillStyle = @markedTextColor.toString()\n      context.fillText c, p.x, p.y + fontHeight(@fontSize)\n    #\n    # notify my parent of layout change\n    @parent.layoutChanged()  if @parent.layoutChanged  if @parent\n  \n  setExtent: (aPoint) ->\n    @maxWidth = Math.max(aPoint.x, 0)\n    @changed()\n    @updateRendering()\n  \n  # TextMorph measuring ////\n\n  # answer the logical position point of the given index ("slot")\n  # i.e. the row and the column where a particular character is.\n  slotRowAndColumn: (slot) ->\n    idx = 0\n    # Note that this solution scans all the characters\n    # in all the rows up to the slot. This could be\n    # done a lot quicker by stopping at the first row\n    # such that @lineSlots[theRow] <= slot\n    # You could even do a binary search if one really\n    # wanted to, because the contents of @lineSlots are\n    # in order, as they contain a cumulative count...\n    for row in [0...@lines.length]\n      idx = @lineSlots[row]\n      for col in [0...@lines[row].length]\n        return [row, col]  if idx is slot\n        idx += 1\n    [@lines.length - 1, @lines[@lines.length - 1].length - 1]\n  \n  # Answer the position (in pixels) of the given index ("slot")\n  # where the caret should be placed.\n  # This is in absolute world coordinates.\n  # This function assumes that the text is left-justified.\n  slotCoordinates: (slot) ->\n    [slotRow, slotColumn] = @slotRowAndColumn(slot)\n    context = @image.getContext("2d")\n    shadowHeight = Math.abs(@shadowOffset.y)\n    yOffset = slotRow * (fontHeight(@fontSize) + shadowHeight)\n    xOffset = context.measureText((@lines[slotRow]).substring(0,slotColumn)).width\n    x = @left() + xOffset\n    y = @top() + yOffset\n    new Point(x, y)\n  \n  # Returns the slot (index) closest to the given point\n  # so the caret can be moved accordingly\n  # This function assumes that the text is left-justified.\n  slotAt: (aPoint) ->\n    charX = 0\n    row = 0\n    col = 0\n    shadowHeight = Math.abs(@shadowOffset.y)\n    context = @image.getContext("2d")\n    row += 1  while aPoint.y - @top() > ((fontHeight(@fontSize) + shadowHeight) * row)\n    row = Math.max(row, 1)\n    while aPoint.x - @left() > charX\n      charX += context.measureText(@lines[row - 1][col]).width\n      col += 1\n    @lineSlots[Math.max(row - 1, 0)] + col - 1\n  \n  upFrom: (slot) ->\n    # answer the slot above the given one\n    [slotRow, slotColumn] = @slotRowAndColumn(slot)\n    return slot  if slotRow < 1\n    above = @lines[slotRow - 1]\n    return @lineSlots[slotRow - 1] + above.length  if above.length < slotColumn - 1\n    @lineSlots[slotRow - 1] + slotColumn\n  \n  downFrom: (slot) ->\n    # answer the slot below the given one\n    [slotRow, slotColumn] = @slotRowAndColumn(slot)\n    return slot  if slotRow > @lines.length - 2\n    below = @lines[slotRow + 1]\n    return @lineSlots[slotRow + 1] + below.length  if below.length < slotColumn - 1\n    @lineSlots[slotRow + 1] + slotColumn\n  \n  startOfLine: (slot) ->\n    # answer the first slot (index) of the line for the given slot\n    @lineSlots[@slotRowAndColumn(slot).y]\n  \n  endOfLine: (slot) ->\n    # answer the slot (index) indicating the EOL for the given slot\n    @startOfLine(slot) + @lines[@slotRowAndColumn(slot).y].length - 1\n  \n  # TextMorph menus:\n  developersMenu: ->\n    menu = super()\n    menu.addLine()\n    menu.addItem "align left", (->@setAlignmentToLeft())  if @alignment isnt "left"\n    menu.addItem "align right", (->@setAlignmentToRight())  if @alignment isnt "right"\n    menu.addItem "align center", (->@setAlignmentToCenter())  if @alignment isnt "center"\n    menu.addItem "run contents", (->@doContents())\n    menu\n  \n  setAlignmentToLeft: ->\n    @alignment = "left"\n    @updateRendering()\n    @changed()\n  \n  setAlignmentToRight: ->\n    @alignment = "right"\n    @updateRendering()\n    @changed()\n  \n  setAlignmentToCenter: ->\n    @alignment = "center"\n    @updateRendering()\n    @changed()  \n  \n  # TextMorph evaluation:\n  evaluationMenu: ->\n    menu = @hierarchyMenu()\n\n    if @text.length > 0\n      menu.prependLine()\n      menu.prependItem "select all", (->@selectAllAndEdit())\n\n    # only show the do it / show it / inspect it entries\n    # if there is actually something selected.\n    if @selection().replace(/^\s\s*/, \'\').replace(/\s\s*$/, \'\') != \'\'\n      menu.prependLine()\n      menu.prependItem "inspect selection", (->@inspectSelection()), "evaluate the\nselected expression\nand inspect the result"\n      menu.prependItem "show selection", (->@showSelection()), "evaluate the\nselected expression\nand show the result"\n      menu.prependItem "do selection", (->@doSelection()), "evaluate the\nselected expression"\n    menu\n\n  selectAllAndEdit: ->\n    @edit()\n    @selectAll()\n   \n  # this is set by the inspector. It tells the TextMorph\n  # that any following doSelection/showSelection/inspectSelection action needs to be\n  # done apropos a particural obj\n  setReceiver: (obj) ->\n    @receiver = obj\n    @customContextMenu = @evaluationMenu\n  \n  doSelection: ->\n    @receiver.evaluateString @selection()\n    @edit()\n\n  doContents: ->\n    if @receiver?\n      @receiver.evaluateString @text\n    else\n      @evaluateString @text\n\n  showSelection: ->\n    result = @receiver.evaluateString(@selection())\n    if result? then @inform result\n  \n  inspectSelection: ->\n    # evaluateString is a pimped-up eval in\n    # the Morph class.\n    result = @receiver.evaluateString(@selection())\n    if result? then @spawnInspector result';

  return TextMorph;

})(StringMorph);

WorkspaceMorph = (function(_super) {
  __extends(WorkspaceMorph, _super);

  WorkspaceMorph.prototype.morphsList = null;

  WorkspaceMorph.prototype.buttonClose = null;

  WorkspaceMorph.prototype.resizer = null;

  function WorkspaceMorph(target) {
    WorkspaceMorph.__super__.constructor.call(this);
    this.silentSetExtent(new Point(WorldMorph.preferencesAndSettings.handleSize * 10, WorldMorph.preferencesAndSettings.handleSize * 20 * 2 / 3));
    this.isDraggable = true;
    this.border = 1;
    this.edge = 5;
    this.color = new Color(60, 60, 60);
    this.borderColor = new Color(95, 95, 95);
    this.buildAndConnectChildren();
  }

  WorkspaceMorph.prototype.setTarget = function(target) {
    this.target = target;
    this.currentProperty = null;
    return this.buildAndConnectChildren();
  };

  WorkspaceMorph.prototype.buildAndConnectChildren = function() {
    var ListOfMorphs, attribs, theWordMorph;
    attribs = [];
    this.destroyAll();
    this.children = [];
    this.label = new TextMorph("Morphs List");
    this.label.fontSize = WorldMorph.preferencesAndSettings.menuFontSize;
    this.label.isBold = true;
    this.label.color = new Color(255, 255, 255);
    this.add(this.label);
    theWordMorph = "Morph";
    ListOfMorphs = (Object.keys(window)).filter(function(i) {
      return i.indexOf(theWordMorph, i.length - theWordMorph.length) !== -1;
    });
    this.morphsList = new ListMorph(ListOfMorphs, null);
    this.morphsList.hBar.alpha = 0.6;
    this.morphsList.vBar.alpha = 0.6;
    this.add(this.morphsList);
    this.buttonClose = new TriggerMorph(this);
    this.buttonClose.setLabel("close");
    this.buttonClose.action = (function(_this) {
      return function() {
        return _this.destroy();
      };
    })(this);
    this.add(this.buttonClose);
    this.resizer = new HandleMorph(this, 150, 100, this.edge, this.edge);
    return this.layoutSubmorphs();
  };

  WorkspaceMorph.prototype.layoutSubmorphs = function() {
    var b, h, handleSize, r, w, x, y;
    Morph.prototype.trackChanges = false;
    handleSize = WorldMorph.preferencesAndSettings.handleSize;
    x = this.left() + this.edge;
    y = this.top() + this.edge;
    r = this.right() - this.edge;
    w = r - x;
    this.label.setPosition(new Point(x + handleSize * 2 / 3 + this.edge, y - this.edge / 2));
    this.label.setWidth(w);
    if (this.label.height() > (this.height() - 50)) {
      this.setHeight(this.label.height() + 50);
      this.changed();
    }
    y = this.label.bottom() + this.edge / 2;
    w = this.width() - this.edge;
    w -= this.edge;
    b = this.bottom() - (2 * this.edge) - handleSize;
    h = b - y;
    this.morphsList.setPosition(new Point(x, y));
    this.morphsList.setExtent(new Point(w, h));
    x = this.morphsList.left();
    y = this.morphsList.bottom() + this.edge;
    h = handleSize;
    w = this.morphsList.width() - h - this.edge;
    this.buttonClose.setPosition(new Point(x, y));
    this.buttonClose.setExtent(new Point(w, h));
    Morph.prototype.trackChanges = true;
    return this.changed();
  };

  WorkspaceMorph.prototype.setExtent = function(aPoint) {
    WorkspaceMorph.__super__.setExtent.call(this, aPoint);
    return this.layoutSubmorphs();
  };

  WorkspaceMorph.coffeeScriptSourceOfThisClass = '# WorkspaceMorph //////////////////////////////////////////////////////\n\n# just an experiment to see how a "close" button at the top left of\n# any window would look like. Unclear why I called it something\n# so important given that this looks like a temporary experiment.\n\nclass WorkspaceMorph extends BoxMorph\n\n  # panes:\n  morphsList: null\n  buttonClose: null\n  resizer: null\n\n  constructor: (target) ->\n    super()\n\n    @silentSetExtent new Point(\n      WorldMorph.preferencesAndSettings.handleSize * 10,\n      WorldMorph.preferencesAndSettings.handleSize * 20 * 2 / 3)\n    @isDraggable = true\n    @border = 1\n    @edge = 5\n    @color = new Color(60, 60, 60)\n    @borderColor = new Color(95, 95, 95)\n    @buildAndConnectChildren()\n  \n  setTarget: (target) ->\n    @target = target\n    @currentProperty = null\n    @buildAndConnectChildren()\n  \n  buildAndConnectChildren: ->\n    attribs = []\n\n    # remove existing panes\n    @destroyAll()\n\n    @children = []\n\n    # label\n    @label = new TextMorph("Morphs List")\n    @label.fontSize = WorldMorph.preferencesAndSettings.menuFontSize\n    @label.isBold = true\n    @label.color = new Color(255, 255, 255)\n    @add @label\n\n    # Check which objects end with the word Morph\n    theWordMorph = "Morph"\n    ListOfMorphs = (Object.keys(window)).filter (i) ->\n      i.indexOf(theWordMorph, i.length - theWordMorph.length) isnt -1\n    @morphsList = new ListMorph(ListOfMorphs, null)\n\n    # so far nothing happens when items are selected\n    #@morphsList.action = (selected) ->\n    #  val = myself.target[selected]\n    #  myself.currentProperty = val\n    #  if val is null\n    #    txt = "NULL"\n    #  else if isString(val)\n    #    txt = val\n    #  else\n    #    txt = val.toString()\n    #  cnts = new TextMorph(txt)\n    #  cnts.isEditable = true\n    #  cnts.enableSelecting()\n    #  cnts.setReceiver myself.target\n    #  myself.detail.setContents cnts\n\n    @morphsList.hBar.alpha = 0.6\n    @morphsList.vBar.alpha = 0.6\n    @add @morphsList\n\n    # close button\n    @buttonClose = new TriggerMorph(@)\n    @buttonClose.setLabel "close"\n    @buttonClose.action = =>\n      @destroy()\n\n    @add @buttonClose\n\n    # resizer\n    @resizer = new HandleMorph(@, 150, 100, @edge, @edge)\n\n    # update layout\n    @layoutSubmorphs()\n  \n  layoutSubmorphs: ->\n    Morph::trackChanges = false\n\n    handleSize = WorldMorph.preferencesAndSettings.handleSize;\n\n    x = @left() + @edge\n    y = @top() + @edge\n    r = @right() - @edge\n    w = r - x\n\n    # label\n    @label.setPosition new Point(x + handleSize * 2/3 + @edge, y - @edge/2)\n    @label.setWidth w\n    if @label.height() > (@height() - 50)\n      @setHeight @label.height() + 50\n      @changed()\n      #@resizer.updateRendering()\n\n    # morphsList\n    y = @label.bottom() + @edge/2\n    w = @width() - @edge\n    w -= @edge\n    b = @bottom() - (2 * @edge) - handleSize\n    h = b - y\n    @morphsList.setPosition new Point(x, y)\n    @morphsList.setExtent new Point(w, h)\n\n    # close button\n    x = @morphsList.left()\n    y = @morphsList.bottom() + @edge\n    h = handleSize\n    w = @morphsList.width() - h - @edge\n    @buttonClose.setPosition new Point(x, y)\n    @buttonClose.setExtent new Point(w, h)\n    Morph::trackChanges = true\n    @changed()\n  \n  setExtent: (aPoint) ->\n    super aPoint\n    @layoutSubmorphs()';

  return WorkspaceMorph;

})(BoxMorph);

morphicVersion = 'version of 2015-02-22 19:44:30';
