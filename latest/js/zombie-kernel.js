// Generated by CoffeeScript 1.7.1
var Arg, Args, AutomatorCommand, AutomatorCommandCheckNumberOfItemsInMenu, AutomatorCommandCheckStringsOfItemsInMenuOrderImportant, AutomatorCommandCheckStringsOfItemsInMenuOrderUnimportant, AutomatorCommandCopy, AutomatorCommandDoNothing, AutomatorCommandDrop, AutomatorCommandGrab, AutomatorCommandKeyDown, AutomatorCommandKeyPress, AutomatorCommandKeyUp, AutomatorCommandLeftOrRightClickOnMenuItem, AutomatorCommandMouseButtonChange, AutomatorCommandMouseClick, AutomatorCommandMouseDoubleClick, AutomatorCommandMouseMove, AutomatorCommandOpenContextMenu, AutomatorCommandPaste, AutomatorCommandResetWorld, AutomatorCommandScreenshot, AutomatorCommandShowComment, AutomatorCommandTurnOffAlignmentOfMorphIDsMechanism, AutomatorCommandTurnOffAnimationsPacingControl, AutomatorCommandTurnOffHidingOfMorphsContentExtractInLabels, AutomatorCommandTurnOffHidingOfMorphsGeometryInfoInLabels, AutomatorCommandTurnOffHidingOfMorphsNumberIDInLabels, AutomatorCommandTurnOnAlignmentOfMorphIDsMechanism, AutomatorCommandTurnOnAnimationsPacingControl, AutomatorCommandTurnOnHidingOfMorphsContentExtractInLabels, AutomatorCommandTurnOnHidingOfMorphsGeometryInfoInLabels, AutomatorCommandTurnOnHidingOfMorphsNumberIDInLabels, AutomatorRecorderAndPlayer, BackingStoreMixin, BasicCalculatedVal, BlinkerMorph, BouncerMorph, BoxMorph, CanvasMorph, CaretMorph, CircleBoxMorph, Color, ColorPaletteMorph, ColorPickerMorph, ContainerMixin, ControllerMixin, DeepCopierMixin, FrameMorph, GrayPaletteMorph, GroundVal, HandMorph, HandleMorph, HashCalculator, InspectorMorph, LayoutAdjustingMorph, LayoutMorph, LayoutSpec, ListMorph, MenuItemMorph, MenuMorph, MixedClassKeywords, Morph, MorphicNode, MorphsListMorph, MouseSensorMorph, Mousetrap, PenMorph, Point, Point2, PreferencesAndSettings, ProfilerData, ProfilingDataCollector, ReactiveValuesTests, ReactiveValuesTestsRectangleMorph, Rectangle, RectangleMorph, ScrollFrameMorph, ShadowMorph, SliderButtonMorph, SliderMorph, SpeechBubbleMorph, StringFieldMorph, StringMorph, SystemInfo, SystemTestsControlPanelUpdater, SystemTestsReferenceImage, SystemTestsSystemInfo, TextMorph, TriggerMorph, WorkspaceMorph, WorldMorph, arrayShallowCopy, arrayShallowCopyAndReverse, contains, decamelize, degreesToRadians, detect, fade, fontHeight, getBlurredShadowSupport, getDocumentPositionOf, getMinimumFontHeight, getParameterByName, hashCode, i, isFunction, isNil, isObject, isString, localize, morphicVersion, namedClasses, newCanvas, noOperation, nop, radiansToDegrees, sizeOf, _KEYCODE_MAP, _MAP, _REVERSE_MAP, _SHIFT_MAP, _SPECIAL_ALIASES, _addEvent, _bindMultiple, _bindSequence, _bindSingle, _callbacks, _characterFromEvent, _directMap, _eventModifiers, _fireCallback, _getMatches, _getReverseMap, _handleCharacter, _handleKey, _ignoreNextKeyup, _isModifier, _modifiersMatch, _pickBestAction, _resetSequenceTimer, _resetSequences, _resetTimer, _sequenceLevels, _sequenceType,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

ProfilerData = (function() {
  function ProfilerData() {}

  ProfilerData.reactiveValues_valueRecalculations = 0;

  ProfilerData.reactiveValues_signatureCalculations = 0;

  ProfilerData.reactiveValues_signatureComparison = 0;

  ProfilerData.reactiveValues_argumentInvalidations = 0;

  ProfilerData.reactiveValues_valueInvalidations = 0;

  ProfilerData.reactiveValues_parentValuesRechecks = 0;

  ProfilerData.reactiveValues_createdGroundVals = 0;

  ProfilerData.reactiveValues_createdBasicCalculatedValues = 0;

  ProfilerData.resetReactiveValuesCounts = function() {
    this.reactiveValues_valueRecalculations = 0;
    this.reactiveValues_signatureCalculations = 0;
    this.reactiveValues_signatureComparison = 0;
    this.reactiveValues_argumentInvalidations = 0;
    this.reactiveValues_valueInvalidations = 0;
    this.reactiveValues_parentValuesRechecks = 0;
    this.reactiveValues_createdGroundVals = 0;
    return this.reactiveValues_createdBasicCalculatedValues = 0;
  };

  ProfilerData.coffeeScriptSourceOfThisClass = 'class ProfilerData\n  \n  @reactiveValues_valueRecalculations: 0\n  @reactiveValues_signatureCalculations: 0\n  @reactiveValues_signatureComparison: 0\n  @reactiveValues_argumentInvalidations: 0\n  @reactiveValues_valueInvalidations: 0\n  @reactiveValues_parentValuesRechecks: 0\n  @reactiveValues_createdGroundVals: 0\n  @reactiveValues_createdBasicCalculatedValues: 0\n\n  @resetReactiveValuesCounts: ->\n    @reactiveValues_valueRecalculations = 0\n    @reactiveValues_signatureCalculations = 0\n    @reactiveValues_signatureComparison = 0\n    @reactiveValues_argumentInvalidations = 0\n    @reactiveValues_valueInvalidations = 0\n    @reactiveValues_parentValuesRechecks = 0\n    @reactiveValues_createdGroundVals = 0\n    @reactiveValues_createdBasicCalculatedValues = 0\n\n';

  return ProfilerData;

})();

Arg = (function() {
  Arg.prototype.valWrappedByThisArg = null;

  Arg.prototype.maybeChangedSinceLastCalculation = true;

  Arg.prototype.directlyCalculatedFromParent = false;

  Arg.prototype.fromChild = false;

  Arg.prototype.fromLocal = false;

  Arg.prototype.directlyOrIndirectlyCalculatedFromParent = false;

  Arg.prototype.morphContainingThisArg = null;

  Arg.prototype.args = null;

  Arg.prototype.markedForRemoval = false;

  Arg.signatureAtLastCalculation = "";

  Arg.id = "";

  function Arg(valWrappedByThisArg, valContainingThisArg) {
    this.valWrappedByThisArg = valWrappedByThisArg;
    this.valContainingThisArg = valContainingThisArg;
    this.morphContainingThisArg = this.valContainingThisArg.ownerMorph;
    this.args = this.valContainingThisArg.args;
    this.id = this.valWrappedByThisArg.id;
    this.args.argById[this.id] = this;
  }

  Arg.prototype.fetchVal = function() {
    return this.valWrappedByThisArg.fetchVal();
  };

  Arg.prototype.getSignatureOrCustomSignatureOfWrappedVal = function() {
    var theValSignature;
    if (this.args.customSignatureMethod != null) {
      theValSignature = this.args.customSignatureMethod(this.valWrappedByThisArg);
    } else {
      theValSignature = this.valWrappedByThisArg.lastCalculatedValContent.signature;
      if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
        console.log("fetching default signature of argument: " + this.id + " : " + theValSignature);
      }
    }
    theValSignature = theValSignature + this.markedForRemoval;
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      console.log("calculated signature of argument: " + this.id + " : " + theValSignature);
    }
    return theValSignature;
  };

  Arg.prototype.semanticallyChangedSinceLastValCalculation = function() {
    if (this.getSignatureOrCustomSignatureOfWrappedVal() !== this.signatureAtLastCalculation) {
      return true;
    } else {
      return false;
    }
  };

  Arg.prototype.checkBasedOnSignature = function() {
    var signatureOfArgUsedInLastCalculation;
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      console.log("checking signature of argument: " + this.id);
    }
    signatureOfArgUsedInLastCalculation = this.signatureAtLastCalculation;
    if (signatureOfArgUsedInLastCalculation === void 0) {
      if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
        console.log("argument: " + this.id + " is undefined, breaking and returning ");
      }
      this["break"]();
      return void 0;
    }
    if (this.valWrappedByThisArg.lastCalculatedValContentMaybeOutdated) {
      if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
        console.log("argument: " + this.id + " is broken on its own anyways, breaking this arg");
      }
      return this["break"]();
    } else {
      if (this.semanticallyChangedSinceLastValCalculation()) {
        if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
          console.log("argument: " + this.id + " has equal signature to one used for last calculation, healing");
        }
        return this.heal();
      } else {
        if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
          console.log("argument: " + this.id + " has different signature to one used for last calculation, breaking");
        }
        return this["break"]();
      }
    }
  };

  Arg.prototype.updateSignature = function() {
    var newSig, oldSig, signatureChanged;
    oldSig = this.signatureAtLastCalculation;
    newSig = this.getSignatureOrCustomSignatureOfWrappedVal();
    signatureChanged = false;
    if (newSig !== oldSig) {
      signatureChanged = true;
    }
    this.signatureAtLastCalculation = newSig;
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      if (signatureChanged) {
        console.log("checked signature of argument: " + this.id + " and it changed was: " + oldSig + " now is: " + newSig);
      } else {
        console.log("checked signature of argument: " + this.id + " and it didn't change was: " + oldSig + " now is: " + newSig);
      }
    }
    return signatureChanged;
  };

  Arg.prototype.updateSignatureAndHeal = function() {
    var signatureChanged;
    signatureChanged = this.updateSignature();
    this.heal();
    return signatureChanged;
  };

  Arg.prototype.heal = function() {
    this.maybeChangedSinceLastCalculation = false;
    delete this.args.argsMaybeChangedSinceLastCalculationById[this.id];
    this.args.countOfDamaged--;
    if (!this.valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal) {
      return this.valContainingThisArg.checkAndPropagateChangeBasedOnArgChange();
    }
  };

  Arg.prototype["break"] = function() {
    this.maybeChangedSinceLastCalculation = true;
    this.args.argsMaybeChangedSinceLastCalculationById[this.id] = true;
    this.args.countOfDamaged++;
    if (!this.valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal) {
      return this.valContainingThisArg.checkAndPropagateChangeBasedOnArgChange();
    }
  };

  Arg.prototype.markForRemoval = function() {
    this.markedForRemoval = true;
    this.turnIntoArgNotDirectlyNorIndirectlyDependingOnParent();
    return this.morphContainingThisArg.argMightHaveChanged(this.valWrappedByThisArg);
  };

  Arg.prototype.unmarkForRemoval = function() {
    return this.markedForRemoval = false;
  };

  Arg.prototype.removeArgIfMarkedForRemoval = function() {
    if (this.markedForRemoval) {
      this.removeFromArgs();
      return true;
    } else {
      return false;
    }
  };

  Arg.prototype.removeFromArgs = function() {
    delete this.args.argById[this.id];
    if (this.args.argsMaybeChangedSinceLastCalculationById[this.id] != null) {
      delete this.args.argsMaybeChangedSinceLastCalculationById[this.id];
      return this.args.countOfDamaged--;
    }
  };

  Arg.prototype.disconnectChildArg = function() {
    this.fromChild = false;
    delete this.args.childrenArgByName[this.valContainingThisArg.valName];
    this.args.childrenArgByNameCount[this.valContainingThisArg.valName]--;
    return this.markForRemoval();
  };

  Arg.prototype.disconnectParentArg = function() {
    this.directlyCalculatedFromParent = false;
    this.directlyOrIndirectlyCalculatedFromParent = true;
    delete this.args.parentArgByName[this.valContainingThisArg.valName];
    return this.markForRemoval();
  };

  Arg.prototype.turnIntoArgDirectlyOrIndirectlyDependingOnParent = function() {
    var cv, k, v, _i, _j, _len, _len1, _ref, _results;
    this.args.calculatedDirectlyOfIndirectlyFromParentById[this.valWrappedByThisArg.id] = true;
    if (this.args.calculatedDirectlyOfIndirectlyFromParentById[this.valWrappedByThisArg.id] == null) {
      this.args.calculatedDirectlyOfIndirectlyFromParentByIdCount++;
    }
    this.valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal = true;
    this.directlyOrIndirectlyCalculatedFromParent = true;
    _ref = this.valContainingThisArg.localValsAffectedByChangeOfThisVal;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cv = _ref[_i];
      cv.stainValCalculatedFromParent(this.valContainingThisArg);
    }
    if (this.ownerMorph.parent != null) {
      v = this.morphContainingThisArg.parent.morphValsDependingOnChildrenVals[this.valName];
      _results = [];
      for (_j = 0, _len1 = v.length; _j < _len1; _j++) {
        k = v[_j];
        _results.push(k.stainValCalculatedFromParent(this.valContainingThisArg));
      }
      return _results;
    }
  };

  Arg.prototype.turnIntoArgNotDirectlyNorIndirectlyDependingOnParent = function() {
    var cv, k, v, _i, _j, _len, _len1, _ref, _results;
    if (this.args.calculatedDirectlyOfIndirectlyFromParentById[this.valWrappedByThisArg.id] != null) {
      this.args.calculatedDirectlyOfIndirectlyFromParentByIdCount--;
    }
    delete this.args.calculatedDirectlyOfIndirectlyFromParentById[this.valWrappedByThisArg.id];
    this.directlyOrIndirectlyCalculatedFromParent = false;
    if (this.args.calculatedDirectlyOfIndirectlyFromParentByIdCount > 0) {
      this.valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal = false;
      _ref = this.valContainingThisArg.localValsAffectedByChangeOfThisVal;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        cv = _ref[_i];
        cv.unstainValCalculatedFromParent(this.valContainingThisArg);
      }
      if (this.valContainingThisArg.ownerMorph.parent != null) {
        v = this.morphContainingThisArg.parent.morphValsDependingOnChildrenVals[this.valContainingThisArg.valName];
        _results = [];
        for (_j = 0, _len1 = v.length; _j < _len1; _j++) {
          k = v[_j];
          _results.push(k.unstainValCalculatedFromParent(this.valContainingThisArg));
        }
        return _results;
      }
    }
  };

  Arg.coffeeScriptSourceOfThisClass = '# an Arg wraps a Val that is an input to the\n# calculation of the current Val.\n# an Arg for example contains the signature that\n# the input val had when the Val was calculated.\n# The signature could be a custom signature that is\n# only relevant to this Val. So it contains several\n# pieces of information about each input val, that are\n# specific to the context of this Val (hence, we\n# can\'t put it in the input arg val, we need to\n# put this Arg which lives in the context of this\n# Val).\n\n# REQUIRES ProfilerData\n\nclass Arg\n  valWrappedByThisArg: null\n  maybeChangedSinceLastCalculation: true\n  \n  # an argument can either be\n  #  1. connected to a parent\n  #  2. connected to a child\n  #  3. connected to a local value\n  # and this is determined when the\n  # value that depends on this argument is created.\n  # (the parent/child is dynamic, but the nature of\n  # the argument is decided early)\n  directlyCalculatedFromParent: false\n  fromChild: false\n  fromLocal: false\n\n  # this flag tracks whether this argument\n  # directly or indirectly depends on a parent\n  # value. So if @directlyCalculatedFromParent is true\n  # then this is true as well. But this could be true\n  # even is @directlyCalculatedFromParent is false,\n  # because you could have an argument which\n  # is connected to a value in a child BUT\n  # that value might directly or indirectly\n  # depend on a parent value at some stage.\n  directlyOrIndirectlyCalculatedFromParent: false\n  \n  morphContainingThisArg: null\n  args: null\n  markedForRemoval: false\n  # we keep the vals of the args we\n  # used to calculate the last val. This is so\n  # we can keep an eye on how the args\n  # change. If they change back to the original\n  # vals we used then we can propagate this\n  # "OK our last calculation actually holds"\n  # information WITHOUT triggering a recalculation.\n  @signatureAtLastCalculation: ""\n  @id: ""\n\n  constructor: (@valWrappedByThisArg, @valContainingThisArg) ->\n    @morphContainingThisArg = @valContainingThisArg.ownerMorph\n    @args = @valContainingThisArg.args\n    @id = @valWrappedByThisArg.id\n    @args.argById[@id] = @\n\n  fetchVal: () ->\n    @valWrappedByThisArg.fetchVal()\n\n  ################################################\n  #  signature checking / calculation\n  ################################################\n\n  # we give the opportunity to specify a custom signature\n  # for args, in case we have a signature that\n  # is more efficient considering the type of\n  # calculation that we are going to do\n  getSignatureOrCustomSignatureOfWrappedVal: () ->\n    if @args.customSignatureMethod?\n      theValSignature = @args.customSignatureMethod @valWrappedByThisArg\n    else\n      theValSignature = @valWrappedByThisArg.lastCalculatedValContent.signature\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "fetching default signature of argument: " + @id + " : " + theValSignature\n    theValSignature = theValSignature + @markedForRemoval\n\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "calculated signature of argument: " + @id + " : " + theValSignature\n\n    return theValSignature\n\n  semanticallyChangedSinceLastValCalculation: () ->\n    if @getSignatureOrCustomSignatureOfWrappedVal() != @signatureAtLastCalculation\n      return true\n    else\n      return false\n\n  # an Argument of this value has notified its change\n  # but we want to check, based on either its default\n  # signature or a custom signature, whether its\n  # value changed from when we calculated this value\n  # the last time. Following this check, we might\n  # "heal"/break the value and potentially\n  # propagate the change\n  checkBasedOnSignature: () ->\n\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "checking signature of argument: " + @id\n\n    # the unique identifier of a val is given by\n    # its name as a string and the id of the Morph it\n    # belongs to. For localVals this is ever so slightly\n    # inefficient as you could always index them through\n    # an integer, which would be faster, but probably\n    # the improvement would be "in the noise".\n    signatureOfArgUsedInLastCalculation =\n      @signatureAtLastCalculation\n    # this is the case where a child has been added:\n    # the arg wasn\'t there before\n    if signatureOfArgUsedInLastCalculation == undefined\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "argument: " + @id + " is undefined, breaking and returning "\n      @break()\n      return undefined\n\n    # if the arg which has maybe changed doesn\'t know\n    # its val then we just mark the arg as broken\n    # and we do nothing else\n    if @valWrappedByThisArg.lastCalculatedValContentMaybeOutdated\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "argument: " + @id + " is broken on its own anyways, breaking this arg"\n      @break()\n    else\n      # if the val that asserts change claims that its val\n      # is actually correct then we proceed to check its\n      # signature to check whether it changed since the\n      # last time we calculated our val.\n      # We let the user provide her own signature calculation\n      # method for args: this is because for the purpose of\n      # the calculation of this val, there might be a better\n      # notion of equivalency of the args that lets us be\n      # more tolerant of changes (which means less invalidation which\n      # means less recalculations which means fewer invalidations further\n      # on). An example of such "wider" equivalency is for the HSV color\n      # values if we need to convert them to RGB. Every HSV value\n      # with V set to zero is equivalent in this respect because it\n      # always means black.\n      if @semanticallyChangedSinceLastValCalculation()\n        # argsMaybeChangedSinceLastCalculation is an object, we add\n        # a property to it for each dirty arg, so we delete\n        # such property when we verify it\'s actually healthy.\n        if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n          console.log "argument: " + @id + " has equal signature to one used for last calculation, healing"\n        @heal()\n      else\n        if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n          console.log "argument: " + @id + " has different signature to one used for last calculation, breaking"\n        @break()\n\n\n  updateSignature: () ->\n    oldSig = @signatureAtLastCalculation\n    newSig = @getSignatureOrCustomSignatureOfWrappedVal()\n    signatureChanged = false\n    if newSig != oldSig\n        signatureChanged = true\n    @signatureAtLastCalculation = newSig\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      if signatureChanged\n      	console.log "checked signature of argument: " + @id + " and it changed was: " + oldSig + " now is: " + newSig\n      else\n      	console.log "checked signature of argument: " + @id + " and it didn\'t change was: " + oldSig + " now is: " + newSig\n    return signatureChanged\n\n  updateSignatureAndHeal: () ->\n    signatureChanged = @updateSignature()\n    @heal()\n    return signatureChanged\n\n\n  ################################################\n  #  breaking / healing\n  ################################################\n\n  heal: () ->\n    @maybeChangedSinceLastCalculation = false\n    delete @args.argsMaybeChangedSinceLastCalculationById[@id]\n    @args.countOfDamaged--\n    # check implications of argument being healed: it\n    # might be that this means that the value heals as\n    # well and propagates healing\n    if !@valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal\n      @valContainingThisArg.checkAndPropagateChangeBasedOnArgChange()\n\n  break: () ->\n    @maybeChangedSinceLastCalculation = true\n    @args.argsMaybeChangedSinceLastCalculationById[@id] = true\n    @args.countOfDamaged++\n    # check implications of argument being broken: it\n    # might be that this means that the value breaks as\n    # well and propagates damage\n    if !@valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal\n      @valContainingThisArg.checkAndPropagateChangeBasedOnArgChange()\n\n\n  ################################################\n  #  removal\n  ################################################\n\n  # we don\'t completely destroy the argument\n  # (like removeFromArgs does)\n  # for the simple reason that we do need to\n  # remember its signature when the value\n  # was last calculated.\n  markForRemoval: () ->\n    @markedForRemoval = true\n    @turnIntoArgNotDirectlyNorIndirectlyDependingOnParent()\n    @morphContainingThisArg.argMightHaveChanged(@valWrappedByThisArg)\n\n  unmarkForRemoval: () ->\n    @markedForRemoval = false\n\n  removeArgIfMarkedForRemoval: () ->\n    if @markedForRemoval\n      @removeFromArgs()\n      return true\n    else\n      return false\n\n  removeFromArgs: () ->\n    #@turnIntoArgNotDirectlyNorIndirectlyDependingOnParent()\n    delete @args.argById[@id]\n    if @args.argsMaybeChangedSinceLastCalculationById[@id]?\n      delete @args.argsMaybeChangedSinceLastCalculationById[@id]\n      @args.countOfDamaged--\n\n\n\n  ################################################\n  #  disconnection\n  ################################################\n\n  disconnectChildArg: () ->\n    @fromChild = false\n    delete @args.childrenArgByName[@valContainingThisArg.valName]\n    @args.childrenArgByNameCount[@valContainingThisArg.valName]--\n    @markForRemoval()\n\n  disconnectParentArg: () ->\n    @directlyCalculatedFromParent = false\n    @directlyOrIndirectlyCalculatedFromParent = true\n    delete @args.parentArgByName[@valContainingThisArg.valName]\n    @markForRemoval()\n\n  ################################################\n  #  (un)turning into argument\n  #  directly or indirectly depending on parent\n  ################################################\n\n  turnIntoArgDirectlyOrIndirectlyDependingOnParent: () ->\n    @args.calculatedDirectlyOfIndirectlyFromParentById[@valWrappedByThisArg.id] = true\n    if !@args.calculatedDirectlyOfIndirectlyFromParentById[@valWrappedByThisArg.id]?\n        @args.calculatedDirectlyOfIndirectlyFromParentByIdCount++\n    @valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal = true\n    @directlyOrIndirectlyCalculatedFromParent = true\n\n    for cv in @valContainingThisArg.localValsAffectedByChangeOfThisVal\n      cv.stainValCalculatedFromParent @valContainingThisArg\n    if @ownerMorph.parent?\n      v = @morphContainingThisArg.parent.morphValsDependingOnChildrenVals[@valName]\n      for k in v\n        k.stainValCalculatedFromParent @valContainingThisArg\n\n\n\n  turnIntoArgNotDirectlyNorIndirectlyDependingOnParent: () ->\n    # note that we might turn also an Argument that we know\n    # directly depends on a parent. The reason is that\n    # we might be removing the parent, in which case\n    # this morph might cease to depend on parent values.\n    # we need to find out by doing the full works here.\n\n    # this changes @directlyOrIndirectlyDependsOnAParentVal if there are no\n    # more args depending on parent vals\n    if @args.calculatedDirectlyOfIndirectlyFromParentById[@valWrappedByThisArg.id]?\n        @args.calculatedDirectlyOfIndirectlyFromParentByIdCount--\n    delete @args.calculatedDirectlyOfIndirectlyFromParentById[@valWrappedByThisArg.id]\n    @directlyOrIndirectlyCalculatedFromParent = false\n\n    if @args.calculatedDirectlyOfIndirectlyFromParentByIdCount > 0\n      @valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal = false\n\n      # this means that the arg that has unstained itself\n      # was the last and only reason why this val was stained\n      # so we proceed to unstain ourselves\n      for cv in @valContainingThisArg.localValsAffectedByChangeOfThisVal\n        cv.unstainValCalculatedFromParent @valContainingThisArg\n      if @valContainingThisArg.ownerMorph.parent?\n        v = @morphContainingThisArg.parent.morphValsDependingOnChildrenVals[@valContainingThisArg.valName]\n        for k in v\n          k.unstainValCalculatedFromParent @valContainingThisArg';

  return Arg;

})();

Args = (function() {
  Args.prototype.argById = null;

  Args.prototype.parentArgByName = null;

  Args.prototype.childrenArgByName = null;

  Args.prototype.childrenArgByNameCount = null;

  Args.prototype.localArgByName = null;

  Args.prototype.calculatedDirectlyOfIndirectlyFromParentById = null;

  Args.prototype.calculatedDirectlyOfIndirectlyFromParentByIdCount = 0;

  Args.prototype.countOfDamaged = 0;

  Args.prototype.morphContainingTheseArgs = null;

  Args.prototype.argsMaybeChangedSinceLastCalculationById = null;

  function Args(valContainingTheseArgs) {
    this.valContainingTheseArgs = valContainingTheseArgs;
    this.argById = {};
    this.parentArgByName = {};
    this.childrenArgByName = {};
    this.childrenArgByNameCount = {};
    this.localArgByName = {};
    this.calculatedDirectlyOfIndirectlyFromParentById = {};
    this.argsMaybeChangedSinceLastCalculationById = {};
    this.morphContainingTheseArgs = this.valContainingTheseArgs.ownerMorph;
  }

  Args.prototype.healAll = function() {
    var eachArg, _results;
    _results = [];
    for (eachArg in this.argsMaybeChangedSinceLastCalculationById) {
      _results.push(eachArg.heal());
    }
    return _results;
  };

  Args.prototype.getByVal = function(theVal) {
    return this.getById(theVal.id);
  };

  Args.prototype.setup_AddAllLocalArgVals = function(localInputVals) {
    var each, newArg, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = localInputVals.length; _i < _len; _i++) {
      each = localInputVals[_i];
      each.localValsAffectedByChangeOfThisVal.push(this.valContainingTheseArgs);
      newArg = new Arg(localInputVals, this.valContainingTheseArgs);
      newArg.fromLocal = true;
      _results.push(this.localArgByName[localInputVals.valueName] = newArg);
    }
    return _results;
  };

  Args.prototype.setup_AddAllParentArgNames = function(parentArgsNames) {
    var eachVar, _base, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = parentArgsNames.length; _i < _len; _i++) {
      eachVar = parentArgsNames[_i];
      if ((_base = this.morphContainingTheseArgs.morphValsDirectlyDependingOnParentVals)[eachVar] == null) {
        _base[eachVar] = {};
      }
      _results.push(this.morphContainingTheseArgs.morphValsDirectlyDependingOnParentVals[eachVar][this.valContainingTheseArgs.valName] = this.valContainingTheseArgs);
    }
    return _results;
  };

  Args.prototype.setup_AddAllChildrenArgNames = function(childrenArgsNames) {
    var eachVar, _base, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = childrenArgsNames.length; _i < _len; _i++) {
      eachVar = childrenArgsNames[_i];
      if ((_base = this.morphContainingTheseArgs.morphValsDependingOnChildrenVals)[eachVar] == null) {
        _base[eachVar] = {};
      }
      _results.push(this.morphContainingTheseArgs.morphValsDependingOnChildrenVals[eachVar][this.valContainingTheseArgs.valName] = this.valContainingTheseArgs);
    }
    return _results;
  };

  Args.prototype.tryToReconnectDisconnectedArgFirst = function(parentOrChildVal) {
    var existingArg;
    existingArg = this.argById[parentOrChildVal.id];
    if (existingArg != null) {
      existingArg.markedForRemoval = false;
      existingArg.valContainingThisArg.argMightHaveChanged(parentOrChildVal);
      return existingArg;
    }
    return null;
  };

  Args.prototype.connectToChildVal = function(valDependingOnChildrenVal, childVal) {
    var argumentToBeConnected, _base, _base1, _name, _name1;
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      console.log("connecting " + valDependingOnChildrenVal.valName + " in morph " + valDependingOnChildrenVal.ownerMorph.uniqueIDString() + " to receive input from " + childVal.valName + " in morph " + childVal.ownerMorph.uniqueIDString());
    }
    argumentToBeConnected = this.tryToReconnectDisconnectedArgFirst(childVal);
    if (argumentToBeConnected == null) {
      argumentToBeConnected = new Arg(childVal, valDependingOnChildrenVal);
    }
    argumentToBeConnected.fromChild = true;
    if ((_base = this.childrenArgByName)[_name = childVal.valName] == null) {
      _base[_name] = {};
    }
    this.childrenArgByName[childVal.valName][childVal.id] = argumentToBeConnected;
    if ((_base1 = this.childrenArgByNameCount)[_name1 = childVal.valName] == null) {
      _base1[_name1] = 0;
    }
    this.childrenArgByNameCount[childVal.valName]++;
    if (childVal.directlyOrIndirectlyDependsOnAParentVal) {
      this.valContainingTheseArgs.stainValCalculatedFromParent(childVal);
    }
    return argumentToBeConnected.args.argFromChildMightHaveChanged(childVal);
  };

  Args.prototype.connectToParentVal = function(valDependingOnParentVal, parentVal) {
    var argumentToBeConnected;
    argumentToBeConnected = this.tryToReconnectDisconnectedArgFirst(parentVal);
    if (argumentToBeConnected == null) {
      argumentToBeConnected = new Arg(parentVal, valDependingOnParentVal);
    }
    argumentToBeConnected.directlyCalculatedFromParent = true;
    return argumentToBeConnected.turnIntoArgDirectlyOrIndirectlyDependingOnParent();
  };

  Args.prototype.argFromChildMightHaveChanged = function(childValThatMightHaveChanged) {
    var arg;
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      console.log("marking child value " + childValThatMightHaveChanged.valName + " in morph " + childValThatMightHaveChanged.ownerMorph.uniqueIDString() + " as \"might have changed\" ");
    }
    arg = this.argById[childValThatMightHaveChanged.id];
    if ((arg == null) || this.holdOffFromPropagatingChanges) {
      return;
    }
    if (arg.markedForRemoval) {
      return;
    }
    if (arg.maybeChangedSinceLastCalculation && childValThatMightHaveChanged.ownerMorph.parent === this.morphContainingTheseArgs) {
      arg.checkBasedOnSignature();
    } else if (arg.maybeChangedSinceLastCalculation && childValThatMightHaveChanged.ownerMorph.parent !== this.morphContainingTheseArgs) {
      arg["break"]();
    } else if (!arg.maybeChangedSinceLastCalculation && childValThatMightHaveChanged.ownerMorph.parent === this.morphContainingTheseArgs) {
      nop;
    } else if (!arg.maybeChangedSinceLastCalculation && childValThatMightHaveChanged.ownerMorph.parent !== this.morphContainingTheseArgs) {
      nop;
    }
    if (!this.valContainingTheseArgs.directlyOrIndirectlyDependsOnAParentVal) {
      return this.valContainingTheseArgs.checkAndPropagateChangeBasedOnArgChange();
    }
  };

  Args.prototype.fetchAllArgsDirectlyOrIndirectlyCalculatedFromParent = function() {
    var argCalculatedFromParent, idNotUsed, oneOrMoreArgsHaveActuallyChanged, _ref;
    oneOrMoreArgsHaveActuallyChanged = false;
    _ref = this.calculatedDirectlyOfIndirectlyFromParentById;
    for (idNotUsed in _ref) {
      argCalculatedFromParent = _ref[idNotUsed];
      if (argCalculatedFromParent.removeArgIfMarkedForRemoval()) {
        continue;
      }
      argCalculatedFromParent.fetchVal();
      oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged || argCalculatedFromParent.updateSignatureAndHeal();
    }
    return oneOrMoreArgsHaveActuallyChanged;
  };

  Args.prototype.fetchAllRemainingArgsNeedingRecalculation = function() {
    var maybeModifiedArg, maybeModifiedArgId, oneOrMoreArgsHaveActuallyChanged;
    this.holdOffFromPropagatingChanges = true;
    oneOrMoreArgsHaveActuallyChanged = false;
    for (maybeModifiedArgId in this.argsMaybeChangedSinceLastCalculationById) {
      maybeModifiedArg = this.argById[maybeModifiedArgId];
      if (maybeModifiedArg.removeArgIfMarkedForRemoval()) {
        continue;
      }
      if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
        console.log("fetching potentially changed input: " + maybeModifiedArg.id);
      }
      debugger;
      maybeModifiedArg.fetchVal();
      oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged || maybeModifiedArg.updateSignature();
    }
    return oneOrMoreArgsHaveActuallyChanged;
    this.args.healAll();
    return this.holdOffFromPropagatingChanges = false;
  };

  Args.coffeeScriptSourceOfThisClass = '# Args are the input based on which a val is calculated\n# There are several pieces of "aggregate" information that\n# we keep about args considered together e.g. whether\n# any of them has changed since the last calculation of the\n# Val, or which ones directly or indirectly depend on a Parent\n# Val.\n\n# REQUIRES ProfilerData\n\nclass Args\n  # some accessors need to get to the\n  # actual arguments. You can get to all\n  # of them by Id of the Value\n  # or, in the case of an argument connected\n  # to a parent morph, by the value name\n  # (since there is only one Arg connected\n  # to the parent for each value name, which is\n  # not the case for children Args as\n  # obviously you may have many children and hence\n  # many arguments)\n  argById: null\n  parentArgByName: null\n  childrenArgByName: null\n  # we want to group together all children\n  # values under the same name\n  # so we keep this count separate\n  # rather than counting navigating the keys\n  childrenArgByNameCount: null\n  localArgByName: null\n  calculatedDirectlyOfIndirectlyFromParentById: null\n  calculatedDirectlyOfIndirectlyFromParentByIdCount: 0\n\n  countOfDamaged: 0\n  morphContainingTheseArgs: null\n\n  # just some flags to keep track of which\n  # args might have changed. Again, we might\n  # not know for sure because we don\'t necessarily\n  # recalculate them\n  argsMaybeChangedSinceLastCalculationById: null\n\n  constructor: (@valContainingTheseArgs) ->\n    @argById = {}\n    @parentArgByName = {}\n    @childrenArgByName = {}\n    @childrenArgByNameCount = {}\n    @localArgByName = {}\n    @calculatedDirectlyOfIndirectlyFromParentById = {}\n    @argsMaybeChangedSinceLastCalculationById = {}\n\n    @morphContainingTheseArgs = @valContainingTheseArgs.ownerMorph\n\n\n  ################################################\n  #  breaking / healing\n  ################################################\n\n  healAll: () ->\n    for eachArg of @argsMaybeChangedSinceLastCalculationById\n      eachArg.heal()\n\n\n  ################################################\n  #  accessors\n  ################################################\n\n  getByVal: (theVal) ->\n    return @getById theVal.id\n\n  ################################################\n  #  setup methods - these are called in the\n  #  constructors of each value to prepare\n  #  for the arguments.\n  ################################################\n\n  # for local arguments, you can\n  # actually create the arguments as they are static\n  setup_AddAllLocalArgVals: (localInputVals) ->\n    for each in localInputVals\n      # connecting arguments that come from local values is\n      # easier because those links are static, they are done\n      # at construction time once and for all\n      each.localValsAffectedByChangeOfThisVal.push @valContainingTheseArgs\n      newArg = new Arg localInputVals, @valContainingTheseArgs\n      newArg.fromLocal = true\n      @localArgByName[localInputVals.valueName] = newArg\n\n  # you can\'t create the actual arguments yet as these\n  # arguments will be connected dynamically. we just prepare\n  # some a structure in the morph so we\'ll be able\n  # to connect the actual values in the morph\'s\n  # childAdded and childRemoved methods\n  setup_AddAllParentArgNames: (parentArgsNames) ->\n    # ORIGINAL CODE:\n    #for each var in parentArgsNames\n    #  if !@ownerMorph.morphValsDirectlyDependingOnParentVals[each]?\n    #    @ownerMorph.morphValsDirectlyDependingOnParentVals[each] = {}\n    #  @ownerMorph.morphValsDirectlyDependingOnParentVals[each][@valName] = @\n\n    for eachVar in parentArgsNames\n      @morphContainingTheseArgs.morphValsDirectlyDependingOnParentVals[eachVar]?= {}\n      @morphContainingTheseArgs.morphValsDirectlyDependingOnParentVals[eachVar][@valContainingTheseArgs.valName] = @valContainingTheseArgs\n\n  # you can\'t create the actual arguments yet as these\n  # arguments will be connected dynamically. we just prepare\n  # some a structure in the morph so we\'ll be able\n  # to connect the actual values in the morph\'s\n  # childAdded and childRemoved methods\n  setup_AddAllChildrenArgNames: (childrenArgsNames) ->\n    #debugger\n    for eachVar in childrenArgsNames\n      @morphContainingTheseArgs.morphValsDependingOnChildrenVals[eachVar] ?= {}\n      @morphContainingTheseArgs.morphValsDependingOnChildrenVals[eachVar][@valContainingTheseArgs.valName] = @valContainingTheseArgs\n\n  ################################################\n  #  argument connection methods\n  #  these are called when Morphs are moved\n  #  around so we need to connect/disconnect\n  #  the arguments of each value to/from the\n  #  (new) parent/children\n  ################################################\n\n  # check whether you are reconnecting\n  # an arg that was temporarily\n  # disconnected\n  tryToReconnectDisconnectedArgFirst: (parentOrChildVal) ->\n    existingArg = @argById[parentOrChildVal.id]\n    if existingArg?\n      existingArg.markedForRemoval = false\n      existingArg.valContainingThisArg.argMightHaveChanged(parentOrChildVal)\n      return existingArg\n    return null\n\n\n  # connects a val depending on a children val to a child val.\n  # This is called by childAdded on the new parent of the childMorph\n  # that has just been added\n  connectToChildVal: (valDependingOnChildrenVal, childVal) ->\n\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "connecting " + valDependingOnChildrenVal.valName + " in morph "+ valDependingOnChildrenVal.ownerMorph.uniqueIDString() + " to receive input from " + childVal.valName + " in morph "+ childVal.ownerMorph.uniqueIDString()\n\n    # check whether you are reconnecting\n    # an arg that was temporarily\n    # disconnected\n    #if @morphContainingTheseArgs.constructor.name == "RectangleMorph"\n    #  debugger\n    argumentToBeConnected = @tryToReconnectDisconnectedArgFirst childVal\n    argumentToBeConnected ?= new Arg childVal, valDependingOnChildrenVal\n    argumentToBeConnected.fromChild = true\n    @childrenArgByName[childVal.valName] ?= {}\n    @childrenArgByName[childVal.valName][childVal.id] = argumentToBeConnected\n    @childrenArgByNameCount[childVal.valName]?= 0\n    @childrenArgByNameCount[childVal.valName]++\n    if childVal.directlyOrIndirectlyDependsOnAParentVal\n      @valContainingTheseArgs.stainValCalculatedFromParent(childVal)\n    argumentToBeConnected.args.argFromChildMightHaveChanged childVal\n\n  # connects a val depending on a parent val to a parent val.\n  # This is called by childAdded on the childMorph that has just\n  # been added\n  connectToParentVal: (valDependingOnParentVal, parentVal) ->\n    # check whether you are reconnecting\n    # an arg that was temporarily\n    # disconnected\n    argumentToBeConnected = @tryToReconnectDisconnectedArgFirst parentVal\n    argumentToBeConnected ?= new Arg parentVal, valDependingOnParentVal\n    argumentToBeConnected.directlyCalculatedFromParent = true\n    argumentToBeConnected.turnIntoArgDirectlyOrIndirectlyDependingOnParent()\n\n  ################################################\n  #  handling update of argument coming from\n  #  other values\n  ################################################\n\n  argFromChildMightHaveChanged: (childValThatMightHaveChanged) ->\n\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "marking child value " + childValThatMightHaveChanged.valName + " in morph "+ childValThatMightHaveChanged.ownerMorph.uniqueIDString() + " as \"might have changed\" "\n\n\n    arg = @argById[childValThatMightHaveChanged.id]\n    if  !arg?  or  @holdOffFromPropagatingChanges then return\n    if arg.markedForRemoval then return\n    # the unique identifier of a val is given by\n    # its name as a string and the id of the Morph it belongs to\n    if arg.maybeChangedSinceLastCalculation and childValThatMightHaveChanged.ownerMorph.parent == @morphContainingTheseArgs\n      arg.checkBasedOnSignature()\n    else if arg.maybeChangedSinceLastCalculation and childValThatMightHaveChanged.ownerMorph.parent != @morphContainingTheseArgs\n      # argsMaybeChangedSinceLastCalculation contains kid and kid not child anymore\n      arg.break()\n    else if !arg.maybeChangedSinceLastCalculation and childValThatMightHaveChanged.ownerMorph.parent == @morphContainingTheseArgs\n      # argsMaybeChangedSinceLastCalculation not contains kid and kid is now child\n      # ???\n      # add the data structures and mark it as dirty and signature undefined\n      nop\n    else if !arg.maybeChangedSinceLastCalculation and childValThatMightHaveChanged.ownerMorph.parent != @morphContainingTheseArgs\n      # argsMaybeChangedSinceLastCalculation not contains kid and not child\n      # ???\n      # this should never happen\n      nop\n    if !@valContainingTheseArgs.directlyOrIndirectlyDependsOnAParentVal\n      @valContainingTheseArgs.checkAndPropagateChangeBasedOnArgChange()\n\n  ################################################\n  #  fetching correct arguments values\n  ################################################\n\n  # all @calculatedDirectlyOfIndirectlyFromParentById\n  # always need\n  # to be fetched (maybe recalculated)\n  # regardless of their dirty val\n  # we then update the signature and heal them.\n  # Note that some children args can be in this set\n  # as children args can maybe depend directly\n  # or indirectly from parent vals.\n  fetchAllArgsDirectlyOrIndirectlyCalculatedFromParent: ->\n    oneOrMoreArgsHaveActuallyChanged = false\n    for idNotUsed, argCalculatedFromParent of @calculatedDirectlyOfIndirectlyFromParentById\n      # check that the child/parent arg we are going to fetch\n      # is still a in a child/parent relationship with\n      # this morph. If not, this check will remove the\n      # arg and just move on\n      if argCalculatedFromParent.removeArgIfMarkedForRemoval()\n        continue\n      # note here that since in @argValsById we keep the\n      # reference to the Val object, which is the one\n      # we pass to the "functionToRecalculate", we\n      # don\'t need to put the fetched val anywhere.\n      argCalculatedFromParent.fetchVal()\n      # updateSignatureAndHeal returns true if\n      # the argument has actually changed since last\n      # recalculation\n      oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged or argCalculatedFromParent.updateSignatureAndHeal()\n    return oneOrMoreArgsHaveActuallyChanged\n\n  fetchAllRemainingArgsNeedingRecalculation: ->\n    @holdOffFromPropagatingChanges = true\n\n    oneOrMoreArgsHaveActuallyChanged = false\n    for maybeModifiedArgId of @argsMaybeChangedSinceLastCalculationById\n      maybeModifiedArg = @argById[maybeModifiedArgId]\n      # check that the child arg we are going to fetch\n      # is still a in a child relationship with\n      # this morph. If not, this check will remove the\n      # arg and just move on.\n      if maybeModifiedArg.removeArgIfMarkedForRemoval()\n        continue\n      # note here that since in @argValsById we keep the\n      # reference to the Val object, which is the one\n      # we pass to the "functionToRecalculate", we\n      # don\'t need to put the fetched val anywhere.\n\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "fetching potentially changed input: " + maybeModifiedArg.id\n\n      debugger\n      maybeModifiedArg.fetchVal()\n      # the argument has actually changed since last\n      # recalculation\n      oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged or maybeModifiedArg.updateSignature()\n    return oneOrMoreArgsHaveActuallyChanged\n\n    # since we calculated all the damaged args,\n    # heal them all\n    @args.healAll()\n    @holdOffFromPropagatingChanges = false  ';

  return Args;

})();

AutomatorCommand = (function() {
  AutomatorCommand.prototype.automatorCommandName = '';

  AutomatorCommand.prototype.millisecondsSincePreviousCommand = 0;

  function AutomatorCommand(systemTestsRecorderAndPlayer) {
    this.millisecondsSincePreviousCommand = (new Date().getTime()) - systemTestsRecorderAndPlayer.timeOfPreviouslyRecordedCommand;
  }

  AutomatorCommand.coffeeScriptSourceOfThisClass = '# The SystemTests recorder collects a number\n# of commands from the user and puts them in a\n# queue. This is the superclass of all the\n# possible commands.\n\n\nclass AutomatorCommand\n  automatorCommandName: \'\'\n  millisecondsSincePreviousCommand: 0\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    @millisecondsSincePreviousCommand = (new Date().getTime()) - systemTestsRecorderAndPlayer.timeOfPreviouslyRecordedCommand';

  return AutomatorCommand;

})();

AutomatorCommandCheckNumberOfItemsInMenu = (function(_super) {
  __extends(AutomatorCommandCheckNumberOfItemsInMenu, _super);

  AutomatorCommandCheckNumberOfItemsInMenu.prototype.numberOfItemsInMenu = 0;

  AutomatorCommandCheckNumberOfItemsInMenu.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.checkNumberOfItemsInMenu(commandBeingPlayed.numberOfItemsInMenu);
  };

  function AutomatorCommandCheckNumberOfItemsInMenu(numberOfItemsInMenu, systemTestsRecorderAndPlayer) {
    this.numberOfItemsInMenu = numberOfItemsInMenu;
    AutomatorCommandCheckNumberOfItemsInMenu.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandCheckNumberOfItemsInMenu";
  }

  AutomatorCommandCheckNumberOfItemsInMenu.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandCheckNumberOfItemsInMenu extends AutomatorCommand\n  numberOfItemsInMenu: 0\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.checkNumberOfItemsInMenu(commandBeingPlayed.numberOfItemsInMenu)\n\n  constructor: (@numberOfItemsInMenu, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandCheckNumberOfItemsInMenu"';

  return AutomatorCommandCheckNumberOfItemsInMenu;

})(AutomatorCommand);

AutomatorCommandCheckStringsOfItemsInMenuOrderImportant = (function(_super) {
  __extends(AutomatorCommandCheckStringsOfItemsInMenuOrderImportant, _super);

  AutomatorCommandCheckStringsOfItemsInMenuOrderImportant.prototype.stringOfItemsInMenuInOriginalOrder = [];

  AutomatorCommandCheckStringsOfItemsInMenuOrderImportant.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderImportant(commandBeingPlayed.stringOfItemsInMenuInOriginalOrder);
  };

  function AutomatorCommandCheckStringsOfItemsInMenuOrderImportant(stringOfItemsInMenuInOriginalOrder, systemTestsRecorderAndPlayer) {
    this.stringOfItemsInMenuInOriginalOrder = stringOfItemsInMenuInOriginalOrder;
    AutomatorCommandCheckStringsOfItemsInMenuOrderImportant.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandCheckStringsOfItemsInMenuOrderImportant";
  }

  AutomatorCommandCheckStringsOfItemsInMenuOrderImportant.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandCheckStringsOfItemsInMenuOrderImportant extends AutomatorCommand\n  stringOfItemsInMenuInOriginalOrder: []\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderImportant(commandBeingPlayed.stringOfItemsInMenuInOriginalOrder)\n\n  constructor: (@stringOfItemsInMenuInOriginalOrder, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandCheckStringsOfItemsInMenuOrderImportant"';

  return AutomatorCommandCheckStringsOfItemsInMenuOrderImportant;

})(AutomatorCommand);

AutomatorCommandCheckStringsOfItemsInMenuOrderUnimportant = (function(_super) {
  __extends(AutomatorCommandCheckStringsOfItemsInMenuOrderUnimportant, _super);

  AutomatorCommandCheckStringsOfItemsInMenuOrderUnimportant.prototype.stringOfItemsInMenuInOriginalOrder = [];

  AutomatorCommandCheckStringsOfItemsInMenuOrderUnimportant.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderUnimportant(commandBeingPlayed.stringOfItemsInMenuInOriginalOrder);
  };

  function AutomatorCommandCheckStringsOfItemsInMenuOrderUnimportant(stringOfItemsInMenuInOriginalOrder, systemTestsRecorderAndPlayer) {
    this.stringOfItemsInMenuInOriginalOrder = stringOfItemsInMenuInOriginalOrder;
    AutomatorCommandCheckStringsOfItemsInMenuOrderUnimportant.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandCheckStringsOfItemsInMenuOrderUnimportant";
  }

  AutomatorCommandCheckStringsOfItemsInMenuOrderUnimportant.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandCheckStringsOfItemsInMenuOrderUnimportant extends AutomatorCommand\n  stringOfItemsInMenuInOriginalOrder: []\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderUnimportant(commandBeingPlayed.stringOfItemsInMenuInOriginalOrder)\n\n  constructor: (@stringOfItemsInMenuInOriginalOrder, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandCheckStringsOfItemsInMenuOrderUnimportant"';

  return AutomatorCommandCheckStringsOfItemsInMenuOrderUnimportant;

})(AutomatorCommand);

AutomatorCommandCopy = (function(_super) {
  __extends(AutomatorCommandCopy, _super);

  AutomatorCommandCopy.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.worldMorph.processCopy(null);
  };

  function AutomatorCommandCopy(clipboardText, systemTestsRecorderAndPlayer) {
    this.clipboardText = clipboardText;
    AutomatorCommandCopy.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandCopy";
  }

  AutomatorCommandCopy.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandCopy extends AutomatorCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.worldMorph.processCopy null\n\n  constructor: (@clipboardText, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandCopy"  ';

  return AutomatorCommandCopy;

})(AutomatorCommand);

AutomatorCommandDoNothing = (function(_super) {
  __extends(AutomatorCommandDoNothing, _super);

  AutomatorCommandDoNothing.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {};

  function AutomatorCommandDoNothing(systemTestsRecorderAndPlayer) {
    AutomatorCommandDoNothing.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandDoNothing";
  }

  AutomatorCommandDoNothing.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandDoNothing extends AutomatorCommand\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandDoNothing"';

  return AutomatorCommandDoNothing;

})(AutomatorCommand);

AutomatorCommandDrop = (function(_super) {
  __extends(AutomatorCommandDrop, _super);

  AutomatorCommandDrop.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {};

  function AutomatorCommandDrop(systemTestsRecorderAndPlayer) {
    AutomatorCommandDrop.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandDrop";
  }

  AutomatorCommandDrop.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandDrop extends AutomatorCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandDrop"';

  return AutomatorCommandDrop;

})(AutomatorCommand);

AutomatorCommandGrab = (function(_super) {
  __extends(AutomatorCommandGrab, _super);

  AutomatorCommandGrab.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {};

  function AutomatorCommandGrab(systemTestsRecorderAndPlayer) {
    AutomatorCommandGrab.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandGrab";
  }

  AutomatorCommandGrab.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandGrab extends AutomatorCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandGrab"';

  return AutomatorCommandGrab;

})(AutomatorCommand);

AutomatorCommandKeyDown = (function(_super) {
  __extends(AutomatorCommandKeyDown, _super);

  AutomatorCommandKeyDown.prototype.scanCode = null;

  AutomatorCommandKeyDown.prototype.shiftKey = null;

  AutomatorCommandKeyDown.prototype.ctrlKey = null;

  AutomatorCommandKeyDown.prototype.altKey = null;

  AutomatorCommandKeyDown.prototype.metaKey = null;

  AutomatorCommandKeyDown.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    console.log("replaying key");
    return systemTestsRecorderAndPlayer.worldMorph.processKeydown(null, commandBeingPlayed.scanCode, commandBeingPlayed.shiftKey, commandBeingPlayed.ctrlKey, commandBeingPlayed.altKey, commandBeingPlayed.metaKey);
  };

  function AutomatorCommandKeyDown(scanCode, shiftKey, ctrlKey, altKey, metaKey, systemTestsRecorderAndPlayer) {
    this.scanCode = scanCode;
    this.shiftKey = shiftKey;
    this.ctrlKey = ctrlKey;
    this.altKey = altKey;
    this.metaKey = metaKey;
    AutomatorCommandKeyDown.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandKeyDown";
  }

  AutomatorCommandKeyDown.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandKeyDown extends AutomatorCommand\n  scanCode: null\n  shiftKey: null\n  ctrlKey: null\n  altKey: null\n  metaKey: null\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    console.log "replaying key"\n    systemTestsRecorderAndPlayer.worldMorph.processKeydown null, commandBeingPlayed.scanCode, commandBeingPlayed.shiftKey, commandBeingPlayed.ctrlKey, commandBeingPlayed.altKey, commandBeingPlayed.metaKey\n\n\n  constructor: (@scanCode, @shiftKey, @ctrlKey, @altKey, @metaKey, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandKeyDown"  ';

  return AutomatorCommandKeyDown;

})(AutomatorCommand);

AutomatorCommandKeyPress = (function(_super) {
  __extends(AutomatorCommandKeyPress, _super);

  AutomatorCommandKeyPress.prototype.charCode = null;

  AutomatorCommandKeyPress.prototype.symbol = null;

  AutomatorCommandKeyPress.prototype.shiftKey = null;

  AutomatorCommandKeyPress.prototype.ctrlKey = null;

  AutomatorCommandKeyPress.prototype.altKey = null;

  AutomatorCommandKeyPress.prototype.metaKey = null;

  AutomatorCommandKeyPress.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    console.log("replaying key");
    return systemTestsRecorderAndPlayer.worldMorph.processKeypress(null, commandBeingPlayed.charCode, commandBeingPlayed.symbol, commandBeingPlayed.shiftKey, commandBeingPlayed.ctrlKey, commandBeingPlayed.altKey, commandBeingPlayed.metaKey);
  };

  function AutomatorCommandKeyPress(charCode, symbol, shiftKey, ctrlKey, altKey, metaKey, systemTestsRecorderAndPlayer) {
    this.charCode = charCode;
    this.symbol = symbol;
    this.shiftKey = shiftKey;
    this.ctrlKey = ctrlKey;
    this.altKey = altKey;
    this.metaKey = metaKey;
    AutomatorCommandKeyPress.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandKeyPress";
  }

  AutomatorCommandKeyPress.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandKeyPress extends AutomatorCommand\n  charCode: null\n  symbol: null\n  shiftKey: null\n  ctrlKey: null\n  altKey: null\n  metaKey: null\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    console.log "replaying key"\n    systemTestsRecorderAndPlayer.worldMorph.processKeypress null, commandBeingPlayed.charCode, commandBeingPlayed.symbol, commandBeingPlayed.shiftKey, commandBeingPlayed.ctrlKey, commandBeingPlayed.altKey, commandBeingPlayed.metaKey\n\n\n  constructor: (@charCode, @symbol, @shiftKey, @ctrlKey, @altKey, @metaKey, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandKeyPress"';

  return AutomatorCommandKeyPress;

})(AutomatorCommand);

AutomatorCommandKeyUp = (function(_super) {
  __extends(AutomatorCommandKeyUp, _super);

  AutomatorCommandKeyUp.prototype.scanCode = null;

  AutomatorCommandKeyUp.prototype.shiftKey = null;

  AutomatorCommandKeyUp.prototype.ctrlKey = null;

  AutomatorCommandKeyUp.prototype.altKey = null;

  AutomatorCommandKeyUp.prototype.metaKey = null;

  AutomatorCommandKeyUp.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    console.log("replaying key");
    return systemTestsRecorderAndPlayer.worldMorph.processKeyup(null, commandBeingPlayed.scanCode, commandBeingPlayed.shiftKey, commandBeingPlayed.ctrlKey, commandBeingPlayed.altKey, commandBeingPlayed.metaKey);
  };

  function AutomatorCommandKeyUp(scanCode, shiftKey, ctrlKey, altKey, metaKey, systemTestsRecorderAndPlayer) {
    this.scanCode = scanCode;
    this.shiftKey = shiftKey;
    this.ctrlKey = ctrlKey;
    this.altKey = altKey;
    this.metaKey = metaKey;
    AutomatorCommandKeyUp.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandKeyUp";
  }

  AutomatorCommandKeyUp.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandKeyUp extends AutomatorCommand\n  scanCode: null\n  shiftKey: null\n  ctrlKey: null\n  altKey: null\n  metaKey: null\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    console.log "replaying key"\n    systemTestsRecorderAndPlayer.worldMorph.processKeyup null, commandBeingPlayed.scanCode, commandBeingPlayed.shiftKey, commandBeingPlayed.ctrlKey, commandBeingPlayed.altKey, commandBeingPlayed.metaKey\n\n\n  constructor: (@scanCode, @shiftKey, @ctrlKey, @altKey, @metaKey, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandKeyUp"';

  return AutomatorCommandKeyUp;

})(AutomatorCommand);

AutomatorCommandLeftOrRightClickOnMenuItem = (function(_super) {
  var whichMouseButtonPressed;

  __extends(AutomatorCommandLeftOrRightClickOnMenuItem, _super);

  whichMouseButtonPressed = "";

  AutomatorCommandLeftOrRightClickOnMenuItem.prototype.textLabelOfClickedItem = 0;

  AutomatorCommandLeftOrRightClickOnMenuItem.prototype.textLabelOccurrenceNumber = 0;

  AutomatorCommandLeftOrRightClickOnMenuItem.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {};

  function AutomatorCommandLeftOrRightClickOnMenuItem(whichMouseButtonPressed, textLabelOfClickedItem, textLabelOccurrenceNumber, systemTestsRecorderAndPlayer) {
    this.whichMouseButtonPressed = whichMouseButtonPressed;
    this.textLabelOfClickedItem = textLabelOfClickedItem;
    this.textLabelOccurrenceNumber = textLabelOccurrenceNumber;
    AutomatorCommandLeftOrRightClickOnMenuItem.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandLeftOrRightClickOnMenuItem";
  }

  AutomatorCommandLeftOrRightClickOnMenuItem.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandLeftOrRightClickOnMenuItem extends AutomatorCommand\n  whichMouseButtonPressed = ""\n  textLabelOfClickedItem: 0\n  # there might be multiple instances of\n  # the same text label so we count\n  # which one it is\n  textLabelOccurrenceNumber: 0\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    #systemTestsRecorderAndPlayer.handMorph.leftOrRightClickOnMenuItemWithText(commandBeingPlayed.whichMouseButtonPressed, commandBeingPlayed.textLabelOfClickedItem, commandBeingPlayed.textLabelOccurrenceNumber)\n\n  constructor: (@whichMouseButtonPressed, @textLabelOfClickedItem, @textLabelOccurrenceNumber, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandLeftOrRightClickOnMenuItem"';

  return AutomatorCommandLeftOrRightClickOnMenuItem;

})(AutomatorCommand);

AutomatorCommandMouseButtonChange = (function(_super) {
  __extends(AutomatorCommandMouseButtonChange, _super);

  AutomatorCommandMouseButtonChange.prototype.upOrDown = null;

  AutomatorCommandMouseButtonChange.prototype.button = null;

  AutomatorCommandMouseButtonChange.prototype.ctrlKey = null;

  AutomatorCommandMouseButtonChange.prototype.morphIdentifierViaTextLabel = null;

  AutomatorCommandMouseButtonChange.prototype.pointerPositionFractionalInMorph = null;

  AutomatorCommandMouseButtonChange.prototype.pointerPositionPixelsInMorph = null;

  AutomatorCommandMouseButtonChange.prototype.pointerPositionPixelsInWorld = null;

  AutomatorCommandMouseButtonChange.prototype.absoluteBoundsOfMorphRelativeToWorld = null;

  AutomatorCommandMouseButtonChange.prototype.morphUniqueIDString = null;

  AutomatorCommandMouseButtonChange.prototype.morphPathRelativeToWorld = null;

  AutomatorCommandMouseButtonChange.prototype.isPartOfListMorph = null;

  AutomatorCommandMouseButtonChange.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    var button, newX, newY, theMorph;
    theMorph = world.getMorphViaTextLabel(commandBeingPlayed.morphIdentifierViaTextLabel);
    newX = Math.round(theMorph.bounds.width() * commandBeingPlayed.pointerPositionFractionalInMorph[0]) + theMorph.bounds.origin.x;
    newY = Math.round(theMorph.bounds.height() * commandBeingPlayed.pointerPositionFractionalInMorph[1]) + theMorph.bounds.origin.y;
    world.hand.silentSetPosition(new Point(newX, newY));
    if (commandBeingPlayed.button === "left") {
      button = 0;
    } else if (commandBeingPlayed.button === "middle") {
      button = 1;
    } else if (commandBeingPlayed.button === "right") {
      button = 2;
    }
    if (commandBeingPlayed.upOrDown === "up") {
      return systemTestsRecorderAndPlayer.handMorph.processMouseUp(button);
    } else {
      return systemTestsRecorderAndPlayer.handMorph.processMouseDown(button, commandBeingPlayed.ctrlKey);
    }
  };

  AutomatorCommandMouseButtonChange.prototype.transformIntoDoNothingCommand = function() {
    return this.automatorCommandName = "AutomatorCommandDoNothing";
  };

  function AutomatorCommandMouseButtonChange(upOrDown, button, ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph, systemTestsRecorderAndPlayer) {
    this.upOrDown = upOrDown;
    this.ctrlKey = ctrlKey;
    this.morphUniqueIDString = morphUniqueIDString;
    this.morphPathRelativeToWorld = morphPathRelativeToWorld;
    this.morphIdentifierViaTextLabel = morphIdentifierViaTextLabel;
    this.absoluteBoundsOfMorphRelativeToWorld = absoluteBoundsOfMorphRelativeToWorld;
    this.pointerPositionFractionalInMorph = pointerPositionFractionalInMorph;
    this.pointerPositionPixelsInMorph = pointerPositionPixelsInMorph;
    this.pointerPositionPixelsInWorld = pointerPositionPixelsInWorld;
    this.isPartOfListMorph = isPartOfListMorph;
    AutomatorCommandMouseButtonChange.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    if (button === 0) {
      this.button = "left";
    } else if (button === 1) {
      this.button = "middle";
    } else if (button === 2) {
      this.button = "right";
    }
    this.automatorCommandName = "AutomatorCommandMouseButtonChange";
  }

  AutomatorCommandMouseButtonChange.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandMouseButtonChange extends AutomatorCommand\n  upOrDown: null\n  button: null\n  ctrlKey: null\n  morphIdentifierViaTextLabel: null\n  pointerPositionFractionalInMorph: null\n  pointerPositionPixelsInMorph: null\n  pointerPositionPixelsInWorld: null\n  absoluteBoundsOfMorphRelativeToWorld: null\n  morphUniqueIDString: null\n  morphPathRelativeToWorld: null\n  isPartOfListMorph: null\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    theMorph = world.getMorphViaTextLabel(commandBeingPlayed.morphIdentifierViaTextLabel)\n    newX = Math.round((theMorph.bounds.width() * commandBeingPlayed.pointerPositionFractionalInMorph[0])) + theMorph.bounds.origin.x\n    newY = Math.round((theMorph.bounds.height() * commandBeingPlayed.pointerPositionFractionalInMorph[1])) + theMorph.bounds.origin.y\n    world.hand.silentSetPosition new Point(newX, newY)\n\n    if commandBeingPlayed.button == "left"\n      button = 0\n    else if commandBeingPlayed.button == "middle"\n      button = 1\n    else if commandBeingPlayed.button == "right"\n      button = 2\n\n    if commandBeingPlayed.upOrDown == "up"\n      # the mouse up doesn\'t need the control key info\n      systemTestsRecorderAndPlayer.handMorph.processMouseUp(button)\n    else\n      systemTestsRecorderAndPlayer.handMorph.processMouseDown(button, commandBeingPlayed.ctrlKey)\n\n  transformIntoDoNothingCommand: ->\n    @automatorCommandName = "AutomatorCommandDoNothing"\n\n  constructor: (@upOrDown, button, @ctrlKey, @morphUniqueIDString, @morphPathRelativeToWorld, @morphIdentifierViaTextLabel, @absoluteBoundsOfMorphRelativeToWorld, @pointerPositionFractionalInMorph, @pointerPositionPixelsInMorph, @pointerPositionPixelsInWorld, @isPartOfListMorph, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n\n    if button == 0\n      @button = "left"\n    else if button == 1\n      @button = "middle"\n    else if button == 2\n      @button = "right"\n\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandMouseButtonChange"';

  return AutomatorCommandMouseButtonChange;

})(AutomatorCommand);

AutomatorCommandMouseClick = (function(_super) {
  __extends(AutomatorCommandMouseClick, _super);

  AutomatorCommandMouseClick.prototype.button = null;

  AutomatorCommandMouseClick.prototype.ctrlKey = null;

  AutomatorCommandMouseClick.prototype.morphIdentifierViaTextLabel = null;

  AutomatorCommandMouseClick.prototype.pointerPositionFractionalInMorph = null;

  AutomatorCommandMouseClick.prototype.pointerPositionPixelsInMorph = null;

  AutomatorCommandMouseClick.prototype.pointerPositionPixelsInWorld = null;

  AutomatorCommandMouseClick.prototype.absoluteBoundsOfMorphRelativeToWorld = null;

  AutomatorCommandMouseClick.prototype.morphUniqueIDString = null;

  AutomatorCommandMouseClick.prototype.morphPathRelativeToWorld = null;

  AutomatorCommandMouseClick.prototype.isPartOfListMorph = null;

  AutomatorCommandMouseClick.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {};

  AutomatorCommandMouseClick.prototype.transformIntoDoNothingCommand = function() {
    return this.automatorCommandName = "AutomatorCommandDoNothing";
  };

  function AutomatorCommandMouseClick(button, ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph, systemTestsRecorderAndPlayer) {
    this.ctrlKey = ctrlKey;
    this.morphUniqueIDString = morphUniqueIDString;
    this.morphPathRelativeToWorld = morphPathRelativeToWorld;
    this.morphIdentifierViaTextLabel = morphIdentifierViaTextLabel;
    this.absoluteBoundsOfMorphRelativeToWorld = absoluteBoundsOfMorphRelativeToWorld;
    this.pointerPositionFractionalInMorph = pointerPositionFractionalInMorph;
    this.pointerPositionPixelsInMorph = pointerPositionPixelsInMorph;
    this.pointerPositionPixelsInWorld = pointerPositionPixelsInWorld;
    this.isPartOfListMorph = isPartOfListMorph;
    AutomatorCommandMouseClick.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    if (button === 0) {
      this.button = "left";
    } else if (button === 1) {
      this.button = "middle";
    } else if (button === 2) {
      this.button = "right";
    }
    this.automatorCommandName = "AutomatorCommandMouseClick";
  }

  AutomatorCommandMouseClick.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandMouseClick extends AutomatorCommand\n  button: null\n  ctrlKey: null\n  morphIdentifierViaTextLabel: null\n  pointerPositionFractionalInMorph: null\n  pointerPositionPixelsInMorph: null\n  pointerPositionPixelsInWorld: null\n  absoluteBoundsOfMorphRelativeToWorld: null\n  morphUniqueIDString: null\n  morphPathRelativeToWorld: null\n  isPartOfListMorph: null\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n\n  transformIntoDoNothingCommand: ->\n    @automatorCommandName = "AutomatorCommandDoNothing"\n\n  constructor: (button, @ctrlKey, @morphUniqueIDString, @morphPathRelativeToWorld, @morphIdentifierViaTextLabel, @absoluteBoundsOfMorphRelativeToWorld, @pointerPositionFractionalInMorph, @pointerPositionPixelsInMorph, @pointerPositionPixelsInWorld, @isPartOfListMorph, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    \n    if button == 0\n      @button = "left"\n    else if button == 1\n      @button = "middle"\n    else if button == 2\n      @button = "right"\n\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandMouseClick"';

  return AutomatorCommandMouseClick;

})(AutomatorCommand);

AutomatorCommandMouseDoubleClick = (function(_super) {
  __extends(AutomatorCommandMouseDoubleClick, _super);

  AutomatorCommandMouseDoubleClick.prototype.ctrlKey = null;

  AutomatorCommandMouseDoubleClick.prototype.morphIdentifierViaTextLabel = null;

  AutomatorCommandMouseDoubleClick.prototype.pointerPositionFractionalInMorph = null;

  AutomatorCommandMouseDoubleClick.prototype.pointerPositionPixelsInMorph = null;

  AutomatorCommandMouseDoubleClick.prototype.pointerPositionPixelsInWorld = null;

  AutomatorCommandMouseDoubleClick.prototype.absoluteBoundsOfMorphRelativeToWorld = null;

  AutomatorCommandMouseDoubleClick.prototype.morphUniqueIDString = null;

  AutomatorCommandMouseDoubleClick.prototype.morphPathRelativeToWorld = null;

  AutomatorCommandMouseDoubleClick.prototype.isPartOfListMorph = null;

  AutomatorCommandMouseDoubleClick.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {};

  AutomatorCommandMouseDoubleClick.prototype.transformIntoDoNothingCommand = function() {
    return this.automatorCommandName = "AutomatorCommandDoNothing";
  };

  function AutomatorCommandMouseDoubleClick(ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph, systemTestsRecorderAndPlayer) {
    this.ctrlKey = ctrlKey;
    this.morphUniqueIDString = morphUniqueIDString;
    this.morphPathRelativeToWorld = morphPathRelativeToWorld;
    this.morphIdentifierViaTextLabel = morphIdentifierViaTextLabel;
    this.absoluteBoundsOfMorphRelativeToWorld = absoluteBoundsOfMorphRelativeToWorld;
    this.pointerPositionFractionalInMorph = pointerPositionFractionalInMorph;
    this.pointerPositionPixelsInMorph = pointerPositionPixelsInMorph;
    this.pointerPositionPixelsInWorld = pointerPositionPixelsInWorld;
    this.isPartOfListMorph = isPartOfListMorph;
    AutomatorCommandMouseDoubleClick.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandMouseDoubleClick";
  }

  AutomatorCommandMouseDoubleClick.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandMouseDoubleClick extends AutomatorCommand\n  ctrlKey: null\n  morphIdentifierViaTextLabel: null\n  pointerPositionFractionalInMorph: null\n  pointerPositionPixelsInMorph: null\n  pointerPositionPixelsInWorld: null\n  absoluteBoundsOfMorphRelativeToWorld: null\n  morphUniqueIDString: null\n  morphPathRelativeToWorld: null\n  isPartOfListMorph: null\n\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n\n  transformIntoDoNothingCommand: ->\n    @automatorCommandName = "AutomatorCommandDoNothing"\n\n  constructor: (@ctrlKey, @morphUniqueIDString, @morphPathRelativeToWorld, @morphIdentifierViaTextLabel, @absoluteBoundsOfMorphRelativeToWorld, @pointerPositionFractionalInMorph, @pointerPositionPixelsInMorph, @pointerPositionPixelsInWorld, @isPartOfListMorph, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandMouseDoubleClick"';

  return AutomatorCommandMouseDoubleClick;

})(AutomatorCommand);

AutomatorCommandMouseMove = (function(_super) {
  __extends(AutomatorCommandMouseMove, _super);

  AutomatorCommandMouseMove.prototype.mouseX = null;

  AutomatorCommandMouseMove.prototype.mouseY = null;

  AutomatorCommandMouseMove.prototype.floatDraggingSomething = null;

  AutomatorCommandMouseMove.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.handMorph.processMouseMove(commandBeingPlayed.mouseX, commandBeingPlayed.mouseY);
  };

  function AutomatorCommandMouseMove(mouseX, mouseY, floatDraggingSomething, systemTestsRecorderAndPlayer) {
    this.mouseX = mouseX;
    this.mouseY = mouseY;
    this.floatDraggingSomething = floatDraggingSomething;
    AutomatorCommandMouseMove.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandMouseMove";
  }

  AutomatorCommandMouseMove.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandMouseMove extends AutomatorCommand\n  mouseX: null\n  mouseY: null\n  floatDraggingSomething: null\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.handMorph.processMouseMove(commandBeingPlayed.mouseX, commandBeingPlayed.mouseY)\n\n  constructor: (@mouseX, @mouseY, @floatDraggingSomething, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandMouseMove"';

  return AutomatorCommandMouseMove;

})(AutomatorCommand);

AutomatorCommandOpenContextMenu = (function(_super) {
  __extends(AutomatorCommandOpenContextMenu, _super);

  AutomatorCommandOpenContextMenu.prototype.morphToOpenContextMenuAgainst_UniqueIDString = null;

  AutomatorCommandOpenContextMenu.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {};

  function AutomatorCommandOpenContextMenu(morphToOpenContextMenuAgainst_UniqueIDString, systemTestsRecorderAndPlayer) {
    this.morphToOpenContextMenuAgainst_UniqueIDString = morphToOpenContextMenuAgainst_UniqueIDString;
    AutomatorCommandOpenContextMenu.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandOpenContextMenu";
  }

  AutomatorCommandOpenContextMenu.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandOpenContextMenu extends AutomatorCommand\n  morphToOpenContextMenuAgainst_UniqueIDString: null\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    #systemTestsRecorderAndPlayer.handMorph.openContextMenuAtPointer (Morph.morphFromUniqueIDString commandBeingPlayed.morphToOpenContextMenuAgainst_UniqueIDString)\n\n\n  constructor: (@morphToOpenContextMenuAgainst_UniqueIDString, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandOpenContextMenu"';

  return AutomatorCommandOpenContextMenu;

})(AutomatorCommand);

AutomatorCommandPaste = (function(_super) {
  __extends(AutomatorCommandPaste, _super);

  AutomatorCommandPaste.prototype.clipboardText = null;

  AutomatorCommandPaste.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    console.log("test player inserting text: " + commandBeingPlayed.clipboardText);
    return systemTestsRecorderAndPlayer.worldMorph.processPaste(null, commandBeingPlayed.clipboardText);
  };

  function AutomatorCommandPaste(clipboardText, systemTestsRecorderAndPlayer) {
    this.clipboardText = clipboardText;
    AutomatorCommandPaste.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandPaste";
  }

  AutomatorCommandPaste.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandPaste extends AutomatorCommand\n  clipboardText: null\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    console.log "test player inserting text: " + commandBeingPlayed.clipboardText\n    systemTestsRecorderAndPlayer.worldMorph.processPaste null, commandBeingPlayed.clipboardText\n\n\n  constructor: (@clipboardText, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandPaste"  ';

  return AutomatorCommandPaste;

})(AutomatorCommand);

AutomatorCommandResetWorld = (function(_super) {
  __extends(AutomatorCommandResetWorld, _super);

  AutomatorCommandResetWorld.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.worldMorph.resetWorld();
  };

  function AutomatorCommandResetWorld(systemTestsRecorderAndPlayer) {
    AutomatorCommandResetWorld.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandResetWorld";
  }

  AutomatorCommandResetWorld.coffeeScriptSourceOfThisClass = '# \n\nclass AutomatorCommandResetWorld extends AutomatorCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.worldMorph.resetWorld()\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandResetWorld"';

  return AutomatorCommandResetWorld;

})(AutomatorCommand);

AutomatorCommandScreenshot = (function(_super) {
  __extends(AutomatorCommandScreenshot, _super);

  AutomatorCommandScreenshot.prototype.screenShotImageName = null;

  AutomatorCommandScreenshot.prototype.screenshotTakenOfAParticularMorph = false;

  AutomatorCommandScreenshot.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.compareScreenshots(commandBeingPlayed.screenShotImageName, commandBeingPlayed.screenshotTakenOfAParticularMorph);
  };

  function AutomatorCommandScreenshot(screenShotImageName, systemTestsRecorderAndPlayer, screenshotTakenOfAParticularMorph) {
    this.screenShotImageName = screenShotImageName;
    this.screenshotTakenOfAParticularMorph = screenshotTakenOfAParticularMorph != null ? screenshotTakenOfAParticularMorph : false;
    AutomatorCommandScreenshot.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandScreenshot";
  }

  AutomatorCommandScreenshot.coffeeScriptSourceOfThisClass = '#\n\n\nclass AutomatorCommandScreenshot extends AutomatorCommand\n  screenShotImageName: null\n  # The screenshot can be of the entire\n  # world or of a particular morph (through\n  # the "take pic" menu entry.\n  # The screenshotTakenOfAParticularMorph flag\n  # remembers which case we are in.\n  # In the case that the screenshot is\n  # of a particular morph, the comparison\n  # will have to wait for the world\n  # to provide the image data (the take pic command\n  # will do it)\n  screenshotTakenOfAParticularMorph: false\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.compareScreenshots(commandBeingPlayed.screenShotImageName, commandBeingPlayed.screenshotTakenOfAParticularMorph)\n\n\n  constructor: (@screenShotImageName, systemTestsRecorderAndPlayer, @screenshotTakenOfAParticularMorph = false ) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandScreenshot"';

  return AutomatorCommandScreenshot;

})(AutomatorCommand);

AutomatorCommandShowComment = (function(_super) {
  __extends(AutomatorCommandShowComment, _super);

  AutomatorCommandShowComment.prototype.message = "";

  AutomatorCommandShowComment.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return SystemTestsControlPanelUpdater.addMessageToTestCommentsConsole(commandBeingPlayed.message);
  };

  function AutomatorCommandShowComment(message, systemTestsRecorderAndPlayer) {
    this.message = message;
    AutomatorCommandShowComment.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandShowComment";
  }

  AutomatorCommandShowComment.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandShowComment extends AutomatorCommand\n  message: ""\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    SystemTestsControlPanelUpdater.addMessageToTestCommentsConsole commandBeingPlayed.message\n\n  constructor: (@message, systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandShowComment"';

  return AutomatorCommandShowComment;

})(AutomatorCommand);

AutomatorCommandTurnOffAlignmentOfMorphIDsMechanism = (function(_super) {
  __extends(AutomatorCommandTurnOffAlignmentOfMorphIDsMechanism, _super);

  AutomatorCommandTurnOffAlignmentOfMorphIDsMechanism.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOffAlignmentOfMorphIDsMechanism();
  };

  function AutomatorCommandTurnOffAlignmentOfMorphIDsMechanism(systemTestsRecorderAndPlayer) {
    AutomatorCommandTurnOffAlignmentOfMorphIDsMechanism.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandTurnOffAlignmentOfMorphIDsMechanism";
  }

  AutomatorCommandTurnOffAlignmentOfMorphIDsMechanism.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandTurnOffAlignmentOfMorphIDsMechanism extends AutomatorCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOffAlignmentOfMorphIDsMechanism()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandTurnOffAlignmentOfMorphIDsMechanism"';

  return AutomatorCommandTurnOffAlignmentOfMorphIDsMechanism;

})(AutomatorCommand);

AutomatorCommandTurnOffAnimationsPacingControl = (function(_super) {
  __extends(AutomatorCommandTurnOffAnimationsPacingControl, _super);

  AutomatorCommandTurnOffAnimationsPacingControl.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl();
  };

  function AutomatorCommandTurnOffAnimationsPacingControl(systemTestsRecorderAndPlayer) {
    AutomatorCommandTurnOffAnimationsPacingControl.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandTurnOffAnimationsPacingControl";
  }

  AutomatorCommandTurnOffAnimationsPacingControl.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandTurnOffAnimationsPacingControl extends AutomatorCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandTurnOffAnimationsPacingControl"';

  return AutomatorCommandTurnOffAnimationsPacingControl;

})(AutomatorCommand);

AutomatorCommandTurnOffHidingOfMorphsContentExtractInLabels = (function(_super) {
  __extends(AutomatorCommandTurnOffHidingOfMorphsContentExtractInLabels, _super);

  AutomatorCommandTurnOffHidingOfMorphsContentExtractInLabels.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOffHidingOfMorphsContentExtractInLabels();
  };

  function AutomatorCommandTurnOffHidingOfMorphsContentExtractInLabels(systemTestsRecorderAndPlayer) {
    AutomatorCommandTurnOffHidingOfMorphsContentExtractInLabels.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandTurnOffHidingOfMorphsContentExtractInLabels";
  }

  AutomatorCommandTurnOffHidingOfMorphsContentExtractInLabels.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandTurnOffHidingOfMorphsContentExtractInLabels extends AutomatorCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOffHidingOfMorphsContentExtractInLabels()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandTurnOffHidingOfMorphsContentExtractInLabels"';

  return AutomatorCommandTurnOffHidingOfMorphsContentExtractInLabels;

})(AutomatorCommand);

AutomatorCommandTurnOffHidingOfMorphsGeometryInfoInLabels = (function(_super) {
  __extends(AutomatorCommandTurnOffHidingOfMorphsGeometryInfoInLabels, _super);

  AutomatorCommandTurnOffHidingOfMorphsGeometryInfoInLabels.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOffHidingOfMorphsGeometryInfoInLabels();
  };

  function AutomatorCommandTurnOffHidingOfMorphsGeometryInfoInLabels(systemTestsRecorderAndPlayer) {
    AutomatorCommandTurnOffHidingOfMorphsGeometryInfoInLabels.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandTurnOffHidingOfMorphsGeometryInfoInLabels";
  }

  AutomatorCommandTurnOffHidingOfMorphsGeometryInfoInLabels.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandTurnOffHidingOfMorphsGeometryInfoInLabels extends AutomatorCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOffHidingOfMorphsGeometryInfoInLabels()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandTurnOffHidingOfMorphsGeometryInfoInLabels"';

  return AutomatorCommandTurnOffHidingOfMorphsGeometryInfoInLabels;

})(AutomatorCommand);

AutomatorCommandTurnOffHidingOfMorphsNumberIDInLabels = (function(_super) {
  __extends(AutomatorCommandTurnOffHidingOfMorphsNumberIDInLabels, _super);

  AutomatorCommandTurnOffHidingOfMorphsNumberIDInLabels.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOffHidingOfMorphsNumberIDInLabels();
  };

  function AutomatorCommandTurnOffHidingOfMorphsNumberIDInLabels(systemTestsRecorderAndPlayer) {
    AutomatorCommandTurnOffHidingOfMorphsNumberIDInLabels.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandTurnOffHidingOfMorphsNumberIDInLabels";
  }

  AutomatorCommandTurnOffHidingOfMorphsNumberIDInLabels.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandTurnOffHidingOfMorphsNumberIDInLabels extends AutomatorCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOffHidingOfMorphsNumberIDInLabels()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandTurnOffHidingOfMorphsNumberIDInLabels"';

  return AutomatorCommandTurnOffHidingOfMorphsNumberIDInLabels;

})(AutomatorCommand);

AutomatorCommandTurnOnAlignmentOfMorphIDsMechanism = (function(_super) {
  __extends(AutomatorCommandTurnOnAlignmentOfMorphIDsMechanism, _super);

  AutomatorCommandTurnOnAlignmentOfMorphIDsMechanism.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOnAlignmentOfMorphIDsMechanism();
  };

  function AutomatorCommandTurnOnAlignmentOfMorphIDsMechanism(systemTestsRecorderAndPlayer) {
    AutomatorCommandTurnOnAlignmentOfMorphIDsMechanism.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandTurnOnAlignmentOfMorphIDsMechanism";
  }

  AutomatorCommandTurnOnAlignmentOfMorphIDsMechanism.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandTurnOnAlignmentOfMorphIDsMechanism extends AutomatorCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOnAlignmentOfMorphIDsMechanism()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandTurnOnAlignmentOfMorphIDsMechanism"';

  return AutomatorCommandTurnOnAlignmentOfMorphIDsMechanism;

})(AutomatorCommand);

AutomatorCommandTurnOnAnimationsPacingControl = (function(_super) {
  __extends(AutomatorCommandTurnOnAnimationsPacingControl, _super);

  AutomatorCommandTurnOnAnimationsPacingControl.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOnAnimationsPacingControl();
  };

  function AutomatorCommandTurnOnAnimationsPacingControl(systemTestsRecorderAndPlayer) {
    AutomatorCommandTurnOnAnimationsPacingControl.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandTurnOnAnimationsPacingControl";
  }

  AutomatorCommandTurnOnAnimationsPacingControl.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandTurnOnAnimationsPacingControl extends AutomatorCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOnAnimationsPacingControl()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandTurnOnAnimationsPacingControl"';

  return AutomatorCommandTurnOnAnimationsPacingControl;

})(AutomatorCommand);

AutomatorCommandTurnOnHidingOfMorphsContentExtractInLabels = (function(_super) {
  __extends(AutomatorCommandTurnOnHidingOfMorphsContentExtractInLabels, _super);

  AutomatorCommandTurnOnHidingOfMorphsContentExtractInLabels.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOnHidingOfMorphsContentExtractInLabels();
  };

  function AutomatorCommandTurnOnHidingOfMorphsContentExtractInLabels(systemTestsRecorderAndPlayer) {
    AutomatorCommandTurnOnHidingOfMorphsContentExtractInLabels.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandTurnOnHidingOfMorphsContentExtractInLabels";
  }

  AutomatorCommandTurnOnHidingOfMorphsContentExtractInLabels.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandTurnOnHidingOfMorphsContentExtractInLabels extends AutomatorCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOnHidingOfMorphsContentExtractInLabels()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandTurnOnHidingOfMorphsContentExtractInLabels"';

  return AutomatorCommandTurnOnHidingOfMorphsContentExtractInLabels;

})(AutomatorCommand);

AutomatorCommandTurnOnHidingOfMorphsGeometryInfoInLabels = (function(_super) {
  __extends(AutomatorCommandTurnOnHidingOfMorphsGeometryInfoInLabels, _super);

  AutomatorCommandTurnOnHidingOfMorphsGeometryInfoInLabels.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOnHidingOfMorphsGeometryInfoInLabels();
  };

  function AutomatorCommandTurnOnHidingOfMorphsGeometryInfoInLabels(systemTestsRecorderAndPlayer) {
    AutomatorCommandTurnOnHidingOfMorphsGeometryInfoInLabels.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandTurnOnHidingOfMorphsGeometryInfoInLabels";
  }

  AutomatorCommandTurnOnHidingOfMorphsGeometryInfoInLabels.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandTurnOnHidingOfMorphsGeometryInfoInLabels extends AutomatorCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOnHidingOfMorphsGeometryInfoInLabels()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandTurnOnHidingOfMorphsGeometryInfoInLabels"';

  return AutomatorCommandTurnOnHidingOfMorphsGeometryInfoInLabels;

})(AutomatorCommand);

AutomatorCommandTurnOnHidingOfMorphsNumberIDInLabels = (function(_super) {
  __extends(AutomatorCommandTurnOnHidingOfMorphsNumberIDInLabels, _super);

  AutomatorCommandTurnOnHidingOfMorphsNumberIDInLabels.replayFunction = function(systemTestsRecorderAndPlayer, commandBeingPlayed) {
    return systemTestsRecorderAndPlayer.turnOnHidingOfMorphsNumberIDInLabels();
  };

  function AutomatorCommandTurnOnHidingOfMorphsNumberIDInLabels(systemTestsRecorderAndPlayer) {
    AutomatorCommandTurnOnHidingOfMorphsNumberIDInLabels.__super__.constructor.call(this, systemTestsRecorderAndPlayer);
    this.automatorCommandName = "AutomatorCommandTurnOnHidingOfMorphsNumberIDInLabels";
  }

  AutomatorCommandTurnOnHidingOfMorphsNumberIDInLabels.coffeeScriptSourceOfThisClass = '# \n\n\nclass AutomatorCommandTurnOnHidingOfMorphsNumberIDInLabels extends AutomatorCommand\n\n  @replayFunction: (systemTestsRecorderAndPlayer, commandBeingPlayed) ->\n    systemTestsRecorderAndPlayer.turnOnHidingOfMorphsNumberIDInLabels()\n\n\n  constructor: (systemTestsRecorderAndPlayer) ->\n    super(systemTestsRecorderAndPlayer)\n    # it\'s important that this is the same name of\n    # the class cause we need to use the static method\n    # replayFunction to replay the command\n    @automatorCommandName = "AutomatorCommandTurnOnHidingOfMorphsNumberIDInLabels"';

  return AutomatorCommandTurnOnHidingOfMorphsNumberIDInLabels;

})(AutomatorCommand);

MixedClassKeywords = ['onceAddedClassProperties', 'included'];

namedClasses = {};

HTMLCanvasElement.prototype.deepCopy = function(doSerialize, objOriginalsClonedAlready, objectClones, allMorphsInStructure) {
  var cloneOfMe, ctx, haveIBeenCopiedAlready, positionInObjClonesArray;
  haveIBeenCopiedAlready = objOriginalsClonedAlready.indexOf(this);
  if (haveIBeenCopiedAlready >= 0) {
    if (doSerialize) {
      return "$" + haveIBeenCopiedAlready;
    } else {
      return objectClones[haveIBeenCopiedAlready];
    }
  }
  positionInObjClonesArray = objOriginalsClonedAlready.length;
  objOriginalsClonedAlready.push(this);
  cloneOfMe = newCanvas(new Point(this.width, this.height));
  ctx = cloneOfMe.getContext("2d");
  ctx.drawImage(this, 0, 0);
  if (doSerialize) {
    cloneOfMe = {};
  }
  objectClones.push(cloneOfMe);
  if (doSerialize) {
    cloneOfMe.className = "Canvas";
    cloneOfMe.width = this.width;
    cloneOfMe.height = this.height;
    cloneOfMe.data = this.toDataURL();
    return "$" + positionInObjClonesArray;
  }
  return cloneOfMe;
};

Array.prototype.deepCopy = function(doSerialize, objOriginalsClonedAlready, objectClones, allMorphsInStructure) {
  var cloneOfMe, haveIBeenCopiedAlready, i, positionInObjClonesArray, _i, _ref;
  haveIBeenCopiedAlready = objOriginalsClonedAlready.indexOf(this);
  if (haveIBeenCopiedAlready >= 0) {
    if (doSerialize) {
      return "$" + haveIBeenCopiedAlready;
    } else {
      return objectClones[haveIBeenCopiedAlready];
    }
  }
  positionInObjClonesArray = objOriginalsClonedAlready.length;
  objOriginalsClonedAlready.push(this);
  cloneOfMe = [];
  objectClones.push(cloneOfMe);
  for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    if (this[i] == null) {
      cloneOfMe[i] = null;
    } else if (typeof this[i] === 'object') {
      if (this[i].deepCopy == null) {
        debugger;
      }
      cloneOfMe[i] = this[i].deepCopy(doSerialize, objOriginalsClonedAlready, objectClones, allMorphsInStructure);
    } else {
      cloneOfMe[i] = this[i];
    }
  }
  if (doSerialize) {
    return "$" + positionInObjClonesArray;
  }
  return cloneOfMe;
};

Array.prototype.chunk = function(chunkSize) {
  var array;
  array = this;
  return [].concat.apply([], array.map(function(elem, i) {
    if (i % chunkSize) {
      return [];
    } else {
      return [array.slice(i, i + chunkSize)];
    }
  }));
};

fade = function(eid, initOp, finalOp, TimeToFade, time) {
  var curTick, elapsedTicks, newOp;
  if (initOp === 0) {
    document.getElementById(eid).style.visibility = 'visible';
  }
  curTick = (new Date).getTime();
  elapsedTicks = curTick - time;
  newOp = initOp + (finalOp - initOp) * elapsedTicks / TimeToFade;
  if (Math.abs(newOp - initOp) > Math.abs(finalOp - initOp)) {
    document.getElementById(eid).style.opacity = finalOp;
    if (finalOp === 0) {
      document.getElementById(eid).style.visibility = 'hidden';
    }
    return;
  }
  document.getElementById(eid).style.opacity = newOp;
  setTimeout('fade( \'' + eid + '\',' + initOp + ',' + finalOp + ',' + TimeToFade + ',' + time + ')', TimeToFade / 100);
};

decamelize = function(str, sep) {
  if ((typeof str) !== 'string') {
    throw new TypeError('Expected a string');
  }
  return str.replace(/([a-z\d])([A-Z])/g, '$1' + (sep || '_') + '$2').toLowerCase();
};

getParameterByName = function(name) {
  var regex, results;
  name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
  regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
  results = regex.exec(location.search);
  if (results != null) {
    return decodeURIComponent(results[1].replace(/\+/g, ' '));
  } else {
    return null;
  }
};

Object.prototype.augmentWith = function(obj) {
  var key, value, _ref;
  for (key in obj) {
    value = obj[key];
    if (__indexOf.call(MixedClassKeywords, key) < 0) {
      this[key] = value;
    }
  }
  if ((_ref = obj.onceAddedClassProperties) != null) {
    _ref.apply(this);
  }
  return this;
};

Object.prototype.addInstanceProperties = function(obj) {
  var key, value, _ref;
  for (key in obj) {
    value = obj[key];
    if (__indexOf.call(MixedClassKeywords, key) < 0) {
      this.prototype[key] = value;
    }
  }
  if ((_ref = obj.included) != null) {
    _ref.apply(this);
  }
  return this;
};

arrayShallowCopy = function(anArray) {
  return anArray.concat();
};

arrayShallowCopyAndReverse = function(anArray) {
  return anArray.concat().reverse();
};

hashCode = function(stringToBeHashed) {
  var char, hash, i, _i, _ref;
  hash = 0;
  if (stringToBeHashed.length === 0) {
    return hash;
  }
  for (i = _i = 0, _ref = stringToBeHashed.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    char = stringToBeHashed.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return hash;
};

nop = function() {
  return function() {
    return null;
  };
};

noOperation = function() {
  return null;
};

isFunction = function(functionToCheck) {
  return typeof functionToCheck === "function";
};

localize = function(string) {
  return string;
};

isNil = function(thing) {
  return thing === undefined || thing === null;
};

contains = function(list, element) {
  return list.some(function(any) {
    return any === element;
  });
};

detect = function(list, predicate) {
  var element, _i, _len;
  for (_i = 0, _len = list.length; _i < _len; _i++) {
    element = list[_i];
    if (predicate.call(null, element)) {
      return element;
    }
  }
  return null;
};

sizeOf = function(object) {
  var key, size;
  size = 0;
  key = void 0;
  for (key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      size += 1;
    }
  }
  return size;
};

isString = function(target) {
  return typeof target === "string" || target instanceof String;
};

isObject = function(target) {
  return (target != null) && (typeof target === "object" || target instanceof Object);
};

degreesToRadians = function(degrees) {
  return degrees * Math.PI / 180;
};

radiansToDegrees = function(radians) {
  return radians * 180 / Math.PI;
};

fontHeight = function(height) {
  var minHeight;
  minHeight = Math.max(height, WorldMorph.preferencesAndSettings.minimumFontHeight);
  return Math.ceil(minHeight * 1.2);
};

newCanvas = function(extentPoint) {
  var canvas, ext;
  if (extentPoint != null) {
    extentPoint.debugIfFloats();
  }
  ext = extentPoint || {
    x: 0,
    y: 0
  };
  canvas = document.createElement("canvas");
  canvas.width = Math.ceil(ext.x);
  canvas.height = Math.ceil(ext.y);
  return canvas;
};

getMinimumFontHeight = function() {
  var canvas, ctx, data, maxX, size, str, x, y, _i, _j;
  str = "I";
  size = 50;
  canvas = document.createElement("canvas");
  canvas.width = size;
  canvas.height = size;
  ctx = canvas.getContext("2d");
  ctx.font = "1px serif";
  maxX = Math.ceil(ctx.measureText(str).width);
  ctx.fillStyle = "black";
  ctx.textBaseline = "bottom";
  ctx.fillText(str, 0, size);
  for (y = _i = 0; 0 <= size ? _i < size : _i > size; y = 0 <= size ? ++_i : --_i) {
    for (x = _j = 0; 0 <= maxX ? _j < maxX : _j > maxX; x = 0 <= maxX ? ++_j : --_j) {
      data = ctx.getImageData(x, y, 1, 1);
      if (data.data[3] !== 0) {
        return size - y + 1;
      }
    }
  }
  return 0;
};

getBlurredShadowSupport = function() {
  var ctx, source, target;
  source = document.createElement("canvas");
  source.width = 10;
  source.height = 10;
  ctx = source.getContext("2d");
  ctx.fillStyle = "rgb(255, 0, 0)";
  ctx.beginPath();
  ctx.arc(5, 5, 5, 0, Math.PI * 2, true);
  ctx.closePath();
  ctx.fill();
  target = document.createElement("canvas");
  target.width = 10;
  target.height = 10;
  ctx = target.getContext("2d");
  ctx.shadowBlur = 10;
  ctx.shadowColor = "rgba(0, 0, 255, 1)";
  ctx.drawImage(source, 0, 0);
  if (ctx.getImageData(0, 0, 1, 1).data[3]) {
    return true;
  } else {
    return false;
  }
};

getDocumentPositionOf = function(aDOMelement) {
  var offsetParent, pos;
  if (aDOMelement === null) {
    return {
      x: 0,
      y: 0
    };
  }
  pos = {
    x: aDOMelement.offsetLeft,
    y: aDOMelement.offsetTop
  };
  offsetParent = aDOMelement.offsetParent;
  while (offsetParent != null) {
    pos.x += offsetParent.offsetLeft;
    pos.y += offsetParent.offsetTop;
    if (offsetParent !== document.body && offsetParent !== document.documentElement) {
      pos.x -= offsetParent.scrollLeft;
      pos.y -= offsetParent.scrollTop;
    }
    offsetParent = offsetParent.offsetParent;
  }
  return pos;
};

HashCalculator = (function() {
  function HashCalculator() {}

  namedClasses[HashCalculator.name] = HashCalculator.prototype;

  HashCalculator.calculateHash = function(theString) {
    var chr, hash, i, _i, _ref;
    hash = 0;
    if (theString.length === 0) {
      return hash;
    }
    for (i = _i = 0, _ref = theString.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      chr = theString.charCodeAt(i);
      hash = ((hash << 5) - hash) + chr;
      hash |= 0;
      i++;
    }
    return hash;
  };

  HashCalculator.coffeeScriptSourceOfThisClass = '# REQUIRES globalFunctions\n\n# HashCalculator ///////////////////////////////////////////////////\n# adapted from http://stackoverflow.com/a/7616484\n\n# Currently used to differentiate the filenames\n# for test reference images taken in\n# different os/browser config: a hash of the\n# configuration is added to the filename.\n\nclass HashCalculator\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @calculateHash: (theString) ->\n      hash = 0\n      return hash  if theString.length is 0\n\n      for i in [0...theString.length]\n        chr = theString.charCodeAt(i)\n        hash = ((hash << 5) - hash) + chr\n        hash |= 0 # Convert to 32bit integer\n        i++\n      return hash';

  return HashCalculator;

})();

SystemTestsReferenceImage = (function() {
  var fileName;

  SystemTestsReferenceImage.prototype.imageName = '';

  SystemTestsReferenceImage.prototype.imageData = '';

  SystemTestsReferenceImage.prototype.systemInfo = null;

  SystemTestsReferenceImage.prototype.hashOfData = 0;

  SystemTestsReferenceImage.prototype.hashOfSystemInfo = 0;

  fileName = '';

  function SystemTestsReferenceImage(imageName, imageData, systemInfo) {
    this.imageName = imageName;
    this.imageData = imageData;
    this.systemInfo = systemInfo;
    this.hashOfData = HashCalculator.calculateHash(this.imageData);
    this.hashOfSystemInfo = HashCalculator.calculateHash(JSON.stringify(this.systemInfo));
    this.fileName = this.imageName + "-systemInfoHash" + this.hashOfSystemInfo + "-dataHash" + this.hashOfData;
  }

  SystemTestsReferenceImage.prototype.createJSContent = function() {
    return "if (!AutomatorRecorderAndPlayer.loadedImages.hasOwnProperty('" + this.imageName + "')) { " + "AutomatorRecorderAndPlayer.loadedImages." + this.imageName + ' = []; } ' + "AutomatorRecorderAndPlayer.loadedImages." + this.imageName + '.push(' + JSON.stringify(this) + ');';
  };

  SystemTestsReferenceImage.prototype.addToZipAsJS = function(zip) {
    return zip.file(this.fileName + ".js", this.createJSContent());
  };

  SystemTestsReferenceImage.prototype.addToZipAsJSIgnoringItsAnObtained = function(zip) {
    return zip.file(this.fileName + ".js", this.createJSContent().replace(/obtained-/g, ""));
  };

  SystemTestsReferenceImage.prototype.addToZipAsPNG = function(zip) {
    return zip.file(this.fileName + ".png", this.imageData.replace(/^data:image\/png;base64,/, ""), {
      base64: true
    });
  };

  SystemTestsReferenceImage.coffeeScriptSourceOfThisClass = '# Holds image data and metadata.\n# These images are saved as javascript files\n# and are used to test the actual rendering\n# on screen (or parts of it)\n\n# REQUIRES HashCalculator\n\nclass SystemTestsReferenceImage\n  imageName: \'\'\n  # the image data as string, like\n  # e.g. "data:image/png;base64,iVBORw0KGgoAA..."\n  imageData: \'\'\n  systemInfo: null\n  hashOfData: 0\n  hashOfSystemInfo: 0\n  fileName = \'\'\n\n  constructor: (@imageName, @imageData, @systemInfo) ->\n    @hashOfData = HashCalculator.calculateHash(@imageData)\n    @hashOfSystemInfo = HashCalculator.calculateHash(JSON.stringify(@systemInfo))\n\n    # The filenames contain the test name and the image "number"\n    # AND hashes of data and metadata. This is because the same\n    # test/step might have different images for different\n    # OSs/browsers, so they all must be different files.\n    # The js files contain directly the code to load the image.\n    # There can be multiple files for the same image, since\n    # the images vary according to OS and Browser, so for\n    # each image of each test there is an array of files.\n    # No extension added, cause we are going to\n    # generate both png and js files.\n    @fileName = @imageName + "-systemInfoHash" + @hashOfSystemInfo + "-dataHash" + @hashOfData\n\n  createJSContent: ->\n  	  return "if (!AutomatorRecorderAndPlayer.loadedImages.hasOwnProperty(\'" + @imageName + "\')) { " + "AutomatorRecorderAndPlayer.loadedImages." + @imageName + \' = []; } \' + "AutomatorRecorderAndPlayer.loadedImages." + @imageName + \'.push(\' + JSON.stringify(@) + \');\'\n\n  addToZipAsJS: (zip) ->\n  	zip.file(\n  	  @fileName + ".js",\n  	  @createJSContent()\n  	)\n\n  # This method does the same of the one above\n  # but it eliminates the "obtained-" text everywhere\n  # in the content. In this way, the file can just\n  # be renamed and can be added to the tests together\n  # with all the other "good screenshots"\n  # right away withouth having to open it and doing\n  # the change manually.\n  addToZipAsJSIgnoringItsAnObtained: (zip) ->\n  	zip.file(\n  	  @fileName + ".js",\n  	  @createJSContent().replace(/obtained-/g,"")\n  	)\n\n  addToZipAsPNG: (zip) ->\n    # the imageData string contains a little bit of string\n    # that we need to strip out before the base64-encoded png data\n    zip.file(\n      @fileName + ".png",\n      @imageData.replace(/^data:image\/png;base64,/, ""), {base64: true}\n    )';

  return SystemTestsReferenceImage;

})();

SystemInfo = (function() {
  SystemInfo.prototype.userAgent = null;

  SystemInfo.prototype.screenWidth = null;

  SystemInfo.prototype.screenHeight = null;

  SystemInfo.prototype.screenColorDepth = null;

  SystemInfo.prototype.screenPixelRatio = null;

  SystemInfo.prototype.appCodeName = null;

  SystemInfo.prototype.appName = null;

  SystemInfo.prototype.appVersion = null;

  SystemInfo.prototype.cookieEnabled = null;

  SystemInfo.prototype.platform = null;

  SystemInfo.prototype.systemLanguage = null;

  SystemInfo.prototype.browser = null;

  SystemInfo.prototype.browserVersion = null;

  SystemInfo.prototype.mobile = null;

  SystemInfo.prototype.os = null;

  SystemInfo.prototype.osVersion = null;

  SystemInfo.prototype.cookies = null;

  function SystemInfo() {
    var browser, clientStrings, cookieEnabled, cs, id, ix, majorVersion, mobile, nAgt, nVer, nameOffset, os, osVersion, unknown, verOffset, version;
    this.userAgent = navigator.userAgent;
    this.screenWidth = window.screen.width;
    this.screenHeight = window.screen.height;
    this.screenColorDepth = window.screen.colorDepth;
    this.screenPixelRatio = window.devicePixelRatio;
    this.appCodeName = navigator.appCodeName;
    this.appName = navigator.appName;
    this.appVersion = navigator.appVersion;
    this.cookieEnabled = navigator.cookieEnabled;
    this.platform = navigator.platform;
    this.systemLanguage = navigator.systemLanguage;

    /**
     * code here is from "JavaScript Client Detection"
     * (C) viazenetti GmbH (Christian Ludwig)
     */
    unknown = '-';
    nVer = navigator.appVersion;
    nAgt = navigator.userAgent;
    browser = navigator.appName;
    version = '' + parseFloat(navigator.appVersion);
    majorVersion = parseInt(navigator.appVersion, 10);
    nameOffset = void 0;
    verOffset = void 0;
    ix = void 0;
    if ((verOffset = nAgt.indexOf('Opera')) !== -1) {
      browser = 'Opera';
      version = nAgt.substring(verOffset + 6);
      if ((verOffset = nAgt.indexOf('Version')) !== -1) {
        version = nAgt.substring(verOffset + 8);
      }
    } else if ((verOffset = nAgt.indexOf('MSIE')) !== -1) {
      browser = 'Microsoft Internet Explorer';
      version = nAgt.substring(verOffset + 5);
    } else if ((verOffset = nAgt.indexOf('Chrome')) !== -1) {
      browser = 'Chrome';
      version = nAgt.substring(verOffset + 7);
    } else if ((verOffset = nAgt.indexOf('Safari')) !== -1) {
      browser = 'Safari';
      version = nAgt.substring(verOffset + 7);
      if ((verOffset = nAgt.indexOf('Version')) !== -1) {
        version = nAgt.substring(verOffset + 8);
      }
    } else if ((verOffset = nAgt.indexOf('Firefox')) !== -1) {
      browser = 'Firefox';
      version = nAgt.substring(verOffset + 8);
    } else if (nAgt.indexOf('Trident/') !== -1) {
      browser = 'Microsoft Internet Explorer';
      version = nAgt.substring(nAgt.indexOf('rv:') + 3);
    } else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {
      browser = nAgt.substring(nameOffset, verOffset);
      version = nAgt.substring(verOffset + 1);
      if (browser.toLowerCase() === browser.toUpperCase()) {
        browser = navigator.appName;
      }
    }
    if ((ix = version.indexOf(';')) !== -1) {
      version = version.substring(0, ix);
    }
    if ((ix = version.indexOf(' ')) !== -1) {
      version = version.substring(0, ix);
    }
    if ((ix = version.indexOf(')')) !== -1) {
      version = version.substring(0, ix);
    }
    majorVersion = parseInt('' + version, 10);
    if (isNaN(majorVersion)) {
      version = '' + parseFloat(navigator.appVersion);
      majorVersion = parseInt(navigator.appVersion, 10);
    }
    mobile = /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(nVer);
    cookieEnabled = navigator.cookieEnabled ? true : false;
    if (typeof navigator.cookieEnabled === 'undefined' && !cookieEnabled) {
      document.cookie = 'testcookie';
      cookieEnabled = document.cookie.indexOf('testcookie') !== -1 ? true : false;
    }
    os = unknown;
    clientStrings = [
      {
        s: 'Windows 3.11',
        r: /Win16/
      }, {
        s: 'Windows 95',
        r: /(Windows 95|Win95|Windows_95)/
      }, {
        s: 'Windows ME',
        r: /(Win 9x 4.90|Windows ME)/
      }, {
        s: 'Windows 98',
        r: /(Windows 98|Win98)/
      }, {
        s: 'Windows CE',
        r: /Windows CE/
      }, {
        s: 'Windows 2000',
        r: /(Windows NT 5.0|Windows 2000)/
      }, {
        s: 'Windows XP',
        r: /(Windows NT 5.1|Windows XP)/
      }, {
        s: 'Windows Server 2003',
        r: /Windows NT 5.2/
      }, {
        s: 'Windows Vista',
        r: /Windows NT 6.0/
      }, {
        s: 'Windows 7',
        r: /(Windows 7|Windows NT 6.1)/
      }, {
        s: 'Windows 8.1',
        r: /(Windows 8.1|Windows NT 6.3)/
      }, {
        s: 'Windows 8',
        r: /(Windows 8|Windows NT 6.2)/
      }, {
        s: 'Windows NT 4.0',
        r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/
      }, {
        s: 'Windows ME',
        r: /Windows ME/
      }, {
        s: 'Android',
        r: /Android/
      }, {
        s: 'Open BSD',
        r: /OpenBSD/
      }, {
        s: 'Sun OS',
        r: /SunOS/
      }, {
        s: 'Linux',
        r: /(Linux|X11)/
      }, {
        s: 'iOS',
        r: /(iPhone|iPad|iPod)/
      }, {
        s: 'Mac OS X',
        r: /Mac OS X/
      }, {
        s: 'Mac OS',
        r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/
      }, {
        s: 'QNX',
        r: /QNX/
      }, {
        s: 'UNIX',
        r: /UNIX/
      }, {
        s: 'BeOS',
        r: /BeOS/
      }, {
        s: 'OS/2',
        r: /OS\/2/
      }, {
        s: 'Search Bot',
        r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/
      }
    ];
    for (id in clientStrings) {
      cs = clientStrings[id];
      if (cs.r.test(nAgt)) {
        os = cs.s;
        break;
      }
    }
    osVersion = unknown;
    if (/Windows/.test(os)) {
      osVersion = /Windows (.*)/.exec(os)[1];
      os = 'Windows';
    }
    switch (os) {
      case 'Mac OS X':
        osVersion = /Mac OS X (10[\._\d]+)/.exec(nAgt)[1];
        break;
      case 'Android':
        osVersion = /Android ([\._\d]+)/.exec(nAgt)[1];
        break;
      case 'iOS':
        osVersion = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer);
        osVersion = osVersion[1] + '.' + osVersion[2] + '.' + (osVersion[3] | 0);
    }
    this.browser = browser;
    this.browserVersion = version;
    this.mobile = mobile;
    this.os = os;
    this.osVersion = osVersion;
    this.cookies = cookieEnabled;
  }

  SystemInfo.coffeeScriptSourceOfThisClass = '# Holds information about browser and machine\n# Note that some of these could\n# change during user session.\n\nclass SystemInfo\n\n  userAgent: null\n  screenWidth: null\n  screenHeight: null\n  screenColorDepth: null\n  screenPixelRatio: null\n  appCodeName: null\n  appName: null\n  appVersion: null\n  cookieEnabled: null\n  platform: null\n  systemLanguage: null\n\n  browser: null\n  browserVersion: null\n  mobile: null\n  os: null\n  osVersion: null\n  cookies: null\n\n  constructor: ->\n    @userAgent = navigator.userAgent\n    @screenWidth = window.screen.width\n    @screenHeight = window.screen.height\n    @screenColorDepth = window.screen.colorDepth\n    @screenPixelRatio = window.devicePixelRatio\n    @appCodeName = navigator.appCodeName\n    @appName = navigator.appName\n    @appVersion = navigator.appVersion\n    @cookieEnabled = navigator.cookieEnabled\n    @platform = navigator.platform\n    @systemLanguage = navigator.systemLanguage\n\n    ###*\n    # code here is from "JavaScript Client Detection"\n    # (C) viazenetti GmbH (Christian Ludwig)\n    ###\n\n    unknown = \'-\'\n    #browser\n    nVer = navigator.appVersion\n    nAgt = navigator.userAgent\n    browser = navigator.appName\n    version = \'\' + parseFloat(navigator.appVersion)\n    majorVersion = parseInt(navigator.appVersion, 10)\n    nameOffset = undefined\n    verOffset = undefined\n    ix = undefined\n    # Opera\n    if (verOffset = nAgt.indexOf(\'Opera\')) != -1\n      browser = \'Opera\'\n      version = nAgt.substring(verOffset + 6)\n      if (verOffset = nAgt.indexOf(\'Version\')) != -1\n        version = nAgt.substring(verOffset + 8)\n    else if (verOffset = nAgt.indexOf(\'MSIE\')) != -1\n      browser = \'Microsoft Internet Explorer\'\n      version = nAgt.substring(verOffset + 5)\n    else if (verOffset = nAgt.indexOf(\'Chrome\')) != -1\n      browser = \'Chrome\'\n      version = nAgt.substring(verOffset + 7)\n    else if (verOffset = nAgt.indexOf(\'Safari\')) != -1\n      browser = \'Safari\'\n      version = nAgt.substring(verOffset + 7)\n      if (verOffset = nAgt.indexOf(\'Version\')) != -1\n        version = nAgt.substring(verOffset + 8)\n    else if (verOffset = nAgt.indexOf(\'Firefox\')) != -1\n      browser = \'Firefox\'\n      version = nAgt.substring(verOffset + 8)\n    else if nAgt.indexOf(\'Trident/\') != -1\n      browser = \'Microsoft Internet Explorer\'\n      version = nAgt.substring(nAgt.indexOf(\'rv:\') + 3)\n    else if (nameOffset = nAgt.lastIndexOf(\' \') + 1) < (verOffset = nAgt.lastIndexOf(\'/\'))\n      browser = nAgt.substring(nameOffset, verOffset)\n      version = nAgt.substring(verOffset + 1)\n      if browser.toLowerCase() == browser.toUpperCase()\n        browser = navigator.appName\n    # trim the version string\n    if (ix = version.indexOf(\';\')) != -1\n      version = version.substring(0, ix)\n    if (ix = version.indexOf(\' \')) != -1\n      version = version.substring(0, ix)\n    if (ix = version.indexOf(\')\')) != -1\n      version = version.substring(0, ix)\n    majorVersion = parseInt(\'\' + version, 10)\n    if isNaN(majorVersion)\n      version = \'\' + parseFloat(navigator.appVersion)\n      majorVersion = parseInt(navigator.appVersion, 10)\n    # mobile version\n    mobile = /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(nVer)\n    # cookie\n    cookieEnabled = if navigator.cookieEnabled then true else false\n    if typeof navigator.cookieEnabled == \'undefined\' and !cookieEnabled\n      document.cookie = \'testcookie\'\n      cookieEnabled = if document.cookie.indexOf(\'testcookie\') != -1 then true else false\n    # system\n    os = unknown\n    clientStrings = [\n      {\n        s: \'Windows 3.11\'\n        r: /Win16/\n      }\n      {\n        s: \'Windows 95\'\n        r: /(Windows 95|Win95|Windows_95)/\n      }\n      {\n        s: \'Windows ME\'\n        r: /(Win 9x 4.90|Windows ME)/\n      }\n      {\n        s: \'Windows 98\'\n        r: /(Windows 98|Win98)/\n      }\n      {\n        s: \'Windows CE\'\n        r: /Windows CE/\n      }\n      {\n        s: \'Windows 2000\'\n        r: /(Windows NT 5.0|Windows 2000)/\n      }\n      {\n        s: \'Windows XP\'\n        r: /(Windows NT 5.1|Windows XP)/\n      }\n      {\n        s: \'Windows Server 2003\'\n        r: /Windows NT 5.2/\n      }\n      {\n        s: \'Windows Vista\'\n        r: /Windows NT 6.0/\n      }\n      {\n        s: \'Windows 7\'\n        r: /(Windows 7|Windows NT 6.1)/\n      }\n      {\n        s: \'Windows 8.1\'\n        r: /(Windows 8.1|Windows NT 6.3)/\n      }\n      {\n        s: \'Windows 8\'\n        r: /(Windows 8|Windows NT 6.2)/\n      }\n      {\n        s: \'Windows NT 4.0\'\n        r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/\n      }\n      {\n        s: \'Windows ME\'\n        r: /Windows ME/\n      }\n      {\n        s: \'Android\'\n        r: /Android/\n      }\n      {\n        s: \'Open BSD\'\n        r: /OpenBSD/\n      }\n      {\n        s: \'Sun OS\'\n        r: /SunOS/\n      }\n      {\n        s: \'Linux\'\n        r: /(Linux|X11)/\n      }\n      {\n        s: \'iOS\'\n        r: /(iPhone|iPad|iPod)/\n      }\n      {\n        s: \'Mac OS X\'\n        r: /Mac OS X/\n      }\n      {\n        s: \'Mac OS\'\n        r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/\n      }\n      {\n        s: \'QNX\'\n        r: /QNX/\n      }\n      {\n        s: \'UNIX\'\n        r: /UNIX/\n      }\n      {\n        s: \'BeOS\'\n        r: /BeOS/\n      }\n      {\n        s: \'OS/2\'\n        r: /OS\/2/\n      }\n      {\n        s: \'Search Bot\'\n        r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/\n      }\n    ]\n    for id of clientStrings\n      cs = clientStrings[id]\n      if cs.r.test(nAgt)\n        os = cs.s\n        break\n    osVersion = unknown\n    if /Windows/.test(os)\n      osVersion = /Windows (.*)/.exec(os)[1]\n      os = \'Windows\'\n    switch os\n      when \'Mac OS X\'\n        osVersion = /Mac OS X (10[\._\d]+)/.exec(nAgt)[1]\n      when \'Android\'\n        osVersion = /Android ([\._\d]+)/.exec(nAgt)[1]\n      when \'iOS\'\n        osVersion = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer)\n        osVersion = osVersion[1] + \'.\' + osVersion[2] + \'.\' + (osVersion[3] | 0)\n\n    @browser = browser\n    @browserVersion = version\n    @mobile = mobile\n    @os = os\n    @osVersion = osVersion\n    @cookies = cookieEnabled';

  return SystemInfo;

})();

SystemTestsSystemInfo = (function(_super) {
  __extends(SystemTestsSystemInfo, _super);

  SystemTestsSystemInfo.prototype.AutomatorVersionMajor = null;

  SystemTestsSystemInfo.prototype.AutomatorVersionMinor = null;

  SystemTestsSystemInfo.prototype.AutomatorVersionRelease = null;

  function SystemTestsSystemInfo() {
    SystemTestsSystemInfo.__super__.constructor.call(this);
    this.AutomatorVersionMajor = 0;
    this.AutomatorVersionMinor = 1;
    this.AutomatorVersionRelease = 0;
  }

  SystemTestsSystemInfo.coffeeScriptSourceOfThisClass = '# Holds information about browser and machine\n# Note that some of these could\n# change during user session.\n\nclass SystemTestsSystemInfo extends SystemInfo\n  # cannot just initialise the numbers here\n  # cause we are going to make a JSON\n  # out of this and these would not\n  # be picked up.\n  AutomatorVersionMajor: null\n  AutomatorVersionMinor: null\n  AutomatorVersionRelease: null\n\n  constructor: ->\n    super()\n    @AutomatorVersionMajor = 0\n    @AutomatorVersionMinor = 1\n    @AutomatorVersionRelease = 0';

  return SystemTestsSystemInfo;

})(SystemInfo);

AutomatorRecorderAndPlayer = (function() {
  AutomatorRecorderAndPlayer.prototype.automatorCommandsSequence = [];

  AutomatorRecorderAndPlayer.RECORDING = 0;

  AutomatorRecorderAndPlayer.PLAYING = 1;

  AutomatorRecorderAndPlayer.IDLE = 2;

  AutomatorRecorderAndPlayer.state = 2;

  AutomatorRecorderAndPlayer.prototype.playingAllSystemTests = false;

  AutomatorRecorderAndPlayer.prototype.indexOfSystemTestBeingPlayed = 0;

  AutomatorRecorderAndPlayer.prototype.timeOfPreviouslyRecordedCommand = null;

  AutomatorRecorderAndPlayer.prototype.handMorph = null;

  AutomatorRecorderAndPlayer.prototype.worldMorph = null;

  AutomatorRecorderAndPlayer.prototype.collectedImages = [];

  AutomatorRecorderAndPlayer.prototype.collectedFailureImages = [];

  AutomatorRecorderAndPlayer.prototype.testName = '';

  AutomatorRecorderAndPlayer.prototype.testDescription = 'no description';

  AutomatorRecorderAndPlayer.prototype.testTags = ['noTags'];

  AutomatorRecorderAndPlayer.loadedImages = {};

  AutomatorRecorderAndPlayer.loadedImagesToBeKeptForLaterDiff = {};

  AutomatorRecorderAndPlayer.prototype.ongoingTestPlayingTask = null;

  AutomatorRecorderAndPlayer.prototype.timeOfPreviouslyPlayedCommand = 0;

  AutomatorRecorderAndPlayer.prototype.indexOfTestCommandBeingPlayedFromSequence = 0;

  AutomatorRecorderAndPlayer.animationsPacingControl = false;

  AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism = false;

  AutomatorRecorderAndPlayer.hidingOfMorphsGeometryInfoInLabels = false;

  AutomatorRecorderAndPlayer.hidingOfMorphsNumberIDInLabels = false;

  AutomatorRecorderAndPlayer.hidingOfMorphsContentExtractInLabels = false;

  AutomatorRecorderAndPlayer.prototype.imageDataOfAParticularMorph = null;

  AutomatorRecorderAndPlayer.prototype.lastMouseDownCommand = null;

  AutomatorRecorderAndPlayer.prototype.lastMouseUpCommand = null;

  AutomatorRecorderAndPlayer.prototype.selectedTestsBasedOnTags = [];

  AutomatorRecorderAndPlayer.prototype.numberOfGroups = 1;

  AutomatorRecorderAndPlayer.prototype.groupToBeRun = 0;

  AutomatorRecorderAndPlayer.prototype.atLeastOneTestHasBeenRun = false;

  AutomatorRecorderAndPlayer.prototype.allTestsPassedSoFar = true;

  AutomatorRecorderAndPlayer.prototype.testDuration = 0;

  AutomatorRecorderAndPlayer.prototype.allTestsDuration = 0;

  AutomatorRecorderAndPlayer.prototype.millisOfTestSoFar = 0;

  AutomatorRecorderAndPlayer.prototype.millisOfAllTestsSoFar = 0;

  AutomatorRecorderAndPlayer.prototype.currentlyPlayingTestName = "";

  AutomatorRecorderAndPlayer.prototype.tagsCollectedWhileRecordingTest = [];

  function AutomatorRecorderAndPlayer(worldMorph, handMorph) {
    this.worldMorph = worldMorph;
    this.handMorph = handMorph;
  }

  AutomatorRecorderAndPlayer.prototype.clearCommandSeqAndImagesRelatedToTest = function(testName) {
    var imageNumber, _i;
    for (imageNumber = _i = 0; _i < 100; imageNumber = ++_i) {
      console.log("deleting " + testName + "_image_" + imageNumber);
      delete AutomatorRecorderAndPlayer.loadedImages["" + testName + "_image_" + imageNumber];
    }
    console.log("deleting SystemTest_" + testName);
    window[("" + testName) + "_automationCommands"] = null;
    return delete window[("" + testName) + "_automationCommands"];
  };

  AutomatorRecorderAndPlayer.prototype.clearAnyDataRelatedToTest = function(testName) {
    this.clearCommandSeqAndImagesRelatedToTest(testName);
    return delete window["" + testName];
  };

  AutomatorRecorderAndPlayer.prototype.startTestRecording = function(ignored, ingnored2, testName, testDescription, testTags) {
    this.testName = testName;
    this.testDescription = testDescription;
    this.testTags = testTags;
    if (this.testName == null) {
      this.testName = prompt("Please enter a test name", "test1");
    }
    if (this.testDescription == null) {
      this.testDescription = prompt("Please enter a test description", "no description");
    }
    if (this.testTags == null) {
      this.testTags = prompt("Please enter test tags separated by commas", "noTags");
      this.testTags = this.testTags.replace(/[ ]+/g, "");
      this.testTags = this.testTags.split(",");
    }
    this.clearAnyDataRelatedToTest(this.testName);
    this.automatorCommandsSequence = [];
    this.tagsCollectedWhileRecordingTest = [];
    this.timeOfPreviouslyRecordedCommand = new Date().getTime();
    return AutomatorRecorderAndPlayer.state = AutomatorRecorderAndPlayer.RECORDING;
  };

  AutomatorRecorderAndPlayer.prototype.stopTestRecording = function() {
    return AutomatorRecorderAndPlayer.state = AutomatorRecorderAndPlayer.IDLE;
  };

  AutomatorRecorderAndPlayer.prototype.stopTestPlaying = function() {
    var indexOfTask, mousePointerIndicator;
    SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.stopTestRec);
    console.log("wrapping up the playing of the test");
    world.worldCanvas.tabIndex = "1";
    fade('singleTestProgressIndicator', 1, 0, 10, new Date().getTime());
    fade('singleTestProgressBarWrap', 1, 0, 10, new Date().getTime());
    fade('allTestsProgressIndicator', 1, 0, 10, new Date().getTime());
    fade('allTestsProgressBarWrap', 1, 0, 10, new Date().getTime());
    fade('numberOfTestsDoneIndicator', 1, 0, 10, new Date().getTime());
    SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole("test complete");
    AutomatorRecorderAndPlayer.state = AutomatorRecorderAndPlayer.IDLE;
    mousePointerIndicator = document.getElementById('mousePointerIndicator');
    mousePointerIndicator.style.display = 'none';
    indexOfTask = this.worldMorph.otherTasksToBeRunOnStep.indexOf(this.ongoingTestPlayingTask);
    this.worldMorph.otherTasksToBeRunOnStep.splice(indexOfTask, 1);
    this.worldMorph.initEventListeners();
    this.indexOfTestCommandBeingPlayedFromSequence = 0;
    this.clearCommandSeqAndImagesRelatedToTest(this.testsList()[this.indexOfSystemTestBeingPlayed]);
    if (this.playingAllSystemTests) {
      return this.runNextSystemTest();
    }
  };

  AutomatorRecorderAndPlayer.prototype.showTestSource = function() {
    return window.open("data:text/text;charset=utf-8," + encodeURIComponent(JSON.stringify(this.automatorCommandsSequence, null, 4)));
  };

  AutomatorRecorderAndPlayer.prototype.turnOnAnimationsPacingControl = function() {
    var systemTestCommand;
    this.constructor.animationsPacingControl = true;
    SystemTestsControlPanelUpdater.highlightOnLink(SystemTestsControlPanelUpdater.tieAnimations);
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandTurnOnAnimationsPacingControl(this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.turnOffAnimationsPacingControl = function() {
    var systemTestCommand;
    this.constructor.animationsPacingControl = false;
    SystemTestsControlPanelUpdater.highlightOffLink(SystemTestsControlPanelUpdater.tieAnimations);
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandTurnOffAnimationsPacingControl(this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.turnOnAlignmentOfMorphIDsMechanism = function() {
    var systemTestCommand;
    this.constructor.alignmentOfMorphIDsMechanism = true;
    SystemTestsControlPanelUpdater.highlightOnLink(SystemTestsControlPanelUpdater.alignMorphIDs);
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandTurnOnAlignmentOfMorphIDsMechanism(this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.turnOffAlignmentOfMorphIDsMechanism = function() {
    var systemTestCommand;
    this.constructor.alignmentOfMorphIDsMechanism = false;
    SystemTestsControlPanelUpdater.highlightOffLink(SystemTestsControlPanelUpdater.alignMorphIDs);
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandTurnOffAlignmentOfMorphIDsMechanism(this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.turnOnHidingOfMorphsGeometryInfoInLabels = function() {
    var systemTestCommand;
    this.constructor.hidingOfMorphsGeometryInfoInLabels = true;
    SystemTestsControlPanelUpdater.highlightOnLink(SystemTestsControlPanelUpdater.hideGeometry);
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandTurnOnHidingOfMorphsGeometryInfoInLabels(this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.turnOffHidingOfMorphsGeometryInfoInLabels = function() {
    var systemTestCommand;
    this.constructor.hidingOfMorphsGeometryInfoInLabels = false;
    SystemTestsControlPanelUpdater.highlightOffLink(SystemTestsControlPanelUpdater.hideGeometry);
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandTurnOffHidingOfMorphsGeometryInfoInLabels(this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.turnOnHidingOfMorphsContentExtractInLabels = function() {
    var systemTestCommand;
    this.constructor.hidingOfMorphsContentExtractInLabels = true;
    SystemTestsControlPanelUpdater.highlightOnLink(SystemTestsControlPanelUpdater.hideMorphContentExtracts);
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandTurnOnHidingOfMorphsContentExtractInLabels(this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.turnOffHidingOfMorphsContentExtractInLabels = function() {
    var systemTestCommand;
    this.constructor.hidingOfMorphsContentExtractInLabels = false;
    SystemTestsControlPanelUpdater.highlightOffLink(SystemTestsControlPanelUpdater.hideMorphContentExtracts);
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandTurnOffHidingOfMorphsContentExtractInLabels(this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.turnOnHidingOfMorphsNumberIDInLabels = function() {
    var systemTestCommand;
    this.constructor.hidingOfMorphsNumberIDInLabels = true;
    SystemTestsControlPanelUpdater.highlightOnLink(SystemTestsControlPanelUpdater.hideMorphIDs);
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandTurnOnHidingOfMorphsNumberIDInLabels(this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.turnOffHidingOfMorphsNumberIDInLabels = function() {
    var systemTestCommand;
    this.constructor.hidingOfMorphsNumberIDInLabels = false;
    SystemTestsControlPanelUpdater.highlightOffLink(SystemTestsControlPanelUpdater.hideMorphIDs);
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandTurnOffHidingOfMorphsNumberIDInLabels(this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.addMouseMoveCommand = function(pageX, pageY, floatDraggingSomething) {
    var systemTestCommand;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandMouseMove(pageX, pageY, floatDraggingSomething, this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.addMouseChangeCommand = function(upOrDown, button, ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph) {
    var systemTestCommand;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandMouseButtonChange(upOrDown, button, ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph, this);
    this.lastMouseDownCommand = systemTestCommand;
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.addMouseClickCommand = function(button, ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph) {
    var systemTestCommand;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandMouseClick(button, ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph, this);
    this.lastMouseDownCommand = systemTestCommand;
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.addMouseDoubleClickCommand = function(ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph) {
    var systemTestCommand;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandMouseDoubleClick(ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph, this);
    this.lastMouseDownCommand = systemTestCommand;
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.addOpenContextMenuCommand = function(context) {
    var systemTestCommand;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandOpenContextMenu(context, this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.addCommandLeftOrRightClickOnMenuItem = function(mouseButton, labelString, occurrenceNumber) {
    var systemTestCommand;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandLeftOrRightClickOnMenuItem(mouseButton, labelString, occurrenceNumber, this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.addKeyPressCommand = function(charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) {
    var systemTestCommand;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandKeyPress(charCode, symbol, shiftKey, ctrlKey, altKey, metaKey, this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.addKeyDownCommand = function(scanCode, shiftKey, ctrlKey, altKey, metaKey) {
    var systemTestCommand;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandKeyDown(scanCode, shiftKey, ctrlKey, altKey, metaKey, this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.addKeyUpCommand = function(scanCode, shiftKey, ctrlKey, altKey, metaKey) {
    var systemTestCommand;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandKeyUp(scanCode, shiftKey, ctrlKey, altKey, metaKey, this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.addCopyCommand = function() {
    var systemTestCommand;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandCopy(this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.addPasteCommand = function(clipboardText) {
    var systemTestCommand;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandPaste(clipboardText, this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.addGrabCommand = function() {
    var systemTestCommand;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandGrab(this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.addDropCommand = function() {
    var systemTestCommand;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandDrop(this);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.resetWorld = function() {
    var systemTestCommand;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    systemTestCommand = new AutomatorCommandResetWorld(this);
    window[systemTestCommand.automatorCommandName].replayFunction(this, null);
    this.automatorCommandsSequence.push(systemTestCommand);
    return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
  };

  AutomatorRecorderAndPlayer.prototype.addTestComment = function() {
    var comment, systemTestCommand;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return;
    }
    this.timeOfPreviouslyRecordedCommand = new Date().getTime();
    comment = prompt("enter comment", "your comment here");
    systemTestCommand = new AutomatorCommandShowComment(comment, this);
    return this.automatorCommandsSequence.push(systemTestCommand);
  };

  AutomatorRecorderAndPlayer.prototype.checkStringsOfItemsInMenuOrderImportant = function(stringOfItemsInMenuInOriginalOrder) {
    SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.checkMenuEntriesInOrder);
    return this.checkStringsOfItemsInMenu(stringOfItemsInMenuInOriginalOrder, true);
  };

  AutomatorRecorderAndPlayer.prototype.checkStringsOfItemsInMenuOrderUnimportant = function(stringOfItemsInMenuInOriginalOrder) {
    SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.checkMenuEntriesNotInOrder);
    return this.checkStringsOfItemsInMenu(stringOfItemsInMenuInOriginalOrder, false);
  };

  AutomatorRecorderAndPlayer.prototype.checkStringsOfItemsInMenu = function(stringOfItemsInMenuInOriginalOrder, orderMatters) {
    var copyOfstringOfItemsInMenuInOriginalOrder, eachMenuItem, errorMessage, giveError, giveSuccess, itemNumber, menuAtPointer, menuListIsSame, stringOfItemsInCurrentMenuInOriginalOrder, systemTestCommand, _i, _j, _len, _ref, _ref1;
    console.log("checkStringsOfItemsInMenu");
    menuAtPointer = this.handMorph.menuAtPointer();
    console.log(menuAtPointer);
    stringOfItemsInCurrentMenuInOriginalOrder = [];
    if (menuAtPointer != null) {
      _ref = menuAtPointer.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        eachMenuItem = _ref[_i];
        stringOfItemsInCurrentMenuInOriginalOrder.push(eachMenuItem[0]);
      }
    } else {
      errorMessage = "FAIL was expecting a menu under the pointer";
      console.log(errorMessage);
      this.allTestsPassedSoFar = false;
      document.getElementById("background").style.background = "red";
      if (typeof SystemTestsControlPanelUpdater !== "undefined" && SystemTestsControlPanelUpdater !== null) {
        SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole(errorMessage);
      }
      this.stopTestPlaying();
    }
    if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.RECORDING) {
      if (orderMatters) {
        systemTestCommand = new AutomatorCommandCheckStringsOfItemsInMenuOrderImportant(stringOfItemsInCurrentMenuInOriginalOrder, this);
      } else {
        systemTestCommand = new AutomatorCommandCheckStringsOfItemsInMenuOrderUnimportant(stringOfItemsInCurrentMenuInOriginalOrder, this);
      }
      this.automatorCommandsSequence.push(systemTestCommand);
      return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
    } else if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.PLAYING) {
      giveSuccess = (function(_this) {
        return function() {
          var message;
          if (orderMatters) {
            message = "PASS Strings in menu are same and in same order";
          } else {
            message = "PASS Strings in menu are same (not considering order)";
          }
          if (typeof SystemTestsControlPanelUpdater !== "undefined" && SystemTestsControlPanelUpdater !== null) {
            return SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole(message);
          }
        };
      })(this);
      giveError = (function(_this) {
        return function() {
          if (orderMatters) {
            _this.allTestsPassedSoFar = false;
            document.getElementById("background").style.background = "red";
            errorMessage = "FAIL Strings in menu doesn't match or order is incorrect. Was expecting: " + stringOfItemsInMenuInOriginalOrder + " found: " + stringOfItemsInCurrentMenuInOriginalOrder;
          } else {
            _this.allTestsPassedSoFar = false;
            document.getElementById("background").style.background = "red";
            errorMessage = "FAIL Strings in menu doesn't match (even not considering order). Was expecting: " + stringOfItemsInMenuInOriginalOrder + " found: " + stringOfItemsInCurrentMenuInOriginalOrder;
          }
          if (typeof SystemTestsControlPanelUpdater !== "undefined" && SystemTestsControlPanelUpdater !== null) {
            SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole(errorMessage);
          }
          return _this.stopTestPlaying();
        };
      })(this);
      menuListIsSame = true;
      copyOfstringOfItemsInMenuInOriginalOrder = arrayShallowCopy(stringOfItemsInMenuInOriginalOrder);
      if (!orderMatters) {
        stringOfItemsInCurrentMenuInOriginalOrder.sort();
        copyOfstringOfItemsInMenuInOriginalOrder.sort();
      }
      if (stringOfItemsInCurrentMenuInOriginalOrder.length === copyOfstringOfItemsInMenuInOriginalOrder.length) {
        for (itemNumber = _j = 0, _ref1 = copyOfstringOfItemsInMenuInOriginalOrder.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; itemNumber = 0 <= _ref1 ? ++_j : --_j) {
          if (copyOfstringOfItemsInMenuInOriginalOrder[itemNumber] !== stringOfItemsInCurrentMenuInOriginalOrder[itemNumber]) {
            menuListIsSame = false;
            console.log(copyOfstringOfItemsInMenuInOriginalOrder[itemNumber] + " != " + stringOfItemsInCurrentMenuInOriginalOrder[itemNumber] + " at " + itemNumber);
          }
        }
      } else {
        menuListIsSame = false;
      }
      if (menuListIsSame) {
        return giveSuccess();
      } else {
        return giveError();
      }
    }
  };

  AutomatorRecorderAndPlayer.prototype.checkNumberOfItemsInMenu = function(numberOfItems) {
    var giveError, giveSuccess, menuAtPointer, systemTestCommand;
    SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.checkNumnberOfItems);
    if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.RECORDING) {
      menuAtPointer = this.handMorph.menuAtPointer();
      console.log(menuAtPointer);
      if (menuAtPointer != null) {
        numberOfItems = menuAtPointer.items.length;
        console.log("found " + numberOfItems + " number of items ");
      } else {
        console.log("was expecting a menu under the pointer");
        numberOfItems = 0;
      }
      systemTestCommand = new AutomatorCommandCheckNumberOfItemsInMenu(numberOfItems, this);
      this.automatorCommandsSequence.push(systemTestCommand);
      return this.timeOfPreviouslyRecordedCommand = new Date().getTime();
    } else if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.PLAYING) {
      menuAtPointer = this.handMorph.menuAtPointer();
      giveSuccess = (function(_this) {
        return function() {
          var message;
          message = "PASS Number of items in menu matches. Note that count includes line separators. Found: " + menuAtPointer.items.length;
          if (typeof SystemTestsControlPanelUpdater !== "undefined" && SystemTestsControlPanelUpdater !== null) {
            return SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole(message);
          }
        };
      })(this);
      giveError = (function(_this) {
        return function() {
          var errorMessage;
          _this.allTestsPassedSoFar = false;
          document.getElementById("background").style.background = "red";
          errorMessage = "FAIL Number of items in menu doesn't match. Note that count includes line separators. Was expecting: " + numberOfItems + " found: " + menuAtPointer.items.length;
          if (typeof SystemTestsControlPanelUpdater !== "undefined" && SystemTestsControlPanelUpdater !== null) {
            SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole(errorMessage);
          }
          return _this.stopTestPlaying();
        };
      })(this);
      if (menuAtPointer != null) {
        if (numberOfItems !== menuAtPointer.items.length) {
          return giveError();
        } else {
          return giveSuccess();
        }
      } else {
        return giveError();
      }
    }
  };

  AutomatorRecorderAndPlayer.prototype.takeScreenshot = function(whichMorph) {
    var imageData, imageName, systemTestCommand, takenScreenshot;
    if (whichMorph == null) {
      whichMorph = this.worldMorph;
    }
    console.log("taking screenshot");
    imageName = "SystemTest_" + this.testName + "_image_" + (this.collectedImages.length + 1);
    systemTestCommand = new AutomatorCommandScreenshot(imageName, this, whichMorph !== this.worldMorph);
    imageData = whichMorph.asItAppearsOnScreen();
    takenScreenshot = new SystemTestsReferenceImage(imageName, imageData, new SystemTestsSystemInfo());
    if (AutomatorRecorderAndPlayer.loadedImages["" + imageName] == null) {
      AutomatorRecorderAndPlayer.loadedImages["" + imageName] = [];
    }
    AutomatorRecorderAndPlayer.loadedImages["" + imageName].push(takenScreenshot);
    this.collectedImages.push(takenScreenshot);
    this.automatorCommandsSequence.push(systemTestCommand);
    this.timeOfPreviouslyRecordedCommand = new Date().getTime();
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.RECORDING) {
      return systemTestCommand;
    }
  };

  AutomatorRecorderAndPlayer.prototype.subtractScreenshots = function(expected, obtained, diffNumber, andThen) {
    var expectedCanvas, expectedImage;
    console.log("subtractScreenshots");
    expectedCanvas = document.createElement("canvas");
    expectedImage = new Image;
    expectedImage.onload = (function(_this) {
      return function() {
        var expectedCanvasContext, expectedImageData, obtainedCanvas, obtainedImage;
        console.log("expectedCanvas.imageData: " + expectedCanvas.imageData);
        expectedCanvas.width = expectedImage.width;
        expectedCanvas.height = expectedImage.height;
        expectedCanvasContext = expectedCanvas.getContext("2d");
        console.log("expectedCanvas.width: " + expectedCanvas.width);
        console.log("expectedCanvas.height: " + expectedCanvas.height);
        expectedCanvasContext.drawImage(expectedImage, 0, 0);
        expectedImageData = expectedCanvasContext.getImageData(0, 0, expectedCanvas.width, expectedCanvas.height);
        obtainedCanvas = document.createElement("canvas");
        obtainedImage = new Image;
        obtainedImage.onload = function() {
          var differentPixels, equalPixels, errorRatio, i, obtainedCanvasContext, obtainedImageData, subtractionCanvas, subtractionCanvasContext, subtractionImageData;
          obtainedCanvas.width = obtainedImage.width;
          obtainedCanvas.height = obtainedImage.height;
          obtainedCanvasContext = obtainedCanvas.getContext("2d");
          obtainedCanvasContext.drawImage(obtainedImage, 0, 0);
          obtainedImageData = obtainedCanvasContext.getImageData(0, 0, obtainedCanvas.width, obtainedCanvas.height);
          subtractionCanvas = document.createElement("canvas");
          subtractionCanvas.width = obtainedImage.width;
          subtractionCanvas.height = obtainedImage.height;
          subtractionCanvasContext = subtractionCanvas.getContext("2d");
          subtractionCanvasContext.drawImage(obtainedImage, 0, 0);
          subtractionImageData = subtractionCanvasContext.getImageData(0, 0, subtractionCanvas.width, subtractionCanvas.height);
          i = 0;
          equalPixels = 0;
          differentPixels = 0;
          while (i < subtractionImageData.data.length) {
            if (obtainedImageData.data[i] !== expectedImageData.data[i] || obtainedImageData.data[i + 1] !== expectedImageData.data[i + 1] || obtainedImageData.data[i + 2] !== expectedImageData.data[i + 2]) {
              subtractionImageData.data[i] = 255;
              subtractionImageData.data[i + 1] = 0;
              subtractionImageData.data[i + 2] = 0;
              differentPixels++;
            } else {
              equalPixels++;
            }
            i += 4;
          }
          console.log("equalPixels: " + equalPixels);
          console.log("differentPixels: " + differentPixels);
          subtractionCanvasContext.putImageData(subtractionImageData, 0, 0);
          errorRatio = differentPixels;
          return andThen(subtractionCanvas, expected, errorRatio, diffNumber);
        };
        return obtainedImage.src = obtained.imageData;
      };
    })(this);
    return expectedImage.src = expected.imageData;
  };

  AutomatorRecorderAndPlayer.prototype.compareScreenshots = function(testNameWithImageNumber, screenshotTakenOfAParticularMorph) {
    var eachImage, message, obtainedImage, obtainedImageName, screenshotObtained, _i, _len, _ref;
    if (screenshotTakenOfAParticularMorph == null) {
      screenshotTakenOfAParticularMorph = false;
    }
    SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.takeScreenshot);
    if (screenshotTakenOfAParticularMorph) {
      console.log("comparing pic of a particular morph");
      screenshotObtained = this.imageDataOfAParticularMorph;
      this.imageDataOfAParticularMorph = null;
    } else {
      console.log("comparing pic of whole desktop");
      screenshotObtained = this.worldMorph.asItAppearsOnScreen();
    }
    console.log("trying to match screenshot: " + testNameWithImageNumber);
    console.log("length of obtained: " + screenshotObtained.length);
    AutomatorRecorderAndPlayer.loadedImagesToBeKeptForLaterDiff["" + testNameWithImageNumber] = AutomatorRecorderAndPlayer.loadedImages["" + testNameWithImageNumber];
    _ref = AutomatorRecorderAndPlayer.loadedImages["" + testNameWithImageNumber];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      eachImage = _ref[_i];
      console.log("length of obtained: " + eachImage.imageData.length);
      if (eachImage.imageData === screenshotObtained) {
        message = "PASS - screenshot " + eachImage.fileName + " matched";
        AutomatorRecorderAndPlayer.loadedImagesToBeKeptForLaterDiff["" + testNameWithImageNumber] = null;
        delete AutomatorRecorderAndPlayer.loadedImagesToBeKeptForLaterDiff["" + testNameWithImageNumber];
        console.log(message);
        if (typeof SystemTestsControlPanelUpdater !== "undefined" && SystemTestsControlPanelUpdater !== null) {
          SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole(message);
        }
        return;
      }
    }
    message = "FAIL - no screenshots like this one";
    console.log(message);
    this.allTestsPassedSoFar = false;
    document.getElementById("background").style.background = "red";
    if (typeof SystemTestsControlPanelUpdater !== "undefined" && SystemTestsControlPanelUpdater !== null) {
      SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole(message);
    }
    obtainedImageName = "obtained-" + eachImage.imageName;
    obtainedImage = new SystemTestsReferenceImage(obtainedImageName, screenshotObtained, new SystemTestsSystemInfo());
    return this.collectedFailureImages.push(obtainedImage);
  };

  AutomatorRecorderAndPlayer.prototype.replayTestCommands = function() {
    var commandToBePlayed, consecutiveMouseMoves, nextCommand1, nextCommand2, previousCommand1, runCurrentCommandImmediately, timeNow, timeUntilNextCommand;
    commandToBePlayed = this.automatorCommandsSequence[this.indexOfTestCommandBeingPlayedFromSequence];
    if (commandToBePlayed.automatorCommandName === "AutomatorCommandScreenshot" && commandToBePlayed.screenshotTakenOfAParticularMorph) {
      if (this.imageDataOfAParticularMorph == null) {
        return;
      }
    }
    runCurrentCommandImmediately = false;
    if (window["" + this.currentlyPlayingTestName].maxSpeedupFactor > 1) {
      if ((this.indexOfTestCommandBeingPlayedFromSequence >= 1) && (this.indexOfTestCommandBeingPlayedFromSequence < (this.automatorCommandsSequence.length - 2))) {
        consecutiveMouseMoves = 0;
        while (true) {
          previousCommand1 = this.automatorCommandsSequence[this.indexOfTestCommandBeingPlayedFromSequence - 1];
          commandToBePlayed = this.automatorCommandsSequence[this.indexOfTestCommandBeingPlayedFromSequence];
          nextCommand1 = this.automatorCommandsSequence[this.indexOfTestCommandBeingPlayedFromSequence + 1];
          nextCommand2 = this.automatorCommandsSequence[this.indexOfTestCommandBeingPlayedFromSequence + 2];
          if (previousCommand1.automatorCommandName === "AutomatorCommandMouseMove" && nextCommand1.automatorCommandName === "AutomatorCommandMouseMove" && nextCommand2.automatorCommandName === "AutomatorCommandMouseMove" && commandToBePlayed.automatorCommandName === "AutomatorCommandMouseMove") {
            consecutiveMouseMoves++;
            if ((consecutiveMouseMoves % 10000) !== 0) {
              timeUntilNextCommand = commandToBePlayed.millisecondsSincePreviousCommand || 0;
              this.millisOfTestSoFar += timeUntilNextCommand;
              this.millisOfAllTestsSoFar += timeUntilNextCommand;
              console.log(">>>>>> skipping mousemove");
              this.indexOfTestCommandBeingPlayedFromSequence++;
            } else {
              runCurrentCommandImmediately = true;
              break;
            }
          } else {
            runCurrentCommandImmediately = true;
            break;
          }
        }
      }
    }
    timeNow = (new Date()).getTime();
    timeUntilNextCommand = commandToBePlayed.millisecondsSincePreviousCommand || 0;
    if (runCurrentCommandImmediately || (timeNow - this.timeOfPreviouslyPlayedCommand >= timeUntilNextCommand)) {
      console.log(">>>>>> doing " + commandToBePlayed.automatorCommandName);
      this.millisOfTestSoFar += timeUntilNextCommand;
      this.millisOfAllTestsSoFar += timeUntilNextCommand;
      window[commandToBePlayed.automatorCommandName].replayFunction.call(this, this, commandToBePlayed);
      document.getElementById('singleTestProgressIndicator').innerHTML = "Test " + Math.floor((this.millisOfTestSoFar / this.testDuration) * 100) + "%" + " complete";
      document.getElementById('singleTestProgressBar').style.left = (Math.floor((this.millisOfTestSoFar / this.testDuration) * 100)) + "%";
      document.getElementById('allTestsProgressIndicator').innerHTML = "overall: " + Math.floor((this.millisOfAllTestsSoFar / this.allTestsDuration) * 100) + "%" + " complete";
      document.getElementById('allTestsProgressBar').style.left = (Math.floor((this.millisOfAllTestsSoFar / this.allTestsDuration) * 100)) + "%";
      this.timeOfPreviouslyPlayedCommand = timeNow;
      this.indexOfTestCommandBeingPlayedFromSequence++;
      if (this.indexOfTestCommandBeingPlayedFromSequence === this.automatorCommandsSequence.length) {
        console.log("stopping the test player");
        return this.stopTestPlaying();
      }
    }
  };

  AutomatorRecorderAndPlayer.prototype.calculateTotalTimeOfThisTest = function() {
    var eachCommand, testDuration, _i, _len, _ref;
    testDuration = 0;
    _ref = this.automatorCommandsSequence;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      eachCommand = _ref[_i];
      if (eachCommand.millisecondsSincePreviousCommand != null) {
        testDuration += eachCommand.millisecondsSincePreviousCommand;
      }
    }
    return this.testDuration = testDuration;
  };

  AutomatorRecorderAndPlayer.prototype.startTestPlaying = function() {
    world.worldCanvas.tabIndex = "-1";
    AutomatorRecorderAndPlayer.state = AutomatorRecorderAndPlayer.PLAYING;
    this.atLeastOneTestHasBeenRun = true;
    this.constructor.animationsPacingControl = true;
    this.worldMorph.removeEventListeners();
    this.currentlyPlayingTestName = this.testsList()[this.indexOfSystemTestBeingPlayed];
    if (window["" + this.currentlyPlayingTestName] != null) {
      this.testDuration = window["" + this.currentlyPlayingTestName].testDuration;
    }
    this.millisOfTestSoFar = 0;
    this.ongoingTestPlayingTask = ((function(_this) {
      return function() {
        return _this.replayTestCommands();
      };
    })(this));
    this.worldMorph.otherTasksToBeRunOnStep.push(this.ongoingTestPlayingTask);
    return document.getElementById('numberOfTestsDoneIndicator').innerHTML = "test " + (this.indexOfSystemTestBeingPlayed + 1) + " of " + this.testsList().length;
  };

  AutomatorRecorderAndPlayer.prototype.startTestPlayingWithSlideIntro = function() {
    this.startTestPlaying();
    return this.setUpIntroSlide();
  };

  AutomatorRecorderAndPlayer.prototype.setUpIntroSlide = function() {
    var presentableTestName;
    fade('singleTestProgressIndicator', 0, 1, 10, new Date().getTime());
    fade('singleTestProgressBarWrap', 0, 1, 10, new Date().getTime());
    fade('allTestsProgressIndicator', 0, 1, 10, new Date().getTime());
    fade('allTestsProgressBarWrap', 0, 1, 10, new Date().getTime());
    fade('numberOfTestsDoneIndicator', 0, 1, 10, new Date().getTime());
    fade('testTitleAndDescription', 0, 1, 10, new Date().getTime());
    presentableTestName = this.currentlyPlayingTestName.replace(/SystemTest_/g, "");
    presentableTestName = decamelize(presentableTestName, " ");
    presentableTestName = presentableTestName.charAt(0).toUpperCase() + presentableTestName.slice(1);
    presentableTestName = '"' + presentableTestName + '"';
    testTitleAndDescription.innerHTML = presentableTestName;
    testTitleAndDescription.innerHTML = testTitleAndDescription.innerHTML + ("<br><br><small>(" + this.currentlyPlayingTestName + ")</small>");
    testTitleAndDescription.innerHTML = testTitleAndDescription.innerHTML + "<br><br><small>" + window["" + this.currentlyPlayingTestName].description + "</small>";
    return setTimeout((function(_this) {
      return function() {
        return fade('testTitleAndDescription', 1, 0, 2000, new Date().getTime());
      };
    })(this), 4000);
  };

  AutomatorRecorderAndPlayer.prototype.testMetadataFileContentCreator = function() {
    var testToBeSerialized;
    testToBeSerialized = {};
    testToBeSerialized.timeRecorded = new Date();
    testToBeSerialized.description = this.testDescription;
    testToBeSerialized.tags = this.testTags.concat(this.tagsCollectedWhileRecordingTest);
    testToBeSerialized.systemInfo = new SystemTestsSystemInfo();
    this.calculateTotalTimeOfThisTest();
    testToBeSerialized.testDuration = this.testDuration;
    return "// This Automator file is automatically\n// created.\n// If this is a test,\n// this file (and related reference images)\n// can be copied in the /src/tests folder\n// to make them available in the testing\n// environment.\nvar SystemTest_" + this.testName + ";\n\nSystemTest_" + this.testName + " = " + (JSON.stringify(testToBeSerialized, null, 4)) + ";";
  };

  AutomatorRecorderAndPlayer.prototype.automatorCommandsFileContentCreator = function(commands) {
    var testNameExtended, testToBeSerialized;
    testToBeSerialized = {};
    testToBeSerialized.automatorCommandsSequence = commands;
    testNameExtended = this.testName + "_automationCommands";
    return "// This Automator file is automatically\n// created.\n// It this is a test,\n// this file (and related reference images)\n// can be copied in the /src/tests folder\n// to make them available in the testing\n// environment.\nvar SystemTest_" + testNameExtended + ";\n\nSystemTest_" + testNameExtended + " = " + (JSON.stringify(testToBeSerialized, null, 4)) + ";";
  };

  AutomatorRecorderAndPlayer.prototype.saveFailedScreenshots = function() {
    var aGoodImageName, diffNumber, eachGoodImage, failedImage, filenameForScript, i, image, pixelRatioString, renamerScript, setOfGoodImages, systemInfo, zip, _i, _j, _k, _len, _len1, _ref, _ref1;
    zip = new JSZip();
    AutomatorRecorderAndPlayer.loadedImages = AutomatorRecorderAndPlayer.loadedImagesToBeKeptForLaterDiff;
    _ref = this.collectedFailureImages;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      image = _ref[_i];
      image.addToZipAsJSIgnoringItsAnObtained(zip);
      image.addToZipAsPNG(zip);
    }
    renamerScript = "";
    systemInfo = new SystemTestsSystemInfo();
    pixelRatioString = ("" + pixelRatio).replace(/\.+/g, "_");
    for (i = _j = 0, _ref1 = this.collectedFailureImages.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      failedImage = this.collectedFailureImages[i];
      aGoodImageName = failedImage.imageName.replace("obtained-", "");
      filenameForScript = aGoodImageName.replace(/_image_.*/g, "");
      renamerScript += "rm " + "../Zombie-Kernel-tests/tests/" + filenameForScript + "/automation-assets/" + systemInfo.os.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" + systemInfo.osVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" + systemInfo.browser.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" + systemInfo.browserVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" + "devicePixelRatio_" + pixelRatioString + "/" + aGoodImageName + "*\n";
      renamerScript += "cp " + failedImage.imageName + "* ../Zombie-Kernel-tests/tests/" + filenameForScript + "/automation-assets/" + systemInfo.os.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" + systemInfo.osVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" + systemInfo.browser.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" + systemInfo.browserVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" + "devicePixelRatio_" + pixelRatioString + "/\n\n";
      setOfGoodImages = AutomatorRecorderAndPlayer.loadedImages[aGoodImageName];
      diffNumber = 0;
      for (_k = 0, _len1 = setOfGoodImages.length; _k < _len1; _k++) {
        eachGoodImage = setOfGoodImages[_k];
        diffNumber++;
        this.subtractScreenshots(failedImage, eachGoodImage, diffNumber, function(subtractionCanvas, failedImage, errorRatio, diffNumber) {
          console.log("zipping diff file:" + "diff-" + failedImage.imageName + ".png");
          return zip.file("diff-" + failedImage.imageName + "-error-" + errorRatio + "-diffNumber-" + diffNumber + ".png", subtractionCanvas.toDataURL().replace(/^data:image\/png;base64,/, ""), {
            base64: true
          });
        });
      }
    }
    zip.file("replace_all_images.sh", renamerScript);
    return setTimeout((function(_this) {
      return function() {
        var content;
        console.log("saving failed screenshots");
        if (navigator.userAgent.search("Safari") >= 0 && navigator.userAgent.search("Chrome") < 0) {
          return location.href = "data:application/zip;base64," + zip.generate({
            type: "base64"
          });
        } else {
          console.log("not safari");
          content = zip.generate({
            type: "blob"
          });
          return saveAs(content, "SystemTest_" + _this.testName + "_failedScreenshots.zip");
        }
      };
    })(this), (this.collectedFailureImages.length + 1) * 200);
  };

  AutomatorRecorderAndPlayer.prototype.saveTest = function() {
    var blob, content, image, testNameExtended, zip, _i, _len, _ref;
    zip = new JSZip();
    blob = this.testMetadataFileContentCreator();
    zip.file("SystemTest_" + this.testName + ".js", blob);
    blob = this.automatorCommandsFileContentCreator(window.world.systemTestsRecorderAndPlayer.automatorCommandsSequence);
    testNameExtended = this.testName + "_automationCommands";
    zip.file("SystemTest_" + testNameExtended + ".js", blob);
    _ref = this.collectedImages;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      image = _ref[_i];
      image.addToZipAsJS(zip);
      image.addToZipAsPNG(zip);
    }
    if (navigator.userAgent.search("Safari") >= 0 && navigator.userAgent.search("Chrome") < 0) {
      console.log("safari");
      return location.href = "data:application/zip;base64," + zip.generate({
        type: "base64"
      });
    } else {
      console.log("not safari");
      content = zip.generate({
        type: "blob"
      });
      return saveAs(content, "SystemTest_" + this.testName + ".zip");
    }
  };

  AutomatorRecorderAndPlayer.prototype.loadTest = function(testNumber, andThenDoThis) {
    var script;
    script = document.createElement('script');
    script.src = "js/tests/" + this.testsList()[testNumber] + "_automationCommands.js";
    script.onload = (function(_this) {
      return function() {
        return _this.loadImagesOfTest(testNumber, andThenDoThis);
      };
    })(this);
    return document.head.appendChild(script);
  };

  AutomatorRecorderAndPlayer.prototype.loadImagesOfTest = function(testNumber, andThenDoThis) {
    var eachAssetInManifest, eachCommand, pureImageName, script, _i, _j, _len, _len1, _ref, _ref1;
    _ref = window[(this.testsList()[testNumber]) + "_automationCommands"].automatorCommandsSequence;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      eachCommand = _ref[_i];
      if (eachCommand.screenShotImageName != null) {
        pureImageName = eachCommand.screenShotImageName;
        _ref1 = AutomatorRecorderAndPlayer.testsAssetsManifest;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          eachAssetInManifest = _ref1[_j];
          if (eachAssetInManifest.indexOf(pureImageName) !== -1) {
            script = document.createElement('script');

            /*
            systemInfo = new SystemTestsSystemInfo()
             * some devices have non-integer pixel ratios so
             * let's handle the dot there.
            pixelRatioString = (""+pixelRatio).replace(/\.+/g, "_")
            alert "js/tests/assets/" +
              systemInfo.os.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +
              systemInfo.osVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +
              systemInfo.browser.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +
              systemInfo.browserVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +
              "devicePixelRatio_" + pixelRatioString + "/" +
              eachAssetInManifest +
              ".js"
             */
            script.src = "js/tests/assets/" + eachAssetInManifest + ".js";
            document.head.appendChild(script);
          }
        }
      }
    }
    return setTimeout((function(_this) {
      return function() {
        return andThenDoThis();
      };
    })(this), 1000);
  };

  AutomatorRecorderAndPlayer.prototype.testsList = function() {
    var actualTestList, preselectionBeforeSplittingGroups;
    preselectionBeforeSplittingGroups = null;
    if (this.selectedTestsBasedOnTags.length !== 0) {
      preselectionBeforeSplittingGroups = this.selectedTestsBasedOnTags;
    } else {
      preselectionBeforeSplittingGroups = AutomatorRecorderAndPlayer.testsManifest;
    }
    console.log("tests list before partitioning and picking: " + preselectionBeforeSplittingGroups);
    console.log("tests list after partitioning and picking: " + preselectionBeforeSplittingGroups.chunk(Math.ceil(preselectionBeforeSplittingGroups.length / this.numberOfGroups))[this.groupToBeRun]);
    actualTestList = preselectionBeforeSplittingGroups.chunk(Math.ceil(preselectionBeforeSplittingGroups.length / this.numberOfGroups))[this.groupToBeRun];
    return actualTestList;
  };

  AutomatorRecorderAndPlayer.prototype.loadTestMetadata = function(testNumber, andThen) {
    var script;
    if (testNumber >= AutomatorRecorderAndPlayer.testsManifest.length) {
      andThen();
      return;
    }
    script = document.createElement('script');
    script.src = "js/tests/" + AutomatorRecorderAndPlayer.testsManifest[testNumber] + ".js";
    script.onload = (function(_this) {
      return function() {
        return _this.loadTestMetadata(testNumber + 1, andThen);
      };
    })(this);
    return document.head.appendChild(script);
  };

  AutomatorRecorderAndPlayer.prototype.loadTestsMetadata = function(andThen) {
    return this.loadTestMetadata(0, andThen);
  };

  AutomatorRecorderAndPlayer.prototype.runNextSystemTest = function() {
    this.indexOfSystemTestBeingPlayed++;
    if (this.indexOfSystemTestBeingPlayed >= this.testsList().length) {
      SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole("finished all tests");
      world.nextStartupAction();
      return;
    }
    return this.loadTest(this.indexOfSystemTestBeingPlayed, (function(_this) {
      return function() {
        SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole("playing test: " + _this.testsList()[_this.indexOfSystemTestBeingPlayed]);
        _this.automatorCommandsSequence = window[(_this.testsList()[_this.indexOfSystemTestBeingPlayed]) + "_automationCommands"].automatorCommandsSequence;
        return _this.startTestPlayingWithSlideIntro();
      };
    })(this));
  };

  AutomatorRecorderAndPlayer.prototype.selectTestsFromTagsOrTestNames = function(wantedTagsOrNamesArray) {
    var selectTheTestsBasedOnTags;
    console.log("selectTestsFromTagsOrTestNames");
    selectTheTestsBasedOnTags = (function(_this) {
      return function() {
        var eachTest, eachWantedTagOrName, _i, _j, _len, _len1, _ref;
        _this.selectedTestsBasedOnTags = [];
        _ref = AutomatorRecorderAndPlayer.testsManifest;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          eachTest = _ref[_i];
          for (_j = 0, _len1 = wantedTagsOrNamesArray.length; _j < _len1; _j++) {
            eachWantedTagOrName = wantedTagsOrNamesArray[_j];
            if (eachWantedTagOrName === "all") {
              if ((_this.selectedTestsBasedOnTags.indexOf(eachTest)) < 0) {
                _this.selectedTestsBasedOnTags.push(eachTest);
              }
              continue;
            }
            if (eachWantedTagOrName === eachTest) {
              if ((_this.selectedTestsBasedOnTags.indexOf(eachTest)) < 0) {
                _this.selectedTestsBasedOnTags.push(eachTest);
              }
              continue;
            }
            if ((window[eachTest].tags.indexOf(eachWantedTagOrName)) >= 0) {
              if ((_this.selectedTestsBasedOnTags.indexOf(eachTest)) < 0) {
                _this.selectedTestsBasedOnTags.push(eachTest);
              }
              continue;
            }
          }
        }
        return console.log(_this.selectedTestsBasedOnTags);
      };
    })(this);
    return this.loadTestsMetadata(selectTheTestsBasedOnTags);
  };

  AutomatorRecorderAndPlayer.prototype.runAllSystemTests = function() {
    var actuallyRunTheTests;
    console.log("runAllSystemTests");
    this.millisOfAllTestsSoFar = 0;
    actuallyRunTheTests = (function(_this) {
      return function() {
        var actualTestList, eachTest, _i, _len;
        actualTestList = _this.testsList();
        _this.allTestsDuration = 0;
        for (_i = 0, _len = actualTestList.length; _i < _len; _i++) {
          eachTest = actualTestList[_i];
          _this.allTestsDuration += window["" + eachTest].testDuration;
        }
        _this.playingAllSystemTests = true;
        _this.indexOfSystemTestBeingPlayed = -1;
        return _this.runNextSystemTest();
      };
    })(this);
    this.loadTestsMetadata(actuallyRunTheTests);
    return console.log("Running system tests: " + this.testsList());
  };

  AutomatorRecorderAndPlayer.coffeeScriptSourceOfThisClass = '# REQUIRES SystemTestsReferenceImage\n# REQUIRES SystemTestsSystemInfo\n# REQUIRES globalFunctions\n\n# How to load/play a test:\n# from the Chrome console (Option-Command-J) OR Safari console (Option-Command-C):\n# window.world.systemTestsRecorderAndPlayer.automatorCommandsSequence = NAMEOFTHETEST.automatorCommandsSequence\n# (e.g. window.world.systemTestsRecorderAndPlayer.automatorCommandsSequence = SystemTest_attachRectangleToPartsOfInspector.automatorCommandsSequence )\n# window.world.systemTestsRecorderAndPlayer.startTestPlayingWithSlideIntro()\n\n# How to inspect the screenshot differences:\n# after having played a test with some failing screenshots\n# comparisons:\n# from the Chrome console (Option-Command-J) OR Safari console (Option-Command-C):\n# window.world.systemTestsRecorderAndPlayer.saveFailedScreenshots()\n# it will save a zip file containing three files for each failure:\n# 1) the png of the obtained screenshot (different from the expected)\n# 2) the .js file containing the data for the obtained screenshot\n# (in case it\'s OK and should be added to the "good screenshots")\n# 3) a .png file highlighting the differences in red.\n\n# How to record a test:\n# window.world.systemTestsRecorderAndPlayer.startTestRecording(\'nameOfTheTest\')\n# ...do the test...\n# window.world.systemTestsRecorderAndPlayer.stopTestRecording()\n# if you want to verify the test on the spot:\n# window.world.systemTestsRecorderAndPlayer.startTestPlayingWithSlideIntro()\n\n# For recording screenshot data at any time -\n# can be used for screenshot comparisons during the test:\n# window.world.systemTestsRecorderAndPlayer.takeScreenshot()\n\n# How to save the test:\n# window.world.systemTestsRecorderAndPlayer.saveTest()\n# The created zip will contain both the test and the\n# related reference images.\n\n# What to do with the saved zip file:\n# These files inside the zip package need to be added\n# to the\n#   ./src/tests directory\n# Then the project will need to be recompiled.\n# At this point the\n#   ./build/indexWithTests.html\n# page will automatically load all the tests and\n# images. See "how to load/play a test" above\n# to read how to load and play a test.\n\nclass AutomatorRecorderAndPlayer\n  automatorCommandsSequence: []\n  @RECORDING: 0\n  @PLAYING: 1\n  @IDLE: 2\n  @state: 2\n  playingAllSystemTests: false\n  indexOfSystemTestBeingPlayed: 0\n  timeOfPreviouslyRecordedCommand: null\n  handMorph: null\n  worldMorph: null\n  collectedImages: [] # array of SystemTestsReferenceImage\n  collectedFailureImages: [] # array of SystemTestsReferenceImage\n  testName: \'\'\n  testDescription: \'no description\'\n  testTags: [\'noTags\']\n  @loadedImages: {}\n  @loadedImagesToBeKeptForLaterDiff: {}\n  ongoingTestPlayingTask: null\n  timeOfPreviouslyPlayedCommand: 0\n  indexOfTestCommandBeingPlayedFromSequence: 0\n\n  @animationsPacingControl: false\n  @alignmentOfMorphIDsMechanism: false\n  @hidingOfMorphsGeometryInfoInLabels: false\n  @hidingOfMorphsNumberIDInLabels: false\n  @hidingOfMorphsContentExtractInLabels: false\n\n  # this is a special place where the\n  # "take pic" command places the image\n  # data of a morph.\n  # the test player will wait for this data\n  # before doing the comparison.\n  imageDataOfAParticularMorph: null\n  lastMouseDownCommand: null\n  lastMouseUpCommand: null\n  selectedTestsBasedOnTags: []\n\n  numberOfGroups: 1\n  groupToBeRun: 0\n\n  atLeastOneTestHasBeenRun: false\n  allTestsPassedSoFar: true\n\n  testDuration: 0\n  allTestsDuration: 0\n  millisOfTestSoFar: 0\n  millisOfAllTestsSoFar: 0\n\n  currentlyPlayingTestName: ""\n\n  tagsCollectedWhileRecordingTest: []\n\n  constructor: (@worldMorph, @handMorph) ->\n\n  clearCommandSeqAndImagesRelatedToTest: (testName) ->\n    # we assume that no-one is going to\n    # write a tests with more than\n    # 100 reference images/screenshots\n    for imageNumber in [0...100]\n      # each of these is an array that could contain\n      # multiple screenshots for different browser/os\n      # configuration, we are clearing the variable\n      # containing the array\n      console.log "deleting #{testName}_image_#{imageNumber}"\n      delete AutomatorRecorderAndPlayer.loadedImages["#{testName}_image_#{imageNumber}"]\n    console.log "deleting SystemTest_#{testName}"\n    window["#{testName}" + "_automationCommands"] = null\n    delete window["#{testName}" + "_automationCommands"]\n\n  # clear any test with the same name\n  # that might be loaded\n  # and all the images related to it\n  clearAnyDataRelatedToTest: (testName) ->\n    # we assume that no-one is going to\n    # write a tests with more than\n    # 100 reference images/screenshots\n    @clearCommandSeqAndImagesRelatedToTest testName\n    delete window["#{testName}"]\n  \n  startTestRecording: (ignored, ingnored2, @testName, @testDescription, @testTags) ->\n    # if test name not provided, then\n    # prompt the user for it\n    if not @testName?\n      @testName = prompt("Please enter a test name", "test1")\n    if not @testDescription?\n      @testDescription = prompt("Please enter a test description", "no description")\n    if not @testTags?\n      @testTags = prompt("Please enter test tags separated by commas", "noTags")\n      @testTags = @testTags.replace(/[ ]+/g, "")\n      @testTags = @testTags.split(",");\n\n    # if you choose the same name\n    # of a previously loaded tests,\n    # confusing things might happen such\n    # as comparison with loaded screenshots\n    # so we want to clear the data related\n    # to the chosen name\n    @clearAnyDataRelatedToTest @testName\n\n    @automatorCommandsSequence = []\n    @tagsCollectedWhileRecordingTest = []\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n    AutomatorRecorderAndPlayer.state = AutomatorRecorderAndPlayer.RECORDING\n\n  stopTestRecording: ->\n    AutomatorRecorderAndPlayer.state = AutomatorRecorderAndPlayer.IDLE\n\n\n  # gonna use this in a callback so need\n  # to make this one a double-arrow\n  stopTestPlaying: ->\n    SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.stopTestRec)\n    console.log "wrapping up the playing of the test"\n    \n    # seems that if focus is on canvas\n    # then updates to DOM get coalesced so\n    # much that the highlights/flashed\n    # on the test console are super-late\n    # or completely lost. So we need to\n    # temporarily remove the tab index at\n    # the start of the test and then\n    # put it back when the test playing is\n    # complete\n    world.worldCanvas.tabIndex = "1"\n\n    fade(\'singleTestProgressIndicator\', 1, 0, 10, new Date().getTime());\n    fade(\'singleTestProgressBarWrap\', 1, 0, 10, new Date().getTime());\n    fade(\'allTestsProgressIndicator\', 1, 0, 10, new Date().getTime());\n    fade(\'allTestsProgressBarWrap\', 1, 0, 10, new Date().getTime());\n    fade(\'numberOfTestsDoneIndicator\', 1, 0, 10, new Date().getTime());\n\n\n    SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole "test complete"\n    AutomatorRecorderAndPlayer.state = AutomatorRecorderAndPlayer.IDLE\n\n    # hide indicator of mouse pointer\n    mousePointerIndicator = document.getElementById(\'mousePointerIndicator\')\n    mousePointerIndicator.style.display = \'none\'\n    \n    # There is a background interval that polls\n    # to check whether it\'s time/condition to play\n    # the next queued command. Remove it.\n    indexOfTask = @worldMorph.otherTasksToBeRunOnStep.indexOf(@ongoingTestPlayingTask)\n    @worldMorph.otherTasksToBeRunOnStep.splice(indexOfTask, 1)\n    @worldMorph.initEventListeners()\n    \n    @indexOfTestCommandBeingPlayedFromSequence = 0\n    @clearCommandSeqAndImagesRelatedToTest @testsList()[@indexOfSystemTestBeingPlayed]\n\n    if @playingAllSystemTests\n      @runNextSystemTest()\n\n  showTestSource: ->\n    window.open("data:text/text;charset=utf-8," + encodeURIComponent(JSON.stringify( @automatorCommandsSequence, null, 4 )))\n\n  turnOnAnimationsPacingControl: ->\n    @constructor.animationsPacingControl = true\n    SystemTestsControlPanelUpdater.highlightOnLink SystemTestsControlPanelUpdater.tieAnimations\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOnAnimationsPacingControl @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n\n  turnOffAnimationsPacingControl: ->\n    @constructor.animationsPacingControl = false\n    SystemTestsControlPanelUpdater.highlightOffLink SystemTestsControlPanelUpdater.tieAnimations\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOffAnimationsPacingControl @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n\n  turnOnAlignmentOfMorphIDsMechanism: ->\n    @constructor.alignmentOfMorphIDsMechanism = true\n    SystemTestsControlPanelUpdater.highlightOnLink SystemTestsControlPanelUpdater.alignMorphIDs\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOnAlignmentOfMorphIDsMechanism @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOffAlignmentOfMorphIDsMechanism: ->\n    @constructor.alignmentOfMorphIDsMechanism = false\n    SystemTestsControlPanelUpdater.highlightOffLink SystemTestsControlPanelUpdater.alignMorphIDs\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOffAlignmentOfMorphIDsMechanism @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOnHidingOfMorphsGeometryInfoInLabels: ->\n    @constructor.hidingOfMorphsGeometryInfoInLabels = true\n    SystemTestsControlPanelUpdater.highlightOnLink SystemTestsControlPanelUpdater.hideGeometry\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOnHidingOfMorphsGeometryInfoInLabels @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOffHidingOfMorphsGeometryInfoInLabels: ->\n    @constructor.hidingOfMorphsGeometryInfoInLabels = false\n    SystemTestsControlPanelUpdater.highlightOffLink SystemTestsControlPanelUpdater.hideGeometry\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOffHidingOfMorphsGeometryInfoInLabels @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOnHidingOfMorphsContentExtractInLabels: ->\n    @constructor.hidingOfMorphsContentExtractInLabels = true\n    SystemTestsControlPanelUpdater.highlightOnLink SystemTestsControlPanelUpdater.hideMorphContentExtracts\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOnHidingOfMorphsContentExtractInLabels @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOffHidingOfMorphsContentExtractInLabels: ->\n    @constructor.hidingOfMorphsContentExtractInLabels = false\n    SystemTestsControlPanelUpdater.highlightOffLink SystemTestsControlPanelUpdater.hideMorphContentExtracts\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOffHidingOfMorphsContentExtractInLabels @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOnHidingOfMorphsNumberIDInLabels: ->\n    @constructor.hidingOfMorphsNumberIDInLabels = true\n    SystemTestsControlPanelUpdater.highlightOnLink SystemTestsControlPanelUpdater.hideMorphIDs\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOnHidingOfMorphsNumberIDInLabels @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOffHidingOfMorphsNumberIDInLabels: ->\n    @constructor.hidingOfMorphsNumberIDInLabels = false\n    SystemTestsControlPanelUpdater.highlightOffLink SystemTestsControlPanelUpdater.hideMorphIDs\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOffHidingOfMorphsNumberIDInLabels @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n\n  addMouseMoveCommand: (pageX, pageY, floatDraggingSomething) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandMouseMove pageX, pageY, floatDraggingSomething, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addMouseChangeCommand: (upOrDown, button, ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandMouseButtonChange upOrDown, button, ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph, @\n    @lastMouseDownCommand = systemTestCommand\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addMouseClickCommand: (button, ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandMouseClick button, ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph, @\n    @lastMouseDownCommand = systemTestCommand\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  # note that we give for granted that double click\n  # is always on the left button\n  addMouseDoubleClickCommand: (ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandMouseDoubleClick ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph, @\n    @lastMouseDownCommand = systemTestCommand\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n\n  addOpenContextMenuCommand: (context) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    #@removeLastMouseUpAndMouseDownCommands()\n    systemTestCommand = new AutomatorCommandOpenContextMenu context, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addCommandLeftOrRightClickOnMenuItem: (mouseButton, labelString, occurrenceNumber) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    #@removeLastMouseUpAndMouseDownCommands()\n    systemTestCommand = new AutomatorCommandLeftOrRightClickOnMenuItem mouseButton, labelString, occurrenceNumber, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  # doesn\'t *actually* remove the command\n  # because you do need to wait the time.\n  # because for example the bubbles pop-up\n  # after some time.\n  # You could remove the commands and note down\n  # how much was the wait on each and charge it to\n  # the next command but that would be very messy.\n  #removeLastMouseUpAndMouseDownCommands: ->\n  #  @lastMouseDownCommand.transformIntoDoNothingCommand()\n  #  @lastMouseUpCommand.transformIntoDoNothingCommand()\n\n  addKeyPressCommand: (charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandKeyPress charCode, symbol, shiftKey, ctrlKey, altKey, metaKey, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addKeyDownCommand: (scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandKeyDown scanCode, shiftKey, ctrlKey, altKey, metaKey, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addKeyUpCommand: (scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandKeyUp scanCode, shiftKey, ctrlKey, altKey, metaKey, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addCopyCommand: () ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandCopy @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addPasteCommand: (clipboardText) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandPaste clipboardText, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addGrabCommand: ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandGrab @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addDropCommand: ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandDrop @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  resetWorld: ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandResetWorld @\n    window[systemTestCommand.automatorCommandName].replayFunction @, null\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addTestComment: ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    # note how we take the time before we prompt the\n    # user so we can show the message sooner when playing\n    # the test - i.e. the message will appear at the time\n    # the user got the prompt window rather than when she\n    # actually wrote the message...\n    # So we anticipate the message so the user can actually have\n    # the time to read it before the test moves on with the\n    # next steps.\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n    comment = prompt("enter comment", "your comment here")\n    systemTestCommand = new AutomatorCommandShowComment comment, @\n    @automatorCommandsSequence.push systemTestCommand\n\n  checkStringsOfItemsInMenuOrderImportant: (stringOfItemsInMenuInOriginalOrder) ->\n    SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.checkMenuEntriesInOrder)\n    @checkStringsOfItemsInMenu(stringOfItemsInMenuInOriginalOrder, true)\n\n  checkStringsOfItemsInMenuOrderUnimportant: (stringOfItemsInMenuInOriginalOrder) ->\n    SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.checkMenuEntriesNotInOrder)\n    @checkStringsOfItemsInMenu(stringOfItemsInMenuInOriginalOrder, false)\n\n  checkStringsOfItemsInMenu: (stringOfItemsInMenuInOriginalOrder, orderMatters) ->\n    console.log "checkStringsOfItemsInMenu"\n    menuAtPointer = @handMorph.menuAtPointer()\n    console.log menuAtPointer\n\n    stringOfItemsInCurrentMenuInOriginalOrder = []\n\n    if menuAtPointer?\n      for eachMenuItem in menuAtPointer.items\n        stringOfItemsInCurrentMenuInOriginalOrder.push eachMenuItem[0]\n    else\n      errorMessage = "FAIL was expecting a menu under the pointer"\n      console.log errorMessage\n      @allTestsPassedSoFar = false\n      document.getElementById("background").style.background = "red"\n      if SystemTestsControlPanelUpdater?\n        SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole errorMessage\n      @stopTestPlaying()\n\n    if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n      if orderMatters\n        systemTestCommand = new AutomatorCommandCheckStringsOfItemsInMenuOrderImportant stringOfItemsInCurrentMenuInOriginalOrder, @\n      else\n        systemTestCommand = new AutomatorCommandCheckStringsOfItemsInMenuOrderUnimportant stringOfItemsInCurrentMenuInOriginalOrder, @\n\n      @automatorCommandsSequence.push systemTestCommand\n      @timeOfPreviouslyRecordedCommand = new Date().getTime()\n    else if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      giveSuccess = =>\n        if orderMatters\n          message = "PASS Strings in menu are same and in same order"\n        else\n          message = "PASS Strings in menu are same (not considering order)"\n        if SystemTestsControlPanelUpdater?\n          SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole message\n      giveError = =>\n        if orderMatters\n          @allTestsPassedSoFar = false\n          document.getElementById("background").style.background = "red"\n          errorMessage = "FAIL Strings in menu doesn\'t match or order is incorrect. Was expecting: " + stringOfItemsInMenuInOriginalOrder + " found: " + stringOfItemsInCurrentMenuInOriginalOrder\n        else\n          @allTestsPassedSoFar = false\n          document.getElementById("background").style.background = "red"\n          errorMessage = "FAIL Strings in menu doesn\'t match (even not considering order). Was expecting: " + stringOfItemsInMenuInOriginalOrder + " found: " + stringOfItemsInCurrentMenuInOriginalOrder\n        if SystemTestsControlPanelUpdater?\n          SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole errorMessage\n        @stopTestPlaying()\n      \n      menuListIsSame = true\n\n      # the reason why we make a copy here is the following:\n      # if you kept the original array then this could happen:\n      # you record a test and then you play it back and then you save it\n      # the array is always the same and could get mutated during the play\n      # (because it could be sorted). So when you save the test, you\n      # save the ordered array instead of the original.\n      copyOfstringOfItemsInMenuInOriginalOrder = arrayShallowCopy(stringOfItemsInMenuInOriginalOrder)\n\n      # if the order doesn\'t matter then we need to\n      # sort the strings first so we compare regardless\n      # of the original order\n      if !orderMatters\n        stringOfItemsInCurrentMenuInOriginalOrder.sort()\n        copyOfstringOfItemsInMenuInOriginalOrder.sort()\n\n      if stringOfItemsInCurrentMenuInOriginalOrder.length == copyOfstringOfItemsInMenuInOriginalOrder.length\n        for itemNumber in [0...copyOfstringOfItemsInMenuInOriginalOrder.length]\n          if copyOfstringOfItemsInMenuInOriginalOrder[itemNumber] != stringOfItemsInCurrentMenuInOriginalOrder[itemNumber]\n            menuListIsSame = false\n            console.log copyOfstringOfItemsInMenuInOriginalOrder[itemNumber] + " != " + stringOfItemsInCurrentMenuInOriginalOrder[itemNumber] + " at " + itemNumber\n      else\n        menuListIsSame = false\n\n      if menuListIsSame\n        giveSuccess()\n      else\n        giveError()\n\n  checkNumberOfItemsInMenu: (numberOfItems) ->\n    SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.checkNumnberOfItems)\n    if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n      menuAtPointer = @handMorph.menuAtPointer()\n      console.log menuAtPointer\n      if menuAtPointer?\n        numberOfItems = menuAtPointer.items.length\n        console.log "found " + numberOfItems + " number of items "\n      else\n        console.log "was expecting a menu under the pointer"\n        numberOfItems = 0\n      systemTestCommand = new AutomatorCommandCheckNumberOfItemsInMenu numberOfItems, @\n      @automatorCommandsSequence.push systemTestCommand\n      @timeOfPreviouslyRecordedCommand = new Date().getTime()\n    else if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      menuAtPointer = @handMorph.menuAtPointer()\n      giveSuccess = =>\n        message = "PASS Number of items in menu matches. Note that count includes line separators. Found: " + menuAtPointer.items.length\n        if SystemTestsControlPanelUpdater?\n          SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole message\n      giveError = =>\n        @allTestsPassedSoFar = false\n        document.getElementById("background").style.background = "red"\n        errorMessage = "FAIL Number of items in menu doesn\'t match. Note that count includes line separators. Was expecting: " + numberOfItems + " found: " + menuAtPointer.items.length\n        if SystemTestsControlPanelUpdater?\n          SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole errorMessage\n        @stopTestPlaying()\n      if menuAtPointer?\n        if numberOfItems != menuAtPointer.items.length\n          giveError()\n        else\n          giveSuccess()\n      else\n          giveError()\n\n  takeScreenshot: (whichMorph = @worldMorph) ->\n    console.log "taking screenshot"\n    imageName = "SystemTest_"+@testName+"_image_" + (@collectedImages.length + 1)\n    systemTestCommand = new AutomatorCommandScreenshot imageName, @, whichMorph != @worldMorph\n\n    imageData = whichMorph.asItAppearsOnScreen()\n\n    takenScreenshot = new SystemTestsReferenceImage(imageName,imageData, new SystemTestsSystemInfo())\n    unless AutomatorRecorderAndPlayer.loadedImages["#{imageName}"]?\n      AutomatorRecorderAndPlayer.loadedImages["#{imageName}"] = []\n    AutomatorRecorderAndPlayer.loadedImages["#{imageName}"].push takenScreenshot\n    @collectedImages.push takenScreenshot\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n      return systemTestCommand\n\n  # a lenghty method because there\n  # is a lot of API dancing, but the\n  # concept is really easy: return\n  # a new canvas with an image that is\n  # red in all areas where the\n  # "expected" and "obtained" images\n  # are different.\n  # So it neatly highlights where the differences\n  # are.\n  subtractScreenshots: (expected, obtained, diffNumber, andThen) ->\n    console.log "subtractScreenshots"\n    expectedCanvas = document.createElement "canvas"\n    expectedImage = new Image\n    # unfortunately the operation of loading\n    # the base64 data into the image is asynchronous\n    # (seems to work immediately in Chrome but it\'s\n    # recommended to consider it asynchronous)\n    # so here we need to chain two callbacks\n    # to make it all work, as we need to load\n    # two such images.\n    expectedImage.onload = =>\n      console.log "expectedCanvas.imageData: " + expectedCanvas.imageData\n      expectedCanvas.width = expectedImage.width\n      expectedCanvas.height = expectedImage.height\n      expectedCanvasContext = expectedCanvas.getContext "2d"\n      console.log "expectedCanvas.width: " + expectedCanvas.width\n      console.log "expectedCanvas.height: " + expectedCanvas.height\n      expectedCanvasContext.drawImage(expectedImage,0,0)\n      expectedImageData = expectedCanvasContext.getImageData(0, 0, expectedCanvas.width, expectedCanvas.height)\n\n      obtainedCanvas = document.createElement "canvas"\n      obtainedImage = new Image\n      obtainedImage.onload = =>\n        obtainedCanvas.width = obtainedImage.width\n        obtainedCanvas.height = obtainedImage.height\n        obtainedCanvasContext = obtainedCanvas.getContext "2d"\n        obtainedCanvasContext.drawImage(obtainedImage,0,0)\n        obtainedImageData = obtainedCanvasContext.getImageData(0, 0, obtainedCanvas.width, obtainedCanvas.height)\n\n        subtractionCanvas = document.createElement "canvas"\n        subtractionCanvas.width = obtainedImage.width\n        subtractionCanvas.height = obtainedImage.height\n        subtractionCanvasContext = subtractionCanvas.getContext("2d")\n        subtractionCanvasContext.drawImage(obtainedImage,0,0)\n        subtractionImageData = subtractionCanvasContext.getImageData(0, 0, subtractionCanvas.width, subtractionCanvas.height)\n\n        i = 0\n        equalPixels = 0\n        differentPixels = 0\n\n        while i < subtractionImageData.data.length\n          if obtainedImageData.data[i] != expectedImageData.data[i] or\n             obtainedImageData.data[i+1] != expectedImageData.data[i+1] or\n             obtainedImageData.data[i+2] != expectedImageData.data[i+2]\n            subtractionImageData.data[i] = 255\n            subtractionImageData.data[i+1] = 0\n            subtractionImageData.data[i+2] = 0\n            differentPixels++\n          else\n            equalPixels++\n          i += 4\n        console.log "equalPixels: " + equalPixels\n        console.log "differentPixels: " + differentPixels\n        subtractionCanvasContext.putImageData subtractionImageData, 0, 0\n        #errorRatio = Math.ceil((differentPixels/(equalPixels+differentPixels))*1000)\n        errorRatio = differentPixels\n        andThen subtractionCanvas, expected, errorRatio, diffNumber\n\n      obtainedImage.src = obtained.imageData\n\n    expectedImage.src = expected.imageData\n\n  compareScreenshots: (testNameWithImageNumber, screenshotTakenOfAParticularMorph = false) ->\n   SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.takeScreenshot)\n\n   if screenshotTakenOfAParticularMorph\n     console.log "comparing pic of a particular morph"\n     # todo this seems broken, this image data is not\n     # actually fetched anywhere?\n     screenshotObtained = @imageDataOfAParticularMorph\n     @imageDataOfAParticularMorph = null\n   else\n     console.log "comparing pic of whole desktop"\n     screenshotObtained = @worldMorph.asItAppearsOnScreen()\n   \n   console.log "trying to match screenshot: " + testNameWithImageNumber\n   console.log "length of obtained: " + screenshotObtained.length\n\n   # There can be multiple files for the same image, since\n   # the images vary according to OS and Browser, so for\n   # each image of each test there is an array of candidates\n   # to be checked. If any of them matches in terms of pixel data,\n   # then fine, otherwise complain...\n   #\n   # in "loadedImagesToBeKeptForLaterDiff" we keep the images\n   # related to the failed tests. If we don\'t keep those\n   # in this reference, they are disposed of and garbage collected\n   # since they are quite big and they accumulate.\n   AutomatorRecorderAndPlayer.loadedImagesToBeKeptForLaterDiff["#{testNameWithImageNumber}"] = AutomatorRecorderAndPlayer.loadedImages["#{testNameWithImageNumber}"]\n   for eachImage in AutomatorRecorderAndPlayer.loadedImages["#{testNameWithImageNumber}"]\n     console.log "length of obtained: " + eachImage.imageData.length\n     if eachImage.imageData == screenshotObtained\n      message = "PASS - screenshot " + eachImage.fileName + " matched"\n      AutomatorRecorderAndPlayer.loadedImagesToBeKeptForLaterDiff["#{testNameWithImageNumber}"] = null\n      delete AutomatorRecorderAndPlayer.loadedImagesToBeKeptForLaterDiff["#{testNameWithImageNumber}"]\n      console.log message\n      if SystemTestsControlPanelUpdater?\n        SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole message\n      return\n   # OK none of the images we loaded matches the one we\n   # just took. Hence create a SystemTestsReferenceImage\n   # that we can let the user download - it will contain\n   # the image actually obtained (rather than the one\n   # we should have seen)\n   message = "FAIL - no screenshots like this one"\n   console.log message\n   @allTestsPassedSoFar = false\n   document.getElementById("background").style.background = "red"\n   if SystemTestsControlPanelUpdater?\n     SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole message\n   obtainedImageName = "obtained-" + eachImage.imageName\n   obtainedImage = new SystemTestsReferenceImage(obtainedImageName,screenshotObtained, new SystemTestsSystemInfo())\n   @collectedFailureImages.push obtainedImage\n\n  replayTestCommands: ->\n   commandToBePlayed = @automatorCommandsSequence[@indexOfTestCommandBeingPlayedFromSequence]\n   # console.log "examining command: " + commandToBePlayed.automatorCommandName + " at: " + commandToBePlayed.millisecondsSincePreviousCommand +\n   #   " time now: " + timeNow + " we are at: " + (timeNow - @timeOfPreviouslyPlayedCommand)\n\n\n\n   # for the screenshot, the replay is going\n   # to consist in comparing the image data.\n   # in case the screenshot is made of the entire world\n   # then the comparison can happen now.\n   # in case the screenshot is made of a particular\n   # morph then we want to wait that the world\n   # has taken that screenshot image data and put\n   # it in here.\n   # search for imageDataOfAParticularMorph everywhere\n   # to see where the image data is created and\n   # put there.\n   if commandToBePlayed.automatorCommandName == "AutomatorCommandScreenshot" and commandToBePlayed.screenshotTakenOfAParticularMorph\n     if not @imageDataOfAParticularMorph?\n       # no image data of morph, so just wait\n       return\n\n   #if commandToBePlayed.automatorCommandName == "AutomatorCommandScreenshot"\n   # @automatorCommandsSequence[@indexOfTestCommandBeingPlayedFromSequence + 1].millisecondsSincePreviousCommand = 0\n   # debugger\n\n   runCurrentCommandImmediately = false\n   if window["#{@currentlyPlayingTestName}"].maxSpeedupFactor > 1\n     if (@indexOfTestCommandBeingPlayedFromSequence >= 1) and\n      (@indexOfTestCommandBeingPlayedFromSequence < (@automatorCommandsSequence.length - 2))\n        consecutiveMouseMoves = 0\n        while true\n          previousCommand1 = @automatorCommandsSequence[@indexOfTestCommandBeingPlayedFromSequence - 1]\n          commandToBePlayed = @automatorCommandsSequence[@indexOfTestCommandBeingPlayedFromSequence]\n          nextCommand1 = @automatorCommandsSequence[@indexOfTestCommandBeingPlayedFromSequence + 1]\n          nextCommand2 = @automatorCommandsSequence[@indexOfTestCommandBeingPlayedFromSequence + 2]\n          if previousCommand1.automatorCommandName == "AutomatorCommandMouseMove" and\n           nextCommand1.automatorCommandName == "AutomatorCommandMouseMove" and\n           nextCommand2.automatorCommandName == "AutomatorCommandMouseMove" and\n           commandToBePlayed.automatorCommandName == "AutomatorCommandMouseMove"\n            consecutiveMouseMoves++\n            #if (consecutiveMouseMoves % window["#{@currentlyPlayingTestName}"].maxSpeedupFactor) != 0\n            #if (consecutiveMouseMoves % 6) != 0\n            if (consecutiveMouseMoves % 10000) != 0\n              timeUntilNextCommand = commandToBePlayed.millisecondsSincePreviousCommand or 0\n              @millisOfTestSoFar += timeUntilNextCommand\n              @millisOfAllTestsSoFar += timeUntilNextCommand\n              console.log ">>>>>> skipping mousemove"\n              @indexOfTestCommandBeingPlayedFromSequence++\n            else\n              runCurrentCommandImmediately = true\n              break\n          else\n            runCurrentCommandImmediately = true\n            break\n\n\n   timeNow = (new Date()).getTime()\n   timeUntilNextCommand = commandToBePlayed.millisecondsSincePreviousCommand or 0\n   \n   if runCurrentCommandImmediately or (timeNow - @timeOfPreviouslyPlayedCommand >= timeUntilNextCommand)\n\n     console.log ">>>>>> doing "  + commandToBePlayed.automatorCommandName\n\n     @millisOfTestSoFar += timeUntilNextCommand\n     @millisOfAllTestsSoFar += timeUntilNextCommand\n\n     #console.log "running command: " + commandToBePlayed.automatorCommandName + " " + @indexOfTestCommandBeingPlayedFromSequence + " / " + @automatorCommandsSequence.length + " ms: " + @millisOfTestSoFar + " / " + @testDuration\n     window[commandToBePlayed.automatorCommandName].replayFunction.call @,@,commandToBePlayed\n\n     document.getElementById(\'singleTestProgressIndicator\').innerHTML = "Test " + Math.floor((@millisOfTestSoFar / @testDuration)*100) + "%" + " complete"\n     document.getElementById(\'singleTestProgressBar\').style.left =  (Math.floor((@millisOfTestSoFar / @testDuration)*100)) + "%"\n\n     document.getElementById(\'allTestsProgressIndicator\').innerHTML = "overall: " + Math.floor((@millisOfAllTestsSoFar / @allTestsDuration)*100) + "%" + " complete"\n     document.getElementById(\'allTestsProgressBar\').style.left =  (Math.floor((@millisOfAllTestsSoFar / @allTestsDuration)*100)) + "%"\n\n     @timeOfPreviouslyPlayedCommand = timeNow\n     @indexOfTestCommandBeingPlayedFromSequence++\n     if @indexOfTestCommandBeingPlayedFromSequence == @automatorCommandsSequence.length\n       console.log "stopping the test player"\n       @stopTestPlaying()\n\n  calculateTotalTimeOfThisTest: ->\n    testDuration = 0\n    for eachCommand in @automatorCommandsSequence\n      if eachCommand.millisecondsSincePreviousCommand?\n        testDuration += eachCommand.millisecondsSincePreviousCommand\n    @testDuration = testDuration\n\n  startTestPlaying: ->\n\n    # seems that if focus is on canvas\n    # then updates to DOM get coalesced so\n    # much that the highlights/flashed\n    # on the test console are super-late\n    # or completely lost. So we need to\n    # temporarily remove the tab index at\n    # the start of the test and then\n    # put it back when the test playing is\n    # complete\n    world.worldCanvas.tabIndex = "-1"\n\n    AutomatorRecorderAndPlayer.state = AutomatorRecorderAndPlayer.PLAYING\n    @atLeastOneTestHasBeenRun = true\n    @constructor.animationsPacingControl = true\n    @worldMorph.removeEventListeners()\n\n    @currentlyPlayingTestName = @testsList()[@indexOfSystemTestBeingPlayed]\n    if window["#{@currentlyPlayingTestName}"]?\n      @testDuration = window["#{@currentlyPlayingTestName}"].testDuration\n\n    @millisOfTestSoFar = 0\n    @ongoingTestPlayingTask = (=> @replayTestCommands())\n    @worldMorph.otherTasksToBeRunOnStep.push @ongoingTestPlayingTask\n\n    document.getElementById(\'numberOfTestsDoneIndicator\').innerHTML = "test " + (@indexOfSystemTestBeingPlayed + 1) + " of " + @testsList().length\n\n\n  startTestPlayingWithSlideIntro: ->\n    @startTestPlaying()\n    @setUpIntroSlide()\n\n  setUpIntroSlide: ->\n    fade(\'singleTestProgressIndicator\', 0, 1, 10, new Date().getTime());\n    fade(\'singleTestProgressBarWrap\', 0, 1, 10, new Date().getTime());\n    fade(\'allTestsProgressIndicator\', 0, 1, 10, new Date().getTime());\n    fade(\'allTestsProgressBarWrap\', 0, 1, 10, new Date().getTime());\n    fade(\'numberOfTestsDoneIndicator\', 0, 1, 10, new Date().getTime());\n\n    fade(\'testTitleAndDescription\', 0, 1, 10, new Date().getTime());\n\n    presentableTestName = @currentlyPlayingTestName.replace(/SystemTest_/g, "")\n    presentableTestName = decamelize presentableTestName, " "\n    presentableTestName = presentableTestName.charAt(0).toUpperCase() + presentableTestName.slice(1)\n    presentableTestName = \'"\' + presentableTestName + \'"\'\n    testTitleAndDescription.innerHTML =  presentableTestName\n    testTitleAndDescription.innerHTML = testTitleAndDescription.innerHTML + "<br><br><small>(#{@currentlyPlayingTestName})</small>"\n    testTitleAndDescription.innerHTML = testTitleAndDescription.innerHTML + "<br><br><small>" + window["#{@currentlyPlayingTestName}"].description + "</small>"\n    setTimeout =>\n        fade(\'testTitleAndDescription\', 1, 0, 2000, new Date().getTime());        \n      , 4000\n\n\n  testMetadataFileContentCreator: ->\n    # these here below is just one string\n    # spanning multiple lines, which\n    # includes the testName and commands\n    # in the right places.\n\n    testToBeSerialized = {}\n    testToBeSerialized.timeRecorded = new Date()\n    testToBeSerialized.description = @testDescription\n    testToBeSerialized.tags = @testTags.concat @tagsCollectedWhileRecordingTest\n    testToBeSerialized.systemInfo = new SystemTestsSystemInfo()\n    @calculateTotalTimeOfThisTest()\n    testToBeSerialized.testDuration = @testDuration\n\n    """\n  // This Automator file is automatically\n  // created.\n  // If this is a test,\n  // this file (and related reference images)\n  // can be copied in the /src/tests folder\n  // to make them available in the testing\n  // environment.\n  var SystemTest_#{@testName};\n\n  SystemTest_#{@testName} = #{JSON.stringify(testToBeSerialized, null, 4)};\n    """\n\n  automatorCommandsFileContentCreator: (commands) ->\n    # these here below is just one string\n    # spanning multiple lines, which\n    # includes the testName and commands\n    # in the right places.\n\n    testToBeSerialized = {}\n    testToBeSerialized.automatorCommandsSequence = commands\n    testNameExtended = @testName + "_automationCommands"\n\n    """\n  // This Automator file is automatically\n  // created.\n  // It this is a test,\n  // this file (and related reference images)\n  // can be copied in the /src/tests folder\n  // to make them available in the testing\n  // environment.\n  var SystemTest_#{testNameExtended};\n\n  SystemTest_#{testNameExtended} = #{JSON.stringify(testToBeSerialized, null, 4)};\n    """\n\n  saveFailedScreenshots: ->\n    zip = new JSZip()\n    \n    AutomatorRecorderAndPlayer.loadedImages = AutomatorRecorderAndPlayer.loadedImagesToBeKeptForLaterDiff\n\n    # debugger\n    # save all the images, each as a .png and .js file\n    # the png is for quick browsing, while the js contains\n    # the pixel data and the metadata of which configuration\n    # the picture was recorded with.\n    # (we expect the screenshots to be different across\n    # browsers and OSs)\n    # Note that the .js files are saved so the content\n    # doesn\'t contain "obtained-" anywhere in metadata\n    # (as it should, in theory) so that, if the\n    # screenshot is good, the file can just be\n    # renamed and moved together with the "good"\n    # screenshots.\n    for image in @collectedFailureImages\n      image.addToZipAsJSIgnoringItsAnObtained zip\n      \n      # let\'s also save the png file so it\'s easier to browse the data\n      # note that these png files are not copied over into the\n      # build directory.\n      image.addToZipAsPNG zip\n\n    # create and save all diff .png images\n    # the diff images just highlight in red\n    # the parts that differ from any one\n    # of the "good" screenshots\n    # (remember, there can be more than one\n    # good screenshot, we pick the first one\n    # we find)\n    renamerScript = ""\n    systemInfo = new SystemTestsSystemInfo()\n    pixelRatioString = (""+pixelRatio).replace(/\.+/g, "_")\n\n    for i in [0...@collectedFailureImages.length]\n      failedImage = @collectedFailureImages[i]\n\n      aGoodImageName = (failedImage).imageName.replace("obtained-", "")\n      filenameForScript = aGoodImageName.replace(/_image_.*/g, "")\n      renamerScript += "rm " + "../Zombie-Kernel-tests/tests/" + filenameForScript + "/automation-assets/" +\n              systemInfo.os.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              systemInfo.osVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              systemInfo.browser.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              systemInfo.browserVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              "devicePixelRatio_" + pixelRatioString + "/" +\n              aGoodImageName + "*\n"\n      renamerScript += "cp " + (failedImage).imageName + "* ../Zombie-Kernel-tests/tests/" + filenameForScript + "/automation-assets/" +\n              systemInfo.os.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              systemInfo.osVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              systemInfo.browser.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              systemInfo.browserVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              "devicePixelRatio_" + pixelRatioString + "/\n\n"\n\n      setOfGoodImages = AutomatorRecorderAndPlayer.loadedImages[aGoodImageName]\n      diffNumber = 0\n      for eachGoodImage in setOfGoodImages\n        diffNumber++\n        # note the asynchronous operation here - this is because\n        # the subtractScreenshots needs to create some Images and\n        # load them with data from base64 string. The operation\n        # of loading the data is asynchronous...\n        @subtractScreenshots failedImage, eachGoodImage, diffNumber, (subtractionCanvas, failedImage, errorRatio, diffNumber) ->\n          console.log "zipping diff file:" + "diff-"+failedImage.imageName+".png"\n          zip.file(\n            "diff-"+\n            failedImage.imageName +\n            "-error-" +\n            errorRatio+\n            "-diffNumber-"+\n            diffNumber+\n            ".png"\n          , subtractionCanvas.toDataURL().replace(/^data:image\/png;base64,/, ""), {base64: true});\n    zip.file("replace_all_images.sh", renamerScript);\n\n    # OK the images are all put in the zip\n    # asynchronously. So, in theory what we should do is to\n    # check that we have all the image packed\n    # and then save the zip. In practice we just wait\n    # some time (200ms for each image)\n    # and then save the zip.\n    setTimeout =>\n        console.log "saving failed screenshots"\n        if navigator.userAgent.search("Safari") >= 0 and navigator.userAgent.search("Chrome") < 0\n          # Safari can\'t save blobs nicely with a nice\n          # file name, see\n          # http://stuk.github.io/jszip/documentation/howto/write_zip.html\n          # so what this does is it saves a file "Unknown". User\n          # then has to rename it and open it.\n          location.href="data:application/zip;base64," + zip.generate({type:"base64"})\n        else\n          console.log "not safari"\n          content = zip.generate({type:"blob"})\n          saveAs(content, "SystemTest_#{@testName}_failedScreenshots.zip")        \n      , (@collectedFailureImages.length+1) * 200 \n\n\n\n  saveTest: ->\n    zip = new JSZip()\n\n    blob = @testMetadataFileContentCreator()\n    zip.file("SystemTest_#{@testName}.js", blob);\n\n    blob = @automatorCommandsFileContentCreator window.world.systemTestsRecorderAndPlayer.automatorCommandsSequence\n    testNameExtended = @testName + "_automationCommands"\n    zip.file("SystemTest_#{testNameExtended}.js", blob);\n    \n    # save all the images, each as a .png and .js file\n    # the png is for quick browsing, while the js contains\n    # the pixel data and the metadata of which configuration\n    # the picture was recorded with.\n    # (we expect the screenshots to be different across\n    # browsers and OSs)\n    for image in @collectedImages\n      image.addToZipAsJS zip\n      \n      # let\'s also save the png file so it\'s easier to browse the data\n      # note that these png files are not copied over into the\n      # build directory.\n      image.addToZipAsPNG zip\n    \n\n    if navigator.userAgent.search("Safari") >= 0 and navigator.userAgent.search("Chrome") < 0\n      # Safari can\'t save blobs nicely with a nice\n      # file name, see\n      # http://stuk.github.io/jszip/documentation/howto/write_zip.html\n      # so what this does is it saves a file "Unknown". User\n      # then has to rename it and open it.\n      console.log "safari"\n      location.href="data:application/zip;base64," + zip.generate({type:"base64"})\n    else\n      console.log "not safari"\n      content = zip.generate({type:"blob"})\n      saveAs(content, "SystemTest_#{@testName}.zip")    \n\n  loadTest: (testNumber, andThenDoThis)->\n    script = document.createElement(\'script\')\n    script.src = "js/tests/"+@testsList()[testNumber] + "_automationCommands.js"\n\n    script.onload = =>\n      @loadImagesOfTest testNumber, andThenDoThis\n\n    document.head.appendChild script\n\n  loadImagesOfTest: (testNumber, andThenDoThis)->\n\n    for eachCommand in window[(@testsList()[testNumber])+ "_automationCommands"].automatorCommandsSequence\n      if eachCommand.screenShotImageName?\n        pureImageName = eachCommand.screenShotImageName\n        for eachAssetInManifest in AutomatorRecorderAndPlayer.testsAssetsManifest\n          if eachAssetInManifest.indexOf(pureImageName) != -1\n            script = document.createElement(\'script\')\n            ###\n            systemInfo = new SystemTestsSystemInfo()\n            # some devices have non-integer pixel ratios so\n            # let\'s handle the dot there.\n            pixelRatioString = (""+pixelRatio).replace(/\.+/g, "_")\n            alert "js/tests/assets/" +\n              systemInfo.os.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              systemInfo.osVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              systemInfo.browser.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              systemInfo.browserVersion.replace(/\s+/g, "-").replace(/\.+/g, "_") + "/" +\n              "devicePixelRatio_" + pixelRatioString + "/" +\n              eachAssetInManifest +\n              ".js"\n            ###\n            script.src = "js/tests/assets/"+ eachAssetInManifest + ".js"\n            document.head.appendChild script\n\n    setTimeout =>\n        andThenDoThis()\n      , 1000\n\n\n  testsList: ->\n    preselectionBeforeSplittingGroups = null\n    if @selectedTestsBasedOnTags.length != 0\n      preselectionBeforeSplittingGroups = @selectedTestsBasedOnTags\n    else\n      preselectionBeforeSplittingGroups = AutomatorRecorderAndPlayer.testsManifest\n\n    console.log "tests list before partitioning and picking: " + preselectionBeforeSplittingGroups\n\n    console.log "tests list after partitioning and picking: " + preselectionBeforeSplittingGroups.chunk(Math.ceil(preselectionBeforeSplittingGroups.length / @numberOfGroups))[@groupToBeRun]\n\n    actualTestList = preselectionBeforeSplittingGroups.chunk(Math.ceil(preselectionBeforeSplittingGroups.length / @numberOfGroups))[@groupToBeRun]\n\n    return actualTestList\n\n\n  loadTestMetadata: (testNumber, andThen)->\n\n    if testNumber >= AutomatorRecorderAndPlayer.testsManifest.length\n      andThen()\n      return\n\n    script = document.createElement(\'script\')\n    script.src = "js/tests/" + AutomatorRecorderAndPlayer.testsManifest[testNumber] + ".js"\n\n    script.onload = =>\n      @loadTestMetadata(testNumber+1, andThen)\n\n    document.head.appendChild script\n\n\n  loadTestsMetadata: (andThen) ->\n    @loadTestMetadata 0, andThen\n\n  runNextSystemTest: ->\n    @indexOfSystemTestBeingPlayed++\n    if @indexOfSystemTestBeingPlayed >= @testsList().length\n      SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole "finished all tests"\n      world.nextStartupAction()\n      return\n    # Here we load the test dynamically,\n    # by injecting a script that loads the js files\n    # with the data. Better this than loading\n    # all the tests data at once, we might only\n    # need a few tests rather than all of them.\n    @loadTest @indexOfSystemTestBeingPlayed, =>\n      SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole "playing test: " + @testsList()[@indexOfSystemTestBeingPlayed]\n      @automatorCommandsSequence = window[(@testsList()[@indexOfSystemTestBeingPlayed])+ "_automationCommands"].automatorCommandsSequence\n      @startTestPlayingWithSlideIntro()\n\n  # Select tests based on test names, or tags, or special\n  # tag "all" to select them all.\n  #\n  # Examples to try from cosole:\n  # world.systemTestsRecorderAndPlayer.selectTestsFromTagsOrTestNames(["shadow"]);\n  # world.systemTestsRecorderAndPlayer.selectTestsFromTagsOrTestNames(["bubble"]);\n  # world.systemTestsRecorderAndPlayer.selectTestsFromTagsOrTestNames(["shadow", "bubble"]);\n  # world.systemTestsRecorderAndPlayer.selectTestsFromTagsOrTestNames(["all"]);\n  # world.systemTestsRecorderAndPlayer.selectTestsFromTagsOrTestNames(["SystemTest_buildAllMorphs", "SystemTest_compositeMorphsHaveCorrectShadow"]);\n  # world.systemTestsRecorderAndPlayer.selectTestsFromTagsOrTestNames(["bubble", "SystemTest_buildAllMorphs", "SystemTest_compositeMorphsHaveCorrectShadow"]);\n\n  selectTestsFromTagsOrTestNames: (wantedTagsOrNamesArray) ->\n    console.log "selectTestsFromTagsOrTestNames"\n    # we proceed here to FIRST load all the\n    # metadata of all the tests, then\n    # we check the tags.\n\n    # First name the callback that doest the\n    # tags/names checks after the metadata\n    # of all the tests is loaded.\n    selectTheTestsBasedOnTags = =>\n        @selectedTestsBasedOnTags = []\n        for eachTest in AutomatorRecorderAndPlayer.testsManifest\n          for eachWantedTagOrName in wantedTagsOrNamesArray\n            # special tag/name "all" matches all the tests\n            if eachWantedTagOrName == "all"\n              if (@selectedTestsBasedOnTags.indexOf eachTest) < 0\n                @selectedTestsBasedOnTags.push eachTest\n              continue\n            if eachWantedTagOrName == eachTest\n              if (@selectedTestsBasedOnTags.indexOf eachTest) < 0\n                @selectedTestsBasedOnTags.push eachTest\n              continue\n            if (window[eachTest].tags.indexOf eachWantedTagOrName) >= 0\n              if (@selectedTestsBasedOnTags.indexOf eachTest) < 0\n                @selectedTestsBasedOnTags.push eachTest\n              continue\n\n        console.log @selectedTestsBasedOnTags\n\n    # load the metadata of all the tests\n    # and pass the callback to be run\n    # when all the metadata is loaded.\n    @loadTestsMetadata(selectTheTestsBasedOnTags)\n\n  runAllSystemTests: ->\n    console.log "runAllSystemTests"\n    @millisOfAllTestsSoFar = 0\n\n    # we proceed here to FIRST load all the\n    # metadata of all the tests, then\n    # one by one as needed we need the automatorCommands\n    # and the assets.\n\n    # First name the callback that starts the\n    # running of the tests after the metadata\n    # of all the tests is loaded.\n    actuallyRunTheTests = =>\n        actualTestList = @testsList()\n        @allTestsDuration = 0\n        #debugger\n        for eachTest in actualTestList\n          @allTestsDuration += window["#{eachTest}"].testDuration\n\n        @playingAllSystemTests = true\n        @indexOfSystemTestBeingPlayed = -1\n        @runNextSystemTest()\n\n    # load the metadata of all the tests\n    # and pass the callback to be run\n    # when all the metadata is loaded.\n    @loadTestsMetadata(actuallyRunTheTests)\n    console.log "Running system tests: " + @testsList()\n';

  return AutomatorRecorderAndPlayer;

})();

BackingStoreMixin = {
  onceAddedClassProperties: function() {
    this.addInstanceProperties({
      silentUpdateBackingStore: function() {
        var context;
        this.image = newCanvas(this.extent().scaleBy(pixelRatio));
        context = this.image.getContext("2d");
        context.scale(pixelRatio, pixelRatio);
        context.fillStyle = this.color.toString();
        context.fillRect(0, 0, this.width(), this.height());
        if (this.cachedTexture) {
          return this.drawCachedTexture();
        } else {
          if (this.texture) {
            return this.drawTexture(this.texture);
          }
        }
      }
    });
    return this.addInstanceProperties({
      blit: function(aCanvas, clippingRectangle) {
        var al, area, at, context, delta, h, randomB, randomG, randomR, sl, src, st, w;
        if (this.isMinimised || !this.isVisible || (this.image == null)) {
          return null;
        }
        area = clippingRectangle.intersect(this.bounds).round();
        if (area.isNotEmpty()) {
          delta = this.position().neg();
          src = area.copy().translateBy(delta).round();
          context = aCanvas.getContext("2d");
          context.globalAlpha = this.alpha;
          sl = src.left() * pixelRatio;
          st = src.top() * pixelRatio;
          al = area.left() * pixelRatio;
          at = area.top() * pixelRatio;
          w = Math.min(src.width() * pixelRatio, this.image.width - sl);
          h = Math.min(src.height() * pixelRatio, this.image.height - st);
          if (w < 1 || h < 1) {
            return null;
          }
          context.drawImage(this.image, Math.round(sl), Math.round(st), Math.round(w), Math.round(h), Math.round(al), Math.round(at), Math.round(w), Math.round(h));
          if (world.showRedraws) {
            randomR = Math.round(Math.random() * 255);
            randomG = Math.round(Math.random() * 255);
            randomB = Math.round(Math.random() * 255);
            context.globalAlpha = 0.5;
            context.fillStyle = "rgb(" + randomR + "," + randomG + "," + randomB + ")";
            return context.fillRect(Math.round(al), Math.round(at), Math.round(w), Math.round(h));
          }
        }
      }
    });
  }
};

GroundVal = (function() {
  GroundVal.prototype.directlyOrIndirectlyDependsOnAParentVal = false;

  GroundVal.prototype.lastCalculatedValContent = null;

  GroundVal.prototype.lastCalculatedValContentMaybeOutdated = false;

  GroundVal.prototype.localValsAffectedByChangeOfThisVal = null;

  GroundVal.prototype.args = null;

  function GroundVal(valName, lastCalculatedValContent, ownerMorph) {
    var contentOfLastCalculatedVal;
    this.valName = valName;
    this.lastCalculatedValContent = lastCalculatedValContent;
    this.ownerMorph = ownerMorph;
    if (this.constructor.name === "GroundVal" && WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      ProfilerData.reactiveValues_createdGroundVals++;
      if (this.lastCalculatedValContent == null) {
        contentOfLastCalculatedVal = null;
      } else {
        contentOfLastCalculatedVal = this.lastCalculatedValContent;
      }
      console.log("building GroundVal named " + this.valName + " in morph " + this.ownerMorph.uniqueIDString() + " with content: " + contentOfLastCalculatedVal);
    }
    this.addMyselfToMorphsValsList(valName);
    this.id = this.valName + this.ownerMorph.uniqueIDString();
    this.localValsAffectedByChangeOfThisVal = [];
  }

  GroundVal.prototype.checkAndPropagateChangeBasedOnArgChange = function() {
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      console.log("checking if " + this.valName + " in morph " + this.ownerMorph.uniqueIDString() + " has any damaged inputs...");
    }
    if (this.args.countOfDamaged > 0) {
      if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
        console.log("... " + this.valName + " in morph " + this.ownerMorph.uniqueIDString() + " has some damaged inputs but it's already broken so nothing to do");
      }
      if (this.lastCalculatedValContentMaybeOutdated === false) {
        if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
          console.log("... " + this.valName + " in morph " + this.ownerMorph.uniqueIDString() + " has some damaged inputs and wasn't damaged so need to propagate damage");
        }
        this.lastCalculatedValContentMaybeOutdated = true;
        return this.notifyDependentParentOrLocalValsOfPotentialChange();
      }
    } else {
      if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
        console.log("... " + this.valName + " in morph " + this.ownerMorph.uniqueIDString() + " has NO damaged inputs");
      }
      return this.heal();
    }
  };

  GroundVal.prototype.heal = function() {
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      console.log("... now healing " + this.id);
    }
    if (this.lastCalculatedValContentMaybeOutdated) {
      if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
        console.log("... " + this.id + "'s last calculated value was marked as broken, notifying dep values of this being healed");
      }
      this.lastCalculatedValContentMaybeOutdated = false;
      return this.notifyDependentParentOrLocalValsOfPotentialChange();
    }
  };

  GroundVal.prototype.addMyselfToMorphsValsList = function(valName) {
    return this.ownerMorph.allValsInMorphByName[valName] = this;
  };

  GroundVal.prototype.stainValCalculatedFromParent = function(stainingArgVal) {
    var stainingArg;
    stainingArg = this.args.getByVal(stainingArgVal);
    return stainingArg.turnIntoArgDirectlyOrIndirectlyDependingOnParent();
  };

  GroundVal.prototype.unstainValCalculatedFromParent = function(unstainedArgVal) {
    var unstainedArg;
    unstainedArg = this.args.getByVal(unstainedArgVal);
    return unstainedArg.turnIntoArgNotDirectlyNorIndirectlyDependingOnParent();
  };

  GroundVal.prototype.setVal = function(newVal) {
    this.signature = newVal.signature;
    if (this.lastCalculatedValContent === newVal) {

    } else {
      this.lastCalculatedValContent = newVal;
      return this.notifyDependentParentOrLocalValsOfPotentialChange();
    }
  };

  GroundVal.prototype.notifyDependentParentOrLocalValsOfPotentialChange = function() {
    var cv, k, v, _i, _len, _ref, _results;
    _ref = this.localValsAffectedByChangeOfThisVal;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cv = _ref[_i];
      cv.argMightHaveChanged(this);
    }
    if (this.ownerMorph.parent != null) {
      v = this.ownerMorph.parent.morphValsDependingOnChildrenVals[this.valName];
      _results = [];
      for (k in v) {
        _results.push(k.argMightHaveChanged(this));
      }
      return _results;
    }
  };

  GroundVal.prototype.fetchVal = function() {
    return this.lastCalculatedValContent;
  };

  GroundVal.coffeeScriptSourceOfThisClass = '# just a draft, it\'s not meant to compile or work\n# just yet, we are just assembling things\n\n# a GroundVal holds a val that is not\n# calculated from anything: it\'s actually\n# changeable as is. It doesn\'t react to the\n# change of any other Val.\n\n# REQUIRES ProfilerData\n\nclass GroundVal\n  \n  directlyOrIndirectlyDependsOnAParentVal: false\n\n  # we use "lastCalculatedValContent" here just as a matter of\n  # uniformity. The cached val of a GroundVal\n  # is always up to date, it\'s always good for use.\n  lastCalculatedValContent: null\n\n  # always false for GroundVals, because there is never\n  # a recalculation to be done here, the val is always\n  # exactly known\n  lastCalculatedValContentMaybeOutdated: false\n  # these vals are affected by change of this\n  # val\n  localValsAffectedByChangeOfThisVal: null\n\n  args: null\n\n  constructor: (@valName, @lastCalculatedValContent, @ownerMorph) ->\n\n    # stuff to do only if we are building GroundVal and not\n    # any of its subclasses\n    if @constructor.name == "GroundVal" and\n        WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n\n      ProfilerData.reactiveValues_createdGroundVals++\n\n      if !@lastCalculatedValContent?\n        contentOfLastCalculatedVal = null\n      else\n        contentOfLastCalculatedVal = @lastCalculatedValContent\n\n      console.log "building GroundVal named " + @valName + " in morph "+ @ownerMorph.uniqueIDString() + " with content: " + contentOfLastCalculatedVal\n\n    @addMyselfToMorphsValsList valName\n    @id = @valName + @ownerMorph.uniqueIDString()\n    @localValsAffectedByChangeOfThisVal = []\n\n\n  checkAndPropagateChangeBasedOnArgChange: () ->\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "checking if " + @valName + " in morph "+ @ownerMorph.uniqueIDString() + " has any damaged inputs..."\n\n    # we can check these with a counter, DON\'T do\n    # something like Object.keys(obj).length because it\'s\n    # unnecessary overhead.\n    # Note here that there is no propagation in case:\n    #  a) there is a change but we already notified our\n    #     change to the connected vals\n    #  b) there is no change and we never notified\n    #     any change to the connected vals\n    if @args.countOfDamaged > 0\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "... " + @valName  + " in morph "+ @ownerMorph.uniqueIDString() + " has some damaged inputs but it\'s already broken so nothing to do"\n      if @lastCalculatedValContentMaybeOutdated == false\n        if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n          console.log "... " + @valName  + " in morph "+ @ownerMorph.uniqueIDString() + " has some damaged inputs and wasn\'t damaged so need to propagate damage"\n        @lastCalculatedValContentMaybeOutdated = true\n        @notifyDependentParentOrLocalValsOfPotentialChange()\n    else # there are NO damaged args\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "... " + @valName  + " in morph "+ @ownerMorph.uniqueIDString() + " has NO damaged inputs"\n      @heal()\n\n\n  heal: ->\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "... now healing " + @id\n\n    if @lastCalculatedValContentMaybeOutdated\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "... " + @id + "\'s last calculated value was marked as broken, notifying dep values of this being healed"\n      @lastCalculatedValContentMaybeOutdated = false\n      @notifyDependentParentOrLocalValsOfPotentialChange()\n\n\n  addMyselfToMorphsValsList: (valName) ->\n    @ownerMorph.allValsInMorphByName[valName] = @\n\n  stainValCalculatedFromParent: (stainingArgVal) ->\n    # note that staining argument here could\n    # be a child argument, as it might directly or\n    # indirectly depend on\n    # a value which is in a parent\n    stainingArg = @args.getByVal stainingArgVal\n    # this might recursively stain other values\n    # depending on this value\n    stainingArg.turnIntoArgDirectlyOrIndirectlyDependingOnParent()\n\n  unstainValCalculatedFromParent: (unstainedArgVal) ->\n    # note that argument here could\n    # be a child argument, as it might directly or\n    # indirectly depend on\n    # a value which is in a parent\n    unstainedArg = @args.getByVal unstainedArgVal\n    # this might recursively un-stain other values\n    # depending on this value\n    unstainedArg.turnIntoArgNotDirectlyNorIndirectlyDependingOnParent()\n\n\n  # this is the only type of val that we\n  # can actually change directly.\n  # All other typed of vals are calculated\n  # from other vals.\n  setVal: (newVal) ->\n    @signature = newVal.signature\n\n    # comparison needs to be smarter?\n    # does this need to have multiple version for basic vals\n    # like integers and strings?\n    if @lastCalculatedValContent == newVal\n      return\n    else\n      @lastCalculatedValContent = newVal\n      @notifyDependentParentOrLocalValsOfPotentialChange()\n  \n  # note that parents never notify children\n  # of any change, because we don\'t want this\n  # operation to take long as there might be hundreds\n  # of children directly/indirectly under this morph.\n  notifyDependentParentOrLocalValsOfPotentialChange: ->\n    for cv in @localValsAffectedByChangeOfThisVal\n      cv.argMightHaveChanged @\n    if @ownerMorph.parent?\n      v = @ownerMorph.parent.morphValsDependingOnChildrenVals[@valName]\n      for k of v\n        #k.argFromChildMightHaveChanged @\n        k.argMightHaveChanged @\n\n  # no logic for recalculation needed\n  # fetchVal is an apt name because it doesn\'t necessarily\n  # recalculate the val (although it might need to) and it\n  # doesn\'t just look it up either. It\'s some sort of retrieval.\n  fetchVal: ->\n    return @lastCalculatedValContent\n\n';

  return GroundVal;

})();

BasicCalculatedVal = (function(_super) {
  __extends(BasicCalculatedVal, _super);

  BasicCalculatedVal.prototype.lastCalculatedValContentMaybeOutdated = true;

  BasicCalculatedVal.prototype.lastCalculatedValContent = void 0;

  BasicCalculatedVal.prototype.holdOffFromPropagatingChanges = false;

  function BasicCalculatedVal(valName, functionToRecalculate, localInputVals, parentArgsNames, childrenArgsNames, ownerMorph) {
    var collectionOfChildrenValuesNames, eachName, _i, _len;
    this.valName = valName;
    this.functionToRecalculate = functionToRecalculate;
    this.localInputVals = localInputVals;
    this.ownerMorph = ownerMorph;
    BasicCalculatedVal.__super__.constructor.call(this, this.valName, null, this.ownerMorph);
    ProfilerData.reactiveValues_createdBasicCalculatedValues++;
    if (WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode) {
      collectionOfChildrenValuesNames = "";
      for (_i = 0, _len = childrenArgsNames.length; _i < _len; _i++) {
        eachName = childrenArgsNames[_i];
        collectionOfChildrenValuesNames = collectionOfChildrenValuesNames + ", " + eachName;
      }
      console.log("building BasicCalculatedVal named " + this.valName + " in morph " + this.ownerMorph.uniqueIDString() + " depending on children variables: " + collectionOfChildrenValuesNames);
    }
    this.args = new Args(this);
    this.args.setup_AddAllLocalArgVals(this.localInputVals);
    this.args.setup_AddAllParentArgNames(parentArgsNames);
    this.args.setup_AddAllChildrenArgNames(childrenArgsNames);
  }

  BasicCalculatedVal.prototype.propagateChangeOfThisValIfNeeded = function(newValContent) {
    debugger;
    if (newValContent.signature === this.lastCalculatedValContent.signature) {
      return this.heal();
    } else {
      if (this.lastCalculatedValContentMaybeOutdated === false) {
        return notifyDependentParentOrLocalValsOfPotentialChange();
      }
    }
  };

  BasicCalculatedVal.prototype.fetchVal = function() {
    var newValContent, oneOrMoreArgsHaveActuallyChanged;
    if (this.lastCalculatedValContentMaybeOutdated === false) {
      return this.lastCalculatedValContent;
    }
    oneOrMoreArgsHaveActuallyChanged = false;
    oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged || this.args.fetchAllArgsDirectlyOrIndirectlyCalculatedFromParent();
    oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged || this.args.fetchAllRemainingArgsNeedingRecalculation();
    if (oneOrMoreArgsHaveActuallyChanged) {
      newValContent = this.functionToRecalculate(this.args.argById, this.args.localArgByName, this.args.parentArgByName, this.args.childrenArgByName, this.args.childrenArgByNameCount);
      this.signature = newValContent.signature;
      this.lastCalculatedValContent = newValContent;
      if (!this.directlyOrIndirectlyDependsOnAParentVal) {
        this.propagateChangeOfThisValIfNeeded(newValContent);
      }
    }
    return this.lastCalculatedValContent;
  };

  BasicCalculatedVal.coffeeScriptSourceOfThisClass = '# just a draft, it\'s not meant to compile or work\n# just yet, we are just assembling things\n\n# REQUIRES ProfilerData\n\nclass BasicCalculatedVal extends GroundVal\n  # sometimes we know that the cached val\n  # might be out of date but we don\'t want to\n  # trigger a recalculation to actually check.\n  # This is what this flag tracks.\n  # Note that this flag has no meaning if this Val\n  # is @directlyOrIndirectlyDependsOnAParentVal, as in that case\n  # we always have to fetch the val rather than\n  # hope to have a good cached version.\n  lastCalculatedValContentMaybeOutdated: true\n  lastCalculatedValContent: undefined\n  # this is needed because during the recalculation step\n  # we don\'t want to process the notifications that\n  # we receive about our args changing, that\n  # would be messy and wasteful.\n  holdOffFromPropagatingChanges: false\n\n  # this val might be referenced by parent Morph or\n  # children Morphs dynamically so they way to find this\n  # val might be through the name as a string\n  constructor: (@valName, @functionToRecalculate, @localInputVals, parentArgsNames, childrenArgsNames, @ownerMorph) ->\n    super(@valName, null, @ownerMorph)\n\n    ProfilerData.reactiveValues_createdBasicCalculatedValues++\n\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      collectionOfChildrenValuesNames = ""\n      for eachName in childrenArgsNames\n        collectionOfChildrenValuesNames = collectionOfChildrenValuesNames + ", " + eachName\n      console.log "building BasicCalculatedVal named " + @valName + " in morph "+ @ownerMorph.uniqueIDString() + " depending on children variables: " + collectionOfChildrenValuesNames\n    \n    # we don\'t mark immediately this value as\n    # depending on parent, the reason is that there might be\n    # no parent morph to this one, so in some circumstances\n    # this value\'s content can actually just be treated as\n    # a normal value that doesn\'t need to automatically\n    # fetch values for some of its arguments, and which\n    # notification of changes can actually be believed.\n    # As soon as a parent Morph is added, then this doesn\'t\n    # hold true anymore - this Value stops notifying the\n    # other dependent values of changes because it doesn\'t\n    # get the changes from the parent values itself...\n    #@directlyOrIndirectlyDependsOnAParentVal = true\n\n    @args = new Args(@)\n    @args.setup_AddAllLocalArgVals @localInputVals\n    @args.setup_AddAllParentArgNames parentArgsNames\n    @args.setup_AddAllChildrenArgNames childrenArgsNames\n\n\n  # Given that this Val if a pure function depending\n  # on some args, we want to know at all times\n  # whether the args change. If the don\'t, then we\n  # know that there is no need to recalculate the present\n  # val. So this method is used by all the args\n  # of this val to notify whether they have changed\n  # or not.\n  # It\'s important to note that this method can be\n  # called for two reasons:\n  # 1) an arg has just been recalculated. Hence\n  #    we know exactly its val\n  # 2) an arg has just maybe changed because\n  #    he knows that one of HIS args has changed\n  #    but since we want to minimise recalculations we\n  #    don\'t know what the new val is, just that\n  #    maybe it has changed. \n  # There is one exception: all args\n  # that depend on a parent val (directly or indirectly)\n  # never notify anybody. This is because if a parent had\n  # to notify all the directly or indirectly connected\n  # vals, in general it could be\n  # very expensive, as for example there could be 50\n  # children to notify (and they might to notify other\n  # connected vals). What happens instead is that when\n  # this val is calculated, all args that depend on\n  # a parent (directly or indirectly) are\n  # always re-fetched, we just\n  # can\'t trust them to have notified us of their change...\n  # this method never triggers a recalculation!\n  # we could receive this because\n  #   - a recalculation has happened down the line\n  #     and we know the actual val of the\n  #     changed arg\n  #   - some invalidation has happened down the line\n  #     and hence the arg *might* have changed\n  #     but we don\'t know the actual val.\n  # We just need to keep track of which args might\n  # need recalculation and which ones are surely the\n  # same as the version we used for our last calculation.\n  #argMightHaveChanged: (changedArgVal) ->\n  #\n  #  if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n  #    console.log "marking argument " + changedArgVal.valName + " connected to morph " + changedArgVal.ownerMorph.uniqueIDString() + " as \"might have changed\" "\n  #\n  #  changedArg = @args.argById[changedArgVal.id]\n  #  if changedArg.markedForRemoval or @holdOffFromPropagatingChanges then return\n  #  changedArg.checkBasedOnSignature()\n  #  if !@directlyOrIndirectlyDependsOnAParentVal\n  #    @checkAndPropagateChangeBasedOnArgChange()\n\n\n\n  propagateChangeOfThisValIfNeeded: (newValContent) ->\n    debugger\n    if newValContent.signature == @lastCalculatedValContent.signature\n      @heal()\n    else # newValContent.signature != @lastCalculatedValContent.signature\n      if @lastCalculatedValContentMaybeOutdated == false\n        notifyDependentParentOrLocalValsOfPotentialChange()\n        # note that @lastCalculatedValContentMaybeOutdated\n        # remains false because we are sure of this value\n        # as we just calculated\n\n  # this method is called either by the user/system\n  # because it\'s time to get the val, or it\'s\n  # called by another val which is being asked to\n  # return its val recursively.\n  # this method could trigger a recalculation of some\n  # args, and of this val itself (obviously\n  # this whole apparatus is to minimise recalculations).\n  # Even if this\n  # particular function *might* be cheap to compute,\n  # the "dirty" parameters of its input might not be cheap\n  # to calculate.\n  # fetchVal is an apt name because it doesn\'t necessarily\n  # recalculate the val (although it might need to) and it\n  # doesn\'t just look it up either. It\'s some sort of retrieval.\n  fetchVal: () ->\n    if @lastCalculatedValContentMaybeOutdated is false\n      return @lastCalculatedValContent\n    \n    oneOrMoreArgsHaveActuallyChanged = false\n    oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged or @args.fetchAllArgsDirectlyOrIndirectlyCalculatedFromParent()\n    oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged or @args.fetchAllRemainingArgsNeedingRecalculation()\n\n    if oneOrMoreArgsHaveActuallyChanged      \n      # functionToRecalculate must always return\n      # an object with a calculated default signature\n      # in the .signature property\n      newValContent =\n        @functionToRecalculate @args.argById,\n          @args.localArgByName,\n          @args.parentArgByName,\n          @args.childrenArgByName,\n          @args.childrenArgByNameCount\n\n      @signature = newValContent.signature\n      @lastCalculatedValContent = newValContent\n      if !@directlyOrIndirectlyDependsOnAParentVal\n        @propagateChangeOfThisValIfNeeded newValContent\n    return @lastCalculatedValContent\n      \n    \n';

  return BasicCalculatedVal;

})(GroundVal);

DeepCopierMixin = {
  onceAddedClassProperties: function() {
    this.addInstanceProperties({
      deepCopy: function(doSerialize, objOriginalsClonedAlready, objectClones, allMorphsInStructure) {
        var cloneOfMe, haveIBeenCopiedAlready, positionInObjClonesArray, property;
        haveIBeenCopiedAlready = objOriginalsClonedAlready.indexOf(this);
        if (haveIBeenCopiedAlready >= 0) {
          if (doSerialize) {
            return "$" + haveIBeenCopiedAlready;
          } else {
            return objectClones[haveIBeenCopiedAlready];
          }
        }
        if ((this instanceof Morph) && (allMorphsInStructure.indexOf(this) < 0)) {
          if (doSerialize) {
            return "$EXTERNAL" + this.uniqueIDString();
          } else {
            return this;
          }
        }
        positionInObjClonesArray = objOriginalsClonedAlready.length;
        objOriginalsClonedAlready.push(this);
        cloneOfMe = this.createPristineObjOfSameTypeAsThisOne(doSerialize);
        objectClones.push(cloneOfMe);
        for (property in this) {
          if (property === "allValsInMorphByName" || property === "morphValsDependingOnChildrenVals" || property === "morphValsDirectlyDependingOnParentVals") {
            continue;
          }
          if (this.hasOwnProperty(property)) {
            if (this[property] == null) {
              cloneOfMe[property] = null;
            } else if (typeof this[property] === 'object') {
              cloneOfMe[property] = this[property].deepCopy(doSerialize, objOriginalsClonedAlready, objectClones, allMorphsInStructure);
            } else {
              if (property !== "instanceNumericID") {
                cloneOfMe[property] = this[property];
              }
            }
          }
        }
        if (doSerialize) {
          return "$" + positionInObjClonesArray;
        }
        return cloneOfMe;
      }
    });
    return this.addInstanceProperties({
      createPristineObjOfSameTypeAsThisOne: function(addClassNameFieldIfObjectNotArray) {
        var theClone;
        if (typeof this === "object") {
          theClone = Object.create(this.constructor.prototype);
          if (addClassNameFieldIfObjectNotArray) {
            theClone.className = this.constructor.name;
          }
          if (theClone.assignUniqueID != null) {
            theClone.assignUniqueID();
          }
          return theClone;
        } else {
          return this;
        }
      }
    });
  }
};

MorphicNode = (function() {
  MorphicNode.prototype.parent = null;

  MorphicNode.prototype.children = null;

  function MorphicNode(parent, children) {
    this.parent = parent != null ? parent : null;
    this.children = children != null ? children : [];
  }

  MorphicNode.prototype.toString = function() {
    return "a MorphicNode" + "[" + this.children.length + "]";
  };

  MorphicNode.prototype.childrenTopToBottom = function() {
    return arrayShallowCopyAndReverse(this.children);
  };

  MorphicNode.prototype.addChild = function(aMorphicNode) {
    this.children.push(aMorphicNode);
    return aMorphicNode.parent = this;
  };

  MorphicNode.prototype.addChildFirst = function(aMorphicNode) {
    this.children.splice(0, null, aMorphicNode);
    return aMorphicNode.parent = this;
  };

  MorphicNode.prototype.moveAsLastChild = function() {
    var idx;
    if (!this.parent) {
      return;
    }
    idx = this.parent.children.indexOf(this);
    if (idx === this.parent.children.length - 1) {
      return;
    }
    if (idx !== -1) {
      this.parent.children.splice(idx, 1);
    }
    return this.parent.children.push(this);
  };

  MorphicNode.prototype.removeChild = function(aMorphicNode) {
    var idx;
    idx = this.children.indexOf(aMorphicNode);
    if (idx !== -1) {
      this.children.splice(idx, 1);
    }
    return aMorphicNode.parent = null;
  };

  MorphicNode.prototype.root = function() {
    if (this.parent != null) {
      return this.parent.root();
    }
    return this;
  };

  MorphicNode.prototype.pathOfChildrenPositionsRelativeToWorld = function(pathSoFar) {
    if (pathSoFar == null) {
      pathSoFar = {
        actualPath: [],
        lengthOfChildrenArrays: []
      };
    }
    if (this.parent != null) {
      pathSoFar.actualPath.push(this.parent.children.indexOf(this));
      pathSoFar.lengthOfChildrenArrays.push(this.parent.children.length);
      return this.parent.pathOfChildrenPositionsRelativeToWorld(pathSoFar);
    } else {
      if (this === world) {
        pathSoFar.actualPath.reverse();
        pathSoFar.lengthOfChildrenArrays.reverse();
        return pathSoFar;
      } else {
        return null;
      }
    }
  };

  MorphicNode.prototype.isAttachedAnywhereToWorld = function() {
    var theRoot;
    theRoot = this.root();
    if (theRoot === world || theRoot === world.hand) {
      return true;
    } else {
      return false;
    }
  };

  MorphicNode.prototype.depth = function() {
    if (!this.parent) {
      return 0;
    }
    return this.parent.depth() + 1;
  };

  MorphicNode.prototype.allChildrenBottomToTop = function() {
    var result;
    result = [this];
    this.children.forEach(function(child) {
      return result = result.concat(child.allChildrenBottomToTop());
    });
    return result;
  };

  MorphicNode.prototype.allChildrenTopToBottom = function() {
    return allChildrenTopToBottomSuchThat(function() {
      return true;
    });
  };

  MorphicNode.prototype.allChildrenTopToBottomSuchThat = function(predicate) {
    var collected, morph, morphNumber, _i, _ref;
    collected = [];
    for (morphNumber = _i = _ref = this.children.length - 1; _i >= 0; morphNumber = _i += -1) {
      morph = this.children[morphNumber];
      collected = collected.concat(morph.allChildrenTopToBottomSuchThat(predicate));
    }
    if (predicate.call(null, this)) {
      collected.push(this);
    }
    return collected;
  };

  MorphicNode.prototype.forAllChildrenBottomToTop = function(aFunction) {
    aFunction.call(null, this);
    if (this.children.length) {
      return this.children.forEach(function(child) {
        return child.forAllChildrenBottomToTop(aFunction);
      });
    }
  };

  MorphicNode.prototype.allLeafsBottomToTop = function() {
    var result;
    if (this.children.length === 0) {
      return [this];
    }
    result = [];
    this.children.forEach(function(child) {
      return result = result.concat(child.allLeafsBottomToTop());
    });
    return result;
  };

  MorphicNode.prototype.allParentsBottomToTop = function() {
    var someParents;
    if (this.parent != null) {
      someParents = this.parent.allParentsBottomToTop();
      someParents.push(this);
      return someParents;
    } else {
      return [this];
    }
  };

  MorphicNode.prototype.allParentsTopToBottom = function() {
    return this.allParentsBottomToTop().reverse();
  };

  MorphicNode.prototype.allParentsBottomToTopSuchThat = function(predicate) {
    var result;
    result = [];
    if (this.parent != null) {
      result = this.parent.allParentsBottomToTopSuchThat(predicate);
    }
    if (predicate.call(null, this)) {
      result.push(this);
    }
    return result;
  };

  MorphicNode.prototype.allParentsTopToBottomSuchThat = function(predicate) {
    var collected;
    collected = [];
    if (predicate.call(null, this)) {
      collected = [this];
    }
    if (this.parent != null) {
      collected = collected.concat(this.parent.allParentsTopToBottomSuchThat(predicate));
    }
    return collected;
  };

  MorphicNode.prototype.containedInParentsOf = function(morph) {
    var examinedMorph;
    if (morph == null) {
      console.log("failed to find morph in test: " + window.world.systemTestsRecorderAndPlayer.name);
      console.log("trying to find item with text label: " + window.world.systemTestsRecorderAndPlayer.automatorCommandsSequence[window.world.systemTestsRecorderAndPlayer.indexOfTestCommandBeingPlayedFromSequence].textLabelOfClickedItem);
      console.log("...you can likely fix the test by correcting the label above in the test");
      debugger;
    }
    if (morph === this) {
      return true;
    }
    examinedMorph = morph;
    while (examinedMorph.parent != null) {
      examinedMorph = examinedMorph.parent;
      if (examinedMorph === this) {
        return true;
      }
    }
    return false;
  };

  MorphicNode.prototype.siblings = function() {
    var index, siblings;
    if (!this.parent) {
      return [];
    }
    siblings = arrayShallowCopy(this.parent.children);
    index = siblings.indexOf(this);
    siblings.splice(index, 1);
    return siblings;
  };

  MorphicNode.prototype.howManySiblingsBeforeMeSuchThat = function(predicate) {
    var eachSibling, theCount, _i, _len, _ref;
    theCount = 0;
    _ref = this.parent.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      eachSibling = _ref[_i];
      if (eachSibling === this) {
        return theCount;
      }
      if (predicate.call(null, eachSibling)) {
        theCount++;
      }
    }
    return theCount;
  };

  MorphicNode.prototype.nthChildSuchThat = function(n, predicate) {
    var eachChild, theCount, _i, _len, _ref;
    theCount = 0;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      eachChild = _ref[_i];
      if (predicate.call(null, eachChild)) {
        theCount++;
        if (theCount === n) {
          return eachChild;
        }
      }
    }
    return null;
  };

  MorphicNode.prototype.parentThatIsA = function() {
    var constructors, eachConstructor, _i, _len, _ref;
    constructors = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    for (_i = 0, _len = constructors.length; _i < _len; _i++) {
      eachConstructor = constructors[_i];
      if (this instanceof eachConstructor) {
        return [this, eachConstructor];
      }
    }
    if (!this.parent) {
      return null;
    }
    return (_ref = this.parent).parentThatIsA.apply(_ref, constructors);
  };

  MorphicNode.prototype.isADescendantOf = function(theSupposedAncestorMorph) {
    if (this === theSupposedAncestorMorph) {
      return true;
    }
    if (this.parent == null) {
      return false;
    }
    return this.parent.isADescendantOf(theSupposedAncestorMorph);
  };

  MorphicNode.prototype.topMorphSuchThat = function(predicate) {
    var foundMorph, morph, morphNumber, _i, _ref;
    if (this.children.length === 0) {
      if (predicate.call(null, this)) {
        return this;
      } else {
        return null;
      }
    }
    for (morphNumber = _i = _ref = this.children.length - 1; _i >= 0; morphNumber = _i += -1) {
      morph = this.children[morphNumber];
      foundMorph = morph.topMorphSuchThat(predicate);
      if (foundMorph != null) {
        return foundMorph;
      }
    }
    if (predicate.call(null, this)) {
      return this;
    } else {
      return null;
    }
    return null;
  };

  MorphicNode.prototype.topmostChildSuchThat = function(predicate) {
    var morph, morphNumber, _i, _ref;
    for (morphNumber = _i = _ref = this.children.length - 1; _i >= 0; morphNumber = _i += -1) {
      morph = this.children[morphNumber];
      if (predicate.call(null, morph)) {
        return morph;
      }
    }
    return null;
  };

  MorphicNode.prototype.collectAllChildrenBottomToTopSuchThat = function(predicate) {
    var collected;
    collected = [];
    if (predicate.call(null, this)) {
      collected = [this];
    }
    this.children.forEach(function(child) {
      return collected = collected.concat(child.collectAllChildrenBottomToTopSuchThat(predicate));
    });
    return collected;
  };

  MorphicNode.coffeeScriptSourceOfThisClass = '# Morphic node class only cares about the\n# parent/child connection between\n# morphs. It\'s good to connect/disconnect\n# morphs and to find parents or children\n# who satisfy particular properties.\n# OUT OF SCOPE:\n# It\'s important to note that this layer\n# knows nothing about visibility, targets,\n# image buffers, dirty rectangles, events.\n# Please no invocations to changed or fullChanged\n# or updateBackingStore in here, and no\n# touching of any of the out-of-scope properties\n# mentioned.\n\nclass MorphicNode\n\n  parent: null\n  # "children" is an ordered list of the immediate\n  # children of this node. First child is at the\n  # back relative to other children, last child is at the\n  # top.\n  # This makes intuitive sense if you think for example\n  # at a textMorph being added to a box morph: it is\n  # added to the children list of the box morph, at the end,\n  # and it\'s painted on top (otherwise it wouldn\'t be visible).\n  # Note that when you add a morph A to a morph B, it doesn\'t\n  # mean that A is cointained in B. The two potentially might\n  # not even overlap.\n  # The shadow is added as the first child, and it\'s\n  # actually a special child that gets drawn before the\n  # others.\n  children: null\n\n  constructor: (@parent = null, @children = []) ->\n  \n  \n  # MorphicNode string representation: e.g. \'a MorphicNode[3]\'\n  toString: ->\n    "a MorphicNode" + "[" + @children.length + "]"\n\n  # currently unused in ZK\n  childrenTopToBottom: ->\n    arrayShallowCopyAndReverse(@children)  \n  \n  # MorphicNode accessing:\n  addChild: (aMorphicNode) ->\n    @children.push aMorphicNode\n    aMorphicNode.parent = @\n    ## @connectValuesToAddedChild aMorphicNode\n  \n  addChildFirst: (aMorphicNode) ->\n    @children.splice 0, null, aMorphicNode\n    aMorphicNode.parent = @\n\n  moveAsLastChild: ->\n    return unless @parent\n    idx = @parent.children.indexOf(@)\n    # check if already last child\n    # i.e. topmost\n    if idx == @parent.children.length - 1\n      return\n    @parent.children.splice idx, 1  if idx isnt -1\n    @parent.children.push @\n    # whoever invoked this should probably\n    # do a fullChanged() we don\'t do it\n    # here because it seems like a lower-level\n    # function calling a higher-level one.\n  \n  removeChild: (aMorphicNode) ->\n    # remove the array element from the\n    # array\n    idx = @children.indexOf(aMorphicNode)\n    @children.splice idx, 1  if idx isnt -1\n    aMorphicNode.parent = null\n    ## @disconnectValuesFromRemovedChild aMorphicNode\n  \n  \n  # MorphicNode functions:\n  root: ->\n    return @parent.root() if @parent?\n    @\n\n  # returns the path of this morph in terms\n  # of children positions relative to the world.\n  # Meaning that if the morph is not attached to the\n  # world or if it\'s attached to the hand, then\n  # null is returned.\n  # Example: [0, 2, 1] means that this morph is\n  # at\n  #  world.children[0].children[2].children[1]\n  pathOfChildrenPositionsRelativeToWorld: (pathSoFar) ->\n    if !pathSoFar?\n      pathSoFar = \n        actualPath: []\n        lengthOfChildrenArrays: []\n\n    if @parent?\n      pathSoFar.actualPath.push @parent.children.indexOf(@)\n      pathSoFar.lengthOfChildrenArrays.push @parent.children.length\n      @parent.pathOfChildrenPositionsRelativeToWorld(pathSoFar)\n    else\n      if @ == world\n        pathSoFar.actualPath.reverse()\n        pathSoFar.lengthOfChildrenArrays.reverse()\n        return pathSoFar\n      else\n        return null\n\n  isAttachedAnywhereToWorld: ->\n    theRoot = @root()\n    if theRoot == world or theRoot == world.hand\n      return true\n    else\n      return false\n\n  \n  # currently unused\n  depth: ->\n    return 0  unless @parent\n    @parent.depth() + 1\n  \n  # Returns all the internal AND terminal nodes in the subtree starting\n  # at this node - including this node.\n  # Remember that the @children property already sorts morphs\n  # from bottom to top\n\n  allChildrenBottomToTop: ->\n    result = [@] # includes myself\n    @children.forEach (child) ->\n      result = result.concat(child.allChildrenBottomToTop())\n    result\n\n  allChildrenTopToBottom: ->\n    return allChildrenTopToBottomSuchThat(-> true)\n\n  # the easiest way here would be to just return\n  #   arrayShallowCopyAndReverse(@allChildrenBottomToTop())\n  # but that\'s slower.\n  # So we do the proper visit here instead.\n  allChildrenTopToBottomSuchThat: (predicate) ->\n    collected = []\n\n\n    # if I have children, then start from the top\n    # one (i.e. the last in the array) towards the bottom\n    # one and concatenate their respective\n    # top-to-bottom lists\n    for morphNumber in [@children.length-1..0] by -1\n      morph = @children[morphNumber]\n      collected = collected.concat morph.allChildrenTopToBottomSuchThat predicate\n\n    # base case: after we checked all the\n    # children, we add ourselves to the last position\n    # of the list since this node is at the bottom of all of\n    # its children...\n    if predicate.call(null, @)\n      collected.push @ # include myself\n\n    return collected\n\n\n  # A shorthand to run a function on all the internal/terminal nodes in the subtree\n  # starting at this node - including this node.\n  # Note that the function first runs on this node\n  # (which is, when painted, the very bottom-est morph of them all)\n  # and the proceeds by visiting the first child\n  # which is the most "bottom" of the children\n  # (i.e. when painted, the first child in the "children" array\n  # and its children are painted just above the parent node)\n  # and then recursively depht-first all its children\n  # and then the second - bottomest child and children etc.\n  # Also note that there is a more elegant implementation where\n  # we just use @allChildrenBottomToTop() but that would mean to create\n  # all the intermediary arrays with also all the unneeded node elements,\n  # there is no need for that.\n  # This is the simplest and cheapest way to visit all Morphs in\n  # a tree of morphs.\n  forAllChildrenBottomToTop: (aFunction) ->\n    aFunction.call null, @\n    if @children.length\n      @children.forEach (child) ->\n        child.forAllChildrenBottomToTop aFunction\n  \n  # not used in ZK so far\n  allLeafsBottomToTop: ->\n    if @children.length == 0\n      return [@]\n    result = []\n    @children.forEach (child) ->\n      result = result.concat(child.allLeafsBottomToTop())\n    return result\n\n  # Return all "parent" nodes from the root up to this node (including both)\n  allParentsBottomToTop: ->\n    if @parent?\n      someParents = @parent.allParentsBottomToTop()\n      someParents.push @\n      return someParents\n    else\n      return [@]\n  \n  # Return all "parent" nodes from this node up to the root (including both)\n  # Implementation commented-out below works but it\'s probably\n  # slower than the one given, because concat is slower than pushing just\n  # an array element, since concat does a shallow copy of both parts of\n  # the array...\n  #   allParentsTopToBottom: ->\n  #    # includes myself\n  #    result = [@]\n  #    if @parent?\n  #      result = result.concat(@parent.allParentsTopToBottom())\n  #    result\n\n  allParentsTopToBottom: ->\n    return @allParentsBottomToTop().reverse()\n\n  # this should be quicker than allParentsTopToBottomSuchThat\n  # cause there are no concats making shallow copies.\n  allParentsBottomToTopSuchThat: (predicate) ->\n    result = []\n    if @parent?\n      result = @parent.allParentsBottomToTopSuchThat(predicate)\n    if predicate.call(null, @)\n      result.push @\n    result\n\n  allParentsTopToBottomSuchThat: (predicate) ->\n    collected = []\n    if predicate.call(null, @)\n      collected = [@] # include myself\n    if @parent?\n      collected = collected.concat(@parent.allParentsTopToBottomSuchThat(predicate))\n    return collected\n\n  # quicker version that doesn\'t need us\n  # to create any intermediate arrays\n  # but rather just loops up the chain\n  # and lets us return as soon as\n  # we find a match\n  containedInParentsOf: (morph) ->\n    if !morph?\n      # this happens when in a test, you select\n      # a menu entry that doesn\'t exist.\n      # so it\'s a good thing that we block the test\n      # and let the user navigate through the world\n      # to find the state of affairs that caused\n      # the problem.\n      console.log "failed to find morph in test: " + window.world.systemTestsRecorderAndPlayer.name\n      console.log "trying to find item with text label: " +  window.world.systemTestsRecorderAndPlayer.automatorCommandsSequence[window.world.systemTestsRecorderAndPlayer.indexOfTestCommandBeingPlayedFromSequence].textLabelOfClickedItem\n      console.log "...you can likely fix the test by correcting the label above in the test"\n      debugger\n    # test the morph itself\n    if morph is @\n      return true\n    examinedMorph = morph\n    while examinedMorph.parent?\n      examinedMorph = examinedMorph.parent\n      if examinedMorph is @\n        return true\n    return false\n\n  # The direct children of the parent of this node. (current node not included)\n  # never used in ZK\n  # There is an alternative solution here below, in comment,\n  # but I believe to be slower because it requires applying a function to\n  # all the children. My version below just required an array copy, then\n  # finding an element and splicing it out. I didn\'t test it so I don\'t\n  # even know whether it works, but gut feeling...\n  #  siblings: ->\n  #    return []  unless @parent\n  #    @parent.children.filter (child) =>\n  #      child isnt @\n  siblings: ->\n    return []  unless @parent\n    siblings = arrayShallowCopy @parent.children\n    # now remove myself\n    index = siblings.indexOf(@)\n    siblings.splice(index, 1)\n    return siblings\n\n  # find how many siblings before me\n  # satisfy a property\n  # This is used when figuring out\n  # how many buttons before a particular button\n  # are labeled in the same way,\n  # in the test system.\n  # (so that we can say: automatically\n  # click on the nth button labelled "X")\n  howManySiblingsBeforeMeSuchThat: (predicate) ->\n    theCount = 0\n    for eachSibling in @parent.children\n      if eachSibling == @\n        return theCount\n      if predicate.call(null, eachSibling)\n        theCount++\n    return theCount\n\n  # find the nth child satisfying\n  # a property.\n  # This is used when finding\n  # the nth buttons of a menu\n  # having a particular label.\n  # (so that we can say: automatically\n  # click on the nth button labelled "X")\n  nthChildSuchThat: (n, predicate) ->\n    theCount = 0\n    for eachChild in @children\n      if predicate.call(null, eachChild)\n        theCount++\n        if theCount is n\n          return eachChild\n    return null\n  \n  # returns the first parent (going up from this node) that is of a particular class\n  # (includes this particular node)\n  # This is a subcase of "parentThatIsAnyOf".\n  parentThatIsA: (constructors...) ->\n    # including myself\n    for eachConstructor in constructors\n      if @ instanceof eachConstructor\n        return [@, eachConstructor]\n    return null  unless @parent\n    @parent.parentThatIsA(constructors...)\n\n  # checks whether the morph is a child,\n  # directly or indirectly, of a specified\n  # supposed ancestor morph\n  # this is currently unused\n  isADescendantOf: (theSupposedAncestorMorph) ->\n    if @ == theSupposedAncestorMorph\n      return true\n    if !@parent?\n      return false\n    return @parent.isADescendantOf theSupposedAncestorMorph\n  \n\n  # There would be another, simpler, implementation\n  # which is also slower, where you first collect all\n  # the children from top to bottom and then do the\n  # test on each. But this is more efficient - we don\'t\n  # need to create that entire list to start with, we\n  # just navigate through the children arrays depth-first\n  # (in reverse order though, see below)\n  # and stop at the first morph that satisfies the test.\n  topMorphSuchThat: (predicate) ->\n    # base case - I am a leaf child, so I just test\n    # the predicate on myself and return myself\n    # if I satisfy, else I return null\n    if @children.length == 0\n      if predicate.call(null, @)\n        return @\n      else\n        return null\n    # if I have children, then start to test from\n    # the top one (the last one in the array)\n    # and proceed to test "towards the back" i.e.\n    # testing elements of the array towards 0\n    # If you find any morph satisfying, the search is\n    # over.\n    for morphNumber in [@children.length-1..0] by -1\n      morph = @children[morphNumber]\n      foundMorph = morph.topMorphSuchThat(predicate)\n      if foundMorph?\n        return foundMorph\n    # now that all children are tested, test myself\n    if predicate.call(null, @)\n      return @\n    else\n      return null\n    # ok none of my children nor me test positive,\n    # so return null.\n    return null\n\n  topmostChildSuchThat: (predicate) ->\n    # start to test from\n    # the top one (the last one in the array)\n    # and proceed to test "towards the back" i.e.\n    # testing elements of the array towards 0\n    # If you find any child that satisfies, the search is\n    # over.\n    for morphNumber in [@children.length-1..0] by -1\n      morph = @children[morphNumber]\n      if predicate.call(null, morph)\n        return morph\n    # ok none of my children test positive,\n    # so return null.\n    return null\n\n  collectAllChildrenBottomToTopSuchThat: (predicate) ->\n    collected = []\n    if predicate.call(null, @)\n      collected = [@] # include myself\n    @children.forEach (child) ->\n      collected = collected.concat(child.collectAllChildrenBottomToTopSuchThat(predicate))\n    return collected';

  return MorphicNode;

})();

Morph = (function(_super) {
  __extends(Morph, _super);

  namedClasses[Morph.name] = Morph.prototype;

  Morph.augmentWith(DeepCopierMixin);

  Morph.instancesCounter = 0;

  Morph.lastBuiltInstanceNumericID = 0;

  Morph.prototype.instanceNumericID = 0;

  Morph.prototype.propertyUpTheChain = [1, 2, 3];

  Morph.prototype.morphMethod = function() {
    return 3.14;
  };

  Morph.morphStaticMethod = function() {
    return 3.14;
  };

  Morph.prototype.isMorph = true;

  Morph.prototype.bounds = null;

  Morph.prototype.color = null;

  Morph.prototype.texture = null;

  Morph.prototype.cachedTexture = null;

  Morph.prototype.lastTime = null;

  Morph.prototype.alpha = 1;

  Morph.prototype.isMinimised = false;

  Morph.prototype.isVisible = true;

  Morph.prototype.isfloatDraggable = false;

  Morph.prototype.isTemplate = false;

  Morph.prototype.acceptsDrops = false;

  Morph.prototype.noticesTransparentClick = false;

  Morph.prototype.fps = 0;

  Morph.prototype.customContextMenu = null;

  Morph.prototype.trackChanges = true;

  Morph.prototype.shadowBlur = 10;

  Morph.prototype.image = null;

  Morph.prototype.onNextStep = null;

  Morph.prototype.allValsInMorphByName = null;

  Morph.prototype.morphValsDependingOnChildrenVals = null;

  Morph.prototype.morphValsDirectlyDependingOnParentVals = null;

  Morph.prototype.clickOutsideMeOrAnyOfMeChildrenCallback = [null];

  Morph.prototype.isMarkedForDestruction = false;

  Morph.prototype.textDescription = null;

  Morph.prototype.mouseClickRight = function() {
    return world.hand.openContextMenuAtPointer(this);
  };

  Morph.prototype.getTextDescription = function() {
    if (this.textDescription != null) {
      return this.textDescription + "" + this.constructor.name + " (adhoc description of morph)";
    } else {
      return this.constructor.name + " (class name)";
    }
  };

  Morph.prototype.identifyViaTextLabel = function() {
    var allCandidateMorphsWithSameTextDescription, myTextDescription, position, theLenght;
    myTextDescription = this.getTextDescription();
    allCandidateMorphsWithSameTextDescription = world.allChildrenTopToBottomSuchThat(function(m) {
      return m.getTextDescription() === myTextDescription;
    });
    position = allCandidateMorphsWithSameTextDescription.indexOf(this);
    theLenght = allCandidateMorphsWithSameTextDescription.length;
    console.log([myTextDescription, position, theLenght]);
    return [myTextDescription, position, theLenght];
  };

  Morph.prototype.setTextDescription = function(textDescription) {
    this.textDescription = textDescription;
  };

  Morph.prototype.markForDestruction = function() {
    world.markedForDestruction.push(this);
    return this.isMarkedForDestruction = true;
  };

  Morph.prototype.anyParentMarkedForDestruction = function() {
    if (this.isMarkedForDestruction) {
      return true;
    } else if (this.parent != null) {
      return this.parent.anyParentMarkedForDestruction();
    }
    return false;
  };


  /*
  connectValuesToAddedChild: (theChild) ->
     *if theChild.constructor.name == "RectangleMorph"
     *  debugger
  
     * we have a data structure that contains,
     * for each child valName, all vals of this
     * morph that depend on it. Go through
     * all child val names, find the
     * actual val in the child, and connect all
     * to the vals in this morph that depend on it.
    for nameOfChildrenVar, morphValsDependingOnChildrenVals of \
        @morphValsDependingOnChildrenVals
      childVal = theChild.allValsInMorphByName[ nameOfChildrenVar ]
      if childVal?
        for valNameNotUsed, valDependingOnChildrenVal of morphValsDependingOnChildrenVals
          valDependingOnChildrenVal.args.connectToChildVal valDependingOnChildrenVal, childVal
  
     * we have a data structure that contains,
     * for each parent (me) valName, all vals of the child
     * morph that depend on it. Go through
     * all parent (me) val names, find the
     * actual val in the parent (me), and connect it
     * to the vals in the child morph that depend on it.
    for nameOfParentVar, morphValsDirectlyDependingOnParentVals of \
        theChild.morphValsDirectlyDependingOnParentVals
      parentVal = @allValsInMorphByName[ nameOfParentVar ]
      if parentVal?
        for valNameNotUsed, valDependingOnParentVal of morphValsDirectlyDependingOnParentVals
          valDependingOnParentVal.args.connectToParentVal valDependingOnParentVal, parentVal
  
  disconnectValuesFromRemovedChild: (theChild) ->
     * we have a data structure that contains,
     * for each child valName, all vals of this
     * morph that depend on it. Go through
     * all child val names, find the
     * actual val in the child, and DISconnect it
     * FROM the vals in this morph that depended on it.
    for nameOfChildrenVar, morphValsDependingOnChildrenVals of \
        @morphValsDependingOnChildrenVals
      for valNameNotUsed, valDependingOnChildrenVal of morphValsDependingOnChildrenVals
        childArg = valDependingOnChildrenVal.args.argById[theChild.id]
        if childArg?
          childArg.disconnectChildArg()
  
     * we have a data structure that contains,
     * for each parent (me) valName, all vals of the child
     * morph that depend on it. Go through
     * all parent (me) val names, find the
     * actual val in the parent (me), and connect it
     * to the vals in the child morph that depend on it.
    for nameOfParentVar, morphValsDirectlyDependingOnParentVals of \
        theChild.morphValsDirectlyDependingOnParentVals
      for valNameNotUsed, valDependingOnParentVal of morphValsDirectlyDependingOnParentVals
        parentArg = valDependingOnParentVal.args.parentArgByName[ nameOfParentVar ]
        if parentArg?
          parentArg.disconnectParentArg()
   */

  Morph.prototype.uniqueIDString = function() {
    return this.morphClassString() + "#" + this.instanceNumericID;
  };

  Morph.prototype.morphClassString = function() {
    return this.constructor.name || this.constructor.toString().split(" ")[1].split("(")[0];
  };

  Morph.morphFromUniqueIDString = function(theUniqueID) {
    var result;
    result = world.topMorphSuchThat((function(_this) {
      return function(m) {
        return m.uniqueIDString() === theUniqueID;
      };
    })(this));
    if (result == null) {
      alert("theUniqueID " + theUniqueID + " not found!");
    }
    return result;
  };

  Morph.prototype.assignUniqueID = function() {
    this.constructor.instancesCounter++;
    this.constructor.lastBuiltInstanceNumericID++;
    return this.instanceNumericID = this.constructor.lastBuiltInstanceNumericID;
  };

  Morph.roundNumericIDsToNextThousand = function() {
    console.log("@roundNumericIDsToNextThousand");
    if (this.lastBuiltInstanceNumericID % 1000 === 0) {
      this.lastBuiltInstanceNumericID++;
    }
    return this.lastBuiltInstanceNumericID = 1000 * Math.ceil(this.lastBuiltInstanceNumericID / 1000);
  };

  function Morph() {
    var arr;
    Morph.__super__.constructor.call(this);
    this.assignUniqueID();
    if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.RECORDING) {
      arr = window.world.systemTestsRecorderAndPlayer.tagsCollectedWhileRecordingTest;
      if ((arr.indexOf(this.constructor.name)) === -1) {
        arr.push(this.constructor.name);
      }
    }
    this.bounds = new Rectangle(0, 0, 50, 40);
    this.color = this.color || new Color(80, 80, 80);
    this.lastTime = Date.now();
    this.allValsInMorphByName = {};
    this.morphValsDependingOnChildrenVals = {};
    this.morphValsDirectlyDependingOnParentVals = {};
  }

  Morph.prototype.toString = function() {
    var firstPart;
    firstPart = "a ";
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.IDLE && AutomatorRecorderAndPlayer.hidingOfMorphsNumberIDInLabels) {
      firstPart = firstPart + this.morphClassString();
    } else {
      firstPart = firstPart + this.uniqueIDString();
    }
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.IDLE && AutomatorRecorderAndPlayer.hidingOfMorphsGeometryInfoInLabels) {
      return firstPart;
    } else {
      return firstPart + " " + this.bounds;
    }
  };

  Morph.prototype.toStringWithoutGeometry = function() {
    return "a " + this.uniqueIDString();
  };

  Morph.prototype.destroy = function() {
    this.visible = false;
    console.log("****** destroying morph");
    this.onClickOutsideMeOrAnyOfMyChildren(null);
    if (this.parent != null) {
      this.fullChanged();
      this.parent.removeChild(this);
    }
    return null;
  };

  Morph.prototype.destroyAll = function() {
    while (this.children.length !== 0) {
      this.children[0].destroy();
    }
    return null;
  };

  Morph.prototype.runChildrensStepFunction = function() {
    var elapsed, nxt, timeRemainingToWaitedFrame;
    if (!this.step) {
      return null;
    }
    elapsed = WorldMorph.currentTime - this.lastTime;
    if (this.fps > 0) {
      timeRemainingToWaitedFrame = (1000 / this.fps) - elapsed;
    } else {
      timeRemainingToWaitedFrame = 0;
    }
    if (timeRemainingToWaitedFrame < 1) {
      this.lastTime = WorldMorph.currentTime;
      if (this.onNextStep) {
        nxt = this.onNextStep;
        this.onNextStep = null;
        nxt.call(this);
      }
      this.step();
      return this.children.forEach(function(child) {
        if (child.runChildrensStepFunction == null) {
          debugger;
        }
        return child.runChildrensStepFunction();
      });
    }
  };

  Morph.prototype.nextSteps = function(arrayOfFunctions) {
    var lst, nxt;
    lst = arrayOfFunctions || [];
    nxt = lst.shift();
    if (nxt) {
      return this.onNextStep = (function(_this) {
        return function() {
          nxt.call(_this);
          return _this.nextSteps(lst);
        };
      })(this);
    }
  };

  Morph.prototype.step = noOperation;

  Morph.prototype.left = function() {
    return this.bounds.left();
  };

  Morph.prototype.right = function() {
    return this.bounds.right();
  };

  Morph.prototype.top = function() {
    return this.bounds.top();
  };

  Morph.prototype.bottom = function() {
    return this.bounds.bottom();
  };

  Morph.prototype.center = function() {
    return this.bounds.center();
  };

  Morph.prototype.bottomCenter = function() {
    return this.bounds.bottomCenter();
  };

  Morph.prototype.bottomLeft = function() {
    return this.bounds.bottomLeft();
  };

  Morph.prototype.bottomRight = function() {
    return this.bounds.bottomRight();
  };

  Morph.prototype.boundingBox = function() {
    return this.bounds;
  };

  Morph.prototype.corners = function() {
    return this.bounds.corners();
  };

  Morph.prototype.leftCenter = function() {
    return this.bounds.leftCenter();
  };

  Morph.prototype.rightCenter = function() {
    return this.bounds.rightCenter();
  };

  Morph.prototype.topCenter = function() {
    return this.bounds.topCenter();
  };

  Morph.prototype.topLeft = function() {
    return this.bounds.topLeft();
  };

  Morph.prototype.topRight = function() {
    return this.bounds.topRight();
  };

  Morph.prototype.position = function() {
    return this.bounds.origin;
  };

  Morph.prototype.extent = function() {
    return this.bounds.extent();
  };

  Morph.prototype.width = function() {
    return this.bounds.width();
  };

  Morph.prototype.height = function() {
    return this.bounds.height();
  };

  Morph.prototype.plausibleTargetAndDestinationMorphs = function(theMorph) {
    var result;
    result = [];
    if (!this.isMinimised && this.isVisible && !theMorph.containedInParentsOf(this) && this.bounds.intersects(theMorph.bounds) && !this.anyParentMarkedForDestruction()) {
      result = [this];
    }
    this.children.forEach(function(child) {
      return result = result.concat(child.plausibleTargetAndDestinationMorphs(theMorph));
    });
    return result;
  };


  /*
  mergedBoundsOfChildren: ->
    result = new Rectangle(0,0)
    @children.forEach (child) ->
      if !child.isMinimised and child.isVisible
        result = result.merge(child.boundsIncludingChildren())
    result
   */

  Morph.prototype.boundsIncludingChildren = function() {
    var result;
    result = this.bounds;
    this.children.forEach(function(child) {
      if (!child.isMinimised && child.isVisible) {
        return result = result.merge(child.boundsIncludingChildren());
      }
    });
    return result;
  };

  Morph.prototype.boundsIncludingChildrenNoShadow = function() {
    var result;
    result = this.bounds;
    this.children.forEach(function(child) {
      if ((!(child instanceof ShadowMorph)) && (!child.isMinimised) && child.isVisible) {
        return result = result.merge(child.boundsIncludingChildrenNoShadow());
      }
    });
    return result;
  };

  Morph.prototype.visibleBounds = function() {
    var frames, visible;
    visible = this.bounds;
    frames = this.allParentsTopToBottomSuchThat(function(p) {
      return p instanceof FrameMorph;
    });
    frames.forEach(function(f) {
      return visible = visible.intersect(f.bounds);
    });
    return visible;
  };

  Morph.prototype.moveBy = function(delta) {
    this.changed();
    this.bounds = this.bounds.translateBy(delta);
    this.children.forEach(function(child) {
      return child.moveBy(delta);
    });
    return this.changed();
  };

  Morph.prototype.silentMoveBy = function(delta) {
    this.bounds = this.bounds.translateBy(delta);
    return this.children.forEach(function(child) {
      return child.silentMoveBy(delta);
    });
  };

  Morph.prototype.setPosition = function(aPoint) {
    var delta;
    aPoint.debugIfFloats();
    delta = aPoint.subtract(this.topLeft());
    if ((delta.x !== 0) || (delta.y !== 0)) {
      this.moveBy(delta);
    }
    return this.bounds.debugIfFloats();
  };

  Morph.prototype.silentSetPosition = function(aPoint) {
    var delta;
    delta = aPoint.subtract(this.topLeft());
    if ((delta.x !== 0) || (delta.y !== 0)) {
      return this.silentMoveBy(delta);
    }
  };

  Morph.prototype.setLeft = function(x) {
    return this.setPosition(new Point(x, this.top()));
  };

  Morph.prototype.setRight = function(x) {
    return this.setPosition(new Point(x - this.width(), this.top()));
  };

  Morph.prototype.setTop = function(y) {
    return this.setPosition(new Point(this.left(), y));
  };

  Morph.prototype.setBottom = function(y) {
    return this.setPosition(new Point(this.left(), y - this.height()));
  };

  Morph.prototype.setCenter = function(aPoint) {
    return this.setPosition(aPoint.subtract(this.extent().floorDivideBy(2)));
  };

  Morph.prototype.setFullCenter = function(aPoint) {
    return this.setPosition(aPoint.subtract(this.boundsIncludingChildren().extent().floorDivideBy(2)));
  };

  Morph.prototype.keepWithin = function(aMorph) {
    var bottomOff, leftOff, rightOff, topOff;
    leftOff = this.boundsIncludingChildren().left() - aMorph.left();
    if (leftOff < 0) {
      this.moveBy(new Point(-leftOff, 0));
    }
    rightOff = this.boundsIncludingChildren().right() - aMorph.right();
    if (rightOff > 0) {
      this.moveBy(new Point(-rightOff, 0));
    }
    topOff = this.boundsIncludingChildren().top() - aMorph.top();
    if (topOff < 0) {
      this.moveBy(new Point(0, -topOff));
    }
    bottomOff = this.boundsIncludingChildren().bottom() - aMorph.bottom();
    if (bottomOff > 0) {
      return this.moveBy(new Point(0, -bottomOff));
    }
  };

  Morph.prototype.layoutSubmorphs = function() {};

  Morph.prototype.setExtent = function(aPoint) {
    if (!aPoint.eq(this.extent())) {
      this.changed();
      this.silentSetExtent(aPoint);
      this.changed();
      this.setLayoutBeforeUpdatingBackingStore();
      this.updateBackingStore();
      return this.layoutSubmorphs();
    }
  };

  Morph.prototype.silentSetExtent = function(aPoint) {
    var ext, newHeight, newWidth;
    ext = aPoint.round();
    newWidth = Math.max(ext.x, 0);
    newHeight = Math.max(ext.y, 0);
    return this.bounds.corner = new Point(this.bounds.origin.x + newWidth, this.bounds.origin.y + newHeight);
  };

  Morph.prototype.setWidth = function(width) {
    return this.setExtent(new Point(width || 0, this.height()));
  };

  Morph.prototype.silentSetWidth = function(width) {
    var w;
    w = Math.max(Math.round(width || 0), 0);
    return this.bounds.corner = new Point(this.bounds.origin.x + w, this.bounds.corner.y);
  };

  Morph.prototype.setHeight = function(height) {
    return this.setExtent(new Point(this.width(), height || 0));
  };

  Morph.prototype.silentSetHeight = function(height) {
    var h;
    h = Math.max(Math.round(height || 0), 0);
    return this.bounds.corner = new Point(this.bounds.corner.x, this.bounds.origin.y + h);
  };

  Morph.prototype.setColor = function(aColorOrAMorphGivingAColor, morphGivingColor) {
    var aColor;
    if ((morphGivingColor != null ? morphGivingColor.getColor : void 0) != null) {
      aColor = morphGivingColor.getColor();
    } else {
      aColor = aColorOrAMorphGivingAColor;
    }
    if (aColor) {
      if (!this.color.eq(aColor)) {
        this.color = aColor;
        this.changed();
        this.updateBackingStore();
      }
    }
    return aColor;
  };

  Morph.prototype.updateBackingStore = function() {
    this.changed();
    this.silentUpdateBackingStore();
    return this.changed();
  };

  Morph.prototype.drawTexture = function(url) {
    this.cachedTexture = new Image();
    this.cachedTexture.onload = (function(_this) {
      return function() {
        return _this.drawCachedTexture();
      };
    })(this);
    return this.cachedTexture.src = this.texture = url;
  };

  Morph.prototype.drawCachedTexture = function() {
    var bg, cols, context, lines, x, y, _i, _j;
    bg = this.cachedTexture;
    cols = Math.floor(this.image.width / bg.width);
    lines = Math.floor(this.image.height / bg.height);
    context = this.image.getContext("2d");
    for (y = _i = 0; 0 <= lines ? _i <= lines : _i >= lines; y = 0 <= lines ? ++_i : --_i) {
      for (x = _j = 0; 0 <= cols ? _j <= cols : _j >= cols; x = 0 <= cols ? ++_j : --_j) {
        context.drawImage(bg, Math.round(x * bg.width), Math.round(y * bg.height));
      }
    }
    return this.changed();
  };

  Morph.prototype.isTransparentAt = function() {
    return false;
  };

  Morph.prototype.silentUpdateBackingStore = function() {};

  Morph.prototype.blit = function(aCanvas, clippingRectangle) {
    var al, area, at, context, delta, h, randomB, randomG, randomR, sl, src, st, w;
    if (this.isMinimised || !this.isVisible) {
      return null;
    }
    area = clippingRectangle.intersect(this.bounds).round();
    if (area.isNotEmpty()) {
      delta = this.position().neg();
      src = area.copy().translateBy(delta).round();
      context = aCanvas.getContext("2d");
      context.globalAlpha = this.alpha;
      sl = src.left() * pixelRatio;
      st = src.top() * pixelRatio;
      al = area.left() * pixelRatio;
      at = area.top() * pixelRatio;
      w = Math.min(src.width() * pixelRatio, this.width() * pixelRatio - sl);
      h = Math.min(src.height() * pixelRatio, this.height() * pixelRatio - st);
      if (w < 1 || h < 1) {
        return null;
      }
      context.save();
      context.fillStyle = this.color.toString();
      context.fillRect(Math.round(al), Math.round(at), Math.round(w), Math.round(h));
      context.restore();
      if (world.showRedraws) {
        randomR = Math.round(Math.random() * 255);
        randomG = Math.round(Math.random() * 255);
        randomB = Math.round(Math.random() * 255);
        context.save();
        context.globalAlpha = 0.5;
        context.fillStyle = "rgb(" + randomR + "," + randomG + "," + randomB + ")";
        context.fillRect(Math.round(al), Math.round(at), Math.round(w), Math.round(h));
        return context.restore();
      }
    }
  };

  Morph.prototype.recursivelyBlit = function(aCanvas, clippingRectangle) {
    if (clippingRectangle == null) {
      clippingRectangle = this.boundsIncludingChildren();
    }
    if (this.isMinimised || !this.isVisible) {
      return null;
    }
    this.blit(aCanvas, clippingRectangle);
    return this.children.forEach(function(child) {
      return child.recursivelyBlit(aCanvas, clippingRectangle);
    });
  };

  Morph.prototype.hide = function() {
    this.isVisible = false;
    this.changed();
    return this.children.forEach(function(child) {
      return child.hide();
    });
  };

  Morph.prototype.show = function() {
    this.isVisible = true;
    this.changed();
    return this.children.forEach(function(child) {
      return child.show();
    });
  };

  Morph.prototype.minimise = function() {
    this.isMinimised = true;
    this.changed();
    return this.children.forEach(function(child) {
      return child.minimise();
    });
  };

  Morph.prototype.unminimise = function() {
    this.isMinimised = false;
    this.changed();
    return this.children.forEach(function(child) {
      return child.unminimise();
    });
  };

  Morph.prototype.toggleVisibility = function() {
    this.isMinimised = !this.isMinimised;
    this.changed();
    return this.children.forEach(function(child) {
      return child.toggleVisibility();
    });
  };

  Morph.prototype.fullImage = function(bounds) {
    var ctx, img;
    if (bounds == null) {
      bounds = this.boundsIncludingChildren();
    }
    img = newCanvas(bounds.extent().scaleBy(pixelRatio));
    ctx = img.getContext("2d");
    ctx.translate(-bounds.origin.x * pixelRatio, -bounds.origin.y * pixelRatio);
    this.recursivelyBlit(img, bounds);
    return img;
  };

  Morph.prototype.fullImageNoShadow = function() {
    var boundsWithNoShadow;
    boundsWithNoShadow = this.boundsIncludingChildrenNoShadow();
    return this.fullImage(boundsWithNoShadow);
  };

  Morph.prototype.fullImageData = function() {
    return this.fullImage().toDataURL("image/png");
  };

  Morph.prototype.asItAppearsOnScreen = function() {
    var destCanvas, destCtx, fullExtentOfMorph;
    fullExtentOfMorph = this.boundsIncludingChildren();
    destCanvas = newCanvas(fullExtentOfMorph.extent().scaleBy(pixelRatio));
    destCtx = destCanvas.getContext('2d');
    destCtx.drawImage(world.worldCanvas, fullExtentOfMorph.topLeft().x * pixelRatio, fullExtentOfMorph.topLeft().y * pixelRatio, fullExtentOfMorph.width() * pixelRatio, fullExtentOfMorph.height() * pixelRatio, 0, 0, fullExtentOfMorph.width() * pixelRatio, fullExtentOfMorph.height() * pixelRatio);
    return destCanvas.toDataURL("image/png");
  };

  Morph.prototype.fullImageHashCode = function() {
    return hashCode(this.fullImageData());
  };

  Morph.prototype.shadowImage = function(off_, color) {
    var clr, ctx, fb, img, offset, outline, sha;
    offset = off_ || new Point(7, 7);
    clr = color || new Color(0, 0, 0);
    fb = this.boundsIncludingChildrenNoShadow().extent();
    img = this.fullImage();
    outline = newCanvas(fb.scaleBy(pixelRatio));
    ctx = outline.getContext("2d");
    ctx.drawImage(img, 0, 0);
    ctx.globalCompositeOperation = "destination-out";
    ctx.drawImage(img, Math.round(-offset.x * pixelRatio), Math.round(-offset.y * pixelRatio));
    sha = newCanvas(fb.scaleBy(pixelRatio));
    ctx = sha.getContext("2d");
    ctx.drawImage(outline, 0, 0);
    ctx.globalCompositeOperation = "source-atop";
    ctx.fillStyle = clr.toString();
    ctx.fillRect(0, 0, fb.x * pixelRatio, fb.y * pixelRatio);
    return sha;
  };

  Morph.prototype.shadowImageBlurred = function(off_, color) {
    var blur, clr, ctx, fb, img, offset, sha;
    offset = off_ || new Point(7, 7);
    blur = this.shadowBlur;
    clr = color || new Color(0, 0, 0);
    fb = this.boundsIncludingChildrenNoShadow().extent().add(blur * 2);
    img = this.fullImageNoShadow();
    sha = newCanvas(fb.scaleBy(pixelRatio));
    ctx = sha.getContext("2d");
    ctx.shadowOffsetX = offset.x * pixelRatio;
    ctx.shadowOffsetY = offset.y * pixelRatio;
    ctx.shadowBlur = blur * pixelRatio;
    ctx.shadowColor = clr.toString();
    ctx.drawImage(img, Math.round((blur - offset.x) * pixelRatio), Math.round((blur - offset.y) * pixelRatio));
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.shadowBlur = 0;
    ctx.globalCompositeOperation = "destination-out";
    ctx.drawImage(img, Math.round((blur - offset.x) * pixelRatio), Math.round((blur - offset.y) * pixelRatio));
    return sha;
  };

  Morph.prototype.addShadow = function(offset, alpha, color) {
    var shadow;
    shadow = this.silentAddShadow(offset, alpha, color);
    shadow.setLayoutBeforeUpdatingBackingStore();
    shadow.updateBackingStore();
    this.fullChanged();
    return shadow;
  };

  Morph.prototype.silentAddShadow = function(offset, alpha, color) {
    var shadow;
    shadow = new ShadowMorph(this, offset, alpha, color);
    this.addChildFirst(shadow);
    return shadow;
  };

  Morph.prototype.getShadow = function() {
    return this.topmostChildSuchThat(function(child) {
      return child instanceof ShadowMorph;
    });
  };

  Morph.prototype.removeShadow = function() {
    var shadow;
    shadow = this.getShadow();
    if (shadow != null) {
      this.fullChanged();
      return this.removeChild(shadow);
    }
  };

  Morph.prototype.changed = function() {
    var boundsToBeChanged, w;
    if (this.trackChanges) {
      w = this.root();
      if ((w instanceof HandMorph) || (w instanceof WorldMorph && (this instanceof WorldMorph || (this.parent != null)))) {
        if (w instanceof HandMorph) {
          w = w.world;
          boundsToBeChanged = this.boundsIncludingChildren().spread();
        } else {
          boundsToBeChanged = this.visibleBounds().spread();
        }
        w.broken.push(boundsToBeChanged);
      }
    }
    if (this.parent) {
      return this.parent.childChanged(this);
    }
  };

  Morph.prototype.fullChanged = function() {
    var w;
    if (this.trackChanges) {
      w = this.root();
      if ((w instanceof HandMorph) || (w instanceof WorldMorph && (this instanceof WorldMorph || (this.parent != null)))) {
        if (w instanceof HandMorph) {
          w = w.world;
        }
        return w.broken.push(this.boundsIncludingChildren().spread());
      }
    }
  };

  Morph.prototype.childChanged = function() {
    if (this.parent) {
      return this.parent.childChanged(this);
    }
  };

  Morph.prototype.world = function() {
    var root;
    root = this.root();
    if (root instanceof WorldMorph) {
      return root;
    }
    if (root instanceof HandMorph) {
      return root.world;
    }
    return null;
  };

  Morph.prototype.imBeingAddedTo = function(newParentMorph) {
    this.setLayoutBeforeUpdatingBackingStore();
    return this.updateBackingStore();
  };

  Morph.prototype.add = function(aMorph) {
    if (aMorph.parent != null) {
      aMorph.changed();
    }
    this.silentAdd(aMorph, true);
    return aMorph.imBeingAddedTo(this);
  };

  Morph.prototype.setLayoutBeforeUpdatingBackingStore = function() {};

  Morph.prototype.calculateAndUpdateExtent = function() {};

  Morph.prototype.silentAdd = function(aMorph, avoidExtentCalculation) {
    var owner;
    owner = aMorph.parent;
    if (owner != null) {
      owner.removeChild(aMorph);
    }
    aMorph.isMarkedForDestruction = false;
    this.addChild(aMorph);
    if (!avoidExtentCalculation) {
      return aMorph.calculateAndUpdateExtent();
    }
  };

  Morph.prototype.morphAt = function(aPoint) {
    var morphs, result;
    morphs = this.allChildrenTopToBottom();
    result = null;
    morphs.forEach(function(m) {
      if (m.boundsIncludingChildren().containsPoint(aPoint) && (result === null)) {
        return result = m;
      }
    });
    return result;
  };

  Morph.prototype.getPixelColor = function(aPoint) {
    var context, data, point;
    point = aPoint.subtract(this.bounds.origin);
    context = this.image.getContext("2d");
    data = context.getImageData(point.x * pixelRatio, point.y * pixelRatio, 1, 1);
    return new Color(data.data[0], data.data[1], data.data[2], data.data[3]);
  };


  /* not currently used
  completelyRepaint: ()->
    allMorphsInStructure = @allChildrenBottomToTop()
    for eachMorph in allMorphsInStructure
      if eachMorph.updateBackingStore?
        eachMorph.updateBackingStore()
        eachMorph.changed()
   */

  Morph.prototype.duplicateMenuAction = function() {
    var aFullCopy;
    aFullCopy = this.fullCopy();
    return aFullCopy.pickUp();
  };

  Morph.prototype.fullCopy = function() {
    var allMorphsInStructure, copiedMorph;
    allMorphsInStructure = this.allChildrenBottomToTop();
    copiedMorph = this.deepCopy(false, [], [], allMorphsInStructure);
    if (copiedMorph instanceof MenuMorph) {
      copiedMorph.onClickOutsideMeOrAnyOfMyChildren(null);
      copiedMorph.killThisMenuIfClickOnDescendantsTriggers = false;
      copiedMorph.killThisMenuIfClickOutsideDescendants = false;
    }
    return copiedMorph;
  };

  Morph.prototype.serialize = function() {
    var allMorphsInStructure, arr1, arr2, e, element, totalJSON, _i, _len;
    allMorphsInStructure = this.allChildrenBottomToTop();
    arr1 = [];
    arr2 = [];
    this.deepCopy(true, arr1, arr2, allMorphsInStructure);
    totalJSON = "";
    for (_i = 0, _len = arr2.length; _i < _len; _i++) {
      element = arr2[_i];
      try {
        console.log(JSON.stringify(element) + "\n// --------------------------- \n");
      } catch (_error) {
        e = _error;
        debugger;
      }
      totalJSON = totalJSON + JSON.stringify(element) + "\n// --------------------------- \n";
    }
    return totalJSON;
  };

  Morph.prototype.deserialize = function(serializationString) {
    var clonedMorphs, createdObjects, ctx, eachArrayElement, eachClonedMorph, eachObject, eachSerialization, i, image, j, objectsSerializations, property, referenceNumber, referenceNumberAsString, theClone, _i, _j, _k, _l, _len, _len1, _ref, _ref1;
    objectsSerializations = serializationString.split(/^\/\/.*$/gm);
    objectsSerializations.pop();
    createdObjects = [];
    for (_i = 0, _len = objectsSerializations.length; _i < _len; _i++) {
      eachSerialization = objectsSerializations[_i];
      createdObjects.push(JSON.parse(eachSerialization));
    }
    clonedMorphs = [];
    for (_j = 0, _len1 = createdObjects.length; _j < _len1; _j++) {
      eachObject = createdObjects[_j];
      if (eachObject.className === "Canvas") {
        theClone = newCanvas(new Point(eachObject.width, eachObject.height));
        ctx = theClone.getContext("2d");
        image = new Image();
        image.src = eachObject.data;
        ctx.drawImage(image, 0, 0);
      } else if (eachObject.constructor !== Array) {
        theClone = Object.create(namedClasses[eachObject.className]);
        if (theClone.assignUniqueID != null) {
          theClone.assignUniqueID();
        }
      } else {
        theClone = [];
      }
      clonedMorphs.push(theClone);
    }
    for (i = _k = 0, _ref = clonedMorphs.length; 0 <= _ref ? _k < _ref : _k > _ref; i = 0 <= _ref ? ++_k : --_k) {
      eachClonedMorph = clonedMorphs[i];
      if (eachClonedMorph.constructor === HTMLCanvasElement) {

      } else if (eachClonedMorph.constructor !== Array) {
        for (property in createdObjects[i]) {
          if (createdObjects[i].hasOwnProperty(property)) {
            console.log("looking at property: " + property);
            clonedMorphs[i][property] = createdObjects[i][property];
            if (typeof clonedMorphs[i][property] === "string") {
              if ((clonedMorphs[i][property].indexOf("$")) === 0) {
                referenceNumberAsString = clonedMorphs[i][property].substring(1);
                referenceNumber = parseInt(referenceNumberAsString);
                clonedMorphs[i][property] = clonedMorphs[referenceNumber];
              }
            }
          }
        }
      } else {
        for (j = _l = 0, _ref1 = createdObjects[i].length; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; j = 0 <= _ref1 ? ++_l : --_l) {
          eachArrayElement = createdObjects[i][j];
          clonedMorphs[i][j] = createdObjects[i][j];
          if (typeof eachArrayElement === "string") {
            if ((eachArrayElement.indexOf("$")) === 0) {
              referenceNumberAsString = eachArrayElement.substring(1);
              referenceNumber = parseInt(referenceNumberAsString);
              clonedMorphs[i][j] = clonedMorphs[referenceNumber];
            }
          }
        }
      }
    }
    return clonedMorphs[0];
  };

  Morph.prototype.rootForGrab = function() {
    if (this instanceof ShadowMorph) {
      return this.parent.rootForGrab();
    }
    if (this.parent instanceof ScrollFrameMorph) {
      return this.parent;
    }
    if (this.parent === null || this.parent instanceof WorldMorph || this.parent instanceof FrameMorph || this.isfloatDraggable === true) {
      return this;
    }
    return this.parent.rootForGrab();
  };

  Morph.prototype.firstContainerMenu = function() {
    var scanningMorphs;
    scanningMorphs = this;
    while (scanningMorphs.parent != null) {
      scanningMorphs = scanningMorphs.parent;
      if (scanningMorphs instanceof MenuMorph) {
        if (!scanningMorphs.isMarkedForDestruction) {
          return scanningMorphs;
        }
      }
    }
    return scanningMorphs;
    if (this instanceof ShadowMorph) {
      return this.parent.rootForFocus();
    }
    if (this.parent === null || this.parent instanceof WorldMorph) {
      return this;
    }
    return this.parent.rootForFocus();
  };

  Morph.prototype.rootForFocus = function() {
    if (this instanceof ShadowMorph) {
      return this.parent.rootForFocus();
    }
    if (this.parent === null || this.parent instanceof WorldMorph) {
      return this;
    }
    return this.parent.rootForFocus();
  };

  Morph.prototype.bringToForegroud = function() {
    var _ref, _ref1;
    if ((_ref = this.rootForFocus()) != null) {
      _ref.moveAsLastChild();
    }
    return (_ref1 = this.rootForFocus()) != null ? _ref1.fullChanged() : void 0;
  };

  Morph.prototype.propagateKillMenus = function() {
    if (this.parent != null) {
      return this.parent.propagateKillMenus();
    }
  };

  Morph.prototype.mouseClickLeft = function() {
    return this.bringToForegroud();
  };

  Morph.prototype.onClickOutsideMeOrAnyOfMyChildren = function(functionName, arg1, arg2, arg3) {
    var index;
    if (functionName != null) {
      this.clickOutsideMeOrAnyOfMeChildrenCallback = [functionName, arg1, arg2, arg3];
      if ((world.morphsDetectingClickOutsideMeOrAnyOfMeChildren.indexOf(this)) < 0) {
        return world.morphsDetectingClickOutsideMeOrAnyOfMeChildren.push(this);
      }
    } else {
      console.log("****** onClickOutsideMeOrAnyOfMyChildren removing element");
      index = world.morphsDetectingClickOutsideMeOrAnyOfMeChildren.indexOf(this);
      if (index >= 0) {
        return world.morphsDetectingClickOutsideMeOrAnyOfMeChildren.splice(index, 1);
      }
    }
  };

  Morph.prototype.wantsDropOf = function(aMorph) {
    if ((aMorph instanceof HandleMorph) || (aMorph instanceof MenuMorph)) {
      return false;
    }
    return this.acceptsDrops;
  };

  Morph.prototype.pickUp = function() {
    world.hand.grab(this);
    return this.setPosition(world.hand.position().subtract(this.boundsIncludingChildrenNoShadow().extent().floorDivideBy(2)));
  };

  Morph.prototype.isPickedUp = function() {
    return this.parentThatIsA(HandMorph) != null;
  };

  Morph.prototype.situation = function() {
    if (this.parent) {
      return {
        origin: this.parent,
        position: this.position().subtract(this.parent.position())
      };
    }
    return null;
  };

  Morph.prototype.slideBackTo = function(situation, inSteps) {
    var oldFps, oldStep, pos, stepCount, steps, xStep, yStep;
    steps = inSteps || 5;
    pos = situation.origin.position().add(situation.position);
    xStep = -(this.left() - pos.x) / steps;
    yStep = -(this.top() - pos.y) / steps;
    stepCount = 0;
    oldStep = this.step;
    oldFps = this.fps;
    this.fps = 0;
    return this.step = (function(_this) {
      return function() {
        _this.fullChanged();
        _this.silentMoveBy(new Point(xStep, yStep));
        _this.fullChanged();
        stepCount += 1;
        if (stepCount === steps) {
          situation.origin.add(_this);
          if (situation.origin.reactToDropOf) {
            situation.origin.reactToDropOf(_this);
          }
          _this.step = oldStep;
          return _this.fps = oldFps;
        }
      };
    })(this);
  };

  Morph.prototype.resize = function() {
    return this.world().activeHandle = new HandleMorph(this);
  };

  Morph.prototype.move = function() {
    return this.world().activeHandle = new HandleMorph(this, null, null, null, null, "move");
  };

  Morph.prototype.hint = function(msg) {
    var m, text;
    text = msg;
    if (msg) {
      if (msg.toString) {
        text = msg.toString();
      }
    } else {
      text = "NULL";
    }
    m = new MenuMorph(false, this, true, true, text);
    m.isfloatDraggable = true;
    return m.popUpCenteredAtHand(this.world());
  };

  Morph.prototype.inform = function(msg) {
    var m, text;
    text = msg;
    if (msg) {
      if (msg.toString) {
        text = msg.toString();
      }
    } else {
      text = "NULL";
    }
    m = new MenuMorph(false, this, true, true, text);
    m.addItem("Ok");
    m.isfloatDraggable = true;
    return m.popUpCenteredAtHand(this.world());
  };

  Morph.prototype.prompt = function(msg, target, callback, defaultContents, width, floorNum, ceilingNum, isRounded) {
    var isNumeric, menu, slider, tempPromptEntryField;
    if (ceilingNum) {
      isNumeric = true;
    }
    tempPromptEntryField = new StringFieldMorph(defaultContents || "", width || 100, WorldMorph.preferencesAndSettings.prompterFontSize, WorldMorph.preferencesAndSettings.prompterFontName, false, false, isNumeric);
    menu = new MenuMorph(false, target, true, true, msg || "", tempPromptEntryField);
    menu.tempPromptEntryField = tempPromptEntryField;
    menu.items.push(tempPromptEntryField);
    if (ceilingNum || WorldMorph.preferencesAndSettings.useSliderForInput) {
      slider = new SliderMorph(floorNum || 0, ceilingNum, parseFloat(defaultContents), Math.floor((ceilingNum - floorNum) / 4), "horizontal");
      slider.alpha = 1;
      slider.color = new Color(225, 225, 225);
      slider.button.color = new Color(60, 60, 60);
      slider.button.highlightColor = slider.button.color.copy();
      slider.button.highlightColor.b += 100;
      slider.button.pressColor = slider.button.color.copy();
      slider.button.pressColor.b += 150;
      slider.silentSetHeight(WorldMorph.preferencesAndSettings.prompterSliderSize);
      slider.target = this;
      slider.argumentToAction = menu;
      if (isRounded) {
        slider.action = "reactToSliderAction1";
      } else {
        slider.action = "reactToSliderAction2";
      }
      menu.items.push(slider);
    }
    menu.addLine(2);
    menu.addItem("Ok", true, target, callback);
    menu.addItem("Cancel", true, this, function() {
      return null;
    });
    menu.isfloatDraggable = true;
    menu.popUpAtHand(this.firstContainerMenu());
    return tempPromptEntryField.text.edit();
  };

  Morph.prototype.reactToSliderAction1 = function(num, theMenu) {
    theMenu.tempPromptEntryField.changed();
    theMenu.tempPromptEntryField.text.text = Math.round(num).toString();
    theMenu.tempPromptEntryField.text.setLayoutBeforeUpdatingBackingStore();
    theMenu.tempPromptEntryField.text.updateBackingStore();
    theMenu.tempPromptEntryField.text.changed();
    return theMenu.tempPromptEntryField.text.edit();
  };

  Morph.prototype.reactToSliderAction2 = function(num, theMenu) {
    theMenu.tempPromptEntryField.changed();
    theMenu.tempPromptEntryField.text.text = num.toString();
    theMenu.tempPromptEntryField.text.setLayoutBeforeUpdatingBackingStore();
    theMenu.tempPromptEntryField.text.updateBackingStore();
    return theMenu.tempPromptEntryField.text.changed();
  };

  Morph.prototype.pickColor = function(msg, callback, defaultContents) {
    var colorPicker, menu;
    colorPicker = new ColorPickerMorph(defaultContents);
    menu = new MenuMorph(false, this, true, true, msg || "", colorPicker);
    menu.items.push(colorPicker);
    menu.addLine(2);
    menu.addItem("Ok", true, this, callback);
    menu.addItem("Cancel", true, this, function() {
      return null;
    });
    menu.isfloatDraggable = true;
    return menu.popUpAtHand(this.firstContainerMenu());
  };

  Morph.prototype.inspect = function(anotherObject) {
    return this.spawnInspector(this);
  };

  Morph.prototype.spawnInspector = function(inspectee) {
    var inspector, world;
    inspector = new InspectorMorph(inspectee);
    world = (this.world instanceof Function ? this.world() : this.root() || this.world);
    inspector.setPosition(world.hand.position());
    inspector.keepWithin(world);
    world.add(inspector);
    return inspector.changed();
  };

  Morph.prototype.contextMenu = function() {
    var world;
    if (this.customContextMenu) {
      return this.customContextMenu();
    }
    world = (this.world instanceof Function ? this.world() : this.root() || this.world);
    if (world && world.isDevMode) {
      if (this.parent === world) {
        return this.developersMenu();
      }
      return this.hierarchyMenu();
    }
    return this.userMenu() || (this.parent && this.parent.userMenu());
  };

  Morph.prototype.hierarchyMenu = function() {
    var menu, parents, world;
    parents = this.allParentsTopToBottom();
    world = (this.world instanceof Function ? this.world() : this.root() || this.world);
    menu = new MenuMorph(false, this, true, true, null);
    parents.forEach(function(each) {
      var textLabelForMorph;
      if (each.developersMenu && (each !== world) && (!each.anyParentMarkedForDestruction())) {
        textLabelForMorph = each.toString().slice(0, 50);
        return menu.addItem(textLabelForMorph + " ➜", false, each, "popupDeveloperMenu");
      }
    });
    return menu;
  };

  Morph.prototype.popupDeveloperMenu = function(morphTriggeringThis) {
    return this.developersMenu().popUpAtHand(morphTriggeringThis.firstContainerMenu());
  };

  Morph.prototype.popUpColorSetter = function() {
    return this.pickColor("color:", "setColor", "color");
  };

  Morph.prototype.transparencyPopout = function(menuItem) {
    return this.prompt(menuItem.parent.title + "\nalpha\nvalue:", this, "setAlphaScaled", (this.alpha * 100).toString(), null, 1, 100, true);
  };

  Morph.prototype.testMenu = function(ignored, targetMorph) {
    var menu;
    menu = new MenuMorph(false, targetMorph, true, true, null);
    menu.addItem("serialise morph to memory", true, targetMorph, "serialiseToMemory");
    menu.addItem("deserialize from memory and attach to world", true, targetMorph, "deserialiseFromMemoryAndAttachToWorld");
    menu.addItem("deserialize from memory and attach to hand", true, targetMorph, "deserialiseFromMemoryAndAttachToHand");
    return menu.popUpAtHand(this.firstContainerMenu());
  };

  Morph.prototype.serialiseToMemory = function() {
    return world.lastSerializationString = this.serialize();
  };

  Morph.prototype.deserialiseFromMemoryAndAttachToHand = function() {
    var derezzedObject;
    derezzedObject = world.deserialize(world.lastSerializationString);
    return derezzedObject.pickUp();
  };

  Morph.prototype.deserialiseFromMemoryAndAttachToWorld = function() {
    var derezzedObject;
    derezzedObject = world.deserialize(world.lastSerializationString);
    return world.add(derezzedObject);
  };

  Morph.prototype.developersMenu = function() {
    var menu, takePic, userMenu;
    userMenu = this.userMenu() || (this.parent && this.parent.userMenu());
    menu = new MenuMorph(false, this, true, true, this.constructor.name || this.constructor.toString().split(" ")[1].split("(")[0]);
    if (userMenu) {
      menu.addItem("user features...", true, this, function() {
        return userMenu.popUpAtHand(this.firstContainerMenu());
      });
      menu.addLine();
    }
    menu.addItem("color...", true, this, "popUpColorSetter", "choose another color \nfor this morph");
    menu.addItem("transparency...", true, this, "transparencyPopout", "set this morph's\nalpha value");
    menu.addItem("resize...", true, this, "resize", "show a handle\nwhich can be floatDragged\nto change this morph's" + " extent");
    menu.addLine();
    menu.addItem("duplicate", true, this, "duplicateMenuAction", "make a copy\nand pick it up");
    menu.addItem("pick up", true, this, "pickUp", "disattach and put \ninto the hand");
    menu.addItem("attach...", true, this, "attach", "stick this morph\nto another one");
    menu.addItem("move", true, this, "move", "show a handle\nwhich can be floatDragged\nto move this morph");
    menu.addItem("inspect", true, this, "inspect", "open a window\non all properties");
    takePic = (function(_this) {
      return function() {
        if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.RECORDING) {
          return window.world.systemTestsRecorderAndPlayer.takeScreenshot(_this);
        } else if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.PLAYING) {
          return window.world.systemTestsRecorderAndPlayer.imageDataOfAParticularMorph = _this.fullImageData();
        } else {
          return window.open(_this.fullImageData());
        }
      };
    })(this);
    menu.addItem("take pic", true, this, "takePic", "open a new window\nwith a picture of this morph");
    menu.addItem("test menu ➜", false, this, "testMenu", "debugging and testing operations");
    menu.addLine();
    if (this.isfloatDraggable) {
      menu.addItem("lock", true, this, "toggleIsfloatDraggable", "make this morph\nunmovable");
    } else {
      menu.addItem("unlock", true, this, "toggleIsfloatDraggable", "make this morph\nmovable");
    }
    menu.addItem("hide", true, this, "minimise");
    menu.addItem("delete", true, this, "destroy");
    return menu;
  };

  Morph.prototype.userMenu = function() {
    return null;
  };

  Morph.prototype.calculateAlphaScaled = function(alpha) {
    var newAlpha, unscaled;
    if (typeof alpha === "number") {
      unscaled = alpha / 100;
      return Math.min(Math.max(unscaled, 0.1), 1);
    } else {
      newAlpha = parseFloat(alpha);
      if (!isNaN(newAlpha)) {
        unscaled = newAlpha / 100;
        return Math.min(Math.max(unscaled, 0.1), 1);
      }
    }
  };

  Morph.prototype.setAlphaScaled = function(alphaOrMorphGivingAlpha, morphGivingAlpha) {
    var alpha;
    if ((morphGivingAlpha != null ? morphGivingAlpha.getValue : void 0) != null) {
      alpha = morphGivingAlpha.getValue();
    } else {
      alpha = alphaOrMorphGivingAlpha;
    }
    if (alpha) {
      this.alpha = this.calculateAlphaScaled(alpha);
      return this.changed();
    }
  };

  Morph.prototype.newParentChoice = function(ignored, theMorphToBeAttached) {
    this.add(theMorphToBeAttached);
    if (this instanceof ScrollFrameMorph) {
      this.adjustContentsBounds();
      return this.adjustScrollBars();
    } else {
      return theMorphToBeAttached.isfloatDraggable = false;
    }
  };

  Morph.prototype.attach = function() {
    var choices, choicesExcludingParent, menu;
    choices = world.plausibleTargetAndDestinationMorphs(this);
    choicesExcludingParent = [];
    choices.forEach((function(_this) {
      return function(each) {
        if (each !== _this.parent) {
          return choicesExcludingParent.push(each);
        }
      };
    })(this));
    if (choicesExcludingParent.length > 0) {
      menu = new MenuMorph(false, this, true, true, "choose new parent:");
      choicesExcludingParent.forEach((function(_this) {
        return function(each) {
          return menu.addItem(each.toString().slice(0, 50), true, each, "newParentChoice");
        };
      })(this));
    } else {
      menu = new MenuMorph(false, this, true, true, "no morphs to attach to");
    }
    return menu.popUpAtHand(this.firstContainerMenu());
  };

  Morph.prototype.toggleIsfloatDraggable = function() {
    return this.isfloatDraggable = !this.isfloatDraggable;
  };

  Morph.prototype.colorSetters = function() {
    return ["color"];
  };

  Morph.prototype.numericalSetters = function() {
    return ["setLeft", "setTop", "setWidth", "setHeight", "setAlphaScaled"];
  };

  Morph.prototype.allEntryFields = function() {
    return this.collectAllChildrenBottomToTopSuchThat(function(each) {
      return each.isEditable && (each instanceof StringMorph || each instanceof TextMorph);
    });
  };

  Morph.prototype.nextEntryField = function(current) {
    var fields, idx;
    fields = this.allEntryFields();
    idx = fields.indexOf(current);
    if (idx !== -1) {
      if (fields.length > (idx + 1)) {
        return fields[idx + 1];
      }
    }
    return fields[0];
  };

  Morph.prototype.previousEntryField = function(current) {
    var fields, idx;
    fields = this.allEntryFields();
    idx = fields.indexOf(current);
    if (idx !== -1) {
      if (idx > 0) {
        return fields[idx - 1];
      }
      return fields[fields.length - 1];
    }
    return fields[0];
  };

  Morph.prototype.tab = function(editField) {
    if (this.nextTab) {
      return this.nextTab(editField);
    } else {
      if (this.parent) {
        return this.parent.tab(editField);
      }
    }
  };

  Morph.prototype.backTab = function(editField) {
    if (this.previousTab) {
      return this.previousTab(editField);
    } else {
      if (this.parent) {
        return this.parent.backTab(editField);
      }
    }
  };

  Morph.prototype.escalateEvent = function(functionName, arg) {
    var handler;
    handler = this.parent;
    if (handler != null) {
      while (!handler[functionName] && (handler.parent != null)) {
        handler = handler.parent;
      }
      if (handler[functionName]) {
        return handler[functionName](arg);
      }
    }
  };

  Morph.prototype.evaluateString = function(code) {
    var err, result;
    try {
      result = eval(code);
      this.setLayoutBeforeUpdatingBackingStore();
      this.updateBackingStore();
      this.changed();
    } catch (_error) {
      err = _error;
      this.inform(err);
    }
    return result;
  };

  Morph.prototype.isTouching = function(otherMorph) {
    var data, oImg;
    oImg = this.overlappingImage(otherMorph);
    data = oImg.getContext("2d").getImageData(1, 1, oImg.width, oImg.height).data;
    return detect(data, function(each) {
      return each !== 0;
    }) !== null;
  };

  Morph.prototype.overlappingImage = function(otherMorph) {
    var ctx, fb, oImg, oRect, otherFb;
    fb = this.boundsIncludingChildren();
    otherFb = otherMorph.boundsIncludingChildren();
    oRect = fb.intersect(otherFb);
    oImg = newCanvas(oRect.extent().scaleBy(pixelRatio));
    ctx = oImg.getContext("2d");
    ctx.scale(pixelRatio, pixelRatio);
    if (oRect.width() < 1 || oRect.height() < 1) {
      return newCanvas((new Point(1, 1)).scaleBy(pixelRatio));
    }
    ctx.drawImage(this.fullImage(), Math.round(oRect.origin.x - fb.origin.x), Math.round(oRect.origin.y - fb.origin.y));
    ctx.globalCompositeOperation = "source-in";
    ctx.drawImage(otherMorph.fullImage(), Math.round(otherFb.origin.x - oRect.origin.x), Math.round(otherFb.origin.y - oRect.origin.y));
    return oImg;
  };

  Morph.coffeeScriptSourceOfThisClass = '# Morph //////////////////////////////////////////////////////////////\n\n# A Morph (from the Greek "shape" or "form") is an interactive\n# graphical object. General information on the Morphic system\n# can be found at http://minnow.cc.gatech.edu/squeak/30. \n\n# Morphs exist in a tree, rooted at a World or at the Hand.\n# The morphs owns submorphs. Morphs are drawn recursively;\n# if a Morph has no owner it never gets drawn\n# (but note that there are other ways to hide a Morph).\n\n# this comment below is needed to figure our dependencies between classes\n# REQUIRES globalFunctions\n# REQUIRES DeepCopierMixin\n\nclass Morph extends MorphicNode\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith DeepCopierMixin\n\n  # we want to keep track of how many instances we have\n  # of each Morph for a few reasons:\n  # 1) it gives us an identifier for each Morph\n  # 2) profiling\n  # 3) generate a uniqueIDString that we can use\n  #    for example for hashtables\n  # each subclass of Morph has its own static\n  # instancesCounter which starts from zero. First object\n  # has instanceNumericID of 1.\n  # instanceNumericID is initialised in the constructor.\n  @instancesCounter: 0\n  # see roundNumericIDsToNextThousand method for an\n  # explanation of why we need to keep this extra\n  # count\n  @lastBuiltInstanceNumericID: 0\n  instanceNumericID: 0\n  \n  # Just some tests here ////////////////////\n  propertyUpTheChain: [1,2,3]\n  morphMethod: ->\n    3.14\n  @morphStaticMethod: ->\n    3.14\n  # End of tests here ////////////////////\n\n  isMorph: true\n  bounds: null\n  color: null\n  texture: null # optional url of a fill-image\n  cachedTexture: null # internal cache of actual bg image\n  lastTime: null\n  alpha: 1\n\n  # for a Morph, being visible and minimised\n  # are two separate things.\n  # isVisible means that the morph is meant to show\n  #  as empty or without any surface. For example\n  #  a scrollbar "collapses" itself when there is no\n  #  content to scroll and puts its isVisible = false\n  # isMinimised means that the morph, whatever its\n  #  content or appearance or design, is not drawn\n  #  on the desktop. So a minimised or unminimised scrollbar\n  #  can be independently either visible or not.\n  # If we merge the two flags into one, then the\n  # following happens: "hiding" a morph causes the\n  # scrollbars in it to hide. Unhiding it causes the\n  # scrollbars to show, even if they should be invisible.\n  # Hence the need of two separate flags.\n  # Also, it\'s semantically two\n  # separate reasons of why a morph is not being\n  # painted on screen, so it makes sense to have\n  # two separate flags.\n  isMinimised: false\n  isVisible: true\n\n  isfloatDraggable: false\n  # if a morph is a "template" it means that\n  # when you floatDrag it, it creates a copy of itself.\n  # it\'s a nice shortcut instead of doing\n  # right click and then "duplicate..."\n  isTemplate: false\n  acceptsDrops: false\n  noticesTransparentClick: false\n  fps: 0\n  customContextMenu: null\n  trackChanges: true\n  shadowBlur: 10\n  # note that image contains only the CURRENT morph, not the composition of this\n  # morph with all of the submorphs. I.e. for an inspector, this will only\n  # contain the background of the window pane. Not any of its contents.\n  # for the worldMorph, this only contains the background\n  image: null\n  onNextStep: null # optional function to be run once. Not currently used in Zombie Kernel\n\n  # contains all the reactive vals\n  allValsInMorphByName: null\n  morphValsDependingOnChildrenVals: null\n  morphValsDirectlyDependingOnParentVals: null\n\n  clickOutsideMeOrAnyOfMeChildrenCallback: [null]\n  isMarkedForDestruction: false\n\n  textDescription: null\n\n\n  mouseClickRight: ->\n    world.hand.openContextMenuAtPointer @\n\n  getTextDescription: ->\n    if @textDescription?\n      return @textDescription + "" + @constructor.name + " (adhoc description of morph)"\n    else\n      return @constructor.name + " (class name)"\n\n  identifyViaTextLabel: ->\n    myTextDescription = @getTextDescription()\n    allCandidateMorphsWithSameTextDescription = \n      world.allChildrenTopToBottomSuchThat( (m) ->\n        m.getTextDescription() == myTextDescription\n      )\n    position = allCandidateMorphsWithSameTextDescription.indexOf @\n\n    theLenght = allCandidateMorphsWithSameTextDescription.length\n    console.log [myTextDescription, position, theLenght]\n    return [myTextDescription, position, theLenght]\n\n  setTextDescription: (@textDescription) ->\n\n\n  ##\n  # Reactive Values start\n  ##\n\n  markForDestruction: ->\n    world.markedForDestruction.push @\n    @isMarkedForDestruction = true\n\n  anyParentMarkedForDestruction: ->\n    if @isMarkedForDestruction\n      return true\n    else if @parent?\n      return @parent.anyParentMarkedForDestruction() \n    return false\n\n\n  ###\n  connectValuesToAddedChild: (theChild) ->\n    #if theChild.constructor.name == "RectangleMorph"\n    #  debugger\n\n    # we have a data structure that contains,\n    # for each child valName, all vals of this\n    # morph that depend on it. Go through\n    # all child val names, find the\n    # actual val in the child, and connect all\n    # to the vals in this morph that depend on it.\n    for nameOfChildrenVar, morphValsDependingOnChildrenVals of @morphValsDependingOnChildrenVals\n      childVal = theChild.allValsInMorphByName[ nameOfChildrenVar ]\n      if childVal?\n        for valNameNotUsed, valDependingOnChildrenVal of morphValsDependingOnChildrenVals\n          valDependingOnChildrenVal.args.connectToChildVal valDependingOnChildrenVal, childVal\n\n    # we have a data structure that contains,\n    # for each parent (me) valName, all vals of the child\n    # morph that depend on it. Go through\n    # all parent (me) val names, find the\n    # actual val in the parent (me), and connect it\n    # to the vals in the child morph that depend on it.\n    for nameOfParentVar, morphValsDirectlyDependingOnParentVals of theChild.morphValsDirectlyDependingOnParentVals\n      parentVal = @allValsInMorphByName[ nameOfParentVar ]\n      if parentVal?\n        for valNameNotUsed, valDependingOnParentVal of morphValsDirectlyDependingOnParentVals\n          valDependingOnParentVal.args.connectToParentVal valDependingOnParentVal, parentVal\n\n  disconnectValuesFromRemovedChild: (theChild) ->\n    # we have a data structure that contains,\n    # for each child valName, all vals of this\n    # morph that depend on it. Go through\n    # all child val names, find the\n    # actual val in the child, and DISconnect it\n    # FROM the vals in this morph that depended on it.\n    for nameOfChildrenVar, morphValsDependingOnChildrenVals of @morphValsDependingOnChildrenVals\n      for valNameNotUsed, valDependingOnChildrenVal of morphValsDependingOnChildrenVals\n        childArg = valDependingOnChildrenVal.args.argById[theChild.id]\n        if childArg?\n          childArg.disconnectChildArg()\n\n    # we have a data structure that contains,\n    # for each parent (me) valName, all vals of the child\n    # morph that depend on it. Go through\n    # all parent (me) val names, find the\n    # actual val in the parent (me), and connect it\n    # to the vals in the child morph that depend on it.\n    for nameOfParentVar, morphValsDirectlyDependingOnParentVals of theChild.morphValsDirectlyDependingOnParentVals\n      for valNameNotUsed, valDependingOnParentVal of morphValsDirectlyDependingOnParentVals\n        parentArg = valDependingOnParentVal.args.parentArgByName[ nameOfParentVar ]\n        if parentArg?\n          parentArg.disconnectParentArg()\n  ###\n\n\n  ## ------------ end of reactive values ----------------------\n\n  uniqueIDString: ->\n    @morphClassString() + "#" + @instanceNumericID\n\n  morphClassString: ->\n    (@constructor.name or @constructor.toString().split(" ")[1].split("(")[0])\n\n  @morphFromUniqueIDString: (theUniqueID) ->\n    result = world.topMorphSuchThat (m) =>\n      m.uniqueIDString() is theUniqueID\n    if not result?\n      alert "theUniqueID " + theUniqueID + " not found!"\n    return result\n\n  assignUniqueID: ->\n    @constructor.instancesCounter++\n    @constructor.lastBuiltInstanceNumericID++\n    @instanceNumericID = @constructor.lastBuiltInstanceNumericID\n\n  # some test commands specify morphs via\n  # their uniqueIDString. This means that\n  # if there is one more TextMorph anywhere during\n  # the playback, for example because\n  # one new menu item is added, then\n  # all the subsequent IDs for the TextMorph will be off.\n  # In order to sort that out, we occasionally re-align\n  # the counts to the next 1000, so the next Morphs\n  # being created will all be aligned and\n  # minor discrepancies are ironed-out\n  @roundNumericIDsToNextThousand: ->\n    console.log "@roundNumericIDsToNextThousand"\n    # this if is because zero and multiples of 1000\n    # don\'t go up to 1000\n    if @lastBuiltInstanceNumericID %1000 == 0\n      @lastBuiltInstanceNumericID++\n    @lastBuiltInstanceNumericID = 1000*Math.ceil(@lastBuiltInstanceNumericID/1000)\n\n  constructor: ->\n    super()\n    @assignUniqueID()\n\n    if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n      arr = window.world.systemTestsRecorderAndPlayer.tagsCollectedWhileRecordingTest\n      if (arr.indexOf @constructor.name) == -1\n        arr.push @constructor.name\n\n    # [TODO] why is there this strange non-zero default bound?\n    @bounds = new Rectangle(0, 0, 50, 40)\n    @color = @color or new Color(80, 80, 80)\n    @lastTime = Date.now()\n    # Note that we don\'t call @updateBackingStore()\n    # that\'s because the actual extending morph will probably\n    # set more details of how it should look (e.g. size),\n    # so we wait and we let the actual extending\n    # morph to draw itself.\n\n    @allValsInMorphByName = {}\n    @morphValsDependingOnChildrenVals = {}\n    @morphValsDirectlyDependingOnParentVals = {}\n\n\n  \n  #\n  #    damage list housekeeping\n  #\n  #	the trackChanges property of the Morph prototype is a Boolean switch\n  #	that determines whether the World\'s damage list (\'broken\' rectangles)\n  #	tracks changes. By default the switch is always on. If set to false\n  #	changes are not stored. This can be very useful for housekeeping of\n  #	the damage list in situations where a large number of (sub-) morphs\n  #	are changed more or less at once. Instead of keeping track of every\n  #	single submorph\'s changes tremendous performance improvements can be\n  #	achieved by setting the trackChanges flag to false before propagating\n  #	the layout changes, setting it to true again and then storing the full\n  #	bounds of the surrounding morph. An an example refer to the\n  #\n  #		layoutSubmorphs()\n  #		\n  #	method of InspectorMorph, or the\n  #	\n  #		startLayout()\n  #		endLayout()\n  #\n  #	methods of SyntaxElementMorph in the Snap application.\n  #\n  \n  \n  # Morph string representation: e.g. \'a Morph#2 [20@45 | 130@250]\'\n  toString: ->\n    firstPart = "a "\n\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.hidingOfMorphsNumberIDInLabels\n      firstPart = firstPart + @morphClassString()\n    else\n      firstPart = firstPart + @uniqueIDString()\n\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.hidingOfMorphsGeometryInfoInLabels\n      return firstPart\n    else\n      return firstPart + " " + @bounds\n\n  # Morph string representation: e.g. \'a Morph#2\'\n  toStringWithoutGeometry: ->\n    "a " +\n      @uniqueIDString()\n  \n  \n  # Morph deleting:\n  destroy: ->\n    # todo there is something to be figured out here\n    # cause in theory ALL the morphs in here are not\n    # visible, not just the parent... but it kind of\n    # seems overkill...\n    @visible = false\n\n    # remove callback when user clicks outside\n    # me or any of my children\n    console.log "****** destroying morph"\n    @onClickOutsideMeOrAnyOfMyChildren null\n\n    if @parent?\n      @fullChanged()\n      @parent.removeChild @\n    return null\n  \n  destroyAll: ->\n    # we can\'t use forEach because we are iterating over\n    # an array that changes its values (and length) while\n    # we are iterating on it.\n    until @children.length == 0\n      @children[0].destroy()\n    return null\n\n  # Morph stepping:\n  runChildrensStepFunction: ->\n    # step is the function that this Morph wants to run at each step.\n    # If the Morph wants to do nothing and let no-one of the children do nothing,\n    # then step is set to null.\n    # If the morph wants to do nothing but the children might want to do something,\n    # then step is set to the function that does nothing (i.e. a function noOperation that\n    # only returns null) \n    return null  unless @step\n\n    # for objects where @fps is defined, check which ones are due to be stepped\n    # and which ones want to wait. \n    elapsed = WorldMorph.currentTime - @lastTime\n    if @fps > 0\n      timeRemainingToWaitedFrame = (1000 / @fps) - elapsed\n    else\n      timeRemainingToWaitedFrame = 0\n    \n    # Question: why 1 here below?\n    if timeRemainingToWaitedFrame < 1\n      @lastTime = WorldMorph.currentTime\n      if @onNextStep\n        nxt = @onNextStep\n        @onNextStep = null\n        nxt.call(@)\n      @step()\n      @children.forEach (child) ->\n        if !child.runChildrensStepFunction?\n          debugger\n        child.runChildrensStepFunction()\n\n  # not used within Zombie Kernel yet.\n  nextSteps: (arrayOfFunctions) ->\n    lst = arrayOfFunctions or []\n    nxt = lst.shift()\n    if nxt\n      @onNextStep = =>\n        nxt.call @\n        @nextSteps lst  \n  \n  # leaving this function as step means that the morph wants to do nothing\n  # but the children *are* traversed and their step function is invoked.\n  # If a Morph wants to do nothing and wants to prevent the children to be\n  # traversed, then this function should be set to null.\n  step: noOperation\n  \n  \n  # Morph accessing - geometry getting:\n  left: ->\n    @bounds.left()\n  \n  right: ->\n    @bounds.right()\n  \n  top: ->\n    @bounds.top()\n  \n  bottom: ->\n    @bounds.bottom()\n  \n  center: ->\n    @bounds.center()\n  \n  bottomCenter: ->\n    @bounds.bottomCenter()\n  \n  bottomLeft: ->\n    @bounds.bottomLeft()\n  \n  bottomRight: ->\n    @bounds.bottomRight()\n  \n  boundingBox: ->\n    @bounds\n  \n  corners: ->\n    @bounds.corners()\n  \n  leftCenter: ->\n    @bounds.leftCenter()\n  \n  rightCenter: ->\n    @bounds.rightCenter()\n  \n  topCenter: ->\n    @bounds.topCenter()\n  \n  topLeft: ->\n    @bounds.topLeft()\n  \n  topRight: ->\n    @bounds.topRight()\n  \n  position: ->\n    @bounds.origin\n  \n  extent: ->\n    @bounds.extent()\n  \n  width: ->\n    @bounds.width()\n  \n  height: ->\n    @bounds.height()\n\n\n  # used for example:\n  # - to determine which morphs you can attach a morph to\n  # - for a SliderMorph\'s "set target" so you can change properties of another Morph\n  # - by the HandleMorph when you attach it to some other morph\n  # Note that this method has a slightly different\n  # version in FrameMorph (because it clips, so we need\n  # to check that we don\'t consider overlaps with\n  # morphs contained in a frame that are clipped and\n  # hence *actually* not overlapping).\n  plausibleTargetAndDestinationMorphs: (theMorph) ->\n    # find if I intersect theMorph,\n    # then check my children recursively\n    # exclude me if I\'m a child of theMorph\n    # (cause it\'s usually odd to attach a Morph\n    # to one of its submorphs or for it to\n    # control the properties of one of its submorphs)\n    result = []\n    if !@isMinimised and\n        @isVisible and\n        !theMorph.containedInParentsOf(@) and\n        @bounds.intersects(theMorph.bounds) and\n        !@anyParentMarkedForDestruction()\n      result = [@]\n\n    @children.forEach (child) ->\n      result = result.concat(child.plausibleTargetAndDestinationMorphs(theMorph))\n\n    return result\n\n  ###\n  mergedBoundsOfChildren: ->\n    result = new Rectangle(0,0)\n    @children.forEach (child) ->\n      if !child.isMinimised and child.isVisible\n        result = result.merge(child.boundsIncludingChildren())\n    result\n  ###\n\n  \n  boundsIncludingChildren: ->\n    result = @bounds\n    @children.forEach (child) ->\n      if !child.isMinimised and child.isVisible\n        result = result.merge(child.boundsIncludingChildren())\n    result\n  \n  boundsIncludingChildrenNoShadow: ->\n    # answer my full bounds but ignore any shadow\n    result = @bounds\n    @children.forEach (child) ->\n      if (child not instanceof ShadowMorph) and (!child.isMinimised) and (child.isVisible)\n        result = result.merge(child.boundsIncludingChildrenNoShadow())\n    result\n  \n  visibleBounds: ->\n    # answer which part of me is not clipped by a Frame\n    visible = @bounds\n    frames = @allParentsTopToBottomSuchThat (p) ->\n      p instanceof FrameMorph\n    frames.forEach (f) ->\n      visible = visible.intersect(f.bounds)\n\n    visible\n  \n  \n  # Morph accessing - simple changes:\n  moveBy: (delta) ->\n    # note that changed() is called two times\n    # because there are two areas of the screens\n    # that are dirty: the starting\n    # position and the end position.\n    # Both need to be repainted.\n    @changed()\n    @bounds = @bounds.translateBy(delta)\n    @children.forEach (child) ->\n      child.moveBy delta\n\n    @changed()\n  \n  silentMoveBy: (delta) ->\n    @bounds = @bounds.translateBy(delta)\n    @children.forEach (child) ->\n      child.silentMoveBy delta\n  \n  \n  setPosition: (aPoint) ->\n    aPoint.debugIfFloats()\n    delta = aPoint.subtract(@topLeft())\n    @moveBy delta  if (delta.x isnt 0) or (delta.y isnt 0)\n    @bounds.debugIfFloats()\n  \n  silentSetPosition: (aPoint) ->\n    delta = aPoint.subtract(@topLeft())\n    @silentMoveBy delta  if (delta.x isnt 0) or (delta.y isnt 0)\n  \n  setLeft: (x) ->\n    @setPosition new Point(x, @top())\n  \n  setRight: (x) ->\n    @setPosition new Point(x - @width(), @top())\n  \n  setTop: (y) ->\n    @setPosition new Point(@left(), y)\n  \n  setBottom: (y) ->\n    @setPosition new Point(@left(), y - @height())\n  \n  setCenter: (aPoint) ->\n    @setPosition aPoint.subtract(@extent().floorDivideBy(2))\n  \n  setFullCenter: (aPoint) ->\n    @setPosition aPoint.subtract(@boundsIncludingChildren().extent().floorDivideBy(2))\n  \n  # make sure I am completely within another Morph\'s bounds\n  keepWithin: (aMorph) ->\n    leftOff = @boundsIncludingChildren().left() - aMorph.left()\n    @moveBy new Point(-leftOff, 0)  if leftOff < 0\n    rightOff = @boundsIncludingChildren().right() - aMorph.right()\n    @moveBy new Point(-rightOff, 0)  if rightOff > 0\n    topOff = @boundsIncludingChildren().top() - aMorph.top()\n    @moveBy new Point(0, -topOff)  if topOff < 0\n    bottomOff = @boundsIncludingChildren().bottom() - aMorph.bottom()\n    @moveBy new Point(0, -bottomOff)  if bottomOff > 0\n  \n  # the default of layoutSubmorphs\n  # is to do nothing, but things like\n  # the inspector might well want to\n  # tweak many of their children...\n  layoutSubmorphs: ->\n  \n  # Morph accessing - dimensional changes requiring a complete redraw\n  setExtent: (aPoint) ->\n    # check whether we are actually changing the extent.\n    unless aPoint.eq(@extent())\n      @changed()\n      @silentSetExtent aPoint\n      @changed()\n      @setLayoutBeforeUpdatingBackingStore()\n      @updateBackingStore()\n      @layoutSubmorphs()\n  \n  silentSetExtent: (aPoint) ->\n    ext = aPoint.round()\n    newWidth = Math.max(ext.x, 0)\n    newHeight = Math.max(ext.y, 0)\n    @bounds.corner = new Point(@bounds.origin.x + newWidth, @bounds.origin.y + newHeight)\n  \n  setWidth: (width) ->\n    @setExtent new Point(width or 0, @height())\n  \n  silentSetWidth: (width) ->\n    # do not updateBackingStore() just yet\n    w = Math.max(Math.round(width or 0), 0)\n    @bounds.corner = new Point(@bounds.origin.x + w, @bounds.corner.y)\n  \n  setHeight: (height) ->\n    @setExtent new Point(@width(), height or 0)\n  \n  silentSetHeight: (height) ->\n    # do not updateBackingStore() just yet\n    h = Math.max(Math.round(height or 0), 0)\n    @bounds.corner = new Point(@bounds.corner.x, @bounds.origin.y + h)\n  \n  setColor: (aColorOrAMorphGivingAColor, morphGivingColor) ->\n    if morphGivingColor?.getColor?\n      aColor = morphGivingColor.getColor()\n    else\n      aColor = aColorOrAMorphGivingAColor\n    if aColor\n      unless @color.eq(aColor)\n        @color = aColor\n        @changed()\n        @updateBackingStore()\n    return aColor\n  \n  \n  # Morph displaying ---------------------------------------------------------\n\n  # There are three fundamental methods for rendering and displaying anything.\n  # * updateBackingStore: this one creates/updates the local canvas of this morph only\n  #   i.e. not the children. For example: a ColorPickerMorph is a Morph which\n  #   contains three children Morphs (a color palette, a greyscale palette and\n  #   a feedback). The updateBackingStore method of ColorPickerMorph only creates\n  #   a canvas for the container Morph. So that\'s just a canvas with a\n  #   solid color. As the\n  #   ColorPickerMorph constructor runs, the three childredn Morphs will\n  #   run their own updateBackingStore method, so each child will have its own\n  #   canvas with their own contents.\n  #   Note that updateBackingStore should be called sparingly. A morph should repaint\n  #   its buffer pretty much only *after* it\'s been added to itf first parent and\n  #   whenever it changes dimensions. Things like changing parent and updating\n  #   the position shouldn\'t normally trigger an update of the buffer.\n  #   Also note that before the buffer is painted for the first time, they\n  #   might not know their extent. Typically text-related Morphs know their\n  #   extensions after they painted the text for the first time...\n  # * blit: takes the local canvas and blits it to a specific area in a passed\n  #   canvas. The local canvas doesn\'t contain any rendering of the children of\n  #   this morph.\n  # * recursivelyBlit: recursively draws all the local canvas of this morph and all\n  #   its children into a specific area of a passed canvas.\n\n  # this is normally invoked form setExtent\n  # and setExtent also invokes layoutSubmorphs\n  # afterwards\n  # no changes of position or extent\n  updateBackingStore: ->\n    @changed()\n    @silentUpdateBackingStore()\n    # to do you might be smarter here and ask the silentUpdateBackingStore\n    # method whether a) there was any change at all and b) whether only\n    # the buffer changed and not the bounds (in which case only one changed()\n    # is needed)\n    @changed()\n\n  \n  drawTexture: (url) ->\n    @cachedTexture = new Image()\n    @cachedTexture.onload = =>\n      @drawCachedTexture()\n\n    @cachedTexture.src = @texture = url # make absolute\n  \n  # tiles the texture\n  drawCachedTexture: ->\n    bg = @cachedTexture\n    cols = Math.floor(@image.width / bg.width)\n    lines = Math.floor(@image.height / bg.height)\n    context = @image.getContext("2d")\n    for y in [0..lines]\n      for x in [0..cols]\n        context.drawImage bg, Math.round(x * bg.width), Math.round(y * bg.height)\n    @changed()\n  \n  \n  isTransparentAt: ->\n    return false\n  \n  silentUpdateBackingStore: ->\n    #console.log \'frame morph doing nothing with the backing store\'\n\n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by recursivelyBlit, which\n  # eventually invokes blit.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  blit: (aCanvas, clippingRectangle) ->\n    return null  if @isMinimised or !@isVisible\n    area = clippingRectangle.intersect(@bounds).round()\n    # test whether anything that we are going to be drawing\n    # is visible (i.e. within the clippingRectangle)\n    if area.isNotEmpty()\n      delta = @position().neg()\n      src = area.copy().translateBy(delta).round()\n      context = aCanvas.getContext("2d")\n      context.globalAlpha = @alpha\n      sl = src.left() * pixelRatio\n      st = src.top() * pixelRatio\n      al = area.left() * pixelRatio\n      at = area.top() * pixelRatio\n      w = Math.min(src.width() * pixelRatio, @width() * pixelRatio - sl)\n      h = Math.min(src.height() * pixelRatio, @height() * pixelRatio - st)\n      return null  if w < 1 or h < 1\n\n      # initialize my surface property\n      #@image = newCanvas(@extent().scaleBy pixelRatio)\n      #context = @image.getContext("2d")\n      #context.scale pixelRatio, pixelRatio\n      context.save()\n      context.fillStyle = @color.toString()\n      context.fillRect  Math.round(al),\n          Math.round(at),\n          Math.round(w),\n          Math.round(h)\n      context.restore()\n\n      if world.showRedraws\n        randomR = Math.round(Math.random()*255)\n        randomG = Math.round(Math.random()*255)\n        randomB = Math.round(Math.random()*255)\n\n        context.save()\n        context.globalAlpha = 0.5\n        context.fillStyle = "rgb("+randomR+","+randomG+","+randomB+")";\n        context.fillRect  Math.round(al),\n            Math.round(at),\n            Math.round(w),\n            Math.round(h)\n        context.restore()\n  \n  \n  # "for debugging purposes:"\n  #\n  #		try {\n  #			context.drawImage(\n  #				this.image,\n  #				src.left(),\n  #				src.top(),\n  #				w,\n  #				h,\n  #				area.left(),\n  #				area.top(),\n  #				w,\n  #				h\n  #			);\n  #		} catch (err) {\n  #			alert(\'internal error\n\n\' + err\n  #				+ \'\n ---\'\n  #				+ \'\n canvas: \' + aCanvas\n  #				+ \'\n canvas.width: \' + aCanvas.width\n  #				+ \'\n canvas.height: \' + aCanvas.height\n  #				+ \'\n ---\'\n  #				+ \'\n image: \' + this.image\n  #				+ \'\n image.width: \' + this.image.width\n  #				+ \'\n image.height: \' + this.image.height\n  #				+ \'\n ---\'\n  #				+ \'\n w: \' + w\n  #				+ \'\n h: \' + h\n  #				+ \'\n sl: \' + sl\n  #				+ \'\n st: \' + st\n  #				+ \'\n area.left: \' + area.left()\n  #				+ \'\n area.top \' + area.top()\n  #				);\n  #		}\n  #	\n  recursivelyBlit: (aCanvas, clippingRectangle = @boundsIncludingChildren()) ->\n    return null  if @isMinimised or !@isVisible\n\n    # in general, the children of a Morph could be outside the\n    # bounds of the parent (they could also be much larger\n    # then the parent). This means that we have to traverse\n    # all the children to find out whether any of those overlap\n    # the clipping rectangle. Note that we can be smarter with\n    # FrameMorphs, as their children are actually all contained\n    # within the parent\'s boundary.\n\n    # Note that if we could dynamically and cheaply keep an updated\n    # boundsIncludingChildren property, then we could be smarter\n    # in discarding whole sections of the scene graph.\n    # (see https://github.com/davidedc/Zombie-Kernel/issues/150 )\n\n    @blit aCanvas, clippingRectangle\n    @children.forEach (child) ->\n      child.recursivelyBlit aCanvas, clippingRectangle\n  \n\n  hide: ->\n    @isVisible = false\n    @changed()\n    @children.forEach (child) ->\n      child.hide()\n\n  show: ->\n    @isVisible = true\n    @changed()\n    @children.forEach (child) ->\n      child.show()\n  \n  minimise: ->\n    @isMinimised = true\n    @changed()\n    @children.forEach (child) ->\n      child.minimise()\n  \n  unminimise: ->\n    @isMinimised = false\n    @changed()\n    @children.forEach (child) ->\n      child.unminimise()\n  \n  \n  toggleVisibility: ->\n    @isMinimised = (not @isMinimised)\n    @changed()\n    @children.forEach (child) ->\n      child.toggleVisibility()\n  \n  \n  # Morph full image:\n  \n  # Fixes https://github.com/jmoenig/morphic.js/issues/7\n  # and https://github.com/davidedc/Zombie-Kernel/issues/160\n  fullImage: (bounds) ->\n    if !bounds?\n      bounds = @boundsIncludingChildren()\n\n    img = newCanvas(bounds.extent().scaleBy pixelRatio)\n    ctx = img.getContext("2d")\n    # ctx.scale pixelRatio, pixelRatio\n    # we are going to draw this morph and its children into "img".\n    # note that the children are not necessarily geometrically\n    # contained in the morph (in which case it would be ok to\n    # translate the context so that the origin of *this* morph is\n    # at the top-left of the "img" canvas).\n    # Hence we have to translate the context\n    # so that the origin of the entire bounds is at the\n    # very top-left of the "img" canvas.\n    ctx.translate -bounds.origin.x * pixelRatio , -bounds.origin.y * pixelRatio\n    @recursivelyBlit img, bounds\n    img\n\n  fullImageNoShadow: ->\n    boundsWithNoShadow = @boundsIncludingChildrenNoShadow()\n    return @fullImage(boundsWithNoShadow)\n\n  fullImageData: ->\n    # returns a string like "data:image/png;base64,iVBORw0KGgoAA..."\n    # note that "image/png" below could be omitted as it\'s\n    # the default, but leaving it here for clarity.\n    @fullImage().toDataURL("image/png")\n\n  # the way we take a picture here is different\n  # than the way we usually take a picture.\n  # Usually we ask the morph and submorphs to\n  # paint themselves anew into a new canvas.\n  # This is different: we take the area of the\n  # screen *as it is* and we crop the part of\n  # interest where the extent of our selected\n  # morph is. This means that the morph might\n  # be occluded by other things.\n  # The advantage here is that we capture\n  # the screen absolutely as is, without\n  # causing any repaints. If streaks are on the\n  # screen due to bad painting, we capture them\n  # exactly as the user sees them.\n  asItAppearsOnScreen: ->\n    fullExtentOfMorph = @boundsIncludingChildren()\n    destCanvas = newCanvas fullExtentOfMorph.extent().scaleBy pixelRatio\n    destCtx = destCanvas.getContext \'2d\'\n    destCtx.drawImage world.worldCanvas,\n      fullExtentOfMorph.topLeft().x * pixelRatio,\n      fullExtentOfMorph.topLeft().y * pixelRatio,\n      fullExtentOfMorph.width() * pixelRatio,\n      fullExtentOfMorph.height() * pixelRatio,\n      0,\n      0,\n      fullExtentOfMorph.width() * pixelRatio,\n      fullExtentOfMorph.height() * pixelRatio\n\n    return destCanvas.toDataURL "image/png"\n\n  fullImageHashCode: ->\n    return hashCode(@fullImageData())\n  \n  # Morph shadow:\n  shadowImage: (off_, color) ->\n    # fallback for Windows Chrome-Shadow bug\n    offset = off_ or new Point(7, 7)\n    clr = color or new Color(0, 0, 0)\n    fb = @boundsIncludingChildrenNoShadow().extent()\n    img = @fullImage()\n    outline = newCanvas(fb.scaleBy pixelRatio)\n    ctx = outline.getContext("2d")\n    #ctx.scale pixelRatio, pixelRatio\n    ctx.drawImage img, 0, 0\n    ctx.globalCompositeOperation = "destination-out"\n    ctx.drawImage img, Math.round(-offset.x * pixelRatio), Math.round(-offset.y * pixelRatio)\n    sha = newCanvas(fb.scaleBy pixelRatio)\n    ctx = sha.getContext("2d")\n    #ctx.scale pixelRatio, pixelRatio\n    ctx.drawImage outline, 0, 0\n    ctx.globalCompositeOperation = "source-atop"\n    ctx.fillStyle = clr.toString()\n    ctx.fillRect 0, 0, fb.x * pixelRatio, fb.y * pixelRatio\n    sha\n  \n  # the one used right now\n  shadowImageBlurred: (off_, color) ->\n    offset = off_ or new Point(7, 7)\n    blur = @shadowBlur\n    clr = color or new Color(0, 0, 0)\n    fb = @boundsIncludingChildrenNoShadow().extent().add(blur * 2)\n    img = @fullImageNoShadow()\n    sha = newCanvas(fb.scaleBy pixelRatio)\n    ctx = sha.getContext("2d")\n    #ctx.scale pixelRatio, pixelRatio\n    ctx.shadowOffsetX = offset.x * pixelRatio\n    ctx.shadowOffsetY = offset.y * pixelRatio\n    ctx.shadowBlur = blur * pixelRatio\n    ctx.shadowColor = clr.toString()\n    ctx.drawImage img, Math.round((blur - offset.x)*pixelRatio), Math.round((blur - offset.y)*pixelRatio)\n    ctx.shadowOffsetX = 0\n    ctx.shadowOffsetY = 0\n    ctx.shadowBlur = 0\n    ctx.globalCompositeOperation = "destination-out"\n    ctx.drawImage img, Math.round((blur - offset.x)*pixelRatio), Math.round((blur - offset.y)*pixelRatio)\n    sha\n  \n  \n  # shadow is added to a morph by\n  # the HandMorph while floatDragging\n  addShadow: (offset, alpha, color) ->\n    shadow = @silentAddShadow offset, alpha, color\n    shadow.setLayoutBeforeUpdatingBackingStore()\n    shadow.updateBackingStore()\n    @fullChanged()\n    shadow\n\n  silentAddShadow: (offset, alpha, color) ->\n    shadow = new ShadowMorph(@, offset, alpha, color)\n    @addChildFirst shadow\n    shadow\n  \n  getShadow: ->\n    return @topmostChildSuchThat (child) ->\n      child instanceof ShadowMorph\n  \n  removeShadow: ->\n    shadow = @getShadow()\n    if shadow?\n      @fullChanged()\n      @removeChild shadow\n  \n  \n  \n  # Morph updating ///////////////////////////////////////////////////////////////\n  changed: ->\n    if @trackChanges\n      w = @root()\n      # unless we are the main desktop, then if the morph has no parent\n      # don\'t add the broken rect since the morph is not visible\n      # also check whether we are attached to the hand cause that still counts\n      # TODO this has to be made simpler and has to take into account\n      # visibility as well?\n      if (w instanceof HandMorph) or (w instanceof WorldMorph and ((@ instanceof WorldMorph or @parent?)))\n        if (w instanceof HandMorph)\n          w = w.world\n          boundsToBeChanged = @boundsIncludingChildren().spread()\n        else\n          # @visibleBounds() should be smaller area\n          # and cheaper to calculate than @boundsIncludingChildren()\n          # cause it doesn\'t traverse the children and clips\n          # the area based on the clipping morphs up the\n          # hierarchy\n          boundsToBeChanged = @visibleBounds().spread()\n\n        w.broken.push boundsToBeChanged\n\n    @parent.childChanged @  if @parent\n  \n  fullChanged: ->\n    if @trackChanges\n      w = @root()\n      # unless we are the main desktop, then if the morph has no parent\n      # don\'t add the broken rect since the morph is not visible\n      # also check whether we are attached to the hand cause that still counts\n      # TODO this has to be made simpler and has to take into account\n      # visibility as well?\n      if (w instanceof HandMorph) or (w instanceof WorldMorph and ((@ instanceof WorldMorph or @parent?)))\n        if (w instanceof HandMorph)\n          w = w.world\n\n        w.broken.push @boundsIncludingChildren().spread()\n  \n  childChanged: ->\n    # react to a  change in one of my children,\n    # default is to just pass this message on upwards\n    # override this method for Morphs that need to adjust accordingly\n    @parent.childChanged @  if @parent\n  \n  \n  # Morph accessing - structure //////////////////////////////////////////////\n  world: ->\n    root = @root()\n    return root  if root instanceof WorldMorph\n    return root.world  if root instanceof HandMorph\n    null\n\n  imBeingAddedTo: (newParentMorph) ->\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n  \n  # attaches submorph on top\n  # ??? TODO you should handle the case of Morph\n  #     being added to itself and the case of\n  # ??? TODO a Morph being added to one of its\n  #     children\n  add: (aMorph) ->\n    # the morph that is being\n    # attached might be attached to\n    # a clipping morph. So we\n    # need to do a "changed" here\n    # to make sure that anything that\n    # is outside the clipping Morph gets\n    # painted over.\n    if aMorph.parent?\n      aMorph.changed()\n    @silentAdd(aMorph, true)\n    aMorph.imBeingAddedTo @\n\n  # this is done before the updating of the\n  # backing store in some morphs that\n  # need to figure out their whole\n  # layout before painting themselves\n  # e.g. the MenuMorph\n  setLayoutBeforeUpdatingBackingStore: ->\n\n\n  calculateAndUpdateExtent: ->\n\n  silentAdd: (aMorph, avoidExtentCalculation) ->\n    # the morph that is being\n    # attached might be attached to\n    # a clipping morph. So we\n    # need to do a "changed" here\n    # to make sure that anything that\n    # is outside the clipping Morph gets\n    # painted over.\n    owner = aMorph.parent\n    owner.removeChild aMorph  if owner?\n    aMorph.isMarkedForDestruction = false\n    @addChild aMorph\n    if !avoidExtentCalculation\n      aMorph.calculateAndUpdateExtent()\n  \n  \n\n  # never currently used in ZK\n  # TBD whether this is 100% correct,\n  # see "topMorphUnderPointer" implementation in\n  # HandMorph.\n  # Also there must be a quicker implementation\n  # cause there is no need to create the entire\n  # morph list. It would be sufficient to\n  # navigate the structure and just return\n  # at the first morph satisfying the test.\n  morphAt: (aPoint) ->\n    morphs = @allChildrenTopToBottom()\n    result = null\n    morphs.forEach (m) ->\n      if m.boundsIncludingChildren().containsPoint(aPoint) and (result is null)\n        result = m\n\n    result\n  \n  #\n  #	potential alternative - solution for morphAt.\n  #	Has some issues, commented out for now...\n  #\n  #Morph.prototype.morphAt = function (aPoint) {\n  #	return this.topMorphSuchThat(function (m) {\n  #		return m.boundsIncludingChildren().containsPoint(aPoint);\n  #	});\n  #};\n  #\n  \n  # Morph pixel access:\n  getPixelColor: (aPoint) ->\n    point = aPoint.subtract(@bounds.origin)\n    context = @image.getContext("2d")\n    data = context.getImageData(point.x * pixelRatio, point.y * pixelRatio, 1, 1)\n    new Color(data.data[0], data.data[1], data.data[2], data.data[3])\n  \n  \n\n  # Duplication and Serialization /////////////////////////////////////////\n\n\n  ### not currently used\n  completelyRepaint: ()->\n    allMorphsInStructure = @allChildrenBottomToTop()\n    for eachMorph in allMorphsInStructure\n      if eachMorph.updateBackingStore?\n        eachMorph.updateBackingStore()\n        eachMorph.changed()\n  ###\n\n  duplicateMenuAction: ->\n    aFullCopy = @fullCopy()\n    aFullCopy.pickUp()\n\n  fullCopy: ()->\n    allMorphsInStructure = @allChildrenBottomToTop()\n    copiedMorph = @deepCopy false, [], [], allMorphsInStructure\n    if copiedMorph instanceof MenuMorph\n      copiedMorph.onClickOutsideMeOrAnyOfMyChildren(null)\n      copiedMorph.killThisMenuIfClickOnDescendantsTriggers = false\n      copiedMorph.killThisMenuIfClickOutsideDescendants = false\n\n    return copiedMorph\n\n  serialize: ()->\n    allMorphsInStructure = @allChildrenBottomToTop()\n    arr1 = []\n    arr2 = []\n    @deepCopy true, arr1, arr2, allMorphsInStructure\n    totalJSON = ""\n\n    for element in arr2\n      try\n        console.log JSON.stringify(element) + "\n// --------------------------- \n"\n      catch e\n        debugger\n\n      totalJSON = totalJSON + JSON.stringify(element) + "\n// --------------------------- \n"\n    return totalJSON\n\n\n  # Deserialization /////////////////////////////////////////\n\n\n  deserialize: (serializationString) ->\n    # this is to ignore all the comment strings\n    # that might be there for reading purposes\n    objectsSerializations = serializationString.split(/^\/\/.*$/gm)\n    # the serialization ends with a comment so\n    # last element is empty, pop it\n    objectsSerializations.pop()\n\n    createdObjects = []\n    for eachSerialization in objectsSerializations\n      createdObjects.push JSON.parse eachSerialization\n\n    clonedMorphs = []\n    for eachObject in createdObjects\n      # note that the constructor method is not run!\n      #console.log "cloning:" + eachMorph.className\n      #console.log "with:" + namedClasses[eachMorph.className]\n      if eachObject.className == "Canvas"\n        theClone = newCanvas new Point eachObject.width, eachObject.height\n        ctx = theClone.getContext("2d");\n\n        image = new Image();\n        image.src = eachObject.data\n        # if something doesn\'t get painted here,\n        # it might be because the allocation of the image\n        # would actually be asynchronous, in theory\n        # you\'d have to do the drawImage in a callback\n        # on onLoad of the image...\n        ctx.drawImage(image, 0, 0)\n\n      else if eachObject.constructor != Array\n        theClone = Object.create(namedClasses[eachObject.className])\n        if theClone.assignUniqueID?\n          theClone.assignUniqueID()\n      else\n        theClone = []\n      clonedMorphs.push theClone\n      #theClone.constructor()\n\n    for i in [0... clonedMorphs.length]\n      eachClonedMorph = clonedMorphs[i]\n      if eachClonedMorph.constructor == HTMLCanvasElement\n        # do nothing\n      else if eachClonedMorph.constructor != Array\n        for property of createdObjects[i]\n          # also includes the "parent" property\n          if createdObjects[i].hasOwnProperty property\n            console.log "looking at property: " + property\n            clonedMorphs[i][property] = createdObjects[i][property]\n            if typeof clonedMorphs[i][property] is "string"\n              if (clonedMorphs[i][property].indexOf "$") == 0\n                referenceNumberAsString = clonedMorphs[i][property].substring(1)\n                referenceNumber = parseInt referenceNumberAsString\n                clonedMorphs[i][property] = clonedMorphs[referenceNumber]\n      else\n        for j in [0... createdObjects[i].length]\n          eachArrayElement = createdObjects[i][j]\n          clonedMorphs[i][j] = createdObjects[i][j]\n          if typeof eachArrayElement is "string"\n            if (eachArrayElement.indexOf "$") == 0\n              referenceNumberAsString = eachArrayElement.substring(1)\n              referenceNumber = parseInt referenceNumberAsString\n              clonedMorphs[i][j] = clonedMorphs[referenceNumber]\n\n\n    return clonedMorphs[0]\n\n  \n  # Morph floatDragging and dropping /////////////////////////////////////////\n  \n  rootForGrab: ->\n    if @ instanceof ShadowMorph\n      return @parent.rootForGrab()\n    if @parent instanceof ScrollFrameMorph\n      return @parent\n    if @parent is null or\n      @parent instanceof WorldMorph or\n      @parent instanceof FrameMorph or\n      @isfloatDraggable is true\n        return @  \n    @parent.rootForGrab()\n\n  firstContainerMenu: ->\n    scanningMorphs = @\n    while scanningMorphs.parent?\n      scanningMorphs = scanningMorphs.parent\n      if scanningMorphs instanceof MenuMorph\n        if !scanningMorphs.isMarkedForDestruction\n          return scanningMorphs\n    return scanningMorphs\n\n    if @ instanceof ShadowMorph\n      return @parent.rootForFocus()\n    if @parent is null or\n      @parent instanceof WorldMorph\n        return @  \n    @parent.rootForFocus()\n\n  rootForFocus: ->\n    if @ instanceof ShadowMorph\n      return @parent.rootForFocus()\n    if @parent is null or\n      @parent instanceof WorldMorph\n        return @  \n    @parent.rootForFocus()\n\n  bringToForegroud: ->\n    @rootForFocus()?.moveAsLastChild()\n    @rootForFocus()?.fullChanged()\n\n  propagateKillMenus: ->\n    if @parent?\n      @parent.propagateKillMenus()\n\n  mouseClickLeft: ->\n    @bringToForegroud()\n\n  onClickOutsideMeOrAnyOfMyChildren: (functionName, arg1, arg2, arg3)->\n    if functionName?\n      @clickOutsideMeOrAnyOfMeChildrenCallback = [functionName, arg1, arg2, arg3]\n      if (world.morphsDetectingClickOutsideMeOrAnyOfMeChildren.indexOf @) < 0\n        world.morphsDetectingClickOutsideMeOrAnyOfMeChildren.push @\n    else\n      console.log "****** onClickOutsideMeOrAnyOfMyChildren removing element"\n      index = world.morphsDetectingClickOutsideMeOrAnyOfMeChildren.indexOf @\n      if index >= 0\n        world.morphsDetectingClickOutsideMeOrAnyOfMeChildren.splice index, 1\n\n  wantsDropOf: (aMorph) ->\n    # default is to answer the general flag - change for my heirs\n    if (aMorph instanceof HandleMorph) or\n      (aMorph instanceof MenuMorph)\n        return false  \n    @acceptsDrops\n  \n  pickUp: ->\n    world.hand.grab @\n    @setPosition world.hand.position().subtract(@boundsIncludingChildrenNoShadow().extent().floorDivideBy(2))\n  \n  # note how this verified that\n  # at *any point* up in the\n  # morphs hierarchy there is a HandMorph\n  isPickedUp: ->\n    @parentThatIsA(HandMorph)?\n  \n  situation: ->\n    # answer a dictionary specifying where I am right now, so\n    # I can slide back to it if I\'m dropped somewhere else\n    if @parent\n      return (\n        origin: @parent\n        position: @position().subtract(@parent.position())\n      )\n    null\n  \n  slideBackTo: (situation, inSteps) ->\n    steps = inSteps or 5\n    pos = situation.origin.position().add(situation.position)\n    xStep = -(@left() - pos.x) / steps\n    yStep = -(@top() - pos.y) / steps\n    stepCount = 0\n    oldStep = @step\n    oldFps = @fps\n    @fps = 0\n    @step = =>\n      @fullChanged()\n      @silentMoveBy new Point(xStep, yStep)\n      @fullChanged()\n      stepCount += 1\n      if stepCount is steps\n        situation.origin.add @\n        situation.origin.reactToDropOf @  if situation.origin.reactToDropOf\n        @step = oldStep\n        @fps = oldFps\n  \n  \n  # Morph utilities ////////////////////////////////////////////////////////\n  \n  resize: ->\n    @world().activeHandle = new HandleMorph(@)\n  \n  move: ->\n    @world().activeHandle = new HandleMorph(@, null, null, null, null, "move")\n  \n  hint: (msg) ->\n    text = msg\n    if msg\n      text = msg.toString()  if msg.toString\n    else\n      text = "NULL"\n    m = new MenuMorph(false, @, true, true, text)\n    m.isfloatDraggable = true\n    m.popUpCenteredAtHand @world()\n  \n  inform: (msg) ->\n    text = msg\n    if msg\n      text = msg.toString()  if msg.toString\n    else\n      text = "NULL"\n    m = new MenuMorph(false, @, true, true, text)\n    m.addItem "Ok"\n    m.isfloatDraggable = true\n    m.popUpCenteredAtHand @world()\n\n  prompt: (msg, target, callback, defaultContents, width, floorNum,\n    ceilingNum, isRounded) ->\n    isNumeric = true  if ceilingNum\n    tempPromptEntryField = new StringFieldMorph(\n      defaultContents or "",\n      width or 100,\n      WorldMorph.preferencesAndSettings.prompterFontSize,\n      WorldMorph.preferencesAndSettings.prompterFontName,\n      false,\n      false,\n      isNumeric)\n    menu = new MenuMorph(false, target, true, true, msg or "", tempPromptEntryField)\n    menu.tempPromptEntryField = tempPromptEntryField\n    menu.items.push tempPromptEntryField\n    if ceilingNum or WorldMorph.preferencesAndSettings.useSliderForInput\n      slider = new SliderMorph(\n        floorNum or 0,\n        ceilingNum,\n        parseFloat(defaultContents),\n        Math.floor((ceilingNum - floorNum) / 4),\n        "horizontal")\n      slider.alpha = 1\n      slider.color = new Color(225, 225, 225)\n      slider.button.color = new Color 60,60,60\n      slider.button.highlightColor = slider.button.color.copy()\n      slider.button.highlightColor.b += 100\n      slider.button.pressColor = slider.button.color.copy()\n      slider.button.pressColor.b += 150\n      slider.silentSetHeight WorldMorph.preferencesAndSettings.prompterSliderSize\n      slider.target = @\n      slider.argumentToAction = menu\n      if isRounded\n        slider.action = "reactToSliderAction1"\n      else\n        slider.action = "reactToSliderAction2"\n      menu.items.push slider\n    menu.addLine 2\n    menu.addItem "Ok", true, target, callback\n\n    menu.addItem "Cancel", true, @, ->\n      null\n\n    menu.isfloatDraggable = true\n    menu.popUpAtHand(@firstContainerMenu())\n    tempPromptEntryField.text.edit()\n\n  reactToSliderAction1: (num, theMenu) ->\n    theMenu.tempPromptEntryField.changed()\n    theMenu.tempPromptEntryField.text.text = Math.round(num).toString()\n    theMenu.tempPromptEntryField.text.setLayoutBeforeUpdatingBackingStore()\n    theMenu.tempPromptEntryField.text.updateBackingStore()\n    theMenu.tempPromptEntryField.text.changed()\n    theMenu.tempPromptEntryField.text.edit()\n\n  reactToSliderAction2: (num, theMenu) ->\n    theMenu.tempPromptEntryField.changed()\n    theMenu.tempPromptEntryField.text.text = num.toString()\n    theMenu.tempPromptEntryField.text.setLayoutBeforeUpdatingBackingStore()\n    theMenu.tempPromptEntryField.text.updateBackingStore()\n    theMenu.tempPromptEntryField.text.changed()\n  \n  pickColor: (msg, callback, defaultContents) ->\n    colorPicker = new ColorPickerMorph(defaultContents)\n    menu = new MenuMorph(false, @, true, true, msg or "", colorPicker)\n    menu.items.push colorPicker\n    menu.addLine 2\n    menu.addItem "Ok", true, @, callback\n\n    menu.addItem "Cancel", true, @, ->\n      null\n\n    menu.isfloatDraggable = true\n    menu.popUpAtHand(@firstContainerMenu())\n\n  inspect: (anotherObject) ->\n    @spawnInspector @\n\n  spawnInspector: (inspectee) ->\n    inspector = new InspectorMorph(inspectee)\n    world = (if @world instanceof Function then @world() else (@root() or @world))\n    inspector.setPosition world.hand.position()\n    inspector.keepWithin world\n    world.add inspector\n    inspector.changed()\n    \n  \n  # Morph menus ////////////////////////////////////////////////////////////////\n  \n  contextMenu: ->\n    # Spacial multiplexing\n    # (search "multiplexing" for the other parts of\n    # code where this matters)\n    # There are two interpretations of what this\n    # list should be:\n    #   1) all morphs "pierced through" by the pointer\n    #   2) all morphs parents of the topmost morph under the pointer\n    # 2 is what is used in Cuis\n    \n    # commented-out addendum for the implementation of 1):\n    #show the normal menu in case there is text selected,\n    #otherwise show the spacial multiplexing list\n    #if !@world().caret\n    #  if @world().hand.allMorphsAtPointer().length > 2\n    #    return @hierarchyMenu()\n    if @customContextMenu\n      return @customContextMenu()\n    world = (if @world instanceof Function then @world() else (@root() or @world))\n    if world and world.isDevMode\n      if @parent is world\n        return @developersMenu()\n      return @hierarchyMenu()\n    @userMenu() or (@parent and @parent.userMenu())\n  \n  # When user right-clicks on a morph that is a child of other morphs,\n  # then it\'s ambiguous which of the morphs she wants to operate on.\n  # An example is right-clicking on a SpeechBubbleMorph: did she\n  # mean to operate on the BubbleMorph or did she mean to operate on\n  # the TextMorph contained in it?\n  # This menu lets her disambiguate.\n  hierarchyMenu: ->\n    # Spacial multiplexing\n    # (search "multiplexing" for the other parts of\n    # code where this matters)\n    # There are two interpretations of what this\n    # list should be:\n    #   1) all morphs "pierced through" by the pointer\n    #   2) all morphs parents of the topmost morph under the pointer\n    # 2 is what is used in Cuis\n    # commented-out addendum for the implementation of 1):\n    # parents = @world().hand.allMorphsAtPointer().reverse()\n    parents = @allParentsTopToBottom()\n    world = (if @world instanceof Function then @world() else (@root() or @world))\n    menu = new MenuMorph(false, @, true, true, null)\n    # show an entry for each of the morphs in the hierarchy.\n    # each entry will open the developer menu for each morph.\n    parents.forEach (each) ->\n      if (each.developersMenu) and (each isnt world) and (!each.anyParentMarkedForDestruction())\n        textLabelForMorph = each.toString().slice(0, 50)\n        menu.addItem textLabelForMorph + " ➜", false, each, "popupDeveloperMenu"\n\n    menu\n\n  popupDeveloperMenu: (morphTriggeringThis)->\n    @developersMenu().popUpAtHand(morphTriggeringThis.firstContainerMenu())\n\n\n  popUpColorSetter: ->\n    @pickColor "color:", "setColor", "color"\n\n  transparencyPopout: (menuItem)->\n    @prompt menuItem.parent.title + "\nalpha\nvalue:",\n      @,\n      "setAlphaScaled",\n      (@alpha * 100).toString(),\n      null,\n      1,\n      100,\n      true\n\n  testMenu: (ignored,targetMorph)->\n    menu = new MenuMorph(false, targetMorph, true, true, null)\n    menu.addItem "serialise morph to memory", true, targetMorph, "serialiseToMemory"\n    menu.addItem "deserialize from memory and attach to world", true, targetMorph, "deserialiseFromMemoryAndAttachToWorld"\n    menu.addItem "deserialize from memory and attach to hand", true, targetMorph, "deserialiseFromMemoryAndAttachToHand"\n    menu.popUpAtHand(@firstContainerMenu())\n\n  serialiseToMemory: ->\n    world.lastSerializationString = @serialize()\n\n  deserialiseFromMemoryAndAttachToHand: ->\n    derezzedObject = world.deserialize world.lastSerializationString\n    derezzedObject.pickUp()\n\n  deserialiseFromMemoryAndAttachToWorld: ->\n    derezzedObject = world.deserialize world.lastSerializationString\n    world.add derezzedObject\n\n  developersMenu: ->\n    # \'name\' is not an official property of a function, hence:\n    userMenu = @userMenu() or (@parent and @parent.userMenu())\n    menu = new MenuMorph(false, \n      @,\n      true,\n      true,\n      @constructor.name or @constructor.toString().split(" ")[1].split("(")[0])\n    if userMenu\n      menu.addItem "user features...", true, @, ->\n        userMenu.popUpAtHand(@firstContainerMenu())\n\n      menu.addLine()\n    menu.addItem "color...", true, @, "popUpColorSetter" , "choose another color \nfor this morph"\n\n    menu.addItem "transparency...", true, @, "transparencyPopout", "set this morph\'s\nalpha value"\n    menu.addItem "resize...", true, @, "resize", "show a handle\nwhich can be floatDragged\nto change this morph\'s" + " extent"\n    menu.addLine()\n    menu.addItem "duplicate", true, @, "duplicateMenuAction" , "make a copy\nand pick it up"\n    menu.addItem "pick up", true, @, "pickUp", "disattach and put \ninto the hand"\n    menu.addItem "attach...", true, @, "attach", "stick this morph\nto another one"\n    menu.addItem "move", true, @, "move", "show a handle\nwhich can be floatDragged\nto move this morph"\n    menu.addItem "inspect", true, @, "inspect", "open a window\non all properties"\n\n    # A) normally, just take a picture of this morph\n    # and open it in a new tab.\n    # B) If a test is being recorded, then the behaviour\n    # is slightly different: a system test command is\n    # triggered to take a screenshot of this particular\n    # morph.\n    # C) If a test is being played, then the screenshot of\n    # the particular morph is put in a special place\n    # in the test player. The command recorded at B) is\n    # going to replay but *waiting* for that screenshot\n    # first.\n    takePic = =>\n      if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n        # While recording a test, just trigger for\n        # the takeScreenshot command to be recorded. \n        window.world.systemTestsRecorderAndPlayer.takeScreenshot(@)\n      else if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n        # While playing a test, this command puts the\n        # screenshot of this morph in a special\n        # variable of the system test runner.\n        # The test runner will wait for this variable\n        # to contain the morph screenshot before\n        # doing the comparison as per command recorded\n        # in the case above.\n        window.world.systemTestsRecorderAndPlayer.imageDataOfAParticularMorph = @fullImageData()\n      else\n        # no system tests recording/playing ongoing,\n        # just open new tab with image of morph.\n        window.open @fullImageData()\n    menu.addItem "take pic", true, @, "takePic", "open a new window\nwith a picture of this morph"\n\n    menu.addItem "test menu ➜", false, @, "testMenu", "debugging and testing operations"\n\n    menu.addLine()\n    if @isfloatDraggable\n      menu.addItem "lock", true, @, "toggleIsfloatDraggable", "make this morph\nunmovable"\n    else\n      menu.addItem "unlock", true, @, "toggleIsfloatDraggable", "make this morph\nmovable"\n    menu.addItem "hide", true, @, "minimise"\n    menu.addItem "delete", true, @, "destroy"\n    menu\n  \n  userMenu: ->\n    null\n  \n  \n  # Morph menu actions\n  calculateAlphaScaled: (alpha) ->\n    if typeof alpha is "number"\n      unscaled = alpha / 100\n      return Math.min(Math.max(unscaled, 0.1), 1)\n    else\n      newAlpha = parseFloat(alpha)\n      unless isNaN(newAlpha)\n        unscaled = newAlpha / 100\n        return Math.min(Math.max(unscaled, 0.1), 1)\n\n  setAlphaScaled: (alphaOrMorphGivingAlpha, morphGivingAlpha) ->\n    if morphGivingAlpha?.getValue?\n      alpha = morphGivingAlpha.getValue()\n    else\n      alpha = alphaOrMorphGivingAlpha\n\n    if alpha\n      @alpha = @calculateAlphaScaled(alpha)\n      @changed()\n  \n  newParentChoice: (ignored, theMorphToBeAttached) ->\n    # this is what happens when "each" is\n    # selected: we attach the selected morph\n    @add theMorphToBeAttached\n    if @ instanceof ScrollFrameMorph\n      @adjustContentsBounds()\n      @adjustScrollBars()\n    else\n      # you expect Morphs attached\n      # inside a FrameMorph\n      # to be floatDraggable out of it\n      # (as opposed to the content of a ScrollFrameMorph)\n      theMorphToBeAttached.isfloatDraggable = false\n\n  attach: ->\n    choices = world.plausibleTargetAndDestinationMorphs(@)\n\n    # my direct parent might be in the\n    # options which is silly, leave that one out\n    choicesExcludingParent = []\n    choices.forEach (each) =>\n      if each != @parent\n        choicesExcludingParent.push each\n\n    if choicesExcludingParent.length > 0\n      menu = new MenuMorph(false, @, true, true, "choose new parent:")\n      choicesExcludingParent.forEach (each) =>\n        menu.addItem each.toString().slice(0, 50), true, each, "newParentChoice"\n    else\n      # the ideal would be to not show the\n      # "attach" menu entry at all but for the\n      # time being it\'s quite costly to\n      # find the eligible morphs to attach\n      # to, so for now let\'s just calculate\n      # this list if the user invokes the\n      # command, and if there are no good\n      # morphs then show some kind of message.\n      menu = new MenuMorph(false, @, true, true, "no morphs to attach to")\n    menu.popUpAtHand(@firstContainerMenu())\n  \n  toggleIsfloatDraggable: ->\n    # for context menu demo purposes\n    @isfloatDraggable = not @isfloatDraggable\n  \n  colorSetters: ->\n    # for context menu demo purposes\n    ["color"]\n  \n  numericalSetters: ->\n    # for context menu demo purposes\n    ["setLeft", "setTop", "setWidth", "setHeight", "setAlphaScaled"]\n  \n  \n  # Morph entry field tabbing //////////////////////////////////////////////\n  \n  allEntryFields: ->\n    @collectAllChildrenBottomToTopSuchThat (each) ->\n      each.isEditable && (each instanceof StringMorph || each instanceof TextMorph);\n  \n  \n  nextEntryField: (current) ->\n    fields = @allEntryFields()\n    idx = fields.indexOf(current)\n    if idx isnt -1\n      if fields.length > (idx + 1)\n        return fields[idx + 1]\n    return fields[0]\n  \n  previousEntryField: (current) ->\n    fields = @allEntryFields()\n    idx = fields.indexOf(current)\n    if idx isnt -1\n      if idx > 0\n        return fields[idx - 1]\n      return fields[fields.length - 1]\n    return fields[0]\n  \n  tab: (editField) ->\n    #\n    #	the <tab> key was pressed in one of my edit fields.\n    #	invoke my "nextTab()" function if it exists, else\n    #	propagate it up my owner chain.\n    #\n    if @nextTab\n      @nextTab editField\n    else @parent.tab editField  if @parent\n  \n  backTab: (editField) ->\n    #\n    #	the <back tab> key was pressed in one of my edit fields.\n    #	invoke my "previousTab()" function if it exists, else\n    #	propagate it up my owner chain.\n    #\n    if @previousTab\n      @previousTab editField\n    else @parent.backTab editField  if @parent\n  \n  \n  #\n  #	the following are examples of what the navigation methods should\n  #	look like. Insert these at the World level for fallback, and at lower\n  #	levels in the Morphic tree (e.g. dialog boxes) for a more fine-grained\n  #	control over the tabbing cycle.\n  #\n  #Morph.prototype.nextTab = function (editField) {\n  #	var	next = this.nextEntryField(editField);\n  #	editField.clearSelection();\n  #	next.selectAll();\n  #	next.edit();\n  #};\n  #\n  #Morph.prototype.previousTab = function (editField) {\n  #	var	prev = this.previousEntryField(editField);\n  #	editField.clearSelection();\n  #	prev.selectAll();\n  #	prev.edit();\n  #};\n  #\n  #\n  \n  # Morph events:\n  escalateEvent: (functionName, arg) ->\n    handler = @parent\n    if handler?\n      handler = handler.parent  while not handler[functionName] and handler.parent?\n      handler[functionName] arg  if handler[functionName]\n  \n  \n  # Morph eval. Used by the Inspector and the TextMorph.\n  evaluateString: (code) ->\n    try\n      result = eval(code)\n      @setLayoutBeforeUpdatingBackingStore()\n      @updateBackingStore()\n      @changed()\n    catch err\n      @inform err\n    result\n  \n  \n  # Morph collision detection - not used anywhere at the moment ////////////////////////\n  \n  isTouching: (otherMorph) ->\n    oImg = @overlappingImage(otherMorph)\n    data = oImg.getContext("2d").getImageData(1, 1, oImg.width, oImg.height).data\n    detect(data, (each) ->\n      each isnt 0\n    ) isnt null\n  \n  overlappingImage: (otherMorph) ->\n    fb = @boundsIncludingChildren()\n    otherFb = otherMorph.boundsIncludingChildren()\n    oRect = fb.intersect(otherFb)\n    oImg = newCanvas(oRect.extent().scaleBy pixelRatio)\n    ctx = oImg.getContext("2d")\n    ctx.scale pixelRatio, pixelRatio\n    if oRect.width() < 1 or oRect.height() < 1\n      return newCanvas((new Point(1, 1)).scaleBy pixelRatio)\n    ctx.drawImage @fullImage(),\n      Math.round(oRect.origin.x - fb.origin.x),\n      Math.round(oRect.origin.y - fb.origin.y)\n    ctx.globalCompositeOperation = "source-in"\n    ctx.drawImage otherMorph.fullImage(),\n      Math.round(otherFb.origin.x - oRect.origin.x),\n      Math.round(otherFb.origin.y - oRect.origin.y)\n    oImg';

  return Morph;

})(MorphicNode);

BlinkerMorph = (function(_super) {
  __extends(BlinkerMorph, _super);

  namedClasses[BlinkerMorph.name] = BlinkerMorph.prototype;

  function BlinkerMorph(fps) {
    this.fps = fps != null ? fps : 2;
    BlinkerMorph.__super__.constructor.call(this);
    this.color = new Color(0, 0, 0);
  }

  BlinkerMorph.prototype.step = function() {
    if (AutomatorRecorderAndPlayer.animationsPacingControl && AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.IDLE) {
      return;
    }
    return this.toggleVisibility();
  };

  BlinkerMorph.coffeeScriptSourceOfThisClass = '# BlinkerMorph ////////////////////////////////////////////////////////\n\n# can be used for text caret\n\nclass BlinkerMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  constructor: (@fps = 2) ->\n    super()\n    @color = new Color(0, 0, 0)\n  \n  # BlinkerMorph stepping:\n  step: ->\n    # if we are recording or playing a test\n    # then there is a flag we need to check that allows\n    # the world to control all the animations.\n    # This is so there is a consistent check\n    # when taking/comparing\n    # screenshots.\n    # So we check here that flag, and make the\n    # caret is always going to be visible.\n    if AutomatorRecorderAndPlayer.animationsPacingControl and\n     AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE\n      return\n \n    # in all other cases just\n    # do like usual, i.e. toggle\n    # visibility at the fps\n    # specified in the constructor.\n    @toggleVisibility()';

  return BlinkerMorph;

})(Morph);

BouncerMorph = (function(_super) {
  __extends(BouncerMorph, _super);

  namedClasses[BouncerMorph.name] = BouncerMorph.prototype;

  BouncerMorph.prototype.isStopped = false;

  BouncerMorph.prototype.type = null;

  BouncerMorph.prototype.direction = null;

  BouncerMorph.prototype.speed = null;

  function BouncerMorph(type, speed) {
    this.type = type != null ? type : "vertical";
    this.speed = speed != null ? speed : 1;
    BouncerMorph.__super__.constructor.call(this);
    this.fps = 50;
    if (this.type === "vertical") {
      this.direction = "down";
    } else {
      this.direction = "right";
    }
  }

  BouncerMorph.prototype.resetPosition = function() {
    if (this.type === "vertical") {
      this.direction = "down";
    } else {
      this.direction = "right";
    }
    return this.setPosition(new Point(this.parent.position().x, this.parent.position().y));
  };

  BouncerMorph.prototype.moveUp = function(silently) {
    if (silently) {
      return this.silentMoveBy(new Point(0, -this.speed));
    } else {
      return this.moveBy(new Point(0, -this.speed));
    }
  };

  BouncerMorph.prototype.moveDown = function(silently) {
    if (silently) {
      return this.silentMoveBy(new Point(0, this.speed));
    } else {
      return this.moveBy(new Point(0, this.speed));
    }
  };

  BouncerMorph.prototype.moveRight = function(silently) {
    if (silently) {
      return this.silentMoveBy(new Point(this.speed, 0));
    } else {
      return this.moveBy(new Point(this.speed, 0));
    }
  };

  BouncerMorph.prototype.moveLeft = function(silently) {
    if (silently) {
      return this.silentMoveBy(new Point(-this.speed, 0));
    } else {
      return this.moveBy(new Point(-this.speed, 0));
    }
  };

  BouncerMorph.prototype.moveAccordingToBounce = function(silently) {
    if (this.type === "vertical") {
      if (this.direction === "down") {
        this.moveDown(silently);
      } else {
        this.moveUp(silently);
      }
      if (this.boundsIncludingChildren().top() < this.parent.top() && this.direction === "up") {
        this.direction = "down";
      }
      if (this.boundsIncludingChildren().bottom() > this.parent.bottom() && this.direction === "down") {
        return this.direction = "up";
      }
    } else if (this.type === "horizontal") {
      if (this.direction === "right") {
        this.moveRight(silently);
      } else {
        this.moveLeft(silently);
      }
      if (this.boundsIncludingChildren().left() < this.parent.left() && this.direction === "left") {
        this.direction = "right";
      }
      if (this.boundsIncludingChildren().right() > this.parent.right() && this.direction === "right") {
        return this.direction = "left";
      }
    }
  };

  BouncerMorph.prototype.step = function() {
    var i, _i, _j, _ref, _ref1;
    if (!this.isStopped) {
      if (AutomatorRecorderAndPlayer.animationsPacingControl) {
        if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.RECORDING) {
          this.resetPosition();
          for (i = _i = 0, _ref = window.world.systemTestsRecorderAndPlayer.automatorCommandsSequence.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            this.moveAccordingToBounce(true);
          }
          this.parent.changed();
          return;
        }
        if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.PLAYING) {
          this.resetPosition();
          for (i = _j = 0, _ref1 = window.world.systemTestsRecorderAndPlayer.indexOfTestCommandBeingPlayedFromSequence; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            this.moveAccordingToBounce(true);
          }
          this.parent.changed();
          return;
        }
      }
      return this.moveAccordingToBounce(false);
    }
  };

  BouncerMorph.coffeeScriptSourceOfThisClass = '# BouncerMorph ////////////////////////////////////////////////////////\n# fishy constructor\n# I am a Demo of a stepping custom Morph\n# Bounces vertically or horizontally within the parent\n\nclass BouncerMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  isStopped: false\n  type: null\n  direction: null\n  speed: null\n\n  constructor: (@type = "vertical", @speed = 1) ->\n    super()\n    @fps = 50\n    # additional properties:\n    if @type is "vertical"\n      @direction = "down"\n    else\n      @direction = "right"\n\n    # @updateBackingStore() not needed, probably\n    # because it\'s repainted in the\n    # next frame since it\'s an animation?\n    #@updateBackingStore()\n\n  resetPosition: ->\n    if @type is "vertical"\n      @direction = "down"\n    else\n      @direction = "right"\n    @setPosition new Point(@parent.position().x, @parent.position().y)\n  \n  \n  # BouncerMorph moving.\n  # We need the silent option because\n  # we might move the bouncer many times\n  # consecutively in the case we tie\n  # the animation to the test step.\n  # The silent option avoids too many\n  # broken rectangles being pushed\n  # so it makes the whole thing smooth\n  # even with many movements at once.\n  moveUp: (silently) ->\n    if silently\n      @silentMoveBy new Point(0, -@speed)\n    else\n      @moveBy new Point(0, -@speed)\n  \n  moveDown: (silently) ->\n    if silently\n      @silentMoveBy new Point(0, @speed)\n    else\n      @moveBy new Point(0, @speed)\n  \n  moveRight: (silently) ->\n    if silently\n      @silentMoveBy new Point(@speed, 0)\n    else\n      @moveBy new Point(@speed, 0)\n  \n  moveLeft: (silently) ->\n    if silently\n      @silentMoveBy new Point(-@speed, 0)\n    else\n      @moveBy new Point(-@speed, 0)\n\n  moveAccordingToBounce: (silently) ->\n    if @type is "vertical"\n      if @direction is "down"\n        @moveDown(silently)\n      else\n        @moveUp(silently)\n      @direction = "down"  if @boundsIncludingChildren().top() < @parent.top() and @direction is "up"\n      @direction = "up"  if @boundsIncludingChildren().bottom() > @parent.bottom() and @direction is "down"\n    else if @type is "horizontal"\n      if @direction is "right"\n        @moveRight(silently)\n      else\n        @moveLeft(silently)\n      @direction = "right"  if @boundsIncludingChildren().left() < @parent.left() and @direction is "left"\n      @direction = "left"  if @boundsIncludingChildren().right() > @parent.right() and @direction is "right"\n  \n  \n  # BouncerMorph stepping:\n  step: ->\n    unless @isStopped\n      # if we are recording or playing a test\n      # then there is a flag we need to check that allows\n      # the world to control all the animations.\n      # This is so there is a consistent check\n      # when taking/comparing\n      # screenshots.\n      # So we check here that flag, and make the\n      # animation is exactly controlled\n      # by the test step count only.\n      #console.log "AutomatorRecorderAndPlayer.animationsPacingControl: " + AutomatorRecorderAndPlayer.animationsPacingControl\n      #console.log "state: " + AutomatorRecorderAndPlayer.state\n      if AutomatorRecorderAndPlayer.animationsPacingControl\n        if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n          @resetPosition()\n          for i in [0... window.world.systemTestsRecorderAndPlayer.automatorCommandsSequence.length]\n            @moveAccordingToBounce(true)\n          @parent.changed()\n          return\n        if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n          @resetPosition()\n          for i in [0... window.world.systemTestsRecorderAndPlayer.indexOfTestCommandBeingPlayedFromSequence]\n            @moveAccordingToBounce(true)\n          @parent.changed()\n          return\n\n      @moveAccordingToBounce(false)';

  return BouncerMorph;

})(Morph);

BoxMorph = (function(_super) {
  __extends(BoxMorph, _super);

  namedClasses[BoxMorph.name] = BoxMorph.prototype;

  BoxMorph.prototype.edge = null;

  BoxMorph.prototype.border = null;

  function BoxMorph(edge, border) {
    this.edge = edge != null ? edge : 4;
    this.border = border || (border === 0 ? 0 : 2);
    BoxMorph.__super__.constructor.call(this);
  }

  BoxMorph.prototype.isTransparentAt = function(aPoint) {
    var radius, relativePoint, thisMorphPosition;
    if (!this.bounds.containsPoint(aPoint)) {
      return true;
    }
    thisMorphPosition = this.position();
    radius = Math.max(this.edge - this.border, 0);
    relativePoint = new Point(aPoint.x - thisMorphPosition.x, aPoint.y - thisMorphPosition.y);
    if (relativePoint.x < radius && relativePoint.y < radius) {
      if (relativePoint.distanceTo(new Point(radius, radius)) > radius) {
        return true;
      }
    } else if (relativePoint.x > this.width() - radius && relativePoint.y < radius) {
      if (relativePoint.distanceTo(new Point(this.width() - radius, radius)) > radius) {
        return true;
      }
    } else if (relativePoint.x < radius && relativePoint.y > this.height() - radius) {
      if (relativePoint.distanceTo(new Point(radius, this.height() - radius)) > radius) {
        return true;
      }
    } else if (relativePoint.x > this.width() - radius && relativePoint.y > this.height() - radius) {
      if (relativePoint.distanceTo(new Point(this.width() - radius, this.height() - radius)) > radius) {
        return true;
      }
    }
    return false;
  };

  BoxMorph.prototype.silentUpdateBackingStore = function() {};

  BoxMorph.prototype.blit = function(aCanvas, clippingRectangle) {
    var al, area, at, context, delta, h, morphPosition, sl, src, st, w;
    if (this.isMinimised || !this.isVisible) {
      return null;
    }
    area = clippingRectangle.intersect(this.bounds).round();
    if (area.isNotEmpty()) {
      delta = this.position().neg();
      src = area.copy().translateBy(delta).round();
      context = aCanvas.getContext("2d");
      sl = src.left() * pixelRatio;
      st = src.top() * pixelRatio;
      al = area.left() * pixelRatio;
      at = area.top() * pixelRatio;
      w = Math.min(src.width() * pixelRatio, this.width() * pixelRatio - sl);
      h = Math.min(src.height() * pixelRatio, this.height() * pixelRatio - st);
      if (w < 1 || h < 1) {
        return null;
      }
      context.save();
      context.beginPath();
      context.moveTo(Math.round(al), Math.round(at));
      context.lineTo(Math.round(al) + Math.round(w), Math.round(at));
      context.lineTo(Math.round(al) + Math.round(w), Math.round(at) + Math.round(h));
      context.lineTo(Math.round(al), Math.round(at) + Math.round(h));
      context.lineTo(Math.round(al), Math.round(at));
      context.closePath();
      context.clip();
      context.globalAlpha = this.alpha;
      context.scale(pixelRatio, pixelRatio);
      morphPosition = this.position();
      context.translate(morphPosition.x, morphPosition.y);
      context.fillStyle = this.color.toString();
      context.beginPath();
      this.outlinePath(context, Math.max(this.edge - this.border, 0), this.border);
      context.closePath();
      context.fill();
      return context.restore();

      /*
      if world.showRedraws
        randomR = Math.round(Math.random()*255)
        randomG = Math.round(Math.random()*255)
        randomB = Math.round(Math.random()*255)
      
        context.save()
        context.globalAlpha = 0.5
        context.fillStyle = "rgb("+randomR+","+randomG+","+randomB+")";
        context.fillRect  Math.round(al),
            Math.round(at),
            Math.round(w),
            Math.round(h)
        context.restore()
       */
    }
  };

  BoxMorph.prototype.outlinePath = function(context, radius, inset) {
    var h, offset, w;
    offset = radius + inset;
    w = this.width();
    h = this.height();
    context.arc(offset, offset, radius, degreesToRadians(-180), degreesToRadians(-90), false);
    context.arc(w - offset, offset, radius, degreesToRadians(-90), degreesToRadians(-0), false);
    context.arc(w - offset, h - offset, radius, degreesToRadians(0), degreesToRadians(90), false);
    return context.arc(offset, h - offset, radius, degreesToRadians(90), degreesToRadians(180), false);
  };

  BoxMorph.prototype.cornerSizePopout = function(menuItem) {
    return this.prompt(menuItem.parent.title + "\ncorner\nsize:", this, "setCornerSize", this.edge.toString(), null, 0, 100, true);
  };

  BoxMorph.prototype.developersMenu = function() {
    var menu;
    menu = BoxMorph.__super__.developersMenu.call(this);
    menu.addLine();
    menu.addItem("border width...", true, this, (function() {
      return this.prompt(menu.title + "\nborder\nwidth:", this.setBorderWidth, this.border.toString(), null, 0, 100, true);
    }), "set the border's\nline size");
    menu.addItem("corner size...", true, this, "cornerSizePopout", "set the corner's\nradius");
    return menu;
  };

  BoxMorph.prototype.setBorderWidth = function(sizeOrMorphGivingSize) {
    var newSize, size;
    if (sizeOrMorphGivingSize.getValue != null) {
      size = sizeOrMorphGivingSize.getValue();
    } else {
      size = sizeOrMorphGivingSize;
    }
    if (typeof size === "number") {
      this.border = Math.max(size, 0);
    } else {
      newSize = parseFloat(size);
      if (!isNaN(newSize)) {
        this.border = Math.max(newSize, 0);
      }
    }
    this.updateBackingStore();
    return this.changed();
  };

  BoxMorph.prototype.setCornerSize = function(sizeOrMorphGivingSize, morphGivingSize) {
    var newSize, size;
    if ((morphGivingSize != null ? morphGivingSize.getValue : void 0) != null) {
      size = morphGivingSize.getValue();
    } else {
      size = sizeOrMorphGivingSize;
    }
    if (typeof size === "number") {
      this.edge = Math.max(size, 0);
    } else {
      newSize = parseFloat(size);
      if (!isNaN(newSize)) {
        this.edge = Math.max(newSize, 0);
      }
    }
    this.updateBackingStore();
    return this.changed();
  };

  BoxMorph.prototype.colorSetters = function() {
    return ["color"];
  };

  BoxMorph.prototype.numericalSetters = function() {
    var list;
    list = BoxMorph.__super__.numericalSetters.call(this);
    list.push("setBorderWidth", "setCornerSize");
    return list;
  };

  BoxMorph.coffeeScriptSourceOfThisClass = '# BoxMorph ////////////////////////////////////////////////////////////\n\n# I can have an optionally rounded border\n\nclass BoxMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  edge: null\n  border: null\n\n  constructor: (@edge = 4, border) ->\n    @border = border or ((if (border is 0) then 0 else 2))\n    super()\n\n  isTransparentAt: (aPoint) ->\n    # first quickly check if the point is even\n    # within the bounding box\n    if !@bounds.containsPoint aPoint\n      return true\n \n    thisMorphPosition = @position()\n    radius = Math.max(@edge - @border, 0)\n \n    relativePoint = new Point(aPoint.x - thisMorphPosition.x, aPoint.y - thisMorphPosition.y)\n\n    # top left corner\n    if relativePoint.x < radius and relativePoint.y < radius\n      if relativePoint.distanceTo(new Point radius,radius) > radius\n        return true\n\n    # top right corner\n    else if relativePoint.x > @width() - radius and relativePoint.y < radius\n      if relativePoint.distanceTo(new Point @width() - radius,radius) > radius\n        return true\n\n    # bottom left corner\n    else if relativePoint.x < radius and relativePoint.y > @height() - radius\n      if relativePoint.distanceTo(new Point radius, @height() - radius) > radius\n        return true\n\n    # bottom right corner\n    else if relativePoint.x > @width() - radius and relativePoint.y > @height() - radius\n      if relativePoint.distanceTo(new Point @width() - radius, @height() - radius) > radius\n        return true\n\n\n    return false\n  \n  silentUpdateBackingStore: ->\n    #console.log \'BoxMorph doing nothing with the backing store\'\n\n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by recursivelyBlit, which\n  # eventually invokes blit.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  blit: (aCanvas, clippingRectangle) ->\n    return null  if @isMinimised or !@isVisible\n    area = clippingRectangle.intersect(@bounds).round()\n    # test whether anything that we are going to be drawing\n    # is visible (i.e. within the clippingRectangle)\n    if area.isNotEmpty()\n      delta = @position().neg()\n      src = area.copy().translateBy(delta).round()\n      context = aCanvas.getContext("2d")\n      sl = src.left() * pixelRatio\n      st = src.top() * pixelRatio\n      al = area.left() * pixelRatio\n      at = area.top() * pixelRatio\n      w = Math.min(src.width() * pixelRatio, @width() * pixelRatio - sl)\n      h = Math.min(src.height() * pixelRatio, @height() * pixelRatio - st)\n      return null  if w < 1 or h < 1\n\n      # initialize my surface property\n      #@image = newCanvas(@extent().scaleBy pixelRatio)\n      #context = @image.getContext("2d")\n      #context.scale pixelRatio, pixelRatio\n\n      context.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      context.beginPath()\n      context.moveTo(Math.round(al), Math.round(at))\n      context.lineTo(Math.round(al) + Math.round(w), Math.round(at))\n      context.lineTo(Math.round(al) + Math.round(w), Math.round(at) + Math.round(h))\n      context.lineTo(Math.round(al), Math.round(at) + Math.round(h))\n      context.lineTo(Math.round(al), Math.round(at))\n      context.closePath()\n      context.clip()\n\n      context.globalAlpha = @alpha\n\n      context.scale pixelRatio, pixelRatio\n      morphPosition = @position()\n      context.translate morphPosition.x, morphPosition.y\n      context.fillStyle = @color.toString()\n      \n      context.beginPath()\n      @outlinePath context, Math.max(@edge - @border, 0), @border\n      context.closePath()\n      context.fill()\n\n      context.restore()\n\n      ###\n      if world.showRedraws\n        randomR = Math.round(Math.random()*255)\n        randomG = Math.round(Math.random()*255)\n        randomB = Math.round(Math.random()*255)\n\n        context.save()\n        context.globalAlpha = 0.5\n        context.fillStyle = "rgb("+randomR+","+randomG+","+randomB+")";\n        context.fillRect  Math.round(al),\n            Math.round(at),\n            Math.round(w),\n            Math.round(h)\n        context.restore()\n      ###\n\n  \n  outlinePath: (context, radius, inset) ->\n    offset = radius + inset\n    w = @width()\n    h = @height()\n    # top left:\n    context.arc offset, offset, radius, degreesToRadians(-180), degreesToRadians(-90), false\n    # top right:\n    context.arc w - offset, offset, radius, degreesToRadians(-90), degreesToRadians(-0), false\n    # bottom right:\n    context.arc w - offset, h - offset, radius, degreesToRadians(0), degreesToRadians(90), false\n    # bottom left:\n    context.arc offset, h - offset, radius, degreesToRadians(90), degreesToRadians(180), false\n\n  cornerSizePopout: (menuItem)->\n    @prompt menuItem.parent.title + "\ncorner\nsize:",\n      @,\n      "setCornerSize",\n      @edge.toString(),\n      null,\n      0,\n      100,\n      true\n\n  \n  # BoxMorph menus:\n  developersMenu: ->\n    menu = super()\n    menu.addLine()\n\n    menu.addItem "border width...", true, @, (->\n      @prompt menu.title + "\nborder\nwidth:",\n        @setBorderWidth,\n        @border.toString(),\n        null,\n        0,\n        100,\n        true\n    ), "set the border\'s\nline size"\n    menu.addItem "corner size...", true, @, "cornerSizePopout", "set the corner\'s\nradius"\n    menu\n  \n  setBorderWidth: (sizeOrMorphGivingSize) ->\n    if sizeOrMorphGivingSize.getValue?\n      size = sizeOrMorphGivingSize.getValue()\n    else\n      size = sizeOrMorphGivingSize\n\n    # for context menu demo purposes\n    if typeof size is "number"\n      @border = Math.max(size, 0)\n    else\n      newSize = parseFloat(size)\n      @border = Math.max(newSize, 0)  unless isNaN(newSize)\n    @updateBackingStore()\n    @changed()\n  \n  \n  setCornerSize: (sizeOrMorphGivingSize, morphGivingSize) ->\n    if morphGivingSize?.getValue?\n      size = morphGivingSize.getValue()\n    else\n      size = sizeOrMorphGivingSize\n\n    # for context menu demo purposes\n    if typeof size is "number"\n      @edge = Math.max(size, 0)\n    else\n      newSize = parseFloat(size)\n      @edge = Math.max(newSize, 0)  unless isNaN(newSize)\n    @updateBackingStore()\n    @changed()\n  \n  colorSetters: ->\n    # for context menu demo purposes\n    ["color"]\n  \n  numericalSetters: ->\n    # for context menu demo purposes\n    list = super()\n    list.push "setBorderWidth", "setCornerSize"\n    list';

  return BoxMorph;

})(Morph);

FrameMorph = (function(_super) {
  __extends(FrameMorph, _super);

  namedClasses[FrameMorph.name] = FrameMorph.prototype;

  FrameMorph.prototype.scrollFrame = null;

  FrameMorph.prototype.extraPadding = 0;

  function FrameMorph(scrollFrame) {
    this.scrollFrame = scrollFrame != null ? scrollFrame : null;
    FrameMorph.__super__.constructor.call(this);
    this.color = new Color(255, 250, 245);
    this.acceptsDrops = true;
    if (this.scrollFrame) {
      this.isfloatDraggable = false;
      this.noticesTransparentClick = false;
    }
  }

  FrameMorph.prototype.setColor = function(aColorOrAMorphGivingAColor, morphGivingColor) {
    var aColor;
    aColor = FrameMorph.__super__.setColor.call(this, aColorOrAMorphGivingAColor, morphGivingColor);
    if (this.scrollFrame) {
      return this.scrollFrame.color = aColor;
    }
  };

  FrameMorph.prototype.setAlphaScaled = function(alpha) {
    if (this.scrollFrame) {
      this.scrollFrame.alpha = this.calculateAlphaScaled(alpha);
    }
    return FrameMorph.__super__.setAlphaScaled.call(this, alpha);
  };

  FrameMorph.prototype.plausibleTargetAndDestinationMorphs = function(theMorph) {
    var result;
    result = [];
    if (!this.isMinimised && this.isVisible && !theMorph.containedInParentsOf(this) && this.bounds.intersects(theMorph.bounds) && !this.anyParentMarkedForDestruction()) {
      result = [this];
    }
    if (this.bounds.intersects(theMorph.bounds)) {
      this.children.forEach(function(child) {
        return result = result.concat(child.plausibleTargetAndDestinationMorphs(theMorph));
      });
    }
    return result;
  };

  FrameMorph.prototype.boundsIncludingChildren = function() {
    var shadow;
    shadow = this.getShadow();
    if (shadow != null) {
      return this.bounds.merge(shadow.bounds);
    }
    return this.bounds;
  };

  FrameMorph.prototype.boundsIncludingChildrenNoShadow = function() {
    return this.bounds;
  };

  FrameMorph.prototype.recursivelyBlit = function(aCanvas, clippingRectangle) {
    var dirtyPartOfFrame;
    if (clippingRectangle == null) {
      clippingRectangle = this.bounds;
    }
    if (!(!this.isMinimised && this.isVisible)) {
      return null;
    }
    dirtyPartOfFrame = this.bounds.intersect(clippingRectangle);
    if (dirtyPartOfFrame.isEmpty()) {
      return null;
    }
    this.blit(aCanvas, dirtyPartOfFrame);
    return this.children.forEach((function(_this) {
      return function(child) {
        if (child instanceof ShadowMorph) {
          return child.recursivelyBlit(aCanvas, clippingRectangle);
        } else {
          return child.recursivelyBlit(aCanvas, dirtyPartOfFrame);
        }
      };
    })(this));
  };

  FrameMorph.prototype.moveBy = function(delta) {
    this.changed();
    this.bounds = this.bounds.translateBy(delta);
    this.children.forEach(function(child) {
      return child.silentMoveBy(delta);
    });
    return this.changed();
  };

  FrameMorph.prototype.reactToDropOf = function() {
    if (this.parent != null) {
      if (this.parent.adjustContentsBounds != null) {
        this.parent.adjustContentsBounds();
        return this.parent.adjustScrollBars();
      }
    }
  };

  FrameMorph.prototype.reactToGrabOf = function() {
    if (this.parent != null) {
      if (this.parent.adjustContentsBounds != null) {
        this.parent.adjustContentsBounds();
        return this.parent.adjustScrollBars();
      }
    }
  };

  FrameMorph.prototype.submorphBounds = function() {
    var result;
    result = null;
    if (this.children.length) {
      result = this.children[0].bounds;
      this.children.forEach(function(child) {
        return result = result.merge(child.boundsIncludingChildren());
      });
    }
    return result;
  };

  FrameMorph.prototype.developersMenu = function() {
    var menu;
    menu = FrameMorph.__super__.developersMenu.call(this);
    if (this.children.length) {
      menu.addLine();
      menu.addItem("move all inside", true, this, "keepAllSubmorphsWithin", "keep all submorphs\nwithin and visible");
    }
    return menu;
  };

  FrameMorph.prototype.keepAllSubmorphsWithin = function() {
    return this.children.forEach((function(_this) {
      return function(m) {
        return m.keepWithin(_this);
      };
    })(this));
  };

  FrameMorph.coffeeScriptSourceOfThisClass = '#| FrameMorph //////////////////////////////////////////////////////////\n#| \n#| I clip my submorphs at my bounds. Which potentially saves a lot of redrawing\n#| \n#| and event handling. \n#| \n#| It\'s a good idea to use me whenever it\'s clear that there is a  \n#| \n#| "container"/"contained" scenario going on.\n\nclass FrameMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  scrollFrame: null\n  extraPadding: 0\n\n  # if this frame belongs to a scrollFrame, then\n  # the @scrollFrame points to it\n  constructor: (@scrollFrame = null) ->\n    super()\n    @color = new Color(255, 250, 245)\n    @acceptsDrops = true\n    if @scrollFrame\n      @isfloatDraggable = false\n      @noticesTransparentClick = false\n\n  setColor: (aColorOrAMorphGivingAColor, morphGivingColor) ->\n    aColor = super(aColorOrAMorphGivingAColor, morphGivingColor)\n    # keep in synch the value of the container scrollFrame\n    # if there is one. Note that the container scrollFrame\n    # is actually not painted.\n    if @scrollFrame\n      @scrollFrame.color = aColor\n\n  setAlphaScaled: (alpha) ->\n    # keep in synch the value of the container scrollFrame\n    # if there is one. Note that the container scrollFrame\n    # is actually not painted.\n    if @scrollFrame\n      @scrollFrame.alpha = @calculateAlphaScaled(alpha)\n    super(alpha)\n\n  # used for example:\n  # - to determine which morphs you can attach a morph to\n  # - for a SliderMorph\'s "set target" so you can change properties of another Morph\n  # - by the HandleMorph when you attach it to some other morph\n  # Note that this method has a slightly different\n  # version in Morph (because it doesn\'t clip)\n  plausibleTargetAndDestinationMorphs: (theMorph) ->\n    # find if I intersect theMorph,\n    # then check my children recursively\n    # exclude me if I\'m a child of theMorph\n    # (cause it\'s usually odd to attach a Morph\n    # to one of its submorphs or for it to\n    # control the properties of one of its submorphs)\n    result = []\n    if !@isMinimised and\n        @isVisible and\n        !theMorph.containedInParentsOf(@) and\n        @bounds.intersects(theMorph.bounds) and\n        !@anyParentMarkedForDestruction()\n      result = [@]\n\n    # Since the FrameMorph clips its children\n    # at its boundary, hence we need\n    # to check that we don\'t consider overlaps with\n    # morphs contained in this frame that are clipped and\n    # hence *actually* not overlapping with theMorph.\n    # So continue checking the children only if the\n    # frame itself actually overlaps.\n    if @bounds.intersects(theMorph.bounds)\n      @children.forEach (child) ->\n        result = result.concat(child.plausibleTargetAndDestinationMorphs(theMorph))\n\n    return result\n  \n  # frames clip at their boundaries\n  # so there is no need to do a deep\n  # traversal to find the bounds.\n  boundsIncludingChildren: ->\n    shadow = @getShadow()\n    if shadow?\n      return @bounds.merge(shadow.bounds)\n    @bounds\n\n  \n  boundsIncludingChildrenNoShadow: ->\n    # answer my full bounds but ignore any shadow\n    @bounds\n\n  \n  recursivelyBlit: (aCanvas, clippingRectangle = @bounds) ->\n    return null  unless (!@isMinimised and @isVisible)\n\n    # a FrameMorph has the special property that all of its children\n    # are actually inside its boundary.\n    # This allows\n    # us to avoid the further traversal of potentially\n    # many many morphs if we see that the rectangle we\n    # want to blit is outside its frame.\n    # If the rectangle we want to blit is inside the frame\n    # then we do have to continue traversing all the\n    # children of the Frame.\n\n    # This is why as well it\'s good to use FrameMorphs whenever\n    # it\'s clear that there is a "container" case. Think\n    # for example that you could stick a small\n    # RectangleMorph (not a Frame) on the desktop and then\n    # attach a thousand\n    # CircleBoxMorphs on it.\n    # Say that the circles are all inside the rectangle,\n    # apart from four that are at the corners of the world.\n    # that\'s a nightmare scenegraph\n    # to *completely* traverse for *any* broken rectangle\n    # anywhere on the screen.\n    # The traversal is complete because a) Morphic doesn\'t\n    # assume that the rectangle clips its children and\n    # b) the bounding rectangle (which currently is not\n    # efficiently calculated anyways) is the whole screen.\n    # So the children could be anywhere and need to be all\n    # checked for damaged areas to repaint.\n    # If the RectangleMorph is made into a frame, one can\n    # avoid the traversal for any broken rectangle not\n    # overlapping it.\n\n    # Also note that in theory you could stop recursion on any\n    # FrameMorph completely covered by a large opaque morph\n    # (or on any Morph which boundsIncludingChildren are completely\n    # covered, for that matter). You could\n    # keep for example a list of the top n biggest opaque morphs\n    # (say, frames and rectangles)\n    # and check that case while you traverse the list.\n    # (see https://github.com/davidedc/Zombie-Kernel/issues/149 )\n    \n    # the part to be redrawn could be outside the frame entirely,\n    # in which case we can stop going down the morphs inside the frame\n    # since the whole point of the frame is to clip everything to a specific\n    # rectangle.\n    # So, check which part of the Frame should be redrawn:\n    dirtyPartOfFrame = @bounds.intersect(clippingRectangle)\n    \n    # if there is no dirty part in the frame then do nothing\n    return null if dirtyPartOfFrame.isEmpty()\n    \n    # this draws the background of the frame itself, which could\n    # contain an image or a pentrail\n    @blit aCanvas, dirtyPartOfFrame\n    \n    @children.forEach (child) =>\n      if child instanceof ShadowMorph\n        child.recursivelyBlit aCanvas, clippingRectangle\n      else\n        child.recursivelyBlit aCanvas, dirtyPartOfFrame\n\n  \n  # FrameMorph scrolling optimization:\n  moveBy: (delta) ->\n    #console.log "moving all morphs in the frame"\n    @changed()\n    @bounds = @bounds.translateBy(delta)\n    @children.forEach (child) ->\n      child.silentMoveBy delta\n    @changed()\n\n  reactToDropOf: ->\n    if @parent?\n      if @parent.adjustContentsBounds?\n        @parent.adjustContentsBounds()\n        @parent.adjustScrollBars()\n  \n  reactToGrabOf: ->\n    if @parent?\n      if @parent.adjustContentsBounds?\n        @parent.adjustContentsBounds()\n        @parent.adjustScrollBars()\n  \n  \n  # FrameMorph scrolling support:\n  submorphBounds: ->\n    result = null\n    if @children.length\n      result = @children[0].bounds\n      @children.forEach (child) ->\n        result = result.merge(child.boundsIncludingChildren())\n    result    \n    \n    \n  # FrameMorph menus:\n  developersMenu: ->\n    menu = super()\n    if @children.length\n      menu.addLine()\n      menu.addItem "move all inside", true, @, "keepAllSubmorphsWithin", "keep all submorphs\nwithin and visible"\n    menu\n  \n  keepAllSubmorphsWithin: ->\n    @children.forEach (m) =>\n      m.keepWithin @';

  return FrameMorph;

})(Morph);

CanvasMorph = (function(_super) {
  __extends(CanvasMorph, _super);

  namedClasses[CanvasMorph.name] = CanvasMorph.prototype;

  CanvasMorph.prototype.scrollFrame = null;

  CanvasMorph.prototype.extraPadding = 0;

  function CanvasMorph(scrollFrame) {
    this.scrollFrame = scrollFrame != null ? scrollFrame : null;
    CanvasMorph.__super__.constructor.call(this);
    this.color = new Color(255, 250, 245);
    this.acceptsDrops = true;
    if (this.scrollFrame) {
      this.isfloatDraggable = false;
      this.noticesTransparentClick = false;
    }
  }

  CanvasMorph.prototype.setColor = function(aColorOrAMorphGivingAColor, morphGivingColor) {
    var aColor;
    aColor = CanvasMorph.__super__.setColor.call(this, aColorOrAMorphGivingAColor, morphGivingColor);
    if (this.scrollFrame) {
      return this.scrollFrame.color = aColor;
    }
  };

  CanvasMorph.prototype.setAlphaScaled = function(alpha) {
    if (this.scrollFrame) {
      this.scrollFrame.alpha = this.calculateAlphaScaled(alpha);
    }
    return CanvasMorph.__super__.setAlphaScaled.call(this, alpha);
  };

  CanvasMorph.prototype.silentUpdateBackingStore = function() {
    var context;
    this.image = newCanvas(this.extent().scaleBy(pixelRatio));
    context = this.image.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    context.fillStyle = this.color.toString();
    context.fillRect(0, 0, this.width(), this.height());
    if (this.cachedTexture) {
      return this.drawCachedTexture();
    } else {
      if (this.texture) {
        return this.drawTexture(this.texture);
      }
    }
  };

  CanvasMorph.prototype.plausibleTargetAndDestinationMorphs = function(theMorph) {
    var result;
    result = [];
    if (!this.isMinimised && this.isVisible && !theMorph.containedInParentsOf(this) && this.bounds.intersects(theMorph.bounds) && !this.anyParentMarkedForDestruction()) {
      result = [this];
    }
    if (this.bounds.intersects(theMorph.bounds)) {
      this.children.forEach(function(child) {
        return result = result.concat(child.plausibleTargetAndDestinationMorphs(theMorph));
      });
    }
    return result;
  };

  CanvasMorph.prototype.penTrails = function() {
    return this.image;
  };

  CanvasMorph.prototype.boundsIncludingChildren = function() {
    var shadow;
    shadow = this.getShadow();
    if (shadow != null) {
      return this.bounds.merge(shadow.bounds);
    }
    return this.bounds;
  };

  CanvasMorph.prototype.boundsIncludingChildrenNoShadow = function() {
    return this.bounds;
  };

  CanvasMorph.prototype.recursivelyBlit = function(aCanvas, clippingRectangle) {
    var dirtyPartOfFrame;
    if (clippingRectangle == null) {
      clippingRectangle = this.bounds;
    }
    if (!(!this.isMinimised && this.isVisible)) {
      return null;
    }
    dirtyPartOfFrame = this.bounds.intersect(clippingRectangle);
    if (dirtyPartOfFrame.isEmpty()) {
      return null;
    }
    this.blit(aCanvas, dirtyPartOfFrame);
    return this.children.forEach((function(_this) {
      return function(child) {
        if (child instanceof ShadowMorph) {
          return child.recursivelyBlit(aCanvas, clippingRectangle);
        } else {
          return child.recursivelyBlit(aCanvas, dirtyPartOfFrame);
        }
      };
    })(this));
  };

  CanvasMorph.prototype.blit = function(aCanvas, clippingRectangle) {
    var al, area, at, context, delta, h, randomB, randomG, randomR, sl, src, st, w;
    if (this.isMinimised || !this.isVisible || (this.image == null)) {
      return null;
    }
    area = clippingRectangle.intersect(this.bounds).round();
    if (area.isNotEmpty()) {
      delta = this.position().neg();
      src = area.copy().translateBy(delta).round();
      context = aCanvas.getContext("2d");
      context.globalAlpha = this.alpha;
      sl = src.left() * pixelRatio;
      st = src.top() * pixelRatio;
      al = area.left() * pixelRatio;
      at = area.top() * pixelRatio;
      w = Math.min(src.width() * pixelRatio, this.image.width - sl);
      h = Math.min(src.height() * pixelRatio, this.image.height - st);
      if (w < 1 || h < 1) {
        return null;
      }
      context.drawImage(this.image, Math.round(sl), Math.round(st), Math.round(w), Math.round(h), Math.round(al), Math.round(at), Math.round(w), Math.round(h));
      if (world.showRedraws) {
        randomR = Math.round(Math.random() * 255);
        randomG = Math.round(Math.random() * 255);
        randomB = Math.round(Math.random() * 255);
        context.globalAlpha = 0.5;
        context.fillStyle = "rgb(" + randomR + "," + randomG + "," + randomB + ")";
        return context.fillRect(Math.round(al), Math.round(at), Math.round(w), Math.round(h));
      }
    }
  };

  CanvasMorph.prototype.moveBy = function(delta) {
    this.changed();
    this.bounds = this.bounds.translateBy(delta);
    this.children.forEach(function(child) {
      return child.silentMoveBy(delta);
    });
    return this.changed();
  };

  CanvasMorph.prototype.submorphBounds = function() {
    var result;
    result = null;
    if (this.children.length) {
      result = this.children[0].bounds;
      this.children.forEach(function(child) {
        return result = result.merge(child.boundsIncludingChildren());
      });
    }
    return result;
  };

  CanvasMorph.prototype.imBeingAddedTo = function(newParentMorph) {};

  CanvasMorph.prototype.developersMenu = function() {
    var menu;
    menu = CanvasMorph.__super__.developersMenu.call(this);
    if (this.children.length) {
      menu.addLine();
      menu.addItem("move all inside", true, this, "keepAllSubmorphsWithin", "keep all submorphs\nwithin and visible");
    }
    return menu;
  };

  CanvasMorph.prototype.keepAllSubmorphsWithin = function() {
    return this.children.forEach((function(_this) {
      return function(m) {
        return m.keepWithin(_this);
      };
    })(this));
  };

  CanvasMorph.coffeeScriptSourceOfThisClass = '#| CanvasMorph //////////////////////////////////////////////////////////\n#| \n#| I clip my submorphs at my bounds. Which potentially saves a lot of redrawing\n#| and event handling. \n#| Also I always use a canvas to retain my graphical representation and respond\n#| to the HTML5 commands.\n#| \n#| "container"/"contained" scenario going on.\n\nclass CanvasMorph extends FrameMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  scrollFrame: null\n  extraPadding: 0\n\n  # if this frame belongs to a scrollFrame, then\n  # the @scrollFrame points to it\n  constructor: (@scrollFrame = null) ->\n    super()\n    @color = new Color(255, 250, 245)\n    @acceptsDrops = true\n    if @scrollFrame\n      @isfloatDraggable = false\n      @noticesTransparentClick = false\n\n  setColor: (aColorOrAMorphGivingAColor, morphGivingColor) ->\n    aColor = super(aColorOrAMorphGivingAColor, morphGivingColor)\n    # keep in synch the value of the container scrollFrame\n    # if there is one. Note that the container scrollFrame\n    # is actually not painted.\n    if @scrollFrame\n      @scrollFrame.color = aColor\n\n  setAlphaScaled: (alpha) ->\n    # keep in synch the value of the container scrollFrame\n    # if there is one. Note that the container scrollFrame\n    # is actually not painted.\n    if @scrollFrame\n      @scrollFrame.alpha = @calculateAlphaScaled(alpha)\n    super(alpha)\n\n  silentUpdateBackingStore: ->\n    # initialize my surface property\n    @image = newCanvas(@extent().scaleBy pixelRatio)\n    context = @image.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    context.fillStyle = @color.toString()\n    context.fillRect 0, 0, @width(), @height()\n    if @cachedTexture\n      @drawCachedTexture()\n    else @drawTexture @texture  if @texture\n\n  # used for example:\n  # - to determine which morphs you can attach a morph to\n  # - for a SliderMorph\'s "set target" so you can change properties of another Morph\n  # - by the HandleMorph when you attach it to some other morph\n  # Note that this method has a slightly different\n  # version in Morph (because it doesn\'t clip)\n  plausibleTargetAndDestinationMorphs: (theMorph) ->\n    # find if I intersect theMorph,\n    # then check my children recursively\n    # exclude me if I\'m a child of theMorph\n    # (cause it\'s usually odd to attach a Morph\n    # to one of its submorphs or for it to\n    # control the properties of one of its submorphs)\n    result = []\n    if !@isMinimised and\n        @isVisible and\n        !theMorph.containedInParentsOf(@) and\n        @bounds.intersects(theMorph.bounds) and\n        !@anyParentMarkedForDestruction()\n      result = [@]\n\n    # Since the FrameMorph clips its children\n    # at its boundary, hence we need\n    # to check that we don\'t consider overlaps with\n    # morphs contained in this frame that are clipped and\n    # hence *actually* not overlapping with theMorph.\n    # So continue checking the children only if the\n    # frame itself actually overlaps.\n    if @bounds.intersects(theMorph.bounds)\n      @children.forEach (child) ->\n        result = result.concat(child.plausibleTargetAndDestinationMorphs(theMorph))\n\n    return result\n\n  # Morph pen trails:\n  penTrails: ->\n    # answer my pen trails canvas. default is to answer my image\n    # The implication is that by default every Morph in the system\n    # (including the World) is able to act as turtle canvas and can\n    # display pen trails.\n    # BUT also this means that pen trails will be lost whenever\n    # the trail\'s morph (the pen\'s parent) performs a "drawNew()"\n    # operation. If you want to create your own pen trails canvas,\n    # you may wish to modify its **penTrails()** property, so that\n    # it keeps a separate offscreen canvas for pen trails\n    # (and doesn\'t lose these on redraw).\n    @image\n  \n  # frames clip at their boundaries\n  # so there is no need to do a deep\n  # traversal to find the bounds.\n  boundsIncludingChildren: ->\n    shadow = @getShadow()\n    if shadow?\n      return @bounds.merge(shadow.bounds)\n    @bounds\n\n  \n  boundsIncludingChildrenNoShadow: ->\n    # answer my full bounds but ignore any shadow\n    @bounds\n\n  \n  recursivelyBlit: (aCanvas, clippingRectangle = @bounds) ->\n    return null  unless (!@isMinimised and @isVisible)\n\n    # a FrameMorph has the special property that all of its children\n    # are actually inside its boundary.\n    # This allows\n    # us to avoid the further traversal of potentially\n    # many many morphs if we see that the rectangle we\n    # want to blit is outside its frame.\n    # If the rectangle we want to blit is inside the frame\n    # then we do have to continue traversing all the\n    # children of the Frame.\n\n    # This is why as well it\'s good to use FrameMorphs whenever\n    # it\'s clear that there is a "container" case. Think\n    # for example that you could stick a small\n    # RectangleMorph (not a Frame) on the desktop and then\n    # attach a thousand\n    # CircleBoxMorphs on it.\n    # Say that the circles are all inside the rectangle,\n    # apart from four that are at the corners of the world.\n    # that\'s a nightmare scenegraph\n    # to *completely* traverse for *any* broken rectangle\n    # anywhere on the screen.\n    # The traversal is complete because a) Morphic doesn\'t\n    # assume that the rectangle clips its children and\n    # b) the bounding rectangle (which currently is not\n    # efficiently calculated anyways) is the whole screen.\n    # So the children could be anywhere and need to be all\n    # checked for damaged areas to repaint.\n    # If the RectangleMorph is made into a frame, one can\n    # avoid the traversal for any broken rectangle not\n    # overlapping it.\n\n    # Also note that in theory you could stop recursion on any\n    # FrameMorph completely covered by a large opaque morph\n    # (or on any Morph which boundsIncludingChildren are completely\n    # covered, for that matter). You could\n    # keep for example a list of the top n biggest opaque morphs\n    # (say, frames and rectangles)\n    # and check that case while you traverse the list.\n    # (see https://github.com/davidedc/Zombie-Kernel/issues/149 )\n    \n    # the part to be redrawn could be outside the frame entirely,\n    # in which case we can stop going down the morphs inside the frame\n    # since the whole point of the frame is to clip everything to a specific\n    # rectangle.\n    # So, check which part of the Frame should be redrawn:\n    dirtyPartOfFrame = @bounds.intersect(clippingRectangle)\n    \n    # if there is no dirty part in the frame then do nothing\n    return null if dirtyPartOfFrame.isEmpty()\n    \n    # this draws the background of the frame itself, which could\n    # contain an image or a pentrail\n    @blit aCanvas, dirtyPartOfFrame\n    \n    @children.forEach (child) =>\n      if child instanceof ShadowMorph\n        child.recursivelyBlit aCanvas, clippingRectangle\n      else\n        child.recursivelyBlit aCanvas, dirtyPartOfFrame\n  \n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by recursivelyBlit, which\n  # eventually invokes blit.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  blit: (aCanvas, clippingRectangle) ->\n    return null  if @isMinimised or !@isVisible or !@image?\n    area = clippingRectangle.intersect(@bounds).round()\n    # test whether anything that we are going to be drawing\n    # is visible (i.e. within the clippingRectangle)\n    if area.isNotEmpty()\n      delta = @position().neg()\n      src = area.copy().translateBy(delta).round()\n      context = aCanvas.getContext("2d")\n      context.globalAlpha = @alpha\n      sl = src.left() * pixelRatio\n      st = src.top() * pixelRatio\n      al = area.left() * pixelRatio\n      at = area.top() * pixelRatio\n      w = Math.min(src.width() * pixelRatio, @image.width - sl)\n      h = Math.min(src.height() * pixelRatio, @image.height - st)\n      return null  if w < 1 or h < 1\n\n      context.drawImage @image,\n        Math.round(sl),\n        Math.round(st),\n        Math.round(w),\n        Math.round(h),\n        Math.round(al),\n        Math.round(at),\n        Math.round(w),\n        Math.round(h)\n\n      if world.showRedraws\n        randomR = Math.round(Math.random()*255)\n        randomG = Math.round(Math.random()*255)\n        randomB = Math.round(Math.random()*255)\n        context.globalAlpha = 0.5\n        context.fillStyle = "rgb("+randomR+","+randomG+","+randomB+")";\n        context.fillRect(Math.round(al),Math.round(at),Math.round(w),Math.round(h));\n\n\n  # FrameMorph scrolling optimization:\n  moveBy: (delta) ->\n    #console.log "moving all morphs in the frame"\n    @changed()\n    @bounds = @bounds.translateBy(delta)\n    @children.forEach (child) ->\n      child.silentMoveBy delta\n    @changed()\n  \n  \n  # FrameMorph scrolling support:\n  submorphBounds: ->\n    result = null\n    if @children.length\n      result = @children[0].bounds\n      @children.forEach (child) ->\n        result = result.merge(child.boundsIncludingChildren())\n    result\n  \n  \n  imBeingAddedTo: (newParentMorph) ->\n  \n    \n  # menus:\n  developersMenu: ->\n    menu = super()\n    if @children.length\n      menu.addLine()\n      menu.addItem "move all inside", true, @, "keepAllSubmorphsWithin", "keep all submorphs\nwithin and visible"\n    menu\n  \n  keepAllSubmorphsWithin: ->\n    @children.forEach (m) =>\n      m.keepWithin @';

  return CanvasMorph;

})(FrameMorph);

CaretMorph = (function(_super) {
  __extends(CaretMorph, _super);

  namedClasses[CaretMorph.name] = CaretMorph.prototype;

  CaretMorph.prototype.keyDownEventUsed = false;

  CaretMorph.prototype.target = null;

  CaretMorph.prototype.originalContents = null;

  CaretMorph.prototype.slot = null;

  CaretMorph.prototype.viewPadding = 1;

  function CaretMorph(target) {
    var ls;
    this.target = target;
    this.originalContents = this.target.text;
    this.originalAlignment = this.target.alignment;
    this.slot = this.target.text.length;
    CaretMorph.__super__.constructor.call(this);
    ls = fontHeight(this.target.fontSize);
    this.setExtent(new Point(Math.max(Math.floor(ls / 20), 1), ls));
    if (this.target instanceof TextMorph && (this.target.alignment !== 'left')) {
      this.target.setAlignmentToLeft();
    }
    this.gotoSlot(this.slot);
  }

  CaretMorph.prototype.processKeyPress = function(charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) {
    if (this.keyDownEventUsed) {
      this.keyDownEventUsed = false;
      return null;
    }
    if (ctrlKey) {
      this.ctrl(charCode);
    } else if (metaKey) {
      this.cmd(charCode);
    } else {
      this.insert(symbol, shiftKey);
    }
    return this.target.escalateEvent("reactToKeystroke", charCode, symbol, shiftKey, ctrlKey, altKey, metaKey);
  };

  CaretMorph.prototype.processKeyDown = function(scanCode, shiftKey, ctrlKey, altKey, metaKey) {
    this.keyDownEventUsed = false;
    if (ctrlKey) {
      this.ctrl(scanCode);
      this.target.escalateEvent("reactToKeystroke", scanCode, null, shiftKey, ctrlKey, altKey, metaKey);
      return;
    } else if (metaKey) {
      this.cmd(scanCode);
      this.target.escalateEvent("reactToKeystroke", scanCode, null, shiftKey, ctrlKey, altKey, metaKey);
      return;
    }
    switch (scanCode) {
      case 37:
        this.goLeft(shiftKey);
        this.keyDownEventUsed = true;
        break;
      case 39:
        this.goRight(shiftKey);
        this.keyDownEventUsed = true;
        break;
      case 38:
        this.goUp(shiftKey);
        this.keyDownEventUsed = true;
        break;
      case 40:
        this.goDown(shiftKey);
        this.keyDownEventUsed = true;
        break;
      case 36:
        this.goHome(shiftKey);
        this.keyDownEventUsed = true;
        break;
      case 35:
        this.goEnd(shiftKey);
        this.keyDownEventUsed = true;
        break;
      case 46:
        this.deleteRight();
        this.keyDownEventUsed = true;
        break;
      case 8:
        this.deleteLeft();
        this.keyDownEventUsed = true;
        break;
      case 13:
        if (this.target.constructor.name === "StringMorph") {
          this.accept();
        } else {
          this.insert("\n");
        }
        this.keyDownEventUsed = true;
        break;
      case 27:
        this.cancel();
        this.keyDownEventUsed = true;
        break;
    }
    return this.target.escalateEvent("reactToKeystroke", scanCode, null, shiftKey, ctrlKey, altKey, metaKey);
  };

  CaretMorph.prototype.gotoSlot = function(slot) {
    var left, length, pos, right;
    length = this.target.text.length;
    this.slot = (slot < 0 ? 0 : (slot > length ? length : slot));
    pos = this.target.slotCoordinates(this.slot);
    if (this.parent && this.target.isScrollable) {
      right = this.parent.right() - this.viewPadding;
      left = this.parent.left() + this.viewPadding;
      if (pos.x > right) {
        this.target.setLeft(this.target.left() + right - pos.x);
        pos.x = right;
      }
      if (pos.x < left) {
        left = Math.min(this.parent.left(), left);
        this.target.setLeft(this.target.left() + left - pos.x);
        pos.x = left;
      }
      if (this.target.right() < right && right - this.target.width() < left) {
        pos.x += right - this.target.right();
        this.target.setRight(right);
      }
    }
    this.show();
    this.setPosition(pos);
    if (this.parent && this.parent.parent instanceof ScrollFrameMorph && this.target.isScrollable) {
      return this.parent.parent.scrollCaretIntoView(this);
    }
  };

  CaretMorph.prototype.goLeft = function(shift) {
    this.updateSelection(shift);
    this.gotoSlot(this.slot - 1);
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.goRight = function(shift, howMany) {
    this.updateSelection(shift);
    this.gotoSlot(this.slot + (howMany || 1));
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.goUp = function(shift) {
    this.updateSelection(shift);
    this.gotoSlot(this.target.upFrom(this.slot));
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.goDown = function(shift) {
    this.updateSelection(shift);
    this.gotoSlot(this.target.downFrom(this.slot));
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.goHome = function(shift) {
    this.updateSelection(shift);
    this.gotoSlot(this.target.startOfLine(this.slot));
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.goEnd = function(shift) {
    this.updateSelection(shift);
    this.gotoSlot(this.target.endOfLine(this.slot));
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.gotoPos = function(aPoint) {
    this.gotoSlot(this.target.slotAt(aPoint));
    return this.show();
  };

  CaretMorph.prototype.updateSelection = function(shift) {
    if (shift) {
      if ((this.target.endMark === null) && (this.target.startMark === null)) {
        this.target.startMark = this.slot;
        return this.target.endMark = this.slot;
      } else if (this.target.endMark !== this.slot) {
        this.target.endMark = this.slot;
        this.target.setLayoutBeforeUpdatingBackingStore();
        this.target.updateBackingStore();
        return this.target.changed();
      }
    } else {
      return this.target.clearSelection();
    }
  };

  CaretMorph.prototype.accept = function() {
    var world;
    world = this.root();
    if (world) {
      world.stopEditing();
    }
    return this.escalateEvent("accept", null);
  };

  CaretMorph.prototype.cancel = function() {
    var world;
    world = this.root();
    this.undo();
    if (world) {
      world.stopEditing();
    }
    return this.escalateEvent('cancel', null);
  };

  CaretMorph.prototype.undo = function() {
    this.target.text = this.originalContents;
    this.target.clearSelection();
    this.target.changed();
    this.target.setLayoutBeforeUpdatingBackingStore();
    this.target.updateBackingStore();
    this.target.changed();
    return this.gotoSlot(0);
  };

  CaretMorph.prototype.insert = function(symbol, shiftKey) {
    var text;
    if (symbol === "\t") {
      this.target.escalateEvent('reactToEdit', this.target);
      if (shiftKey) {
        return this.target.backTab(this.target);
      }
      return this.target.tab(this.target);
    }
    if (!this.target.isNumeric || !isNaN(parseFloat(symbol)) || contains(["-", "."], symbol)) {
      if (this.target.selection() !== "") {
        this.gotoSlot(this.target.selectionStartSlot());
        this.target.deleteSelection();
      }
      text = this.target.text;
      text = text.slice(0, this.slot) + symbol + text.slice(this.slot);
      this.target.text = text;
      this.target.setLayoutBeforeUpdatingBackingStore();
      this.target.updateBackingStore();
      this.target.changed();
      return this.goRight(false, symbol.length);
    }
  };

  CaretMorph.prototype.ctrl = function(scanCodeOrCharCode) {
    if ((scanCodeOrCharCode === 97) || (scanCodeOrCharCode === 65)) {
      return this.target.selectAll();
    } else if (scanCodeOrCharCode === 90) {
      return this.undo();
    } else if (scanCodeOrCharCode === 123) {
      return this.insert("{");
    } else if (scanCodeOrCharCode === 125) {
      return this.insert("}");
    } else if (scanCodeOrCharCode === 91) {
      return this.insert("[");
    } else if (scanCodeOrCharCode === 93) {
      return this.insert("]");
    } else if (scanCodeOrCharCode === 64) {
      return this.insert("@");
    }
  };

  CaretMorph.prototype.cmd = function(scanCode) {
    if (scanCode === 65) {
      return this.target.selectAll();
    } else if (scanCode === 90) {
      return this.undo();
    }
  };

  CaretMorph.prototype.deleteRight = function() {
    var text;
    if (this.target.selection() !== "") {
      this.gotoSlot(this.target.selectionStartSlot());
      this.target.deleteSelection();
    } else {
      text = this.target.text;
      this.target.changed();
      text = text.slice(0, this.slot) + text.slice(this.slot + 1);
      this.target.text = text;
    }
    this.target.setLayoutBeforeUpdatingBackingStore();
    return this.target.updateBackingStore();
  };

  CaretMorph.prototype.deleteLeft = function() {
    var text;
    if (this.target.selection()) {
      this.gotoSlot(this.target.selectionStartSlot());
      this.target.deleteSelection();
    } else {
      text = this.target.text;
      this.target.changed();
      this.target.text = text.substring(0, this.slot - 1) + text.substr(this.slot);
    }
    this.target.setLayoutBeforeUpdatingBackingStore();
    this.target.updateBackingStore();
    return this.goLeft();
  };

  CaretMorph.prototype.destroy = function() {
    if (this.target.alignment !== this.originalAlignment) {
      this.target.alignment = this.originalAlignment;
      this.target.setLayoutBeforeUpdatingBackingStore();
      this.target.updateBackingStore();
      this.target.changed();
    }
    return CaretMorph.__super__.destroy.apply(this, arguments);
  };

  CaretMorph.prototype.inspectKeyEvent = function(event) {
    return this.inform("Key pressed: " + String.fromCharCode(event.charCode) + "\n------------------------" + "\ncharCode: " + event.charCode + "\nkeyCode: " + event.keyCode + "\naltKey: " + event.altKey + "\nctrlKey: " + event.ctrlKey + "\ncmdKey: " + event.metaKey);
  };

  CaretMorph.coffeeScriptSourceOfThisClass = '# CaretMorph /////////////////////////////////////////////////////////\n\n# I mark where the caret is in a String/Text while editing\n\nclass CaretMorph extends BlinkerMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  keyDownEventUsed: false\n  target: null\n  originalContents: null\n  slot: null\n  viewPadding: 1\n\n  constructor: (@target) ->\n    # additional properties:\n    @originalContents = @target.text\n    @originalAlignment = @target.alignment\n    @slot = @target.text.length\n    super()\n    ls = fontHeight(@target.fontSize)\n    @setExtent new Point(Math.max(Math.floor(ls / 20), 1), ls)\n    if (@target instanceof TextMorph && (@target.alignment != \'left\'))\n      @target.setAlignmentToLeft()\n    @gotoSlot @slot\n  \n  # CaretMorph event processing:\n  processKeyPress: (charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) ->\n    # @inspectKeyEvent event\n    if @keyDownEventUsed\n      @keyDownEventUsed = false\n      return null\n    if ctrlKey\n      @ctrl charCode\n    # in Chrome/OSX cmd-a and cmd-z\n    # don\'t trigger a keypress so this\n    # function invocation here does\n    # nothing.\n    else if metaKey\n      @cmd charCode\n    else\n      @insert symbol, shiftKey\n    # notify target\'s parent of key event\n    @target.escalateEvent "reactToKeystroke", charCode, symbol, shiftKey, ctrlKey, altKey, metaKey\n  \n  processKeyDown: (scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    # this.inspectKeyEvent(event);\n    @keyDownEventUsed = false\n    if ctrlKey\n      @ctrl scanCode\n      # notify target\'s parent of key event\n      @target.escalateEvent "reactToKeystroke", scanCode, null, shiftKey, ctrlKey, altKey, metaKey\n      return\n    else if metaKey\n      @cmd scanCode\n      # notify target\'s parent of key event\n      @target.escalateEvent "reactToKeystroke", scanCode, null, shiftKey, ctrlKey, altKey, metaKey\n      return\n    switch scanCode\n      when 37\n        @goLeft(shiftKey)\n        @keyDownEventUsed = true\n      when 39\n        @goRight(shiftKey)\n        @keyDownEventUsed = true\n      when 38\n        @goUp(shiftKey)\n        @keyDownEventUsed = true\n      when 40\n        @goDown(shiftKey)\n        @keyDownEventUsed = true\n      when 36\n        @goHome(shiftKey)\n        @keyDownEventUsed = true\n      when 35\n        @goEnd(shiftKey)\n        @keyDownEventUsed = true\n      when 46\n        @deleteRight()\n        @keyDownEventUsed = true\n      when 8\n        @deleteLeft()\n        @keyDownEventUsed = true\n      when 13\n        # we can\'t check the class using instanceOf\n        # because TextMorphs are instances of StringMorphs\n        # but they want the enter to insert a carriage return.\n        if @target.constructor.name == "StringMorph"\n          @accept()\n        else\n          @insert "\n"\n        @keyDownEventUsed = true\n      when 27\n        @cancel()\n        @keyDownEventUsed = true\n      else\n    # this.inspectKeyEvent(event);\n    # notify target\'s parent of key event\n    @target.escalateEvent "reactToKeystroke", scanCode, null, shiftKey, ctrlKey, altKey, metaKey\n  \n  \n  # CaretMorph navigation - simple version\n  #gotoSlot: (newSlot) ->\n  #  @setPosition @target.slotCoordinates(newSlot)\n  #  @slot = Math.max(newSlot, 0)\n\n  gotoSlot: (slot) ->\n    # check that slot is within the allowed boundaries of\n    # of zero and text length.\n    length = @target.text.length\n    @slot = (if slot < 0 then 0 else (if slot > length then length else slot))\n\n    pos = @target.slotCoordinates(@slot)\n    if @parent and @target.isScrollable\n      right = @parent.right() - @viewPadding\n      left = @parent.left() + @viewPadding\n      if pos.x > right\n        @target.setLeft @target.left() + right - pos.x\n        pos.x = right\n      if pos.x < left\n        left = Math.min(@parent.left(), left)\n        @target.setLeft @target.left() + left - pos.x\n        pos.x = left\n      if @target.right() < right and right - @target.width() < left\n        pos.x += right - @target.right()\n        @target.setRight right\n    @show()\n    @setPosition pos\n\n    if @parent and @parent.parent instanceof ScrollFrameMorph and @target.isScrollable\n      @parent.parent.scrollCaretIntoView @\n  \n  goLeft: (shift) ->\n    @updateSelection shift\n    @gotoSlot @slot - 1\n    @updateSelection shift\n  \n  goRight: (shift, howMany) ->\n    @updateSelection shift\n    @gotoSlot @slot + (howMany || 1)\n    @updateSelection shift\n  \n  goUp: (shift) ->\n    @updateSelection shift\n    @gotoSlot @target.upFrom(@slot)\n    @updateSelection shift\n  \n  goDown: (shift) ->\n    @updateSelection shift\n    @gotoSlot @target.downFrom(@slot)\n    @updateSelection shift\n  \n  goHome: (shift) ->\n    @updateSelection shift\n    @gotoSlot @target.startOfLine(@slot)\n    @updateSelection shift\n  \n  goEnd: (shift) ->\n    @updateSelection shift\n    @gotoSlot @target.endOfLine(@slot)\n    @updateSelection shift\n  \n  gotoPos: (aPoint) ->\n    @gotoSlot @target.slotAt(aPoint)\n    @show()\n\n  updateSelection: (shift) ->\n    if shift\n      if (@target.endMark is null) and (@target.startMark is null)\n        @target.startMark = @slot\n        @target.endMark = @slot\n      else if @target.endMark isnt @slot\n        @target.endMark = @slot\n        @target.setLayoutBeforeUpdatingBackingStore()\n        @target.updateBackingStore()\n        @target.changed()\n    else\n      @target.clearSelection()  \n  \n  # CaretMorph editing.\n\n  # User presses enter on a stringMorph\n  accept: ->\n    world = @root()\n    world.stopEditing()  if world\n    @escalateEvent "accept", null\n  \n  # User presses ESC\n  cancel: ->\n    world = @root()\n    @undo()\n    world.stopEditing()  if world\n    @escalateEvent \'cancel\', null\n    \n  # User presses CTRL-Z or CMD-Z\n  # Note that this is not a real undo,\n  # what we are doing here is just reverting\n  # all the changes and sort-of-resetting the\n  # state of the target.\n  undo: ->\n    @target.text = @originalContents\n    @target.clearSelection()\n    \n    # in theory these three lines are not\n    # needed because clearSelection runs them\n    # already, but I\'m leaving them here\n    # until I understand better this changed\n    # vs. updateBackingStore semantics.\n    @target.changed()\n    @target.setLayoutBeforeUpdatingBackingStore()\n    @target.updateBackingStore()\n    @target.changed()\n\n    @gotoSlot 0\n  \n  insert: (symbol, shiftKey) ->\n    if symbol is "\t"\n      @target.escalateEvent \'reactToEdit\', @target\n      if shiftKey\n        return @target.backTab(@target);\n      return @target.tab(@target)\n    if not @target.isNumeric or not isNaN(parseFloat(symbol)) or contains(["-", "."], symbol)\n      if @target.selection() isnt ""\n        @gotoSlot @target.selectionStartSlot()\n        @target.deleteSelection()\n      text = @target.text\n      text = text.slice(0, @slot) + symbol + text.slice(@slot)\n      @target.text = text\n      @target.setLayoutBeforeUpdatingBackingStore()\n      @target.updateBackingStore()\n      @target.changed()\n      @goRight false, symbol.length\n  \n  ctrl: (scanCodeOrCharCode) ->\n    # ctrl-a apparently can come from either\n    # keypress or keydown\n    # 64 is for keydown\n    # 97 is for keypress\n    # in Chrome on OSX there is no keypress\n    if (scanCodeOrCharCode is 97) or (scanCodeOrCharCode is 65)\n      @target.selectAll()\n    # ctrl-z arrives both via keypress and\n    # keydown but 90 here matches the keydown only\n    else if scanCodeOrCharCode is 90\n      @undo()\n    # unclear which keyboard needs ctrl\n    # to be pressed to give a keypressed\n    # event for {}[]@\n    # but this is what this catches\n    else if scanCodeOrCharCode is 123\n      @insert "{"\n    else if scanCodeOrCharCode is 125\n      @insert "}"\n    else if scanCodeOrCharCode is 91\n      @insert "["\n    else if scanCodeOrCharCode is 93\n      @insert "]"\n    else if scanCodeOrCharCode is 64\n      @insert "@"\n  \n  # these two arrive only from\n  # keypressed, at least in Chrome/OSX\n  # 65 and 90 are both scan codes.\n  cmd: (scanCode) ->\n    # CMD-A\n    if scanCode is 65\n      @target.selectAll()\n    # CMD-Z\n    else if scanCode is 90\n      @undo()\n  \n  deleteRight: ->\n    if @target.selection() isnt ""\n      @gotoSlot @target.selectionStartSlot()\n      @target.deleteSelection()\n    else\n      text = @target.text\n      @target.changed()\n      text = text.slice(0, @slot) + text.slice(@slot + 1)\n      @target.text = text\n    @target.setLayoutBeforeUpdatingBackingStore()\n    @target.updateBackingStore()\n  \n  deleteLeft: ->\n    if @target.selection()\n      @gotoSlot @target.selectionStartSlot()\n      @target.deleteSelection()\n    else\n      text = @target.text\n      @target.changed()\n      @target.text = text.substring(0, @slot - 1) + text.substr(@slot)\n    @target.setLayoutBeforeUpdatingBackingStore()\n    @target.updateBackingStore()\n    @goLeft()\n\n  # CaretMorph destroying:\n  destroy: ->\n    if @target.alignment isnt @originalAlignment\n      @target.alignment = @originalAlignment\n      @target.setLayoutBeforeUpdatingBackingStore()\n      @target.updateBackingStore()\n      @target.changed()\n    super  \n  \n  # CaretMorph utilities:\n  inspectKeyEvent: (event) ->\n    # private\n    @inform "Key pressed: " + String.fromCharCode(event.charCode) + "\n------------------------" + "\ncharCode: " + event.charCode + "\nkeyCode: " + event.keyCode + "\naltKey: " + event.altKey + "\nctrlKey: " + event.ctrlKey  + "\ncmdKey: " + event.metaKey';

  return CaretMorph;

})(BlinkerMorph);

CircleBoxMorph = (function(_super) {
  __extends(CircleBoxMorph, _super);

  namedClasses[CircleBoxMorph.name] = CircleBoxMorph.prototype;

  CircleBoxMorph.augmentWith(BackingStoreMixin);

  CircleBoxMorph.prototype.orientation = null;

  CircleBoxMorph.prototype.autoOrient = true;

  function CircleBoxMorph(orientation) {
    this.orientation = orientation != null ? orientation : "vertical";
    CircleBoxMorph.__super__.constructor.call(this);
    this.silentSetExtent(new Point(20, 100));
  }

  CircleBoxMorph.prototype.autoOrientation = function() {
    if (this.height() > this.width()) {
      return this.orientation = "vertical";
    } else {
      return this.orientation = "horizontal";
    }
  };

  CircleBoxMorph.prototype.updateBackingStore = function() {
    var center1, center2, context, ext, points, radius, rect, x, y;
    if (this.autoOrient) {
      this.autoOrientation();
    }
    this.image = newCanvas(this.extent().scaleBy(pixelRatio));
    context = this.image.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    if (this.orientation === "vertical") {
      radius = this.width() / 2;
      x = this.center().x;
      center1 = new Point(x, this.top() + radius);
      center2 = new Point(x, this.bottom() - radius);
      rect = this.bounds.origin.add(new Point(0, radius)).corner(this.bounds.corner.subtract(new Point(0, radius)));
    } else {
      radius = this.height() / 2;
      y = this.center().y;
      center1 = new Point(this.left() + radius, y);
      center2 = new Point(this.right() - radius, y);
      rect = this.bounds.origin.add(new Point(radius, 0)).corner(this.bounds.corner.subtract(new Point(radius, 0)));
    }
    points = [center1.subtract(this.bounds.origin), center2.subtract(this.bounds.origin)];
    points.forEach((function(_this) {
      return function(center) {
        context.fillStyle = _this.color.toString();
        context.beginPath();
        context.arc(center.x, center.y, radius, 0, 2 * Math.PI, false);
        context.closePath();
        return context.fill();
      };
    })(this));
    rect = rect.translateBy(this.bounds.origin.neg());
    ext = rect.extent();
    if (ext.x > 0 && ext.y > 0) {
      return context.fillRect(rect.origin.x, rect.origin.y, rect.width(), rect.height());
    }
  };

  CircleBoxMorph.prototype.developersMenu = function() {
    var menu;
    menu = CircleBoxMorph.__super__.developersMenu.call(this);
    menu.addLine();
    if (this.orientation === "vertical") {
      menu.addItem("make horizontal", true, this, "toggleOrientation", "toggle the\norientation");
    } else {
      menu.addItem("make vertical", true, this, "toggleOrientation", "toggle the\norientation");
    }
    return menu;
  };

  CircleBoxMorph.prototype.toggleOrientation = function() {
    var center;
    center = this.center();
    this.changed();
    if (this.orientation === "vertical") {
      this.orientation = "horizontal";
    } else {
      this.orientation = "vertical";
    }
    this.silentSetExtent(new Point(this.height(), this.width()));
    this.setCenter(center);
    this.updateBackingStore();
    return this.changed();
  };

  CircleBoxMorph.coffeeScriptSourceOfThisClass = '# CircleBoxMorph //////////////////////////////////////////////////////\n\n# I can be used for sliders\n# REQUIRES BackingStoreMixin\n\nclass CircleBoxMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith BackingStoreMixin\n\n  orientation: null\n  autoOrient: true\n\n  constructor: (@orientation = "vertical") ->\n    super()\n    @silentSetExtent new Point(20, 100)\n\n  \n  autoOrientation: ->\n    if @height() > @width()\n      @orientation = "vertical"\n    else\n      @orientation = "horizontal"\n  \n  # no changes of position or extent\n  updateBackingStore: ->\n    @autoOrientation()  if @autoOrient\n    @image = newCanvas(@extent().scaleBy pixelRatio)\n    context = @image.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    if @orientation is "vertical"\n      radius = @width() / 2\n      x = @center().x\n      center1 = new Point(x, @top() + radius)\n      center2 = new Point(x, @bottom() - radius)\n      rect = @bounds.origin.add(\n        new Point(0, radius)).corner(@bounds.corner.subtract(new Point(0, radius)))\n    else\n      radius = @height() / 2\n      y = @center().y\n      center1 = new Point(@left() + radius, y)\n      center2 = new Point(@right() - radius, y)\n      rect = @bounds.origin.add(\n        new Point(radius, 0)).corner(@bounds.corner.subtract(new Point(radius, 0)))\n\n    # draw the two circles and then the rectangle connecting them\n    points = [center1.subtract(@bounds.origin), center2.subtract(@bounds.origin)]\n    points.forEach (center) =>\n      context.fillStyle = @color.toString()\n      context.beginPath()\n      context.arc center.x, center.y, radius, 0, 2 * Math.PI, false\n      context.closePath()\n      context.fill()\n    rect = rect.translateBy(@bounds.origin.neg())\n    ext = rect.extent()\n    if ext.x > 0 and ext.y > 0\n      context.fillRect rect.origin.x, rect.origin.y, rect.width(), rect.height()\n  \n  \n  # CircleBoxMorph menu:\n  developersMenu: ->\n    menu = super()\n    menu.addLine()\n    # todo Dan Ingalls did show a neat demo where the\n    # boxmorph was automatically changing the orientation\n    # when resized, following the main direction.\n    if @orientation is "vertical"\n      menu.addItem "make horizontal", true, @, "toggleOrientation", "toggle the\norientation"\n    else\n      menu.addItem "make vertical", true, @, "toggleOrientation", "toggle the\norientation"\n    menu\n  \n  toggleOrientation: ->\n    center = @center()\n    @changed()\n    if @orientation is "vertical"\n      @orientation = "horizontal"\n    else\n      @orientation = "vertical"\n    @silentSetExtent new Point(@height(), @width())\n    @setCenter center\n    @updateBackingStore()\n    @changed()';

  return CircleBoxMorph;

})(Morph);

Color = (function() {
  namedClasses[Color.name] = Color.prototype;

  Color.augmentWith(DeepCopierMixin);

  Color.colourNamesValues = {
    aliceblue: [0xf0, 0xf8, 0xff],
    antiquewhite: [0xfa, 0xeb, 0xd7],
    aqua: [0x00, 0xff, 0xff],
    aquamarine: [0x7f, 0xff, 0xd4],
    azure: [0xf0, 0xff, 0xff],
    beige: [0xf5, 0xf5, 0xdc],
    bisque: [0xff, 0xe4, 0xc4],
    black: [0x00, 0x00, 0x00],
    blanchedalmond: [0xff, 0xeb, 0xcd],
    blue: [0x00, 0x00, 0xff],
    blueviolet: [0x8a, 0x2b, 0xe2],
    brown: [0xa5, 0x2a, 0x2a],
    burlywood: [0xde, 0xb8, 0x87],
    cadetblue: [0x5f, 0x9e, 0xa0],
    chartreuse: [0x7f, 0xff, 0x00],
    chocolate: [0xd2, 0x69, 0x1e],
    coral: [0xff, 0x7f, 0x50],
    cornflowerblue: [0x64, 0x95, 0xed],
    cornsilk: [0xff, 0xf8, 0xdc],
    crimson: [0xdc, 0x14, 0x3c],
    cyan: [0x00, 0xff, 0xff],
    darkblue: [0x00, 0x00, 0x8b],
    darkcyan: [0x00, 0x8b, 0x8b],
    darkgoldenrod: [0xb8, 0x86, 0x0b],
    darkgray: [0xa9, 0xa9, 0xa9],
    darkgrey: [0xa9, 0xa9, 0xa9],
    darkgreen: [0x00, 0x64, 0x00],
    darkkhaki: [0xbd, 0xb7, 0x6b],
    darkmagenta: [0x8b, 0x00, 0x8b],
    darkolivegreen: [0x55, 0x6b, 0x2f],
    darkorange: [0xff, 0x8c, 0x00],
    darkorchid: [0x99, 0x32, 0xcc],
    darkred: [0x8b, 0x00, 0x00],
    darksalmon: [0xe9, 0x96, 0x7a],
    darkseagreen: [0x8f, 0xbc, 0x8f],
    darkslateblue: [0x48, 0x3d, 0x8b],
    darkslategray: [0x2f, 0x4f, 0x4f],
    darkslategrey: [0x2f, 0x4f, 0x4f],
    darkturquoise: [0x00, 0xce, 0xd1],
    darkviolet: [0x94, 0x00, 0xd3],
    deeppink: [0xff, 0x14, 0x93],
    deepskyblue: [0x00, 0xbf, 0xff],
    dimgray: [0x69, 0x69, 0x69],
    dimgrey: [0x69, 0x69, 0x69],
    dodgerblue: [0x1e, 0x90, 0xff],
    firebrick: [0xb2, 0x22, 0x22],
    floralwhite: [0xff, 0xfa, 0xf0],
    forestgreen: [0x22, 0x8b, 0x22],
    fuchsia: [0xff, 0x00, 0xff],
    gainsboro: [0xdc, 0xdc, 0xdc],
    ghostwhite: [0xf8, 0xf8, 0xff],
    gold: [0xff, 0xd7, 0x00],
    goldenrod: [0xda, 0xa5, 0x20],
    gray: [0x80, 0x80, 0x80],
    grey: [0x80, 0x80, 0x80],
    green: [0x00, 0x80, 0x00],
    greenyellow: [0xad, 0xff, 0x2f],
    honeydew: [0xf0, 0xff, 0xf0],
    hotpink: [0xff, 0x69, 0xb4],
    indianred: [0xcd, 0x5c, 0x5c],
    indigo: [0x4b, 0x00, 0x82],
    ivory: [0xff, 0xff, 0xf0],
    khaki: [0xf0, 0xe6, 0x8c],
    lavender: [0xe6, 0xe6, 0xfa],
    lavenderblush: [0xff, 0xf0, 0xf5],
    lawngreen: [0x7c, 0xfc, 0x00],
    lemonchiffon: [0xff, 0xfa, 0xcd],
    lightblue: [0xad, 0xd8, 0xe6],
    lightcoral: [0xf0, 0x80, 0x80],
    lightcyan: [0xe0, 0xff, 0xff],
    lightgoldenrodyellow: [0xfa, 0xfa, 0xd2],
    lightgrey: [0xd3, 0xd3, 0xd3],
    lightgray: [0xd3, 0xd3, 0xd3],
    lightgreen: [0x90, 0xee, 0x90],
    lightpink: [0xff, 0xb6, 0xc1],
    lightsalmon: [0xff, 0xa0, 0x7a],
    lightseagreen: [0x20, 0xb2, 0xaa],
    lightskyblue: [0x87, 0xce, 0xfa],
    lightslategray: [0x77, 0x88, 0x99],
    lightslategrey: [0x77, 0x88, 0x99],
    lightsteelblue: [0xb0, 0xc4, 0xde],
    lightyellow: [0xff, 0xff, 0xe0],
    lime: [0x00, 0xff, 0x00],
    limegreen: [0x32, 0xcd, 0x32],
    linen: [0xfa, 0xf0, 0xe6],
    mintcream: [0xf5, 0xff, 0xfa],
    mistyrose: [0xff, 0xe4, 0xe1],
    moccasin: [0xff, 0xe4, 0xb5],
    navajowhite: [0xff, 0xde, 0xad],
    navy: [0x00, 0x00, 0x80],
    oldlace: [0xfd, 0xf5, 0xe6],
    olive: [0x80, 0x80, 0x00],
    olivedrab: [0x6b, 0x8e, 0x23],
    orange: [0xff, 0xa5, 0x00],
    orangered: [0xff, 0x45, 0x00],
    orchid: [0xda, 0x70, 0xd6],
    palegoldenrod: [0xee, 0xe8, 0xaa],
    palegreen: [0x98, 0xfb, 0x98],
    paleturquoise: [0xaf, 0xee, 0xee],
    palevioletred: [0xd8, 0x70, 0x93],
    papayawhip: [0xff, 0xef, 0xd5],
    peachpuff: [0xff, 0xda, 0xb9],
    peru: [0xcd, 0x85, 0x3f],
    pink: [0xff, 0xc0, 0xcb],
    plum: [0xdd, 0xa0, 0xdd],
    powderblue: [0xb0, 0xe0, 0xe6],
    purple: [0x80, 0x00, 0x80],
    red: [0xff, 0x00, 0x00],
    rosybrown: [0xbc, 0x8f, 0x8f],
    royalblue: [0x41, 0x69, 0xe1],
    saddlebrown: [0x8b, 0x45, 0x13],
    salmon: [0xfa, 0x80, 0x72],
    sandybrown: [0xf4, 0xa4, 0x60],
    seagreen: [0x2e, 0x8b, 0x57],
    seashell: [0xff, 0xf5, 0xee],
    sienna: [0xa0, 0x52, 0x2d],
    silver: [0xc0, 0xc0, 0xc0],
    skyblue: [0x87, 0xce, 0xeb],
    slateblue: [0x6a, 0x5a, 0xcd],
    slategray: [0x70, 0x80, 0x90],
    slategrey: [0x70, 0x80, 0x90],
    snow: [0xff, 0xfa, 0xfa],
    springgreen: [0x00, 0xff, 0x7f],
    steelblue: [0x46, 0x82, 0xb4],
    tan: [0xd2, 0xb4, 0x8c],
    teal: [0x00, 0x80, 0x80],
    thistle: [0xd8, 0xbf, 0xd8],
    tomato: [0xff, 0x63, 0x47],
    turquoise: [0x40, 0xe0, 0xd0],
    violet: [0xee, 0x82, 0xee],
    wheat: [0xf5, 0xde, 0xb3],
    white: [0xff, 0xff, 0xff],
    whitesmoke: [0xf5, 0xf5, 0xf5],
    yellow: [0xff, 0xff, 0x00],
    yellowgreen: [0x9a, 0xcd, 0x32]
  };

  Color.prototype.a = null;

  Color.prototype.r = null;

  Color.prototype.g = null;

  Color.prototype.b = null;

  function Color(r, g, b, a) {
    this.r = r != null ? r : 0;
    this.g = g != null ? g : 0;
    this.b = b != null ? b : 0;
    this.a = a || (a === 0 ? 0 : 1);
  }

  Color.prototype.toString = function() {
    return "rgba(" + Math.round(this.r) + "," + Math.round(this.g) + "," + Math.round(this.b) + "," + this.a + ")";
  };

  Color.prototype.prepareBeforeSerialization = function() {
    var property, _results;
    this.className = this.constructor.name;
    this.classVersion = "0.0.1";
    this.serializerVersion = "0.0.1";
    _results = [];
    for (property in this) {
      if (this[property] != null) {
        if (typeof this[property] === 'object') {
          if (this[property].className == null) {
            if (this[property].prepareBeforeSerialization != null) {
              _results.push(this[property].prepareBeforeSerialization());
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Color.prototype.copy = function() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  };

  Color.prototype.eq = function(aColor) {
    return aColor && this.r === aColor.r && this.g === aColor.g && this.b === aColor.b;
  };

  Color.prototype.hsv = function() {
    var bb, d, gg, h, max, min, rr, s, v;
    rr = this.r / 255;
    gg = this.g / 255;
    bb = this.b / 255;
    max = Math.max(rr, gg, bb);
    min = Math.min(rr, gg, bb);
    h = max;
    s = max;
    v = max;
    d = max - min;
    s = (max === 0 ? 0 : d / max);
    if (max === min) {
      h = 0;
    } else {
      switch (max) {
        case rr:
          h = (gg - bb) / d + (gg < bb ? 6 : 0);
          break;
        case gg:
          h = (bb - rr) / d + 2;
          break;
        case bb:
          h = (rr - gg) / d + 4;
      }
      h /= 6;
    }
    return [h, s, v];
  };

  Color.prototype.set_hsv = function(h, s, v) {
    var f, i, p, q, t;
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
      case 0:
        this.r = v;
        this.g = t;
        this.b = p;
        break;
      case 1:
        this.r = q;
        this.g = v;
        this.b = p;
        break;
      case 2:
        this.r = p;
        this.g = v;
        this.b = t;
        break;
      case 3:
        this.r = p;
        this.g = q;
        this.b = v;
        break;
      case 4:
        this.r = t;
        this.g = p;
        this.b = v;
        break;
      case 5:
        this.r = v;
        this.g = p;
        this.b = q;
    }
    this.r *= 255;
    this.g *= 255;
    return this.b *= 255;
  };

  Color.prototype.mixed = function(proportion, otherColor) {
    var frac1, frac2;
    frac1 = Math.min(Math.max(proportion, 0), 1);
    frac2 = 1 - frac1;
    return new this.constructor(this.r * frac1 + otherColor.r * frac2, this.g * frac1 + otherColor.g * frac2, this.b * frac1 + otherColor.b * frac2);
  };

  Color.prototype.darker = function(percent) {
    var fract;
    fract = 0.8333;
    if (percent) {
      fract = (100 - percent) / 100;
    }
    return this.mixed(fract, new this.constructor(0, 0, 0));
  };

  Color.prototype.lighter = function(percent) {
    var fract;
    fract = 0.8333;
    if (percent) {
      fract = (100 - percent) / 100;
    }
    return this.mixed(fract, new this.constructor(255, 255, 255));
  };

  Color.prototype.dansDarker = function() {
    var hsv, result, vv;
    hsv = this.hsv();
    result = new this.constructor();
    vv = Math.max(hsv[2] - 0.16, 0);
    result.set_hsv(hsv[0], hsv[1], vv);
    return result;
  };

  Color.transparent = function() {
    return new this.constructor(0, 0, 0, 0);
  };

  Color.coffeeScriptSourceOfThisClass = '# Colors //////////////////////////////////////////////////////////////\n\n# REQUIRES DeepCopierMixin\n\nclass Color\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith DeepCopierMixin\n\n  # This "colourNamesValues" data\n  # structure is only used to create\n  # all the CSS color literals, like\n  #   Color.red\n  # This creation of constants\n  # is done in WoldMorph, since\n  # it\'s the first morph to be\n  # created.\n  # In pure theory we\'d like these\n  # constants to be created by a piece\n  # of code at the end of the file, just\n  # after the class definition,\n  # unfortunately we can\'t add it there\n  # as the source in this file is\n  # appended as a further static variable\n  # in this class, so we can\'t\n  # "close" the class by adding code\n  # that it\'s supposed to be outside its\n  # definition.\n  @colourNamesValues =\n    aliceblue:            [0xf0,0xf8,0xff]\n    antiquewhite:         [0xfa,0xeb,0xd7]\n    aqua:                 [0x00,0xff,0xff]\n    aquamarine:           [0x7f,0xff,0xd4]\n    azure:                [0xf0,0xff,0xff]\n    beige:                [0xf5,0xf5,0xdc]\n    bisque:               [0xff,0xe4,0xc4]\n    black:                [0x00,0x00,0x00]\n    blanchedalmond:       [0xff,0xeb,0xcd]\n    blue:                 [0x00,0x00,0xff]\n    blueviolet:           [0x8a,0x2b,0xe2]\n    brown:                [0xa5,0x2a,0x2a]\n    burlywood:            [0xde,0xb8,0x87]\n    cadetblue:            [0x5f,0x9e,0xa0]\n    chartreuse:           [0x7f,0xff,0x00]\n    chocolate:            [0xd2,0x69,0x1e]\n    coral:                [0xff,0x7f,0x50]\n    cornflowerblue:       [0x64,0x95,0xed]\n    cornsilk:             [0xff,0xf8,0xdc]\n    crimson:              [0xdc,0x14,0x3c]\n    cyan:                 [0x00,0xff,0xff]\n    darkblue:             [0x00,0x00,0x8b]\n    darkcyan:             [0x00,0x8b,0x8b]\n    darkgoldenrod:        [0xb8,0x86,0x0b]\n    darkgray:             [0xa9,0xa9,0xa9]\n    darkgrey:             [0xa9,0xa9,0xa9]\n    darkgreen:            [0x00,0x64,0x00]\n    darkkhaki:            [0xbd,0xb7,0x6b]\n    darkmagenta:          [0x8b,0x00,0x8b]\n    darkolivegreen:       [0x55,0x6b,0x2f]\n    darkorange:           [0xff,0x8c,0x00]\n    darkorchid:           [0x99,0x32,0xcc]\n    darkred:              [0x8b,0x00,0x00]\n    darksalmon:           [0xe9,0x96,0x7a]\n    darkseagreen:         [0x8f,0xbc,0x8f]\n    darkslateblue:        [0x48,0x3d,0x8b]\n    darkslategray:        [0x2f,0x4f,0x4f]\n    darkslategrey:        [0x2f,0x4f,0x4f]\n    darkturquoise:        [0x00,0xce,0xd1]\n    darkviolet:           [0x94,0x00,0xd3]\n    deeppink:             [0xff,0x14,0x93]\n    deepskyblue:          [0x00,0xbf,0xff]\n    dimgray:              [0x69,0x69,0x69]\n    dimgrey:              [0x69,0x69,0x69]\n    dodgerblue:           [0x1e,0x90,0xff]\n    firebrick:            [0xb2,0x22,0x22]\n    floralwhite:          [0xff,0xfa,0xf0]\n    forestgreen:          [0x22,0x8b,0x22]\n    fuchsia:              [0xff,0x00,0xff]\n    gainsboro:            [0xdc,0xdc,0xdc]\n    ghostwhite:           [0xf8,0xf8,0xff]\n    gold:                 [0xff,0xd7,0x00]\n    goldenrod:            [0xda,0xa5,0x20]\n    gray:                 [0x80,0x80,0x80]\n    grey:                 [0x80,0x80,0x80]\n    green:                [0x00,0x80,0x00]\n    greenyellow:          [0xad,0xff,0x2f]\n    honeydew:             [0xf0,0xff,0xf0]\n    hotpink:              [0xff,0x69,0xb4]\n    indianred:            [0xcd,0x5c,0x5c]\n    indigo:               [0x4b,0x00,0x82]\n    ivory:                [0xff,0xff,0xf0]\n    khaki:                [0xf0,0xe6,0x8c]\n    lavender:             [0xe6,0xe6,0xfa]\n    lavenderblush:        [0xff,0xf0,0xf5]\n    lawngreen:            [0x7c,0xfc,0x00]\n    lemonchiffon:         [0xff,0xfa,0xcd]\n    lightblue:            [0xad,0xd8,0xe6]\n    lightcoral:           [0xf0,0x80,0x80]\n    lightcyan:            [0xe0,0xff,0xff]\n    lightgoldenrodyellow: [0xfa,0xfa,0xd2]\n    lightgrey:            [0xd3,0xd3,0xd3]\n    lightgray:            [0xd3,0xd3,0xd3]\n    lightgreen:           [0x90,0xee,0x90]\n    lightpink:            [0xff,0xb6,0xc1]\n    lightsalmon:          [0xff,0xa0,0x7a]\n    lightseagreen:        [0x20,0xb2,0xaa]\n    lightskyblue:         [0x87,0xce,0xfa]\n    lightslategray:       [0x77,0x88,0x99]\n    lightslategrey:       [0x77,0x88,0x99]\n    lightsteelblue:       [0xb0,0xc4,0xde]\n    lightyellow:          [0xff,0xff,0xe0]\n    lime:                 [0x00,0xff,0x00]\n    limegreen:            [0x32,0xcd,0x32]\n    linen:                [0xfa,0xf0,0xe6]\n    mintcream:            [0xf5,0xff,0xfa]\n    mistyrose:            [0xff,0xe4,0xe1]\n    moccasin:             [0xff,0xe4,0xb5]\n    navajowhite:          [0xff,0xde,0xad]\n    navy:                 [0x00,0x00,0x80]\n    oldlace:              [0xfd,0xf5,0xe6]\n    olive:                [0x80,0x80,0x00]\n    olivedrab:            [0x6b,0x8e,0x23]\n    orange:               [0xff,0xa5,0x00]\n    orangered:            [0xff,0x45,0x00]\n    orchid:               [0xda,0x70,0xd6]\n    palegoldenrod:        [0xee,0xe8,0xaa]\n    palegreen:            [0x98,0xfb,0x98]\n    paleturquoise:        [0xaf,0xee,0xee]\n    palevioletred:        [0xd8,0x70,0x93]\n    papayawhip:           [0xff,0xef,0xd5]\n    peachpuff:            [0xff,0xda,0xb9]\n    peru:                 [0xcd,0x85,0x3f]\n    pink:                 [0xff,0xc0,0xcb]\n    plum:                 [0xdd,0xa0,0xdd]\n    powderblue:           [0xb0,0xe0,0xe6]\n    purple:               [0x80,0x00,0x80]\n    red:                  [0xff,0x00,0x00]\n    rosybrown:            [0xbc,0x8f,0x8f]\n    royalblue:            [0x41,0x69,0xe1]\n    saddlebrown:          [0x8b,0x45,0x13]\n    salmon:               [0xfa,0x80,0x72]\n    sandybrown:           [0xf4,0xa4,0x60]\n    seagreen:             [0x2e,0x8b,0x57]\n    seashell:             [0xff,0xf5,0xee]\n    sienna:               [0xa0,0x52,0x2d]\n    silver:               [0xc0,0xc0,0xc0]\n    skyblue:              [0x87,0xce,0xeb]\n    slateblue:            [0x6a,0x5a,0xcd]\n    slategray:            [0x70,0x80,0x90]\n    slategrey:            [0x70,0x80,0x90]\n    snow:                 [0xff,0xfa,0xfa]\n    springgreen:          [0x00,0xff,0x7f]\n    steelblue:            [0x46,0x82,0xb4]\n    tan:                  [0xd2,0xb4,0x8c]\n    teal:                 [0x00,0x80,0x80]\n    thistle:              [0xd8,0xbf,0xd8]\n    tomato:               [0xff,0x63,0x47]\n    turquoise:            [0x40,0xe0,0xd0]\n    violet:               [0xee,0x82,0xee]\n    wheat:                [0xf5,0xde,0xb3]\n    white:                [0xff,0xff,0xff]\n    whitesmoke:           [0xf5,0xf5,0xf5]\n    yellow:               [0xff,0xff,0x00]\n    yellowgreen:          [0x9a,0xcd,0x32]\n\n  a: null\n  r: null\n  g: null\n  b: null\n\n  constructor: (@r = 0, @g = 0, @b = 0, a) ->\n    # all values are optional, just (r, g, b) is fine\n    @a = a or ((if (a is 0) then 0 else 1))\n  \n  # Color string representation: e.g. \'rgba(255,165,0,1)\'\n  toString: ->\n    "rgba(" + Math.round(@r) + "," + Math.round(@g) + "," + Math.round(@b) + "," + @a + ")"\n\n\n  prepareBeforeSerialization: ->\n    @className = @constructor.name\n    @classVersion = "0.0.1"\n    @serializerVersion = "0.0.1"\n    for property of @\n      if @[property]?\n        if typeof @[property] == \'object\'\n          if !@[property].className?\n            if @[property].prepareBeforeSerialization?\n              @[property].prepareBeforeSerialization()\n  \n  # Color copying:\n  copy: ->\n    new @constructor(@r, @g, @b, @a)\n  \n  # Color comparison:\n  eq: (aColor) ->\n    # ==\n    aColor and @r is aColor.r and @g is aColor.g and @b is aColor.b\n  \n  \n  # Color conversion (hsv):\n  hsv: ->\n    # ignore alpha\n    rr = @r / 255\n    gg = @g / 255\n    bb = @b / 255\n    max = Math.max(rr, gg, bb)\n    min = Math.min(rr, gg, bb)\n    h = max\n    s = max\n    v = max\n    d = max - min\n    s = (if max is 0 then 0 else d / max)\n    if max is min\n      h = 0\n    else\n      switch max\n        when rr\n          h = (gg - bb) / d + ((if gg < bb then 6 else 0))\n        when gg\n          h = (bb - rr) / d + 2\n        when bb\n          h = (rr - gg) / d + 4\n      h /= 6\n    [h, s, v]\n  \n  set_hsv: (h, s, v) ->\n    # ignore alpha\n    # h, s and v are to be within [0, 1]\n    i = Math.floor(h * 6)\n    f = h * 6 - i\n    p = v * (1 - s)\n    q = v * (1 - f * s)\n    t = v * (1 - (1 - f) * s)\n    switch i % 6\n      when 0\n        @r = v\n        @g = t\n        @b = p\n      when 1\n        @r = q\n        @g = v\n        @b = p\n      when 2\n        @r = p\n        @g = v\n        @b = t\n      when 3\n        @r = p\n        @g = q\n        @b = v\n      when 4\n        @r = t\n        @g = p\n        @b = v\n      when 5\n        @r = v\n        @g = p\n        @b = q\n    @r *= 255\n    @g *= 255\n    @b *= 255\n  \n  \n  # Color mixing:\n  mixed: (proportion, otherColor) ->\n    # answer a copy of this color mixed with another color, ignore alpha\n    frac1 = Math.min(Math.max(proportion, 0), 1)\n    frac2 = 1 - frac1\n    new @constructor(\n      @r * frac1 + otherColor.r * frac2,\n      @g * frac1 + otherColor.g * frac2,\n      @b * frac1 + otherColor.b * frac2)\n  \n  darker: (percent) ->\n    # return an rgb-interpolated darker copy of me, ignore alpha\n    fract = 0.8333\n    fract = (100 - percent) / 100  if percent\n    @mixed fract, new @constructor(0, 0, 0)\n  \n  lighter: (percent) ->\n    # return an rgb-interpolated lighter copy of me, ignore alpha\n    fract = 0.8333\n    fract = (100 - percent) / 100  if percent\n    @mixed fract, new @constructor(255, 255, 255)\n  \n  dansDarker: ->\n    # return an hsv-interpolated darker copy of me, ignore alpha\n    hsv = @hsv()\n    result = new @constructor()\n    vv = Math.max(hsv[2] - 0.16, 0)\n    result.set_hsv hsv[0], hsv[1], vv\n    result\n\n  @transparent: ->\n    return new @constructor(0,0,0,0)\n';

  return Color;

})();

ControllerMixin = {
  onceAddedClassProperties: function() {
    return this.addInstanceProperties({
      setTarget: function() {
        var choices, menu;
        choices = world.plausibleTargetAndDestinationMorphs(this);
        if (choices.length > 0) {
          menu = new MenuMorph(false, this, true, true, "choose target:");
          choices.forEach((function(_this) {
            return function(each) {
              return menu.addItem(each.toString().slice(0, 50) + " ➜", false, _this, "setTargetSetter", null, null, null, null, null, each);
            };
          })(this));
        } else {
          menu = new MenuMorph(false, this, true, true, "no targets available");
        }
        return menu.popUpAtHand(this.firstContainerMenu());
      }
    });
  }
};

ColorPaletteMorph = (function(_super) {
  __extends(ColorPaletteMorph, _super);

  namedClasses[ColorPaletteMorph.name] = ColorPaletteMorph.prototype;

  ColorPaletteMorph.augmentWith(ControllerMixin);

  ColorPaletteMorph.augmentWith(BackingStoreMixin);

  ColorPaletteMorph.prototype.target = null;

  ColorPaletteMorph.prototype.targetSetter = "color";

  ColorPaletteMorph.prototype.choice = null;

  function ColorPaletteMorph(target, sizePoint) {
    this.target = target != null ? target : null;
    ColorPaletteMorph.__super__.constructor.call(this);
    this.silentSetExtent(sizePoint || new Point(80, 50));
  }

  ColorPaletteMorph.prototype.updateBackingStore = function() {
    var context, extent, h, l, x, y, _i, _ref, _results;
    extent = this.extent();
    this.image = newCanvas(extent.scaleBy(pixelRatio));
    context = this.image.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    this.choice = new Color();
    _results = [];
    for (x = _i = 0, _ref = extent.x; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
      h = 360 * x / extent.x;
      y = 0;
      _results.push((function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (y = _j = 0, _ref1 = extent.y; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          l = 100 - (y / extent.y * 100);
          context.fillStyle = "hsl(" + h + ",100%," + l + "%)";
          _results1.push(context.fillRect(x, y, 1, 1));
        }
        return _results1;
      })());
    }
    return _results;
  };

  ColorPaletteMorph.prototype.mouseMove = function(pos) {
    this.choice = this.getPixelColor(pos);
    return this.updateTarget();
  };

  ColorPaletteMorph.prototype.mouseDownLeft = function(pos) {
    this.choice = this.getPixelColor(pos);
    return this.updateTarget();
  };

  ColorPaletteMorph.prototype.updateTarget = function() {
    if (this.target instanceof Morph && (this.choice != null)) {
      if (this.target[this.targetSetter] instanceof Function) {
        return this.target[this.targetSetter](this.choice);
      } else {
        this.target[this.targetSetter] = this.choice;
        this.target.setLayoutBeforeUpdatingBackingStore();
        this.target.updateBackingStore();
        return this.target.changed();
      }
    }
  };

  ColorPaletteMorph.prototype.developersMenu = function() {
    var menu;
    menu = ColorPaletteMorph.__super__.developersMenu.call(this);
    menu.addLine();
    menu.addItem("set target", true, this, "setTarget", "choose another morph\nwhose color property\n will be" + " controlled by this one");
    return menu;
  };

  ColorPaletteMorph.prototype.swapTargetsTHISNAMEISRANDOM = function(ignored, ignored2, theTarget, each) {
    this.target = theTarget;
    return this.targetSetter = each;
  };

  ColorPaletteMorph.prototype.setTargetSetter = function(ignored, ignored2, theTarget) {
    var choices, menu;
    choices = theTarget.colorSetters();
    menu = new MenuMorph(false, this, true, true, "choose target property:");
    choices.forEach((function(_this) {
      return function(each) {
        return menu.addItem(each, true, _this, "swapTargetsTHISNAMEISRANDOM", null, null, null, null, null, theTarget, each);
      };
    })(this));
    if (choices.length === 0) {
      menu = new MenuMorph(false, this, true, true, "no target properties available");
    }
    return menu.popUpAtHand(this.firstContainerMenu());
  };

  ColorPaletteMorph.coffeeScriptSourceOfThisClass = '# ColorPaletteMorph ///////////////////////////////////////////////////\n# REQUIRES ControllerMixin\n# REQUIRES BackingStoreMixin\n\nclass ColorPaletteMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith ControllerMixin\n  @augmentWith BackingStoreMixin\n\n  target: null\n  targetSetter: "color"\n  choice: null\n\n  constructor: (@target = null, sizePoint) ->\n    super()\n    @silentSetExtent sizePoint or new Point(80, 50)\n  \n  # no changes of position or extent\n  updateBackingStore: ->\n    extent = @extent()\n    @image = newCanvas(extent.scaleBy pixelRatio)\n    context = @image.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    @choice = new Color()\n    for x in [0..extent.x]\n      h = 360 * x / extent.x\n      y = 0\n      for y in [0..extent.y]\n        l = 100 - (y / extent.y * 100)\n        # see link below for alternatives on how to set a single\n        # pixel color.\n        # You should really be using putImageData of the whole buffer\n        # here anyways. But this is clearer.\n        # http://stackoverflow.com/questions/4899799/whats-the-best-way-to-set-a-single-pixel-in-an-html5-canvas\n        context.fillStyle = "hsl(" + h + ",100%," + l + "%)"\n        context.fillRect x, y, 1, 1\n  \n  mouseMove: (pos) ->\n    @choice = @getPixelColor(pos)\n    @updateTarget()\n  \n  mouseDownLeft: (pos) ->\n    @choice = @getPixelColor(pos)\n    @updateTarget()\n  \n  updateTarget: ->\n    if @target instanceof Morph and @choice?\n      if @target[@targetSetter] instanceof Function\n        @target[@targetSetter] @choice\n      else\n        @target[@targetSetter] = @choice\n        @target.setLayoutBeforeUpdatingBackingStore()\n        @target.updateBackingStore()\n        @target.changed()\n  \n    \n  # ColorPaletteMorph menu:\n  developersMenu: ->\n    menu = super()\n    menu.addLine()\n    menu.addItem "set target", true, @, "setTarget", "choose another morph\nwhose color property\n will be" + " controlled by this one"\n    menu\n  \n  # setTarget: -> taken form the ControllerMixin\n\n  swapTargetsTHISNAMEISRANDOM: (ignored, ignored2, theTarget, each) ->\n    @target = theTarget\n    @targetSetter = each\n\n  setTargetSetter: (ignored, ignored2, theTarget) ->\n    choices = theTarget.colorSetters()\n    menu = new MenuMorph(false, @, true, true, "choose target property:")\n    choices.forEach (each) =>\n      menu.addItem each, true, @, "swapTargetsTHISNAMEISRANDOM", null, null, null, null, null, theTarget, each\n\n    if choices.length == 0\n      menu = new MenuMorph(false, @, true, true, "no target properties available")\n    menu.popUpAtHand(@firstContainerMenu())';

  return ColorPaletteMorph;

})(Morph);

ColorPickerMorph = (function(_super) {
  __extends(ColorPickerMorph, _super);

  namedClasses[ColorPickerMorph.name] = ColorPickerMorph.prototype;

  ColorPickerMorph.prototype.feedback = null;

  ColorPickerMorph.prototype.choice = null;

  ColorPickerMorph.prototype.colorPalette = null;

  ColorPickerMorph.prototype.grayPalette = null;

  function ColorPickerMorph(defaultColor) {
    this.choice = defaultColor || new Color(255, 255, 255);
    ColorPickerMorph.__super__.constructor.call(this);
    this.color = new Color(255, 255, 255);
    this.setExtent(new Point(80, 80));
  }

  ColorPickerMorph.prototype.setLayoutBeforeUpdatingBackingStore = function() {
    return this.buildSubmorphs();
  };

  ColorPickerMorph.prototype.buildSubmorphs = function() {
    var x, y;
    this.destroyAll();
    this.feedback = new RectangleMorph(new Point(20, 20), this.choice);
    this.colorPalette = new ColorPaletteMorph(this.feedback, new Point(this.width(), 50));
    this.grayPalette = new GrayPaletteMorph(this.feedback, new Point(this.width(), 5));
    this.colorPalette.setPosition(this.bounds.origin);
    this.add(this.colorPalette);
    this.grayPalette.setPosition(this.colorPalette.bottomLeft());
    this.add(this.grayPalette);
    x = this.grayPalette.left() + Math.floor((this.grayPalette.width() - this.feedback.width()) / 2);
    y = this.grayPalette.bottom() + Math.floor((this.bottom() - this.grayPalette.bottom() - this.feedback.height()) / 2);
    this.feedback.setPosition(new Point(x, y));
    return this.add(this.feedback);
  };

  ColorPickerMorph.prototype.imBeingAddedTo = function(newParentMorph) {};

  ColorPickerMorph.prototype.getColor = function() {
    return this.feedback.color;
  };

  ColorPickerMorph.prototype.rootForGrab = function() {
    return this;
  };

  ColorPickerMorph.coffeeScriptSourceOfThisClass = '# ColorPickerMorph ///////////////////////////////////////////////////\n\nclass ColorPickerMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  # pattern: all the children should be declared here\n  # the reason is that when you duplicate a morph\n  # , the duplicated morph needs to have the handles\n  # that will be duplicated. If you don\'t list them\n  # here, then they need to be initialised in the\n  # constructor. But actually they might not be\n  # initialised in the constructor if a "lazy initialisation"\n  # approach is taken. So it\'s good practice\n  # to list them here so they can be duplicated either way.\n  feedback: null\n  choice: null\n  colorPalette: null\n  grayPalette: null\n\n  constructor: (defaultColor) ->\n    @choice = defaultColor or new Color(255, 255, 255)\n    super()\n    @color = new Color(255, 255, 255)\n    @setExtent new Point(80, 80)\n\n  setLayoutBeforeUpdatingBackingStore: ->\n    @buildSubmorphs()\n\n  buildSubmorphs: ->\n    @destroyAll()\n    @feedback = new RectangleMorph(new Point(20, 20), @choice)\n    @colorPalette = new ColorPaletteMorph(@feedback, new Point(@width(), 50))\n    @grayPalette = new GrayPaletteMorph(@feedback, new Point(@width(), 5))\n    @colorPalette.setPosition @bounds.origin\n    @add @colorPalette\n    @grayPalette.setPosition @colorPalette.bottomLeft()\n    @add @grayPalette\n    x = (@grayPalette.left() + Math.floor((@grayPalette.width() - @feedback.width()) / 2))\n    y = @grayPalette.bottom() + Math.floor((@bottom() - @grayPalette.bottom() - @feedback.height()) / 2)\n    @feedback.setPosition new Point(x, y)\n    @add @feedback\n\n  imBeingAddedTo: (newParentMorph) ->\n  \n  getColor: ->\n    @feedback.color\n  \n  rootForGrab: ->\n    @';

  return ColorPickerMorph;

})(Morph);

ContainerMixin = {
  onceAddedClassProperties: function() {
    return this.addInstanceProperties({
      setTarget: function() {
        var choices, menu;
        choices = world.plausibleTargetAndDestinationMorphs(this);
        if (choices.length > 0) {
          menu = new MenuMorph(false, this, true, true, "choose target:");
          choices.forEach((function(_this) {
            return function(each) {
              return menu.addItem(each.toString().slice(0, 50) + " ➜", false, _this, "setTargetSetter", null, null, null, null, null, each);
            };
          })(this));
        } else {
          menu = new MenuMorph(false, this, true, true, "no targets available");
        }
        return menu.popUpAtHand(this.firstContainerMenu());
      }
    });
  },
  submorphBounds: function() {
    var result;
    result = null;
    if (this.children.length) {
      result = this.children[0].bounds;
      this.children.forEach(function(child) {
        return result = result.merge(child.boundsIncludingChildren());
      });
    }
    return result;
  },
  adjustBounds: function() {
    var newBounds;
    newBounds = this.submorphBounds();
    if (newBounds) {
      if (this.padding != null) {
        newBounds = newBounds.expandBy(this.padding);
      }
    } else {
      newBounds = this.bounds.copy();
    }
    if (!this.bounds.eq(newBounds)) {
      this.bounds = newBounds;
      this.changed();
      this.setLayoutBeforeUpdatingBackingStore();
      return this.updateBackingStore();
    }
  }
};

GrayPaletteMorph = (function(_super) {
  __extends(GrayPaletteMorph, _super);

  namedClasses[GrayPaletteMorph.name] = GrayPaletteMorph.prototype;

  function GrayPaletteMorph(target, sizePoint) {
    this.target = target != null ? target : null;
    GrayPaletteMorph.__super__.constructor.call(this, this.target, sizePoint || new Point(80, 10));
  }

  GrayPaletteMorph.prototype.updateBackingStore = function() {
    var context, extent, gradient;
    extent = this.extent();
    this.image = newCanvas(extent.scaleBy(pixelRatio));
    context = this.image.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    this.choice = new Color();
    gradient = context.createLinearGradient(0, 0, extent.x, extent.y);
    gradient.addColorStop(0, "black");
    gradient.addColorStop(1, "white");
    context.fillStyle = gradient;
    return context.fillRect(0, 0, extent.x, extent.y);
  };

  GrayPaletteMorph.coffeeScriptSourceOfThisClass = '# GrayPaletteMorph ///////////////////////////////////////////////////\n\nclass GrayPaletteMorph extends ColorPaletteMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  constructor: (@target = null, sizePoint) ->\n    super @target, sizePoint or new Point(80, 10)\n  \n  # no changes of position or extent\n  updateBackingStore: ->\n    extent = @extent()\n    @image = newCanvas(extent.scaleBy pixelRatio)\n    context = @image.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    @choice = new Color()\n    gradient = context.createLinearGradient(0, 0, extent.x, extent.y)\n    gradient.addColorStop 0, "black"\n    gradient.addColorStop 1, "white"\n    context.fillStyle = gradient\n    context.fillRect 0, 0, extent.x, extent.y';

  return GrayPaletteMorph;

})(ColorPaletteMorph);

HandMorph = (function(_super) {
  __extends(HandMorph, _super);

  namedClasses[HandMorph.name] = HandMorph.prototype;

  HandMorph.prototype.world = null;

  HandMorph.prototype.mouseButton = null;

  HandMorph.prototype.mouseDownMorph = null;

  HandMorph.prototype.morphToGrab = null;

  HandMorph.prototype.grabOrigin = null;

  HandMorph.prototype.mouseOverList = null;

  HandMorph.prototype.temporaries = null;

  HandMorph.prototype.touchHoldTimeout = null;

  HandMorph.prototype.doubleClickMorph = null;

  function HandMorph(world) {
    this.world = world;
    this.mouseOverList = [];
    this.temporaries = [];
    HandMorph.__super__.constructor.call(this);
    this.bounds = new Rectangle();
  }

  HandMorph.prototype.changed = function() {
    var b;
    if (this.world != null) {
      b = this.boundsIncludingChildren();
      if (!b.extent().eq(new Point())) {
        return this.world.broken.push(this.boundsIncludingChildren().spread());
      }
    }
  };

  HandMorph.prototype.topMorphUnderPointer = function() {
    var result;
    result = this.world.topMorphSuchThat((function(_this) {
      return function(m) {
        return m.visibleBounds().containsPoint(_this.bounds.origin) && !m.isMinimised && m.isVisible && (m.noticesTransparentClick || (!m.isTransparentAt(_this.bounds.origin))) && (!(m instanceof ShadowMorph));
      };
    })(this));
    if (result != null) {
      return result;
    } else {
      return this.world;
    }
  };

  HandMorph.prototype.menuAtPointer = function() {
    var result;
    result = this.world.topMorphSuchThat((function(_this) {
      return function(m) {
        return m.visibleBounds().containsPoint(_this.bounds.origin) && !m.isMinimised && m.isVisible && (m.noticesTransparentClick || (!m.isTransparentAt(_this.bounds.origin))) && (m instanceof MenuMorph);
      };
    })(this));
    return result;
  };

  HandMorph.prototype.openContextMenuAtPointer = function(morphTheMenuIsAbout) {
    var contextMenu;
    this.destroyActiveHandleIfHandHasNotActionedIt(morphTheMenuIsAbout);
    this.stopEditingIfActionIsElsewhere(morphTheMenuIsAbout);
    if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.PLAYING) {
      fade('rightMouseButtonIndicator', 0, 1, 10, new Date().getTime());
      setTimeout((function(_this) {
        return function() {
          return fade('rightMouseButtonIndicator', 1, 0, 500, new Date().getTime());
        };
      })(this), 100);
    }
    contextMenu = morphTheMenuIsAbout.contextMenu();
    while ((!contextMenu) && morphTheMenuIsAbout.parent) {
      morphTheMenuIsAbout = morphTheMenuIsAbout.parent;
      contextMenu = morphTheMenuIsAbout.contextMenu();
    }
    if (contextMenu) {
      return contextMenu.popUpAtHand(morphTheMenuIsAbout.firstContainerMenu());
    }
  };

  HandMorph.prototype.allMorphsAtPointer = function() {
    return this.world.collectAllChildrenBottomToTopSuchThat((function(_this) {
      return function(m) {
        return !m.isMinimised && m.isVisible && m.visibleBounds().containsPoint(_this.bounds.origin);
      };
    })(this));
  };

  HandMorph.prototype.dropTargetFor = function(aMorph) {
    var target;
    target = this.topMorphUnderPointer();
    while (!target.wantsDropOf(aMorph)) {
      target = target.parent;
    }
    return target;
  };

  HandMorph.prototype.grab = function(aMorph) {
    var action, arr, oldParent;
    oldParent = aMorph.parent;
    if (aMorph instanceof WorldMorph) {
      return null;
    }
    if (!this.floatDraggingSomething()) {
      this.world.systemTestsRecorderAndPlayer.addGrabCommand();
      if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.RECORDING) {
        action = "grab";
        arr = window.world.systemTestsRecorderAndPlayer.tagsCollectedWhileRecordingTest;
        if ((arr.indexOf(action)) === -1) {
          arr.push(action);
        }
      }
      this.world.stopEditing();
      this.grabOrigin = aMorph.situation();
      if (typeof aMorph.prepareToBeGrabbed === "function") {
        aMorph.prepareToBeGrabbed(this);
      }
      this.add(aMorph);
      aMorph.addShadow(new Point(7, 7), 0.2);
      this.changed();
      if (oldParent && oldParent.reactToGrabOf) {
        return oldParent.reactToGrabOf(aMorph);
      }
    }
  };

  HandMorph.prototype.floatDraggingSomething = function() {
    if (this.children.length > 0) {
      return true;
    } else {
      return false;
    }
  };

  HandMorph.prototype.drop = function() {
    var action, arr, doRemoveShadow, morphToDrop, shadow, target;
    if (this.floatDraggingSomething()) {
      this.world.systemTestsRecorderAndPlayer.addDropCommand();
      if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.RECORDING) {
        action = "drop";
        arr = window.world.systemTestsRecorderAndPlayer.tagsCollectedWhileRecordingTest;
        if ((arr.indexOf(action)) === -1) {
          arr.push(action);
        }
      }
      morphToDrop = this.children[0];
      target = this.dropTargetFor(morphToDrop);
      this.changed();
      target.add(morphToDrop);
      morphToDrop.changed();
      doRemoveShadow = true;
      if (morphToDrop instanceof MenuMorph) {
        console.log("dropping menu morph which with pinned status: " + morphToDrop.isPinned());
        if (morphToDrop.isPinned()) {
          doRemoveShadow = true;
        } else {
          doRemoveShadow = false;
        }
      } else {
        doRemoveShadow = true;
      }
      if (doRemoveShadow) {
        morphToDrop.removeShadow();
      } else {
        shadow = morphToDrop.getShadow();
        if (shadow == null) {
          morphToDrop.addShadow();
        }
      }
      this.children = [];
      this.setExtent(new Point());
      if (typeof morphToDrop.justDropped === "function") {
        morphToDrop.justDropped(this);
      }
      if (target.reactToDropOf) {
        target.reactToDropOf(morphToDrop, this);
      }
      return this.floatDragOrigin = null;
    }
  };

  HandMorph.prototype.destroyActiveHandleIfHandHasNotActionedIt = function(actionedMorph) {
    if (this.world.activeHandle != null) {
      if (actionedMorph !== this.world.activeHandle) {
        return this.world.activeHandle = this.world.activeHandle.destroy();
      }
    }
  };

  HandMorph.prototype.stopEditingIfActionIsElsewhere = function(actionedMorph) {
    var mostRecentlyCreatedMenu;
    if (this.world.caret != null) {
      if (actionedMorph !== this.world.caret.target) {
        mostRecentlyCreatedMenu = world.mostRecentlyCreatedMenu();
        if (mostRecentlyCreatedMenu != null) {
          if (!mostRecentlyCreatedMenu.containedInParentsOf(actionedMorph)) {
            return this.world.stopEditing();
          }
        } else {
          return this.world.stopEditing();
        }
      }
    }
  };

  HandMorph.prototype.pointerPositionFractionalInMorph = function(theMorph) {
    var fractionalXPos, fractionalYPos, relativeXPos, relativeYPos, _ref;
    _ref = this.pointerPositionPixelsInMorph(theMorph), relativeXPos = _ref[0], relativeYPos = _ref[1];
    fractionalXPos = relativeXPos / theMorph.bounds.width();
    fractionalYPos = relativeYPos / theMorph.bounds.height();
    return [fractionalXPos, fractionalYPos];
  };

  HandMorph.prototype.pointerPositionPixelsInMorph = function(theMorph) {
    var relativeXPos, relativeYPos;
    relativeXPos = this.bounds.origin.x - theMorph.bounds.origin.x;
    relativeYPos = this.bounds.origin.y - theMorph.bounds.origin.y;
    return [relativeXPos, relativeYPos];
  };

  HandMorph.prototype.processMouseDown = function(button, ctrlKey) {
    var actualClick, expectedClick, morph;
    this.destroyTemporaries();
    this.morphToGrab = null;
    if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.PLAYING) {
      if (button === 2 || ctrlKey) {
        fade('rightMouseButtonIndicator', 0, 1, 10, new Date().getTime());
      } else {
        fade('leftMouseButtonIndicator', 0, 1, 10, new Date().getTime());
      }
    }
    if (this.floatDraggingSomething()) {
      this.drop();
      return this.mouseButton = null;
    } else {
      morph = this.topMorphUnderPointer();
      this.destroyActiveHandleIfHandHasNotActionedIt(morph);
      this.stopEditingIfActionIsElsewhere(morph);
      if (!morph.mouseMove) {
        this.morphToGrab = morph.rootForGrab();
      }
      if (button === 2 || ctrlKey) {
        this.mouseButton = "right";
        actualClick = "mouseDownRight";
        expectedClick = "mouseClickRight";
      } else {
        this.mouseButton = "left";
        actualClick = "mouseDownLeft";
        expectedClick = "mouseClickLeft";
      }
      this.mouseDownMorph = morph;
      while (!this.mouseDownMorph[expectedClick]) {
        this.mouseDownMorph = this.mouseDownMorph.parent;
      }
      while (!morph[actualClick]) {
        morph = morph.parent;
      }
      return morph[actualClick](this.bounds.origin);
    }
  };

  HandMorph.prototype.processTouchStart = function(event) {
    event.preventDefault();
    WorldMorph.preferencesAndSettings.isTouchDevice = true;
    clearInterval(this.touchHoldTimeout);
    if (event.touches.length === 1) {
      this.touchHoldTimeout = setInterval((function(_this) {
        return function() {
          _this.processMouseDown(2);
          _this.processMouseUp(2);
          event.preventDefault();
          return clearInterval(_this.touchHoldTimeout);
        };
      })(this), 400);
      this.processMouseMove(event.touches[0].pageX, event.touches[0].pageY);
      return this.processMouseDown(0);
    }
  };

  HandMorph.prototype.processTouchMove = function(event) {
    var touch;
    event.preventDefault();
    if (event.touches.length === 1) {
      touch = event.touches[0];
      this.processMouseMove(touch.pageX, touch.pageY);
      return clearInterval(this.touchHoldTimeout);
    }
  };

  HandMorph.prototype.processTouchEnd = function(event) {
    WorldMorph.preferencesAndSettings.isTouchDevice = true;
    clearInterval(this.touchHoldTimeout);
    return this.processMouseUp(0);
  };

  HandMorph.prototype.processMouseUp = function(button) {
    var alreadyRecordedLeftOrRightClickOnMenuItem, expectedClick, ignored, labelString, menuItemMorph, morph, mostRecentlyCreatedMenu, occurrenceNumber, pointerAndMorphInfo, toDestructure, _ref, _ref1;
    if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.PLAYING) {
      if (button === 2) {
        fade('rightMouseButtonIndicator', 1, 0, 500, new Date().getTime());
      } else {
        fade('leftMouseButtonIndicator', 1, 0, 500, new Date().getTime());
      }
    }
    morph = this.topMorphUnderPointer();
    alreadyRecordedLeftOrRightClickOnMenuItem = false;
    this.destroyTemporaries();
    world.freshlyCreatedMenus = [];
    if (this.floatDraggingSomething()) {
      this.drop();
    } else {
      ignored = null;
      toDestructure = morph.parentThatIsA(MenuItemMorph);
      if (toDestructure != null) {
        menuItemMorph = toDestructure[0], ignored = toDestructure[1];
        if (menuItemMorph) {
          mostRecentlyCreatedMenu = world.mostRecentlyCreatedMenu();
          if (mostRecentlyCreatedMenu === menuItemMorph.parent) {
            labelString = menuItemMorph.labelString;
            occurrenceNumber = menuItemMorph.howManySiblingsBeforeMeSuchThat(function(m) {
              return m.labelString === labelString;
            });
            this.world.systemTestsRecorderAndPlayer.addCommandLeftOrRightClickOnMenuItem(this.mouseButton, labelString, occurrenceNumber + 1);
            alreadyRecordedLeftOrRightClickOnMenuItem = true;
          }
        }
      }
      if (this.mouseButton === "left") {
        expectedClick = "mouseClickLeft";
      } else {
        expectedClick = "mouseClickRight";
        if (this.mouseButton) {
          if (!alreadyRecordedLeftOrRightClickOnMenuItem) {
            this.world.systemTestsRecorderAndPlayer.addOpenContextMenuCommand(morph.uniqueIDString());
          }
        }
      }
      while (!morph[expectedClick]) {
        morph = morph.parent;
        if (morph == null) {
          break;
        }
      }
      if (morph != null) {
        if (morph === this.mouseDownMorph) {
          if (expectedClick === "mouseClickLeft") {
            pointerAndMorphInfo = world.getPointerAndMorphInfo();
            (_ref = world.systemTestsRecorderAndPlayer).addMouseClickCommand.apply(_ref, [0, null].concat(__slice.call(pointerAndMorphInfo)));
          } else if (expectedClick === "mouseClickRight") {
            pointerAndMorphInfo = world.getPointerAndMorphInfo();
            (_ref1 = world.systemTestsRecorderAndPlayer).addMouseClickCommand.apply(_ref1, [2, null].concat(__slice.call(pointerAndMorphInfo)));
          }
          morph[expectedClick](this.bounds.origin);
          if (this.doubleClickMorph == null) {
            this.doubleClickMorph = morph;
            setTimeout(((function(_this) {
              return function() {
                if (_this.doubleClickMorph != null) {
                  console.log("single click");
                }
                _this.doubleClickMorph = null;
                return false;
              };
            })(this)), 300);
          } else {
            if (this.doubleClickMorph === morph) {
              this.doubleClickMorph = null;
              console.log("double click");
              this.processDoubleClick();
            }
          }
        }
      }
      this.cleanupMenuMorphs(expectedClick, morph);
    }
    return this.mouseButton = null;
  };

  HandMorph.prototype.cleanupMenuMorphs = function(expectedClick, morph) {
    var ascendingMorphs, eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren, morphsDetectingClickOutsideMeOrAnyOfMeChildren, _i, _len, _results;
    world.hierarchyOfClickedMorphs = [];
    world.destroyMorphsMarkedForDestruction();
    world.hierarchyOfClickedMorphs = [morph];
    ascendingMorphs = morph;
    while (ascendingMorphs.parent != null) {
      ascendingMorphs = ascendingMorphs.parent;
      world.hierarchyOfClickedMorphs.push(ascendingMorphs);
    }
    console.log("morphs wanting to be notified: " + world.morphsDetectingClickOutsideMeOrAnyOfMeChildren);
    console.log("hierarchy of clicked morphs: " + world.hierarchyOfClickedMorphs);
    morphsDetectingClickOutsideMeOrAnyOfMeChildren = arrayShallowCopy(world.morphsDetectingClickOutsideMeOrAnyOfMeChildren);
    _results = [];
    for (_i = 0, _len = morphsDetectingClickOutsideMeOrAnyOfMeChildren.length; _i < _len; _i++) {
      eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren = morphsDetectingClickOutsideMeOrAnyOfMeChildren[_i];
      if ((world.hierarchyOfClickedMorphs.indexOf(eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren)) < 0) {
        if ((world.freshlyCreatedMenus.indexOf(eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren)) < 0) {
          if (eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[0] != null) {
            _results.push(eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren[eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[0]].call(eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren, eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[1], eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[2], eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[3]));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  HandMorph.prototype.processDoubleClick = function() {
    var morph, pointerAndMorphInfo, _ref;
    pointerAndMorphInfo = world.getPointerAndMorphInfo();
    (_ref = world.systemTestsRecorderAndPlayer).addMouseDoubleClickCommand.apply(_ref, [null].concat(__slice.call(pointerAndMorphInfo)));
    morph = this.topMorphUnderPointer();
    this.destroyTemporaries();
    if (this.floatDraggingSomething()) {
      this.drop();
    } else {
      while (morph && !morph.mouseDoubleClick) {
        morph = morph.parent;
      }
      if (morph) {
        morph.mouseDoubleClick(this.bounds.origin);
      }
    }
    return this.mouseButton = null;
  };

  HandMorph.prototype.processMouseScroll = function(event) {
    var morph;
    morph = this.topMorphUnderPointer();
    while (morph && !morph.mouseScroll) {
      morph = morph.parent;
    }
    if (morph) {
      return morph.mouseScroll((event.detail / -3) || (Object.prototype.hasOwnProperty.call(event, 'wheelDeltaY') ? event.wheelDeltaY / 120 : event.wheelDelta / 120), event.wheelDeltaX / 120 || 0);
    }
  };

  HandMorph.prototype.processDrop = function(event) {
    var file, files, img, parseImgURL, readAudio, readBinary, readImage, readSVG, readText, src, target, targetDrop, txt, url, _i, _len, _results;
    files = (event instanceof FileList ? event : event.target.files || event.dataTransfer.files);
    url = (event.dataTransfer ? event.dataTransfer.getData("URL") : null);
    txt = (event.dataTransfer ? event.dataTransfer.getData("Text/HTML") : null);
    targetDrop = this.topMorphUnderPointer();
    img = new Image();
    readSVG = function(aFile) {
      var frd, pic, target;
      pic = new Image();
      frd = new FileReader();
      while (!target.droppedSVG) {
        target = target.parent;
      }
      pic.onload = function() {
        return target.droppedSVG(pic, aFile.name);
      };
      frd = new FileReader();
      frd.onloadend = function(e) {
        return pic.src = e.target.result;
      };
      return frd.readAsDataURL(aFile);
    };
    readImage = function(aFile) {
      var frd, pic;
      pic = new Image();
      frd = new FileReader();
      while (!targetDrop.droppedImage) {
        targetDrop = targetDrop.parent;
      }
      pic.onload = function() {
        var canvas;
        canvas = newCanvas(new Point(pic.width, pic.height));
        canvas.getContext("2d").drawImage(pic, 0, 0);
        return targetDrop.droppedImage(canvas, aFile.name);
      };
      frd = new FileReader();
      frd.onloadend = function(e) {
        return pic.src = e.target.result;
      };
      return frd.readAsDataURL(aFile);
    };
    readAudio = function(aFile) {
      var frd, snd;
      snd = new Audio();
      frd = new FileReader();
      while (!targetDrop.droppedAudio) {
        targetDrop = targetDrop.parent;
      }
      frd.onloadend = function(e) {
        snd.src = e.target.result;
        return targetDrop.droppedAudio(snd, aFile.name);
      };
      return frd.readAsDataURL(aFile);
    };
    readText = function(aFile) {
      var frd;
      frd = new FileReader();
      while (!targetDrop.droppedText) {
        targetDrop = targetDrop.parent;
      }
      frd.onloadend = function(e) {
        return targetDrop.droppedText(e.target.result, aFile.name);
      };
      return frd.readAsText(aFile);
    };
    readBinary = function(aFile) {
      var frd;
      frd = new FileReader();
      while (!targetDrop.droppedBinary) {
        targetDrop = targetDrop.parent;
      }
      frd.onloadend = function(e) {
        return targetDrop.droppedBinary(e.target.result, aFile.name);
      };
      return frd.readAsArrayBuffer(aFile);
    };
    parseImgURL = function(html) {
      var c, i, start, _i, _ref;
      url = "";
      start = html.indexOf("<img src=\"");
      if (start === -1) {
        return null;
      }
      start += 10;
      for (i = _i = start, _ref = html.length; start <= _ref ? _i < _ref : _i > _ref; i = start <= _ref ? ++_i : --_i) {
        c = html[i];
        if (c === "\"") {
          return url;
        }
        url = url.concat(c);
      }
      return null;
    };
    if (files.length) {
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        if (file.type.indexOf("svg") !== -1 && !WorldMorph.preferencesAndSettings.rasterizeSVGs) {
          _results.push(readSVG(file));
        } else if (file.type.indexOf("image") === 0) {
          _results.push(readImage(file));
        } else if (file.type.indexOf("audio") === 0) {
          _results.push(readAudio(file));
        } else if (file.type.indexOf("text") === 0) {
          _results.push(readText(file));
        } else {
          _results.push(readBinary(file));
        }
      }
      return _results;
    } else if (url) {
      if (contains(["gif", "png", "jpg", "jpeg", "bmp"], url.slice(url.lastIndexOf(".") + 1).toLowerCase())) {
        while (!target.droppedImage) {
          target = target.parent;
        }
        img = new Image();
        img.onload = function() {
          var canvas;
          canvas = newCanvas(new Point(img.width, img.height));
          canvas.getContext("2d").drawImage(img, 0, 0);
          return target.droppedImage(canvas);
        };
        return img.src = url;
      }
    } else if (txt) {
      while (!targetDrop.droppedImage) {
        targetDrop = targetDrop.parent;
      }
      img = new Image();
      img.onload = function() {
        var canvas;
        canvas = newCanvas(new Point(img.width, img.height));
        canvas.getContext("2d").drawImage(img, 0, 0);
        return targetDrop.droppedImage(canvas);
      };
      src = parseImgURL(txt);
      if (src) {
        return img.src = src;
      }
    }
  };

  HandMorph.prototype.destroyTemporaries = function() {
    return this.temporaries.forEach((function(_this) {
      return function(morph) {
        if (!(morph.isClickable && morph.bounds.containsPoint(_this.position()))) {
          morph = morph.destroy();
          return _this.temporaries.splice(_this.temporaries.indexOf(morph), 1);
        }
      };
    })(this));
  };

  HandMorph.prototype.moveBy = function(delta) {
    Morph.prototype.trackChanges = false;
    HandMorph.__super__.moveBy.call(this, delta);
    Morph.prototype.trackChanges = true;
    return this.fullChanged();
  };

  HandMorph.prototype.processMouseMove = function(worldX, worldY) {
    var fb, morph, mouseOverNew, mousePointerIndicator, pos, posInDocument, topMorph;
    pos = new Point(worldX, worldY);
    this.setPosition(pos);
    if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.PLAYING) {
      mousePointerIndicator = document.getElementById('mousePointerIndicator');
      mousePointerIndicator.style.display = 'block';
      posInDocument = getDocumentPositionOf(this.world.worldCanvas);
      mousePointerIndicator.style.left = (posInDocument.x + worldX - (mousePointerIndicator.clientWidth / 2)) + 'px';
      mousePointerIndicator.style.top = (posInDocument.y + worldY - (mousePointerIndicator.clientHeight / 2)) + 'px';
    }
    mouseOverNew = this.topMorphUnderPointer().allParentsTopToBottom();
    if ((!this.floatDraggingSomething()) && (this.mouseButton === "left")) {
      topMorph = this.topMorphUnderPointer();
      morph = topMorph.rootForGrab();
      if (topMorph.mouseMove) {
        topMorph.mouseMove(pos);
      }
      if (this.morphToGrab) {
        if (this.morphToGrab.isfloatDraggable) {
          morph = this.morphToGrab;
          this.grab(morph);
        } else if (this.morphToGrab.isTemplate) {
          morph = this.morphToGrab.fullCopy();
          morph.isTemplate = false;
          morph.isfloatDraggable = true;
          this.grab(morph);
          this.grabOrigin = this.morphToGrab.situation();
        }
        if (morph) {
          fb = morph.boundsIncludingChildren();
          if (!fb.containsPoint(pos)) {
            this.bounds.origin = fb.center();
            this.grab(morph);
            this.setPosition(pos);
          }
        }
      }
    }
    this.mouseOverList.forEach((function(_this) {
      return function(old) {
        if (!contains(mouseOverNew, old)) {
          if (typeof old.mouseLeave === "function") {
            old.mouseLeave();
          }
          if (_this.mouseButton) {
            return typeof old.mouseLeavefloatDragging === "function" ? old.mouseLeavefloatDragging() : void 0;
          }
        }
      };
    })(this));
    mouseOverNew.forEach((function(_this) {
      return function(newMorph) {
        if (!contains(_this.mouseOverList, newMorph)) {
          if (typeof newMorph.mouseEnter === "function") {
            newMorph.mouseEnter();
          }
          if (_this.mouseButton) {
            if (typeof newMorph.mouseEnterfloatDragging === "function") {
              newMorph.mouseEnterfloatDragging();
            }
          }
        }
        if (_this.floatDraggingSomething()) {
          if (newMorph instanceof ScrollFrameMorph) {
            if (!newMorph.bounds.insetBy(WorldMorph.preferencesAndSettings.scrollBarSize * 3).containsPoint(_this.bounds.origin)) {
              return newMorph.startAutoScrolling();
            }
          }
        }
      };
    })(this));
    return this.mouseOverList = mouseOverNew;
  };

  HandMorph.coffeeScriptSourceOfThisClass = '# HandMorph ///////////////////////////////////////////////////////////\n\n# The mouse cursor. Note that it\'s not a child of the WorldMorph, this Morph\n# is never added to any other morph. [TODO] Find out why and write explanation.\n# Not to be confused with the HandleMorph\n\nclass HandMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  world: null\n  mouseButton: null\n  # used for example to check that\n  # mouseDown and mouseUp happen on the\n  # same Morph (otherwise clicks happen for\n  # example when resizing a button via the\n  # handle)\n  mouseDownMorph: null\n  morphToGrab: null\n  grabOrigin: null\n  mouseOverList: null\n  temporaries: null\n  touchHoldTimeout: null\n  doubleClickMorph: null\n\n  constructor: (@world) ->\n    @mouseOverList = []\n    @temporaries = []\n    super()\n    @bounds = new Rectangle()\n  \n  changed: ->\n    if @world?\n      b = @boundsIncludingChildren()\n      if !b.extent().eq(new Point())\n        @world.broken.push @boundsIncludingChildren().spread()\n  \n  \n  # HandMorph navigation:\n  topMorphUnderPointer: ->\n    result = @world.topMorphSuchThat (m) =>\n      m.visibleBounds().containsPoint(@bounds.origin) and\n        !m.isMinimised and\n        m.isVisible and\n        (m.noticesTransparentClick or (not m.isTransparentAt(@bounds.origin))) and\n        (m not instanceof ShadowMorph)\n    if result?\n      return result\n    else\n      return @world\n\n  menuAtPointer: ->\n    result = @world.topMorphSuchThat (m) =>\n      m.visibleBounds().containsPoint(@bounds.origin) and\n        !m.isMinimised and m.isVisible and (m.noticesTransparentClick or\n        (not m.isTransparentAt(@bounds.origin))) and (m instanceof MenuMorph)\n    return result\n\n\n\n  openContextMenuAtPointer: (morphTheMenuIsAbout) ->\n    # note that the morphs that the menu\n    # belongs to might not be under the mouse.\n    # It usually is, but in cases\n    # where a system test is playing against\n    # a world setup that has varied since the\n    # recording, this could be the case.\n\n    # these three are checks and actions that normally\n    # would happen on MouseDown event, but we\n    # removed that event as we collapsed the down and up\n    # into this coalesced higher-level event,\n    # but we still need to make these checks and actions\n    @destroyActiveHandleIfHandHasNotActionedIt morphTheMenuIsAbout\n    @stopEditingIfActionIsElsewhere morphTheMenuIsAbout\n\n    if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      fade(\'rightMouseButtonIndicator\', 0, 1, 10, new Date().getTime());\n      setTimeout =>\n          fade(\'rightMouseButtonIndicator\', 1, 0, 500, new Date().getTime())\n        , 100\n    \n    contextMenu = morphTheMenuIsAbout.contextMenu()\n    while (not contextMenu) and morphTheMenuIsAbout.parent\n      morphTheMenuIsAbout = morphTheMenuIsAbout.parent\n      contextMenu = morphTheMenuIsAbout.contextMenu()\n\n    if contextMenu \n      contextMenu.popUpAtHand(morphTheMenuIsAbout.firstContainerMenu()) \n\n  #\n  #    alternative -  more elegant and possibly more\n  #	performant - solution for topMorphUnderPointer.\n  #	Has some issues, commented out for now\n  #\n  #HandMorph.prototype.topMorphUnderPointer = function () {\n  #	var myself = this;\n  #	return this.world.topMorphSuchThat(function (m) {\n  #		return m.visibleBounds().containsPoint(myself.bounds.origin) &&\n  #			!m.isMinimised &&\n  #     m.isVisible &&\n  #			(m.noticesTransparentClick ||\n  #				(! m.isTransparentAt(myself.bounds.origin))) &&\n  #			(! (m instanceof ShadowMorph));\n  #	});\n  #};\n  #\n\n\n  # not used in ZK yet\n  allMorphsAtPointer: ->\n    return @world.collectAllChildrenBottomToTopSuchThat (m) =>\n      !m.isMinimised and m.isVisible and m.visibleBounds().containsPoint(@bounds.origin)\n  \n  \n  \n  # HandMorph floatDragging and dropping:\n  #\n  #	floatDrag \'n\' drop events, method(arg) -> receiver:\n  #\n  #		prepareToBeGrabbed(handMorph) -> grabTarget\n  #		reactToGrabOf(grabbedMorph) -> oldParent\n  #		wantsDropOf(morphToDrop) ->  newParent\n  #		justDropped(handMorph) -> droppedMorph\n  #		reactToDropOf(droppedMorph, handMorph) -> newParent\n  #\n  dropTargetFor: (aMorph) ->\n    target = @topMorphUnderPointer()\n    target = target.parent  until target.wantsDropOf(aMorph)\n    target\n  \n  grab: (aMorph) ->\n    oldParent = aMorph.parent\n    return null  if aMorph instanceof WorldMorph\n    if !@floatDraggingSomething()\n\n      @world.systemTestsRecorderAndPlayer.addGrabCommand()\n      if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n        action = "grab"\n        arr = window.world.systemTestsRecorderAndPlayer.tagsCollectedWhileRecordingTest\n        if (arr.indexOf action) == -1\n          arr.push action\n\n\n      @world.stopEditing()\n      @grabOrigin = aMorph.situation()\n      aMorph.prepareToBeGrabbed? @\n      @add aMorph\n      # you must add the shadow\n      # after the morph has been added\n      # because "@add aMorph" causes\n      # the morph to be painted potentially\n      # for the first time.\n      # The shadow needs the image of the\n      # morph to make the shadow, so\n      # this is why we add the shadow after\n      # the morph has been added.\n      # Note that Morphs can specify the look\n      # (i.e. offset blur and color)\n      # of their shadow (e.g. Menus have a particular one\n      # so they all seem to float at a particular height)\n      # but here when we grab morphs we\n      # specify a particular look for the shadow.\n      aMorph.addShadow(new Point(7,7),0.2)\n      \n      #debugger\n      @changed()\n      # this gives an occasion to the old parent\n      # morph to adjust itself e.g. the scrollmorph\n      # readjusts itself if you take some morphs\n      # out of it.\n      oldParent.reactToGrabOf aMorph  if oldParent and oldParent.reactToGrabOf\n\n  floatDraggingSomething: ->\n    if @children.length > 0 then true else false\n\n  drop: ->\n    if @floatDraggingSomething()\n\n      @world.systemTestsRecorderAndPlayer.addDropCommand()\n      if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n        action = "drop"\n        arr = window.world.systemTestsRecorderAndPlayer.tagsCollectedWhileRecordingTest\n        if (arr.indexOf action) == -1\n          arr.push action\n\n      morphToDrop = @children[0]\n      target = @dropTargetFor(morphToDrop)\n      @changed()\n      target.add morphToDrop\n      morphToDrop.changed()\n\n      doRemoveShadow = true\n      if (morphToDrop instanceof MenuMorph)\n        console.log "dropping menu morph which with pinned status: " + morphToDrop.isPinned()\n        if (morphToDrop.isPinned())\n          doRemoveShadow = true\n        else\n          doRemoveShadow = false\n      else\n        doRemoveShadow = true\n\n      if doRemoveShadow\n        morphToDrop.removeShadow()\n      else\n        # TODO adding of the shadow\n        # is not really legit because it\n        # ignores the original color and opacity\n        # of the shadow...\n        shadow = morphToDrop.getShadow()\n        if !shadow?\n          morphToDrop.addShadow()\n\n      @children = []\n      @setExtent new Point()\n      morphToDrop.justDropped? @\n      target.reactToDropOf morphToDrop, @  if target.reactToDropOf\n      @floatDragOrigin = null\n  \n  # HandMorph event dispatching:\n  #\n  #    mouse events:\n  #\n  #		mouseDownLeft\n  #		mouseDownRight\n  #		mouseClickLeft\n  #		mouseClickRight\n  #   mouseDoubleClick\n  #		mouseEnter\n  #		mouseLeave\n  #		mouseEnterfloatDragging\n  #		mouseLeavefloatDragging\n  #		mouseMove\n  #		mouseScroll\n  #\n  # Note that some handlers don\'t want the event but the\n  # interesting parameters of the event. This is because\n  # the testing harness only stores the interesting parameters\n  # rather than a multifaceted and sometimes browser-specific\n  # event object.\n\n  destroyActiveHandleIfHandHasNotActionedIt: (actionedMorph) ->\n    if @world.activeHandle?\n      if actionedMorph isnt @world.activeHandle\n        @world.activeHandle = @world.activeHandle.destroy()    \n\n  stopEditingIfActionIsElsewhere: (actionedMorph) ->\n    if @world.caret?\n      # there is a caret on the screen\n      # depending on what the user is clicking on,\n      # we might need to close an ongoing edit\n      # operation, which means deleting the\n      # caret and un-selecting anything that was selected.\n      # Note that we don\'t want to interrupt an edit\n      # if the user is invoking/clicking on anything\n      # inside a menu, because the invoked function\n      # might do something with the selection\n      # (for example doSelection takes the current selection).\n      if actionedMorph isnt @world.caret.target\n        # user clicked on something other than what the\n        # caret is attached to\n        mostRecentlyCreatedMenu = world.mostRecentlyCreatedMenu()\n        if mostRecentlyCreatedMenu?\n          unless mostRecentlyCreatedMenu.containedInParentsOf(actionedMorph)\n            # only dismiss editing if the actionedMorph the user\n            # clicked on is not part of a menu.\n            @world.stopEditing()\n        # there is no menu at all, in which case\n        # we know there was an editing operation going\n        # on that we need to stop\n        else\n          @world.stopEditing()\n\n  pointerPositionFractionalInMorph: (theMorph) ->\n    [relativeXPos, relativeYPos] = @pointerPositionPixelsInMorph theMorph\n    fractionalXPos = relativeXPos / theMorph.bounds.width()\n    fractionalYPos = relativeYPos / theMorph.bounds.height()\n    return [fractionalXPos, fractionalYPos]\n\n  pointerPositionPixelsInMorph: (theMorph) ->\n    relativeXPos = @bounds.origin.x - theMorph.bounds.origin.x\n    relativeYPos = @bounds.origin.y - theMorph.bounds.origin.y\n    return [relativeXPos, relativeYPos]\n\n  processMouseDown: (button, ctrlKey) ->\n    @destroyTemporaries()\n    @morphToGrab = null\n\n    if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      if button is 2 or ctrlKey\n        fade(\'rightMouseButtonIndicator\', 0, 1, 10, new Date().getTime());\n      else\n        fade(\'leftMouseButtonIndicator\', 0, 1, 10, new Date().getTime());\n\n    # check whether we are in the middle\n    # of a floatDrag/drop operation\n    if @floatDraggingSomething()\n      @drop()\n      @mouseButton = null\n    else\n      morph = @topMorphUnderPointer()\n      @destroyActiveHandleIfHandHasNotActionedIt morph\n      @stopEditingIfActionIsElsewhere morph\n\n      @morphToGrab = morph.rootForGrab()  unless morph.mouseMove\n      if button is 2 or ctrlKey\n        @mouseButton = "right"\n        actualClick = "mouseDownRight"\n        expectedClick = "mouseClickRight"\n      else\n        @mouseButton = "left"\n        actualClick = "mouseDownLeft"\n        expectedClick = "mouseClickLeft"\n\n      @mouseDownMorph = morph\n      @mouseDownMorph = @mouseDownMorph.parent  until @mouseDownMorph[expectedClick]\n      morph = morph.parent  until morph[actualClick]\n      morph[actualClick] @bounds.origin\n  \n  # touch events, see:\n  # https://developer.apple.com/library/safari/documentation/appleapplications/reference/safariwebcontent/HandlingEvents/HandlingEvents.html\n  # A long touch emulates a right click. This is done via\n  # setting a timer 400ms after the touch which triggers\n  # a right mouse click. Any touch event before then just\n  # resets the timer, so one has to hold the finger in\n  # position for the right click to happen.\n  processTouchStart: (event) ->\n    event.preventDefault()\n    WorldMorph.preferencesAndSettings.isTouchDevice = true\n    clearInterval @touchHoldTimeout\n    if event.touches.length is 1\n      # simulate mouseRightClick\n      @touchHoldTimeout = setInterval(=>\n        @processMouseDown 2 # button 2 is the right one\n        @processMouseUp 2 # button 2 is the right one, we don\'t use this parameter\n        event.preventDefault() # I don\'t think that this is needed\n        clearInterval @touchHoldTimeout\n      , 400)\n      @processMouseMove event.touches[0].pageX, event.touches[0].pageY # update my position\n      @processMouseDown 0 # button zero is the left button\n  \n  processTouchMove: (event) ->\n    # Prevent scrolling on this element\n    event.preventDefault()\n\n    if event.touches.length is 1\n      touch = event.touches[0]\n      @processMouseMove touch.pageX, touch.pageY\n      clearInterval @touchHoldTimeout\n  \n  processTouchEnd: (event) ->\n    # note that the mouse down event handler\n    # that is calling this method has ALREADY\n    # added a mousedown command\n\n    WorldMorph.preferencesAndSettings.isTouchDevice = true\n    clearInterval @touchHoldTimeout\n    @processMouseUp 0 # button zero is the left button, we don\'t use this parameter\n  \n   # note that the button param is not used,\n   # but adding it for consistency...\n  processMouseUp: (button) ->\n\n    if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      if button is 2\n        fade(\'rightMouseButtonIndicator\', 1, 0, 500, new Date().getTime());\n      else\n        fade(\'leftMouseButtonIndicator\', 1, 0, 500, new Date().getTime());\n\n    morph = @topMorphUnderPointer()\n    alreadyRecordedLeftOrRightClickOnMenuItem = false\n    @destroyTemporaries()\n    world.freshlyCreatedMenus = []\n    if @floatDraggingSomething()\n      @drop()\n    else\n      # let\'s check if the user clicked on a menu item,\n      # in which case we add a special dedicated command\n      # [TODO] you need to do some of this only if you\n      # are recording a test, it\'s worth saving\n      # these steps...\n      #debugger\n      ignored = null\n      toDestructure = morph.parentThatIsA(MenuItemMorph)\n      if toDestructure?\n        [menuItemMorph, ignored]= toDestructure\n        if menuItemMorph\n          # we check whether the menuitem is actually part\n          # of an activeMenu. Keep in mind you could have\n          # detached a menuItem and placed it on any other\n          # morph so you need to ascertain that you\'ll\n          # find it in the activeMenu later on...\n          mostRecentlyCreatedMenu = world.mostRecentlyCreatedMenu()\n          if mostRecentlyCreatedMenu == menuItemMorph.parent\n            labelString = menuItemMorph.labelString\n            occurrenceNumber = menuItemMorph.howManySiblingsBeforeMeSuchThat (m) ->\n              m.labelString == labelString\n            # this method below is also going to remove\n            # the mouse down/up commands that have\n            # recently/just been added.\n            @world.systemTestsRecorderAndPlayer.addCommandLeftOrRightClickOnMenuItem(@mouseButton, labelString, occurrenceNumber + 1)\n            alreadyRecordedLeftOrRightClickOnMenuItem = true\n\n      # TODO check if there is any other\n      # possibility other than mouseButton being "left"\n      # or "right". If it can only be one of those\n      # that you can simplify this nested if below\n      # and avoid using actionAlreadyProcessed\n      if @mouseButton is "left"\n        expectedClick = "mouseClickLeft"\n      else\n        expectedClick = "mouseClickRight"\n        if @mouseButton\n          if !alreadyRecordedLeftOrRightClickOnMenuItem\n            # this being a right click, pop\n            # up a menu as needed.\n            @world.systemTestsRecorderAndPlayer.addOpenContextMenuCommand morph.uniqueIDString()\n\n      # trigger the action\n      until morph[expectedClick]\n        morph = morph.parent\n        if not morph?\n          break\n      if morph?\n        if morph == @mouseDownMorph\n\n          if expectedClick == "mouseClickLeft"\n            pointerAndMorphInfo = world.getPointerAndMorphInfo()\n            world.systemTestsRecorderAndPlayer.addMouseClickCommand 0, null, pointerAndMorphInfo...\n          else if expectedClick == "mouseClickRight"\n            pointerAndMorphInfo = world.getPointerAndMorphInfo()\n            world.systemTestsRecorderAndPlayer.addMouseClickCommand 2, null, pointerAndMorphInfo...\n\n          morph[expectedClick] @bounds.origin\n          # also send doubleclick if the\n          # two clicks happen on the same morph\n          unless @doubleClickMorph?\n            @doubleClickMorph = morph\n            setTimeout (=>\n              if @doubleClickMorph?\n                console.log "single click"\n              @doubleClickMorph = null\n              return false\n            ), 300\n          else\n            if @doubleClickMorph == morph\n              @doubleClickMorph = null\n              console.log "double click"\n              @processDoubleClick()\n\n\n      @cleanupMenuMorphs(expectedClick, morph)\n    @mouseButton = null\n\n  cleanupMenuMorphs: (expectedClick, morph)->\n\n    world.hierarchyOfClickedMorphs = []\n\n    # not that all the actions due to the clicked\n    # morphs have been performed, now we can destroy\n    # morphs queued up for destruction\n    # which might include menus...\n    # if we destroyed menus earlier, the\n    # actions that come from the click\n    # might be mangled, e.g. adding a menu\n    # to a destroyed menu, etc.\n    world.destroyMorphsMarkedForDestruction()\n\n    # remove menus that have requested\n    # to be removed when a click happens outside\n    # of their bounds OR the bounds of their\n    # children\n    #if expectedClick == "mouseClickLeft"\n    # collect all morphs up the hierarchy of\n    # the one the user clicked on.\n    # (including the one the user clicked on)\n    world.hierarchyOfClickedMorphs = [morph]\n    ascendingMorphs = morph\n    while ascendingMorphs.parent?\n      ascendingMorphs = ascendingMorphs.parent\n      world.hierarchyOfClickedMorphs.push ascendingMorphs\n    \n    # go through the morphs that wanted a notification\n    # in case there is a click outside of them or any\n    # of their children morphs.\n    # Check which ones are not in the hierarchy of the clicked morphs\n    # and call their callback.\n    console.log "morphs wanting to be notified: " + world.morphsDetectingClickOutsideMeOrAnyOfMeChildren\n    console.log "hierarchy of clicked morphs: " + world.hierarchyOfClickedMorphs\n    \n\n\n    # here we do a shallow copy of world.morphsDetectingClickOutsideMeOrAnyOfMeChildren\n    # because we might remove elements of the array while we\n    # iterate on it (as we destroy menus that want to be destroyed\n    # when the user clicks outside of them or their children)\n    # so we need to do a shallow copy to avoid to mangle the for loop\n    morphsDetectingClickOutsideMeOrAnyOfMeChildren = arrayShallowCopy world.morphsDetectingClickOutsideMeOrAnyOfMeChildren\n    for eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren in morphsDetectingClickOutsideMeOrAnyOfMeChildren\n      if (world.hierarchyOfClickedMorphs.indexOf eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren) < 0\n        # skip the freshly created menus as otherwise we might\n        # destroy them immediately\n        if (world.freshlyCreatedMenus.indexOf eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren) < 0\n          if eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[0]?\n            eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren[eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[0]].call eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren, eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[1], eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[2], eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[3]\n\n  processDoubleClick: ->\n\n    pointerAndMorphInfo = world.getPointerAndMorphInfo()\n    world.systemTestsRecorderAndPlayer.addMouseDoubleClickCommand null, pointerAndMorphInfo...\n\n    morph = @topMorphUnderPointer()\n    @destroyTemporaries()\n    if @floatDraggingSomething()\n      @drop()\n    else\n      morph = morph.parent  while morph and not morph.mouseDoubleClick\n      morph.mouseDoubleClick @bounds.origin  if morph\n    @mouseButton = null\n  \n  processMouseScroll: (event) ->\n    morph = @topMorphUnderPointer()\n    morph = morph.parent  while morph and not morph.mouseScroll\n\n    morph.mouseScroll (event.detail / -3) or ((if Object.prototype.hasOwnProperty.call(event,\'wheelDeltaY\') then event.wheelDeltaY / 120 else event.wheelDelta / 120)), event.wheelDeltaX / 120 or 0  if morph\n  \n  \n  #\n  #	drop event:\n  #\n  #        droppedImage\n  #        droppedSVG\n  #        droppedAudio\n  #        droppedText\n  #\n  processDrop: (event) ->\n    #\n    #    find out whether an external image or audio file was dropped\n    #    onto the world canvas, turn it into an offscreen canvas or audio\n    #    element and dispatch the\n    #    \n    #        droppedImage(canvas, name)\n    #        droppedSVG(image, name)\n    #        droppedAudio(audio, name)\n    #    \n    #    events to interested Morphs at the mouse pointer\n    #    if none of the above content types can be determined, the file contents\n    #    is dispatched as an ArrayBuffer to interested Morphs:\n    #\n    #    ```droppedBinary(anArrayBuffer, name)```\n\n    files = (if event instanceof FileList then event else (event.target.files || event.dataTransfer.files))\n    url = (if event.dataTransfer then event.dataTransfer.getData("URL") else null)\n    txt = (if event.dataTransfer then event.dataTransfer.getData("Text/HTML") else null)\n    targetDrop = @topMorphUnderPointer()\n    img = new Image()\n\n    readSVG = (aFile) ->\n      pic = new Image()\n      frd = new FileReader()\n      target = target.parent  until target.droppedSVG\n      pic.onload = ->\n        target.droppedSVG pic, aFile.name\n      frd = new FileReader()\n      frd.onloadend = (e) ->\n        pic.src = e.target.result\n      frd.readAsDataURL aFile\n\n    readImage = (aFile) ->\n      pic = new Image()\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedImage\n      pic.onload = ->\n        canvas = newCanvas(new Point(pic.width, pic.height))\n        canvas.getContext("2d").drawImage pic, 0, 0\n        targetDrop.droppedImage canvas, aFile.name\n\n      frd = new FileReader()\n      frd.onloadend = (e) ->\n        pic.src = e.target.result\n\n      frd.readAsDataURL aFile\n\n    readAudio = (aFile) ->\n      snd = new Audio()\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedAudio\n      frd.onloadend = (e) ->\n        snd.src = e.target.result\n        targetDrop.droppedAudio snd, aFile.name\n      frd.readAsDataURL aFile\n    \n    readText = (aFile) ->\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedText\n      frd.onloadend = (e) ->\n        targetDrop.droppedText e.target.result, aFile.name\n      frd.readAsText aFile\n\n\n    readBinary = (aFile) ->\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedBinary\n      frd.onloadend = (e) ->\n        targetDrop.droppedBinary e.target.result, aFile.name\n      frd.readAsArrayBuffer aFile\n\n    parseImgURL = (html) ->\n      url = ""\n      start = html.indexOf("<img src=\"")\n      return null  if start is -1\n      start += 10\n      for i in [start...html.length]\n        c = html[i]\n        return url  if c is "\""\n        url = url.concat(c)\n      null\n    \n    if files.length\n      for file in files\n        if file.type.indexOf("svg") != -1 && !WorldMorph.preferencesAndSettings.rasterizeSVGs\n          readSVG file\n        else if file.type.indexOf("image") is 0\n          readImage file\n        else if file.type.indexOf("audio") is 0\n          readAudio file\n        else if file.type.indexOf("text") is 0\n          readText file\n        else\n          readBinary file\n    else if url\n      if contains(["gif", "png", "jpg", "jpeg", "bmp"], url.slice(url.lastIndexOf(".") + 1).toLowerCase())\n        target = target.parent  until target.droppedImage\n        img = new Image()\n        img.onload = ->\n          canvas = newCanvas(new Point(img.width, img.height))\n          canvas.getContext("2d").drawImage img, 0, 0\n          target.droppedImage canvas\n        img.src = url\n    else if txt\n      targetDrop = targetDrop.parent  until targetDrop.droppedImage\n      img = new Image()\n      img.onload = ->\n        canvas = newCanvas(new Point(img.width, img.height))\n        canvas.getContext("2d").drawImage img, 0, 0\n        targetDrop.droppedImage canvas\n      src = parseImgURL(txt)\n      img.src = src  if src\n  \n  \n  # HandMorph tools\n  destroyTemporaries: ->\n    #\n    #	temporaries are just an array of morphs which will be deleted upon\n    #	the next mouse click, or whenever another temporary Morph decides\n    #	that it needs to remove them. The primary purpose of temporaries is\n    #	to display tools tips of speech bubble help.\n    #\n    @temporaries.forEach (morph) =>\n      unless morph.isClickable and morph.bounds.containsPoint(@position())\n        morph = morph.destroy()\n        @temporaries.splice @temporaries.indexOf(morph), 1\n  \n  \n  # HandMorph floatDragging optimization\n  moveBy: (delta) ->\n    Morph::trackChanges = false\n    super delta\n    Morph::trackChanges = true\n    @fullChanged()\n\n  processMouseMove: (worldX, worldY) ->\n    #startProcessMouseMove = new Date().getTime()\n    pos = new Point(worldX, worldY)\n    @setPosition pos\n\n    if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      mousePointerIndicator = document.getElementById(\'mousePointerIndicator\')\n      mousePointerIndicator.style.display = \'block\'\n      posInDocument = getDocumentPositionOf(@world.worldCanvas)\n      mousePointerIndicator.style.left = (posInDocument.x + worldX - (mousePointerIndicator.clientWidth/2)) + \'px\'\n      mousePointerIndicator.style.top = (posInDocument.y + worldY - (mousePointerIndicator.clientHeight/2)) + \'px\'\n\n    # determine the new mouse-over-list.\n    # Spacial multiplexing\n    # (search "multiplexing" for the other parts of\n    # code where this matters)\n    # There are two interpretations of what this\n    # list should be:\n    #   1) all morphs "pierced through" by the pointer\n    #   2) all morphs parents of the topmost morph under the pointer\n    # 2 is what is used in Cuis\n    \n    # commented-out implementation of 1):\n    # mouseOverNew = @allMorphsAtPointer().reverse()\n    mouseOverNew = @topMorphUnderPointer().allParentsTopToBottom()\n\n    if (!@floatDraggingSomething()) and (@mouseButton is "left")\n      topMorph = @topMorphUnderPointer()\n      morph = topMorph.rootForGrab()\n      topMorph.mouseMove pos  if topMorph.mouseMove\n\n      # if a morph is marked for grabbing, just grab it\n      if @morphToGrab\n        if @morphToGrab.isfloatDraggable\n          morph = @morphToGrab\n          @grab morph\n        # templates create a copy of\n        # themselves when floatDragged\n        else if @morphToGrab.isTemplate\n          morph = @morphToGrab.fullCopy()\n          morph.isTemplate = false\n          morph.isfloatDraggable = true\n          @grab morph\n          @grabOrigin = @morphToGrab.situation()\n\n        # if the mouse has left its boundsIncludingChildren, center it\n        if morph\n          fb = morph.boundsIncludingChildren()\n          unless fb.containsPoint(pos)\n            @bounds.origin = fb.center()\n            @grab morph\n            @setPosition pos\n    #endProcessMouseMove = new Date().getTime()\n    #timeProcessMouseMove = endProcessMouseMove - startProcessMouseMove;\n    #console.log(\'Execution time ProcessMouseMove: \' + timeProcessMouseMove);\n    \n    #\n    #	original, more cautious code for grabbing Morphs,\n    #	retained in case of needing to fall back:\n    #\n    #		if (morph === this.morphToGrab) {\n    #			if (morph.isfloatDraggable) {\n    #				this.grab(morph);\n    #			} else if (morph.isTemplate) {\n    #				morph = morph.fullCopy();\n    #				morph.isTemplate = false;\n    #				morph.isfloatDraggable = true;\n    #				this.grab(morph);\n    #			}\n    #		}\n    #\n    @mouseOverList.forEach (old) =>\n      unless contains(mouseOverNew, old)\n        old.mouseLeave?()\n        old.mouseLeavefloatDragging?()  if @mouseButton\n\n    mouseOverNew.forEach (newMorph) =>\n      unless contains(@mouseOverList, newMorph)\n        newMorph.mouseEnter?()\n        newMorph.mouseEnterfloatDragging?()  if @mouseButton\n\n      # autoScrolling support:\n      if @floatDraggingSomething()\n          if newMorph instanceof ScrollFrameMorph\n              if !newMorph.bounds.insetBy(\n                WorldMorph.preferencesAndSettings.scrollBarSize * 3\n                ).containsPoint(@bounds.origin)\n                  newMorph.startAutoScrolling();\n\n    @mouseOverList = mouseOverNew';

  return HandMorph;

})(Morph);

HandleMorph = (function(_super) {
  __extends(HandleMorph, _super);

  namedClasses[HandleMorph.name] = HandleMorph.prototype;

  HandleMorph.augmentWith(BackingStoreMixin);

  HandleMorph.prototype.target = null;

  HandleMorph.prototype.minExtent = null;

  HandleMorph.prototype.inset = null;

  HandleMorph.prototype.type = null;

  HandleMorph.prototype.step = null;

  function HandleMorph(target, minX, minY, insetX, insetY, type) {
    var size;
    this.target = target != null ? target : null;
    if (minX == null) {
      minX = 0;
    }
    if (minY == null) {
      minY = 0;
    }
    this.type = type != null ? type : "resize";
    this.minExtent = new Point(minX, minY);
    this.inset = new Point(insetX || 0, insetY || insetX || 0);
    HandleMorph.__super__.constructor.call(this);
    this.color = new Color(255, 255, 255);
    this.noticesTransparentClick = true;
    size = WorldMorph.preferencesAndSettings.handleSize;
    this.silentSetExtent(new Point(size, size));
    if (this.target) {
      this.target.add(this);
    }
    this.updateResizerHandlePosition();
  }

  HandleMorph.prototype.updateResizerHandlePosition = function() {
    if (this.target) {
      this.silentUpdateResizerHandlePosition();
      return this.target.changed();
    }
  };

  HandleMorph.prototype.silentUpdateResizerHandlePosition = function() {
    if (this.target) {
      return this.silentSetPosition(this.target.bottomRight().subtract(this.extent().add(this.inset)));
    }
  };

  HandleMorph.prototype.updateBackingStore = function() {
    var extent, highlightImageContext, normalImageContext;
    extent = this.extent();
    this.normalImage = newCanvas(extent.scaleBy(pixelRatio));
    normalImageContext = this.normalImage.getContext("2d");
    normalImageContext.scale(pixelRatio, pixelRatio);
    this.highlightImage = newCanvas(extent.scaleBy(pixelRatio));
    highlightImageContext = this.highlightImage.getContext("2d");
    highlightImageContext.scale(pixelRatio, pixelRatio);
    this.handleMorphRenderingHelper(normalImageContext, this.color, new Color(100, 100, 100));
    this.handleMorphRenderingHelper(highlightImageContext, new Color(100, 100, 255), new Color(255, 255, 255));
    return this.image = this.normalImage;
  };

  HandleMorph.prototype.handleMorphRenderingHelper = function(context, color, shadowColor) {
    var i, p1, p11, p2, p22, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3, _results;
    context.lineWidth = 1;
    context.lineCap = "round";
    context.strokeStyle = color.toString();
    if (this.type === "move") {
      p1 = this.bottomLeft().subtract(this.position());
      p11 = p1.copy();
      p2 = this.topRight().subtract(this.position());
      p22 = p2.copy();
      for (i = _i = 0, _ref = this.height(); _i <= _ref; i = _i += 6) {
        p11.y = p1.y - i;
        p22.y = p2.y - i;
        context.beginPath();
        context.moveTo(p11.x, p11.y);
        context.lineTo(p22.x, p22.y);
        context.closePath();
        context.stroke();
      }
    }
    p1 = this.bottomLeft().subtract(this.position());
    p11 = p1.copy();
    p2 = this.topRight().subtract(this.position());
    p22 = p2.copy();
    for (i = _j = 0, _ref1 = this.width(); _j <= _ref1; i = _j += 6) {
      p11.x = p1.x + i;
      p22.x = p2.x + i;
      context.beginPath();
      context.moveTo(p11.x, p11.y);
      context.lineTo(p22.x, p22.y);
      context.closePath();
      context.stroke();
    }
    context.strokeStyle = shadowColor.toString();
    if (this.type === "move") {
      p1 = this.bottomLeft().subtract(this.position());
      p11 = p1.copy();
      p2 = this.topRight().subtract(this.position());
      p22 = p2.copy();
      for (i = _k = -1, _ref2 = this.height(); _k <= _ref2; i = _k += 6) {
        p11.y = p1.y - i;
        p22.y = p2.y - i;
        context.beginPath();
        context.moveTo(p11.x, p11.y);
        context.lineTo(p22.x, p22.y);
        context.closePath();
        context.stroke();
      }
    }
    p1 = this.bottomLeft().subtract(this.position());
    p11 = p1.copy();
    p2 = this.topRight().subtract(this.position());
    p22 = p2.copy();
    _results = [];
    for (i = _l = 2, _ref3 = this.width(); _l <= _ref3; i = _l += 6) {
      p11.x = p1.x + i;
      p22.x = p2.x + i;
      context.beginPath();
      context.moveTo(p11.x, p11.y);
      context.lineTo(p22.x, p22.y);
      context.closePath();
      _results.push(context.stroke());
    }
    return _results;
  };

  HandleMorph.prototype.mouseClickLeft = function() {};

  HandleMorph.prototype.mouseUpLeft = function() {};

  HandleMorph.prototype.mouseDownLeft = function() {};

  HandleMorph.prototype.mouseDownLeft = function(pos) {
    var offset, world;
    world = this.root();
    offset = pos.subtract(this.bounds.origin);
    if (!this.target) {
      return null;
    }
    this.target.bringToForegroud();
    this.step = (function(_this) {
      return function() {
        var newExt, newPos;
        if (world.hand.mouseButton) {
          newPos = world.hand.bounds.origin.copy().subtract(offset);
          if (_this.type === "resize") {
            newExt = newPos.add(_this.extent().add(_this.inset)).subtract(_this.target.bounds.origin);
            newExt = newExt.max(_this.minExtent);
            _this.target.setExtent(newExt);
            return _this.setPosition(_this.target.bottomRight().subtract(_this.extent().add(_this.inset)));
          } else {
            return _this.target.setPosition(newPos.subtract(_this.target.extent()).add(_this.extent()));
          }
        } else {
          return _this.step = null;
        }
      };
    })(this);
    if (!this.target.step) {
      return this.target.step = noOperation;
    }
  };

  HandleMorph.prototype.rootForGrab = function() {
    return this;
  };

  HandleMorph.prototype.mouseEnter = function() {
    console.log("<<<<<< handle mousenter");
    this.image = this.highlightImage;
    return this.changed();
  };

  HandleMorph.prototype.mouseLeave = function() {
    console.log("<<<<<< handle mouseleave");
    this.image = this.normalImage;
    return this.changed();
  };

  HandleMorph.prototype.makeHandleSolidWithParentMorph = function(ignored, ignored2, morphAttachedTo) {
    this.isfloatDraggable = false;
    this.target = morphAttachedTo;
    this.target.add(this);
    this.updateResizerHandlePosition();
    this.updateBackingStore();
    return this.noticesTransparentClick = true;
  };

  HandleMorph.prototype.attach = function() {
    var choices, menu;
    choices = world.plausibleTargetAndDestinationMorphs(this);
    menu = new MenuMorph(false, this, true, true, "choose target:");
    if (choices.length > 0) {
      choices.forEach((function(_this) {
        return function(each) {
          return menu.addItem(each.toString().slice(0, 50) + " ➜", true, _this, 'makeHandleSolidWithParentMorph', null, null, null, null, null, each);
        };
      })(this));
    } else {
      menu = new MenuMorph(false, this, true, true, "no morphs to attach to");
    }
    if (choices.length) {
      return menu.popUpAtHand(this.firstContainerMenu());
    }
  };

  HandleMorph.coffeeScriptSourceOfThisClass = '# HandleMorph ////////////////////////////////////////////////////////\n# not to be confused with the HandMorph\n# I am a resize / move handle that can be attached to any Morph\n\n# this comment below is needed to figure our dependencies between classes\n# REQUIRES globalFunctions\n# REQUIRES BackingStoreMixin\n\nclass HandleMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith BackingStoreMixin\n\n  target: null\n  minExtent: null\n  inset: null\n  type: null # "resize" or "move"\n  step: null\n\n  constructor: (@target = null, minX = 0, minY = 0, insetX, insetY, @type = "resize") ->\n    # if insetY is missing, it will be the same as insetX\n    @minExtent = new Point(minX, minY)\n    @inset = new Point(insetX or 0, insetY or insetX or 0)\n    super()\n    @color = new Color(255, 255, 255)\n    @noticesTransparentClick = true\n    size = WorldMorph.preferencesAndSettings.handleSize\n    @silentSetExtent new Point(size, size)\n    if @target\n      @target.add @\n    @updateResizerHandlePosition()\n\n  updateResizerHandlePosition: ->\n    if @target\n        @silentUpdateResizerHandlePosition()\n        # todo wow, wasteful!\n        @target.changed()\n\n  silentUpdateResizerHandlePosition: ->\n    if @target\n        @silentSetPosition @target.bottomRight().subtract(@extent().add(@inset))\n  \n  \n  # HandleMorph drawing:\n  # no changes of position or extent\n  updateBackingStore: ->\n    extent = @extent()\n    @normalImage = newCanvas(extent.scaleBy pixelRatio)\n    normalImageContext = @normalImage.getContext("2d")\n    normalImageContext.scale pixelRatio, pixelRatio\n    @highlightImage = newCanvas(extent.scaleBy pixelRatio)\n    highlightImageContext = @highlightImage.getContext("2d")\n    highlightImageContext.scale pixelRatio, pixelRatio\n    @handleMorphRenderingHelper normalImageContext, @color, new Color(100, 100, 100)\n    @handleMorphRenderingHelper highlightImageContext, new Color(100, 100, 255), new Color(255, 255, 255)\n    @image = @normalImage\n  \n  handleMorphRenderingHelper: (context, color, shadowColor) ->\n    context.lineWidth = 1\n    context.lineCap = "round"\n    context.strokeStyle = color.toString()\n    if @type is "move"\n      p1 = @bottomLeft().subtract(@position())\n      p11 = p1.copy()\n      p2 = @topRight().subtract(@position())\n      p22 = p2.copy()\n      for i in [0..@height()] by 6\n        p11.y = p1.y - i\n        p22.y = p2.y - i\n        context.beginPath()\n        context.moveTo p11.x, p11.y\n        context.lineTo p22.x, p22.y\n        context.closePath()\n        context.stroke()\n\n    p1 = @bottomLeft().subtract(@position())\n    p11 = p1.copy()\n    p2 = @topRight().subtract(@position())\n    p22 = p2.copy()\n    for i in [0..@width()] by 6\n      p11.x = p1.x + i\n      p22.x = p2.x + i\n      context.beginPath()\n      context.moveTo p11.x, p11.y\n      context.lineTo p22.x, p22.y\n      context.closePath()\n      context.stroke()\n\n    context.strokeStyle = shadowColor.toString()\n    if @type is "move"\n      p1 = @bottomLeft().subtract(@position())\n      p11 = p1.copy()\n      p2 = @topRight().subtract(@position())\n      p22 = p2.copy()\n      for i in [-1..@height()] by 6\n        p11.y = p1.y - i\n        p22.y = p2.y - i\n        context.beginPath()\n        context.moveTo p11.x, p11.y\n        context.lineTo p22.x, p22.y\n        context.closePath()\n        context.stroke()\n\n    p1 = @bottomLeft().subtract(@position())\n    p11 = p1.copy()\n    p2 = @topRight().subtract(@position())\n    p22 = p2.copy()\n    for i in [2..@width()] by 6\n      p11.x = p1.x + i\n      p22.x = p2.x + i\n      context.beginPath()\n      context.moveTo p11.x, p11.y\n      context.lineTo p22.x, p22.y\n      context.closePath()\n      context.stroke()\n  \n\n  # implement dummy methods in here\n  # so the handle catches the clicks and\n  # prevents the parent to do anything.\n  mouseClickLeft: ->\n  mouseUpLeft: ->\n  mouseDownLeft: ->\n  \n  # HandleMorph stepping:\n  mouseDownLeft: (pos) ->\n    world = @root()\n    offset = pos.subtract(@bounds.origin)\n    return null  unless @target\n    @target.bringToForegroud()\n    @step = =>\n      if world.hand.mouseButton\n        newPos = world.hand.bounds.origin.copy().subtract(offset)\n        if @type is "resize"\n          newExt = newPos.add(@extent().add(@inset)).subtract(@target.bounds.origin)\n          newExt = newExt.max(@minExtent)\n          @target.setExtent newExt\n          @setPosition @target.bottomRight().subtract(@extent().add(@inset))\n        else # type === \'move\'\n          @target.setPosition newPos.subtract(@target.extent()).add(@extent())\n      else\n        @step = null\n    \n    unless @target.step\n      @target.step = noOperation\n  \n  \n  # HandleMorph floatDragging and dropping:\n  rootForGrab: ->\n    @\n  \n  \n  # HandleMorph events:\n  mouseEnter: ->\n    console.log "<<<<<< handle mousenter"\n    @image = @highlightImage\n    @changed()\n  \n  mouseLeave: ->\n    console.log "<<<<<< handle mouseleave"\n    @image = @normalImage\n    @changed()\n\n  makeHandleSolidWithParentMorph: (ignored, ignored2, morphAttachedTo)->\n    @isfloatDraggable = false\n    @target = morphAttachedTo\n    @target.add @\n    @updateResizerHandlePosition()\n\n    @updateBackingStore()\n    @noticesTransparentClick = true\n  \n    \n  # HandleMorph menu:\n  attach: ->\n    choices = world.plausibleTargetAndDestinationMorphs(@)\n    menu = new MenuMorph(false, @, true, true, "choose target:")\n    if choices.length > 0\n      choices.forEach (each) =>\n        menu.addItem each.toString().slice(0, 50) + " ➜", true, @, \'makeHandleSolidWithParentMorph\', null,null,null,null,null,each\n    else\n      # the ideal would be to not show the\n      # "attach" menu entry at all but for the\n      # time being it\'s quite costly to\n      # find the eligible morphs to attach\n      # to, so for now let\'s just calculate\n      # this list if the user invokes the\n      # command, and if there are no good\n      # morphs then show some kind of message.\n      menu = new MenuMorph(false, @, true, true, "no morphs to attach to")\n    menu.popUpAtHand(@firstContainerMenu())  if choices.length';

  return HandleMorph;

})(Morph);

InspectorMorph = (function(_super) {
  __extends(InspectorMorph, _super);

  namedClasses[InspectorMorph.name] = InspectorMorph.prototype;

  InspectorMorph.prototype.target = null;

  InspectorMorph.prototype.currentProperty = null;

  InspectorMorph.prototype.showing = "attributes";

  InspectorMorph.prototype.markOwnershipOfProperties = false;

  InspectorMorph.prototype.label = null;

  InspectorMorph.prototype.list = null;

  InspectorMorph.prototype.detail = null;

  InspectorMorph.prototype.work = null;

  InspectorMorph.prototype.buttonInspect = null;

  InspectorMorph.prototype.buttonClose = null;

  InspectorMorph.prototype.buttonSubset = null;

  InspectorMorph.prototype.buttonEdit = null;

  InspectorMorph.prototype.resizer = null;

  function InspectorMorph(target) {
    this.target = target;
    InspectorMorph.__super__.constructor.call(this);
    this.silentSetExtent(new Point(WorldMorph.preferencesAndSettings.handleSize * 20, WorldMorph.preferencesAndSettings.handleSize * 20 * 2 / 3));
    this.isfloatDraggable = true;
    this.border = 1;
    this.edge = WorldMorph.preferencesAndSettings.isFlat ? 1 : 5;
    this.color = new Color(60, 60, 60);
    if (this.target) {
      this.buildAndConnectChildren();
    }
  }

  InspectorMorph.prototype.setTarget = function(target) {
    this.target = target;
    this.currentProperty = null;
    return this.buildAndConnectChildren();
  };

  InspectorMorph.prototype.buildAndConnectChildren = function() {
    var attribs, ctrl, doubleClickAction, ev, property, staticAttributes, staticFunctions, staticProperties, targetOwnMethods;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.IDLE && AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism) {
      world.alignIDsOfNextMorphsInSystemTests();
    }
    attribs = [];
    this.destroyAll();
    this.label = new TextMorph(this.target.toString());
    this.label.fontSize = WorldMorph.preferencesAndSettings.menuFontSize;
    this.label.isBold = true;
    this.label.color = new Color(255, 255, 255);
    this.add(this.label);
    for (property in this.target) {
      if (property) {
        attribs.push(property);
      }
    }
    if (this.showing === "attributes") {
      attribs = attribs.filter((function(_this) {
        return function(prop) {
          return !isFunction(_this.target[prop]);
        };
      })(this));
    } else if (this.showing === "methods") {
      attribs = attribs.filter((function(_this) {
        return function(prop) {
          return isFunction(_this.target[prop]);
        };
      })(this));
    }
    staticProperties = Object.getOwnPropertyNames(this.target.constructor);
    staticProperties = staticProperties.filter((function(_this) {
      return function(prop) {
        return prop !== "name" && prop !== "length" && prop !== "prototype" && prop !== "caller" && prop !== "__super__" && prop !== "arguments";
      };
    })(this));
    if (this.showing === "attributes") {
      staticFunctions = [];
      staticAttributes = staticProperties.filter((function(_this) {
        return function(prop) {
          return !isFunction(_this.target.constructor[prop]);
        };
      })(this));
    } else if (this.showing === "methods") {
      staticFunctions = staticProperties.filter((function(_this) {
        return function(prop) {
          return isFunction(_this.target.constructor[prop]);
        };
      })(this));
      staticAttributes = [];
    } else {
      staticFunctions = staticProperties.filter((function(_this) {
        return function(prop) {
          return isFunction(_this.target.constructor[prop]);
        };
      })(this));
      staticAttributes = staticProperties.filter((function(_this) {
        return function(prop) {
          return __indexOf.call(staticFunctions, prop) < 0;
        };
      })(this));
    }
    attribs = (attribs.concat(staticFunctions)).concat(staticAttributes);
    if (this.markOwnershipOfProperties) {
      targetOwnMethods = Object.getOwnPropertyNames(this.target.constructor.prototype);
    }
    doubleClickAction = (function(_this) {
      return function() {
        var inspector, world;
        if (!isObject(_this.currentProperty)) {
          return;
        }
        world = _this.world();
        inspector = new InspectorMorph(_this.currentProperty);
        inspector.setPosition(world.hand.position());
        inspector.keepWithin(world);
        world.add(inspector);
        return inspector.changed();
      };
    })(this);
    this.list = new ListMorph(this, "selectionFromList", (this.target instanceof Array ? attribs : attribs.sort()), null, this.filterProperties(staticProperties, targetOwnMethods), doubleClickAction);
    this.list.acceptsDrops = false;
    this.list.listContents.step = null;
    this.add(this.list);
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.IDLE && AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism) {
      world.alignIDsOfNextMorphsInSystemTests();
    }
    this.detail = new ScrollFrameMorph();
    this.detail.acceptsDrops = false;
    this.detail.contents.acceptsDrops = false;
    this.detail.isTextLineWrapping = true;
    this.detail.color = new Color(255, 255, 255);
    ctrl = new TextMorph("");
    ctrl.isEditable = true;
    ctrl.enableSelecting();
    ctrl.setReceiver(this.target);
    this.detail.setContents(ctrl, 2);
    this.add(this.detail);
    this.work = new ScrollFrameMorph();
    this.work.acceptsDrops = false;
    this.work.contents.acceptsDrops = false;
    this.work.isTextLineWrapping = true;
    this.work.color = new Color(255, 255, 255);
    ev = new TextMorph("");
    ev.isEditable = true;
    ev.enableSelecting();
    ev.setReceiver(this.target);
    this.work.setContents(ev, 2);
    this.add(this.work);
    this.buttonSubset = new TriggerMorph(true, this);
    this.buttonSubset.setLabel("show...");
    this.buttonSubset.alignCenter();
    this.buttonSubset.action = "openShowMenu";
    this.add(this.buttonSubset);
    this.buttonInspect = new TriggerMorph(true, this);
    this.buttonInspect.setLabel("inspect");
    this.buttonInspect.alignCenter();
    this.buttonInspect.action = "openInspectorMenu";
    this.add(this.buttonInspect);
    this.buttonEdit = new TriggerMorph(true, this);
    this.buttonEdit.setLabel("edit...");
    this.buttonEdit.alignCenter();
    this.buttonEdit.action = "openEditMenu";
    this.add(this.buttonEdit);
    this.buttonClose = new TriggerMorph(true, this);
    this.buttonClose.setLabel("close");
    this.buttonClose.alignCenter();
    this.buttonClose.action = "destroy";
    this.add(this.buttonClose);
    this.resizer = new HandleMorph(this, 150, 100, this.edge, this.edge);
    return this.layoutSubmorphs();
  };

  InspectorMorph.prototype.openShowMenu = function() {
    var menu;
    menu = new MenuMorph(false);
    menu.addItem("attributes", true, this, (function(_this) {
      return function() {
        _this.showing = "attributes";
        return _this.buildAndConnectChildren();
      };
    })(this));
    menu.addItem("methods", true, this, (function(_this) {
      return function() {
        _this.showing = "methods";
        return _this.buildAndConnectChildren();
      };
    })(this));
    menu.addItem("all", true, this, (function(_this) {
      return function() {
        _this.showing = "all";
        return _this.buildAndConnectChildren();
      };
    })(this));
    menu.addLine();
    menu.addItem((this.markOwnershipOfProperties ? "un-mark ownership" : "mark ownership"), true, this, ((function(_this) {
      return function() {
        _this.markOwnershipOfProperties = !_this.markOwnershipOfProperties;
        return _this.buildAndConnectChildren();
      };
    })(this)), "highlight\nownership of properties");
    return menu.popUpAtHand(this.firstContainerMenu());
  };

  InspectorMorph.prototype.openInspectorMenu = function() {
    var menu;
    if (isObject(this.currentProperty)) {
      menu = new MenuMorph(false);
      menu.addItem("in new inspector...", true, this, (function(_this) {
        return function() {
          var inspector, world;
          world = _this.world();
          inspector = new _this.constructor(_this.currentProperty);
          inspector.setPosition(world.hand.position());
          inspector.keepWithin(world);
          world.add(inspector);
          return inspector.changed();
        };
      })(this));
      menu.addItem("here...", true, this, (function(_this) {
        return function() {
          return _this.setTarget(_this.currentProperty);
        };
      })(this));
      return menu.popUpAtHand(this.firstContainerMenu());
    } else {
      return this.inform((this.currentProperty === null ? "null" : typeof this.currentProperty) + "\nis not inspectable");
    }
  };

  InspectorMorph.prototype.openEditMenu = function() {
    var menu;
    menu = new MenuMorph(false);
    menu.addItem("save", true, this, "save", "accept changes");
    menu.addLine();
    menu.addItem("add property...", true, this, "addPropertyPopout");
    menu.addItem("rename...", true, this, "renamePropertyPopout");
    menu.addItem("remove", true, this, "removeProperty");
    return menu.popUpAtHand(this.firstContainerMenu());
  };

  InspectorMorph.prototype.filterProperties = function(staticProperties, targetOwnMethods) {
    if (this.markOwnershipOfProperties) {
      return [
        [
          new Color(0, 0, 180), (function(_this) {
            return function(element) {
              return true;
            };
          })(this)
        ], [
          new Color(255, 165, 0), (function(_this) {
            return function(element) {
              return __indexOf.call(staticProperties, element) >= 0;
            };
          })(this)
        ], [
          new Color(0, 180, 0), (function(_this) {
            return function(element) {
              return Object.prototype.hasOwnProperty.call(_this.target, element);
            };
          })(this)
        ], [
          new Color(180, 0, 0), (function(_this) {
            return function(element) {
              return __indexOf.call(targetOwnMethods, element) >= 0;
            };
          })(this)
        ]
      ];
    } else {
      return null;
    }
  };

  InspectorMorph.prototype.selectionFromList = function(selected) {
    var cnts, txt, val;
    if (selected === void 0) {
      return;
    }
    val = this.target[selected];
    if (val === void 0) {
      val = this.target.constructor[selected];
    }
    this.currentProperty = val;
    if (val === null) {
      txt = "null";
    } else if (isString(val)) {
      txt = '"' + val + '"';
    } else {
      txt = val.toString();
    }
    cnts = new TextMorph(txt);
    cnts.isEditable = true;
    cnts.enableSelecting();
    cnts.setReceiver(this.target);
    return this.detail.setContents(cnts, 2);
  };

  InspectorMorph.prototype.layoutSubmorphs = function() {
    var b, closeLeft, closeRight, closeWidth, detailLeft, detailRight, detailWidth, editLeft, editRight, inspectLeft, inspectRight, inspectWidth, labelBottom, labelLeft, labelRight, labelTop, labelWidth, listBottom, listHeight, listWidth, propertiesHeight, propertiesLeft, propertiesTop, propertiesWidth, workTop;
    console.log("fixing the layout of the inspector");
    Morph.prototype.trackChanges = false;
    labelLeft = this.left() + this.edge;
    labelTop = this.top() + this.edge;
    labelRight = this.right() - this.edge;
    labelWidth = labelRight - labelLeft;
    if (this.label.parent === this) {
      this.label.setPosition(new Point(labelLeft, labelTop));
      this.label.setWidth(labelWidth);
      if (this.label.height() > (this.height() - 50)) {
        this.silentSetHeight(this.label.height() + 50);
        this.setLayoutBeforeUpdatingBackingStore();
        this.updateBackingStore();
        this.changed();
        this.resizer.silentUpdateResizerHandlePosition();
      }
    }
    labelBottom = labelTop + this.label.height() + 2;
    listWidth = Math.floor(this.width() / 3);
    listWidth -= this.edge;
    b = this.bottom() - (2 * this.edge) - WorldMorph.preferencesAndSettings.handleSize;
    listHeight = b - labelBottom;
    listBottom = labelBottom + listHeight;
    if (this.list.parent === this) {
      this.list.setPosition(new Point(labelLeft, labelBottom));
      this.list.setExtent(new Point(listWidth, listHeight));
    }
    detailLeft = labelLeft + listWidth + this.edge;
    detailRight = this.right() - this.edge;
    detailWidth = detailRight - detailLeft;
    if (this.detail.parent === this) {
      this.detail.setPosition(new Point(detailLeft, labelBottom));
      this.detail.setExtent(new Point(detailWidth, (listHeight * 2 / 3) - this.edge));
    }
    workTop = labelBottom + (listHeight * 2 / 3);
    if (this.work.parent === this) {
      this.work.setPosition(new Point(detailLeft, workTop));
      this.work.setExtent(new Point(detailWidth, listHeight / 3));
    }
    propertiesLeft = labelLeft;
    propertiesTop = listBottom + this.edge;
    propertiesWidth = listWidth;
    propertiesHeight = WorldMorph.preferencesAndSettings.handleSize;
    if (this.buttonSubset.parent === this) {
      this.buttonSubset.setPosition(new Point(propertiesLeft, propertiesTop));
      this.buttonSubset.setExtent(new Point(propertiesWidth, propertiesHeight));
    }
    inspectLeft = detailLeft;
    inspectWidth = detailWidth - this.edge - WorldMorph.preferencesAndSettings.handleSize;
    inspectWidth = inspectWidth / 3 - this.edge / 3;
    inspectRight = inspectLeft + inspectWidth;
    if (this.buttonInspect.parent === this) {
      this.buttonInspect.setPosition(new Point(inspectLeft, propertiesTop));
      this.buttonInspect.setExtent(new Point(inspectWidth, propertiesHeight));
    }
    editLeft = inspectRight + this.edge;
    editRight = editLeft + inspectWidth;
    if (this.buttonEdit.parent === this) {
      this.buttonEdit.setPosition(new Point(editLeft, propertiesTop));
      this.buttonEdit.setExtent(new Point(inspectWidth, propertiesHeight));
    }
    closeLeft = editRight + this.edge;
    closeRight = detailRight - this.edge - WorldMorph.preferencesAndSettings.handleSize;
    closeWidth = closeRight - closeLeft;
    if (this.buttonClose.parent === this) {
      this.buttonClose.setPosition(new Point(closeLeft, propertiesTop));
      this.buttonClose.setExtent(new Point(closeWidth, propertiesHeight));
    }
    Morph.prototype.trackChanges = true;
    this.changed();
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.IDLE && AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism) {
      return world.alignIDsOfNextMorphsInSystemTests();
    }
  };

  InspectorMorph.prototype.save = function() {
    var err, propertyName, txt;
    txt = this.detail.contents.children[0].text.toString();
    propertyName = this.list.selected.labelString;
    try {
      this.target.evaluateString("this." + propertyName + " = " + txt);
      this.target.changed();
      this.target.setLayoutBeforeUpdatingBackingStore();
      this.target.updateBackingStore();
      return this.target.changed();
    } catch (_error) {
      err = _error;
      return this.inform(err);
    }
  };

  InspectorMorph.prototype.addProperty = function(ignoringThis, morphWithProperty) {
    var prop;
    prop = morphWithProperty.text.text;
    if (prop != null) {
      if (prop.getValue != null) {
        prop = prop.getValue();
      }
      this.target[prop] = null;
      this.buildAndConnectChildren();
      this.target.changed();
      this.target.setLayoutBeforeUpdatingBackingStore();
      this.target.updateBackingStore();
      return this.target.changed();
    }
  };

  InspectorMorph.prototype.addPropertyPopout = function() {
    return this.prompt("new property name:", this, "addProperty", "property");
  };

  InspectorMorph.prototype.renameProperty = function(ignoringThis, morphWithProperty) {
    var err, prop, propertyName;
    propertyName = this.list.selected.labelString;
    prop = morphWithProperty.text.text;
    if (prop.getValue != null) {
      prop = prop.getValue();
    }
    try {
      delete this.target[propertyName];
      this.target[prop] = this.currentProperty;
    } catch (_error) {
      err = _error;
      this.inform(err);
    }
    this.buildAndConnectChildren();
    this.target.changed();
    this.target.setLayoutBeforeUpdatingBackingStore();
    this.target.updateBackingStore();
    return this.target.changed();
  };

  InspectorMorph.prototype.renamePropertyPopout = function() {
    var propertyName;
    propertyName = this.list.selected.labelString;
    return this.prompt("property name:", this, "renameProperty", propertyName);
  };

  InspectorMorph.prototype.removeProperty = function() {
    var err, propertyName;
    propertyName = this.list.selected.labelString;
    try {
      delete this.target[propertyName];
      this.currentProperty = null;
      this.buildAndConnectChildren();
      this.target.changed();
      this.target.setLayoutBeforeUpdatingBackingStore();
      this.target.updateBackingStore();
      return this.target.changed();
    } catch (_error) {
      err = _error;
      return this.inform(err);
    }
  };

  InspectorMorph.coffeeScriptSourceOfThisClass = '# InspectorMorph //////////////////////////////////////////////////////\n\nclass InspectorMorph extends BoxMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  target: null\n  currentProperty: null\n  showing: "attributes"\n  markOwnershipOfProperties: false\n  # panes:\n  label: null\n  list: null\n  detail: null\n  work: null\n  buttonInspect: null\n  buttonClose: null\n  buttonSubset: null\n  buttonEdit: null\n  resizer: null\n\n  constructor: (@target) ->\n    super()\n    # override inherited properties:\n    @silentSetExtent new Point(WorldMorph.preferencesAndSettings.handleSize * 20,\n      WorldMorph.preferencesAndSettings.handleSize * 20 * 2 / 3)\n    @isfloatDraggable = true\n    @border = 1\n    @edge = if WorldMorph.preferencesAndSettings.isFlat then 1 else 5\n    @color = new Color(60, 60, 60)\n    @buildAndConnectChildren()  if @target\n  \n  setTarget: (target) ->\n    @target = target\n    @currentProperty = null\n    @buildAndConnectChildren()\n  \n  buildAndConnectChildren: ->\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n    attribs = []\n\n    # remove all submorhs i.e. panes and buttons\n    # THE ONES THAT ARE STILL\n    # submorphs of the inspector. If they\n    # have been peeled away, they still live\n    @destroyAll()\n\n    # label\n    @label = new TextMorph(@target.toString())\n    @label.fontSize = WorldMorph.preferencesAndSettings.menuFontSize\n    @label.isBold = true\n    @label.color = new Color(255, 255, 255)\n    @add @label\n    \n    # properties list. Note that this picks up ALL properties\n    # (enumerable such as strings and un-enumerable such as functions)\n    # of the whole prototype chain.\n    #\n    #   a) some of these are DECLARED as part of the class that defines the object\n    #   and are proprietary to the object. These are shown RED\n    # \n    #   b) some of these are proprietary to the object but are initialised by\n    #   code higher in the prototype chain. These are shown GREEN\n    #\n    #   c) some of these are not proprietary, i.e. they belong to an object up\n    #   the chain of prototypes. These are shown BLUE\n    #\n    # todo: show the static methods and variables in yet another color.\n    \n    for property of @target\n      # dummy condition, to be refined\n      attribs.push property  if property\n    if @showing is "attributes"\n      attribs = attribs.filter((prop) =>\n        not isFunction @target[prop]\n      )\n    else if @showing is "methods"\n      attribs = attribs.filter((prop) =>\n        isFunction @target[prop]\n      )\n    # otherwise show all properties\n    # label getter\n    # format list\n    # format element: [color, predicate(element]\n    \n    staticProperties = Object.getOwnPropertyNames(@target.constructor)\n    # get rid of all the standard fuff properties that are in classes\n    staticProperties = staticProperties.filter((prop) =>\n        prop not in ["name","length","prototype","caller","__super__","arguments"]\n    )\n    if @showing is "attributes"\n      staticFunctions = []\n      staticAttributes = staticProperties.filter((prop) =>\n        not isFunction(@target.constructor[prop])\n      )\n    else if @showing is "methods"\n      staticFunctions = staticProperties.filter((prop) =>\n        isFunction(@target.constructor[prop])\n      )\n      staticAttributes = []\n    else\n      staticFunctions = staticProperties.filter((prop) =>\n        isFunction(@target.constructor[prop])\n      )\n      staticAttributes = staticProperties.filter((prop) =>\n        prop not in staticFunctions\n      )\n    #alert "stat fun " + staticFunctions + " stat attr " + staticAttributes\n    attribs = (attribs.concat staticFunctions).concat staticAttributes\n    #alert " all attribs " + attribs\n    \n    # caches the own methods of the object\n    if @markOwnershipOfProperties\n      targetOwnMethods = Object.getOwnPropertyNames(@target.constructor.prototype)\n      #alert targetOwnMethods\n\n    # open a new inspector, just on objects so\n    # the idea is that you can view / change\n    # its fields\n    doubleClickAction = =>\n      if (!isObject(@currentProperty))\n        return\n      world = @world()\n      inspector = new InspectorMorph @currentProperty\n      inspector.setPosition world.hand.position()\n      inspector.keepWithin world\n      world.add inspector\n      inspector.changed()\n\n    @list = new ListMorph(\n      @, # target\n      "selectionFromList", #action\n      (if @target instanceof Array then attribs else attribs.sort()), #elements\n      null, #labelGetter\n      @filterProperties(staticProperties, targetOwnMethods), #format\n      doubleClickAction #doubleClickAction\n    )\n    @list.acceptsDrops = false\n\n    # we know that the content of this list in this pane is not going to need the\n    # step function, so we disable that from here by setting it to null, which\n    # prevents the recursion to children. We could have disabled that from the\n    # constructor of MenuMorph, but who knows, maybe someone might intend to use a MenuMorph\n    # with some animated content? We know that in this specific case it won\'t need animation so\n    # we set that here. Note that the ListMorph itself does require animation because of the\n    # scrollbars, but the MenuMorph (which contains the actual list contents)\n    # in this context doesn\'t.\n    @list.listContents.step = null\n    @add @list\n\n    # we add a Morph alignment here because adjusting IDs whenever\n    # we add or remove methods is a pain...\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n\n    # details pane\n    @detail = new ScrollFrameMorph()\n    @detail.acceptsDrops = false\n    @detail.contents.acceptsDrops = false\n    @detail.isTextLineWrapping = true\n    @detail.color = new Color(255, 255, 255)\n    ctrl = new TextMorph("")\n    ctrl.isEditable = true\n    ctrl.enableSelecting()\n    ctrl.setReceiver @target\n    @detail.setContents ctrl, 2\n    @add @detail\n\n    # work (\'evaluation\') pane\n    @work = new ScrollFrameMorph()\n    @work.acceptsDrops = false\n    @work.contents.acceptsDrops = false\n    @work.isTextLineWrapping = true\n    @work.color = new Color(255, 255, 255)\n    ev = new TextMorph("")\n    ev.isEditable = true\n    ev.enableSelecting()\n    ev.setReceiver @target\n    @work.setContents ev, 2\n    @add @work\n\n    # properties button\n    @buttonSubset = new TriggerMorph(true, @)\n    @buttonSubset.setLabel "show..."\n    @buttonSubset.alignCenter()\n    @buttonSubset.action = "openShowMenu"\n    @add @buttonSubset\n\n    # inspect button\n    @buttonInspect = new TriggerMorph(true, @)\n    @buttonInspect.setLabel "inspect"\n    @buttonInspect.alignCenter()\n    @buttonInspect.action = "openInspectorMenu"\n    @add @buttonInspect\n\n    # edit button\n    @buttonEdit = new TriggerMorph(true, @)\n    @buttonEdit.setLabel "edit..."\n    @buttonEdit.alignCenter()\n    @buttonEdit.action = "openEditMenu"\n    @add @buttonEdit\n\n    # close button\n    @buttonClose = new TriggerMorph(true, @)\n    @buttonClose.setLabel "close"\n    @buttonClose.alignCenter()\n    @buttonClose.action = "destroy"\n    @add @buttonClose\n\n    # resizer\n    @resizer = new HandleMorph(@, 150, 100, @edge, @edge)\n\n    # update layout\n    @layoutSubmorphs()\n\n  openShowMenu: ->\n    menu = new MenuMorph(false)\n    menu.addItem "attributes", true, @, =>\n      @showing = "attributes"\n      @buildAndConnectChildren()\n\n    menu.addItem "methods", true, @, =>\n      @showing = "methods"\n      @buildAndConnectChildren()\n\n    menu.addItem "all", true, @, =>\n      @showing = "all"\n      @buildAndConnectChildren()\n\n    menu.addLine()\n    menu.addItem ((if @markOwnershipOfProperties then "un-mark ownership" else "mark ownership")), true, @, (=>\n      @markOwnershipOfProperties = not @markOwnershipOfProperties\n      @buildAndConnectChildren()\n    ), "highlight\nownership of properties"\n    menu.popUpAtHand(@firstContainerMenu())\n\n  openInspectorMenu: ->\n    if isObject(@currentProperty)\n      menu = new MenuMorph(false)\n      menu.addItem "in new inspector...", true, @, =>\n        world = @world()\n        inspector = new @constructor(@currentProperty)\n        inspector.setPosition world.hand.position()\n        inspector.keepWithin world\n        world.add inspector\n        inspector.changed()\n\n      menu.addItem "here...", true, @, =>\n        @setTarget @currentProperty\n\n      menu.popUpAtHand(@firstContainerMenu())\n    else\n      @inform ((if @currentProperty is null then "null" else typeof @currentProperty)) + "\nis not inspectable"\n\n  openEditMenu: ->\n    menu = new MenuMorph(false)\n    menu.addItem "save", true, @, "save", "accept changes"\n    menu.addLine()\n    menu.addItem "add property...", true, @, "addPropertyPopout"\n    menu.addItem "rename...", true, @, "renamePropertyPopout"\n    menu.addItem "remove", true, @, "removeProperty"\n    menu.popUpAtHand(@firstContainerMenu())\n\n\n  filterProperties: (staticProperties, targetOwnMethods)->\n    if @markOwnershipOfProperties\n      return [\n        # give color criteria from the most general to the most specific\n        [new Color(0, 0, 180),\n          (element) =>\n            # if the element is either an enumerable property of the object\n            # or it belongs to the own methods, then it is highlighted.\n            # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n            # functions.\n            # In theory, getOwnPropertyNames should give ALL the properties but the methods\n            # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n            true\n        ],\n        [new Color(255, 165, 0),\n          (element) =>\n            # if the element is either an enumerable property of the object\n            # or it belongs to the own methods, then it is highlighted.\n            # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n            # functions.\n            # In theory, getOwnPropertyNames should give ALL the properties but the methods\n            # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n            element in staticProperties\n        ],\n        [new Color(0, 180, 0),\n          (element) =>\n            # if the element is either an enumerable property of the object\n            # or it belongs to the own methods, then it is highlighted.\n            # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n            # functions.\n            # In theory, getOwnPropertyNames should give ALL the properties but the methods\n            # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n            (Object.prototype.hasOwnProperty.call(@target, element))\n        ],\n        [new Color(180, 0, 0),\n          (element) =>\n            # if the element is either an enumerable property of the object\n            # or it belongs to the own methods, then it is highlighted.\n            # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n            # functions.\n            # In theory, getOwnPropertyNames should give ALL the properties but the methods\n            # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n            (element in targetOwnMethods)\n        ]\n      ]\n    else\n      return null\n\n  selectionFromList: (selected) ->\n    if (selected == undefined) then return\n    val = @target[selected]\n    # this is for finding the static variables\n    if val is undefined\n      val = @target.constructor[selected]\n    @currentProperty = val\n    if val is null\n      txt = "null"\n    else if isString(val)\n      txt = \'"\'+val+\'"\'\n    else\n      txt = val.toString()\n    cnts = new TextMorph(txt)\n    cnts.isEditable = true\n    cnts.enableSelecting()\n    cnts.setReceiver @target\n    @detail.setContents cnts, 2\n  \n  layoutSubmorphs: ->\n    console.log "fixing the layout of the inspector"\n\n    # here we are disabling all the broken\n    # rectangles. The reason is that all the\n    # submorphs of the inspector are within the\n    # bounds of the parent Morph. This means that\n    # if only the parent morph breaks its rectangle\n    # then everything is OK.\n    # Also note that if you attach something else to its\n    # boundary in a way that sticks out, that\'s still\n    # going to be painted and moved OK.\n    Morph::trackChanges = false\n\n    # label\n    labelLeft = @left() + @edge\n    labelTop = @top() + @edge\n    labelRight = @right() - @edge\n    labelWidth = labelRight - labelLeft\n    if @label.parent == @\n      @label.setPosition new Point(labelLeft, labelTop)\n      @label.setWidth labelWidth\n      if @label.height() > (@height() - 50)\n        @silentSetHeight @label.height() + 50\n        @setLayoutBeforeUpdatingBackingStore()\n        @updateBackingStore()\n        @changed()\n        @resizer.silentUpdateResizerHandlePosition()\n\n    # list\n    labelBottom = labelTop + @label.height() + 2\n    listWidth = Math.floor(@width() / 3)\n    listWidth -= @edge\n    b = @bottom() - (2 * @edge) - WorldMorph.preferencesAndSettings.handleSize\n    listHeight = b - labelBottom\n    listBottom = labelBottom + listHeight\n    if @list.parent == @\n      @list.setPosition new Point(labelLeft, labelBottom)\n      @list.setExtent new Point(listWidth, listHeight)\n\n    # detail\n    detailLeft = labelLeft + listWidth + @edge\n    detailRight = @right() - @edge\n    detailWidth = detailRight - detailLeft\n    if @detail.parent == @\n      @detail.setPosition new Point(detailLeft, labelBottom)\n      @detail.setExtent new Point(detailWidth, (listHeight * 2 / 3) - @edge)\n\n    # work\n    workTop = labelBottom + (listHeight * 2 / 3)\n    if @work.parent == @\n      @work.setPosition new Point(detailLeft, workTop)\n      @work.setExtent new Point(detailWidth, listHeight / 3)\n\n    # properties button\n    propertiesLeft = labelLeft\n    propertiesTop = listBottom + @edge\n    propertiesWidth = listWidth\n    propertiesHeight = WorldMorph.preferencesAndSettings.handleSize\n    if @buttonSubset.parent == @\n      @buttonSubset.setPosition new Point(propertiesLeft, propertiesTop)\n      @buttonSubset.setExtent new Point(propertiesWidth, propertiesHeight)\n\n    # inspect button\n    inspectLeft = detailLeft\n    inspectWidth = detailWidth - @edge - WorldMorph.preferencesAndSettings.handleSize\n    inspectWidth = inspectWidth / 3 - @edge / 3\n    inspectRight = inspectLeft + inspectWidth\n    if @buttonInspect.parent == @\n      @buttonInspect.setPosition new Point(inspectLeft, propertiesTop)\n      @buttonInspect.setExtent new Point(inspectWidth, propertiesHeight)\n\n    # edit button\n    editLeft = inspectRight + @edge\n    editRight = editLeft + inspectWidth\n    if @buttonEdit.parent == @\n      @buttonEdit.setPosition new Point(editLeft, propertiesTop)\n      @buttonEdit.setExtent new Point(inspectWidth, propertiesHeight)\n\n    # close button\n    closeLeft = editRight + @edge\n    closeRight = detailRight - @edge - WorldMorph.preferencesAndSettings.handleSize\n    closeWidth = closeRight - closeLeft\n    if @buttonClose.parent == @\n      @buttonClose.setPosition new Point(closeLeft, propertiesTop)\n      @buttonClose.setExtent new Point(closeWidth, propertiesHeight)\n\n    Morph::trackChanges = true\n    @changed()\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n  \n  \n  #InspectorMorph editing ops:\n  save: ->\n    txt = @detail.contents.children[0].text.toString()\n    propertyName = @list.selected.labelString\n\n    try\n      # this.target[propertyName] = evaluate(txt);\n      @target.evaluateString "this." + propertyName + " = " + txt\n      @target.changed()\n      @target.setLayoutBeforeUpdatingBackingStore()\n      @target.updateBackingStore()\n      @target.changed()\n    catch err\n      @inform err\n\n  addProperty: (ignoringThis, morphWithProperty) ->\n    prop = morphWithProperty.text.text\n    if prop?\n      if prop.getValue?\n        prop = prop.getValue()\n      @target[prop] = null\n      @buildAndConnectChildren()\n      @target.changed()\n      @target.setLayoutBeforeUpdatingBackingStore()\n      @target.updateBackingStore()\n      @target.changed()\n  \n  addPropertyPopout: ->\n    @prompt "new property name:", @, "addProperty", "property" # Chrome cannot handle empty strings (others do)\n\n  renameProperty: (ignoringThis, morphWithProperty) ->\n    propertyName = @list.selected.labelString\n    prop = morphWithProperty.text.text\n    if prop.getValue?\n      prop = prop.getValue()\n    try\n      delete (@target[propertyName])\n      @target[prop] = @currentProperty\n    catch err\n      @inform err\n    @buildAndConnectChildren()\n    @target.changed()\n    @target.setLayoutBeforeUpdatingBackingStore()\n    @target.updateBackingStore()\n    @target.changed()\n  \n  renamePropertyPopout: ->\n    propertyName = @list.selected.labelString\n    @prompt "property name:", @, "renameProperty", propertyName\n  \n  removeProperty: ->\n    propertyName = @list.selected.labelString\n    try\n      delete (@target[propertyName])\n\n      @currentProperty = null\n      @buildAndConnectChildren()\n      @target.changed()\n      @target.setLayoutBeforeUpdatingBackingStore()\n      @target.updateBackingStore()\n      @target.changed()\n    catch err\n      @inform err';

  return InspectorMorph;

})(BoxMorph);

RectangleMorph = (function(_super) {
  __extends(RectangleMorph, _super);

  namedClasses[RectangleMorph.name] = RectangleMorph.prototype;

  function RectangleMorph(extent, color) {
    RectangleMorph.__super__.constructor.call(this);
    if (extent != null) {
      this.silentSetExtent(extent);
    }
    if (color != null) {
      this.color = color;
    }
  }

  RectangleMorph.coffeeScriptSourceOfThisClass = '# RectangleMorph /////////////////////////////////////////////////////////\n# a plain rectangular Morph. Because it\'s so basic, it\'s the building\n# block of many more complex constructions, for example containers\n# , clipping windows, and clipping windows which allow content to be\n# scrolled (clipping is particularly easy to do along a rectangular\n# path and it allows many optimisations and it\'s a very common case)\n# It\'s important that the basic unadulterated version of\n# rectangle doesn\'t draw a border, to keep this basic\n# and versatile, so for example there is no case where the children\n# are painted over the border, which would look bad.\n\n\nclass RectangleMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  constructor: (extent, color) ->\n    super()\n    @silentSetExtent(extent) if extent?\n    @color = color if color?  ';

  return RectangleMorph;

})(Morph);

LayoutAdjustingMorph = (function(_super) {
  __extends(LayoutAdjustingMorph, _super);

  namedClasses[LayoutAdjustingMorph.name] = LayoutAdjustingMorph.prototype;

  LayoutAdjustingMorph.prototype.hand = null;

  LayoutAdjustingMorph.prototype.indicator = null;

  function LayoutAdjustingMorph() {}

  LayoutAdjustingMorph.includeInNewMorphMenu = function() {
    return false;
  };


  /*
  adoptWidgetsColor: (paneColor) ->
    super adoptWidgetsColor paneColor
    @color = paneColord
  
  cursor: ->
    if @owner.direction == "#horizontal"
      Cursor.resizeLeft()
    else
      Cursor.resizeTop()
   */

  LayoutAdjustingMorph.coffeeScriptSourceOfThisClass = '# LayoutAdjustingMorph\n\n# this comment below is needed to figure our dependencies between classes\n\n# This is a port of the\n# respective Cuis Smalltalk classes (version 4.2-1766)\n# Cuis is by Juan Vuletich\n\n\nclass LayoutAdjustingMorph extends RectangleMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  hand: null\n  indicator: null\n\n  constructor: ->\n\n  @includeInNewMorphMenu: ->\n    # Return true for all classes that can be instantiated from the menu\n    return false\n\n  ###\n  adoptWidgetsColor: (paneColor) ->\n    super adoptWidgetsColor paneColor\n    @color = paneColord\n\n  cursor: ->\n    if @owner.direction == "#horizontal"\n      Cursor.resizeLeft()\n    else\n      Cursor.resizeTop()\n  ###';

  return LayoutAdjustingMorph;

})(RectangleMorph);

Point = (function() {
  namedClasses[Point.name] = Point.prototype;

  Point.augmentWith(DeepCopierMixin);

  Point.prototype.x = null;

  Point.prototype.y = null;

  function Point(x, y) {
    this.x = x != null ? x : 0;
    this.y = y != null ? y : 0;
  }

  Point.prototype.onlyContainingIntegers = function() {
    if (Math.floor(this.x) === this.x && Math.floor(this.y) === this.y) {
      return true;
    } else {
      return false;
    }
  };

  Point.prototype.debugIfFloats = function() {
    if (!this.onlyContainingIntegers()) {
      debugger;
    }
  };

  Point.prototype.toString = function() {
    return Math.round(this.x) + "@" + Math.round(this.y);
  };

  Point.prototype.prepareBeforeSerialization = function() {
    var property, _results;
    this.className = this.constructor.name;
    this.classVersion = "0.0.1";
    this.serializerVersion = "0.0.1";
    _results = [];
    for (property in this) {
      if (this[property] != null) {
        if (typeof this[property] === 'object') {
          if (this[property].className == null) {
            if (this[property].prepareBeforeSerialization != null) {
              _results.push(this[property].prepareBeforeSerialization());
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Point.prototype.copy = function() {
    return new this.constructor(this.x, this.y);
  };

  Point.prototype.eq = function(aPoint) {
    return this.x === aPoint.x && this.y === aPoint.y;
  };

  Point.prototype.lt = function(aPoint) {
    return this.x < aPoint.x && this.y < aPoint.y;
  };

  Point.prototype.gt = function(aPoint) {
    return this.x > aPoint.x && this.y > aPoint.y;
  };

  Point.prototype.ge = function(aPoint) {
    return this.x >= aPoint.x && this.y >= aPoint.y;
  };

  Point.prototype.le = function(aPoint) {
    return this.x <= aPoint.x && this.y <= aPoint.y;
  };

  Point.prototype.max = function(aPoint) {
    this.debugIfFloats();
    return new this.constructor(Math.max(this.x, aPoint.x), Math.max(this.y, aPoint.y));
  };

  Point.prototype.min = function(aPoint) {
    this.debugIfFloats();
    return new this.constructor(Math.min(this.x, aPoint.x), Math.min(this.y, aPoint.y));
  };

  Point.prototype.round = function() {
    return new this.constructor(Math.round(this.x), Math.round(this.y));
  };

  Point.prototype.abs = function() {
    this.debugIfFloats();
    return new this.constructor(Math.abs(this.x), Math.abs(this.y));
  };

  Point.prototype.neg = function() {
    this.debugIfFloats();
    return new this.constructor(-this.x, -this.y);
  };

  Point.prototype.mirror = function() {
    this.debugIfFloats();
    return new this.constructor(this.y, this.x);
  };

  Point.prototype.floor = function() {
    return new this.constructor(Math.max(Math.floor(this.x), 0), Math.max(Math.floor(this.y), 0));
  };

  Point.prototype.ceil = function() {
    return new this.constructor(Math.ceil(this.x), Math.ceil(this.y));
  };

  Point.prototype.add = function(other) {
    this.debugIfFloats();
    if (other instanceof Point) {
      return new this.constructor(this.x + other.x, this.y + other.y);
    }
    return new this.constructor(this.x + other, this.y + other);
  };

  Point.prototype.subtract = function(other) {
    this.debugIfFloats();
    if (other instanceof Point) {
      return new this.constructor(this.x - other.x, this.y - other.y);
    }
    return new this.constructor(this.x - other, this.y - other);
  };

  Point.prototype.multiplyBy = function(other) {
    this.debugIfFloats();
    if (other instanceof Point) {
      return new this.constructor(this.x * other.x, this.y * other.y);
    }
    return new this.constructor(this.x * other, this.y * other);
  };

  Point.prototype.divideBy = function(other) {
    this.debugIfFloats();
    if (other instanceof Point) {
      return new this.constructor(this.x / other.x, this.y / other.y);
    }
    return new this.constructor(this.x / other, this.y / other);
  };

  Point.prototype.floorDivideBy = function(other) {
    this.debugIfFloats();
    if (other instanceof Point) {
      return new this.constructor(Math.floor(this.x / other.x), Math.floor(this.y / other.y));
    }
    return new this.constructor(Math.floor(this.x / other), Math.floor(this.y / other));
  };

  Point.prototype.r = function() {
    var t;
    t = this.multiplyBy(this);
    return Math.sqrt(t.x + t.y);
  };

  Point.prototype.degrees = function() {
    var tan, theta;
    if (this.x === 0) {
      if (this.y >= 0) {
        return 90;
      }
      return 270;
    }
    tan = this.y / this.x;
    theta = Math.atan(tan);
    if (this.x >= 0) {
      if (this.y >= 0) {
        return radiansToDegrees(theta);
      }
      return 360 + (radiansToDegrees(theta));
    }
    return 180 + radiansToDegrees(theta);
  };

  Point.prototype.theta = function() {
    var tan, theta;
    if (this.x === 0) {
      if (this.y >= 0) {
        return degreesToRadians(90);
      }
      return degreesToRadians(270);
    }
    tan = this.y / this.x;
    theta = Math.atan(tan);
    if (this.x >= 0) {
      if (this.y >= 0) {
        return theta;
      }
      return degreesToRadians(360) + theta;
    }
    return degreesToRadians(180) + theta;
  };

  Point.prototype.distanceTo = function(aPoint) {
    return (aPoint.subtract(this)).r();
  };

  Point.prototype.rotate = function(direction, center) {
    var offset;
    offset = this.subtract(center);
    if (direction === "right") {
      return new this.constructor(-offset.y, offset.y).add(center);
    }
    if (direction === "left") {
      return new this.constructor(offset.y, -offset.y).add(center);
    }
    return center.subtract(offset);
  };

  Point.prototype.flip = function(direction, center) {
    if (direction === "vertical") {
      return new this.constructor(this.x, center.y * 2 - this.y);
    }
    return new this.constructor(center.x * 2 - this.x, this.y);
  };

  Point.prototype.distanceAngle = function(dist, angle) {
    var deg, x, y;
    deg = angle;
    if (deg > 270) {
      deg = deg - 360;
    } else {
      if (deg < -270) {
        deg = deg + 360;
      }
    }
    if (-90 <= deg && deg <= 90) {
      x = Math.sin(degreesToRadians(deg)) * dist;
      y = Math.sqrt((dist * dist) - (x * x));
      return new this.constructor(x + this.x, this.y - y);
    }
    x = Math.sin(degreesToRadians(180 - deg)) * dist;
    y = Math.sqrt((dist * dist) - (x * x));
    return new this.constructor(x + this.x, this.y + y);
  };

  Point.prototype.scaleBy = function(scalePoint) {
    return this.multiplyBy(scalePoint);
  };

  Point.prototype.translateBy = function(deltaPoint) {
    return this.add(deltaPoint);
  };

  Point.prototype.rotateBy = function(angle, centerPoint) {
    var center, p, r, theta;
    center = centerPoint || new this.constructor(0, 0);
    p = this.subtract(center);
    r = p.r();
    theta = angle - p.theta();
    return new this.constructor(center.x + (r * Math.cos(theta)), center.y - (r * Math.sin(theta)));
  };

  Point.prototype.asArray = function() {
    return [this.x, this.y];
  };

  Point.prototype.corner = function(cornerPoint) {
    return new Rectangle(this.x, this.y, cornerPoint.x, cornerPoint.y);
  };

  Point.prototype.rectangle = function(aPoint) {
    var crn, org;
    org = this.min(aPoint);
    crn = this.max(aPoint);
    return new Rectangle(org.x, org.y, crn.x, crn.y);
  };

  Point.prototype.extent = function(aPoint) {
    var crn;
    crn = this.add(aPoint);
    return new Rectangle(this.x, this.y, crn.x, crn.y);
  };

  Point.coffeeScriptSourceOfThisClass = '# Points //////////////////////////////////////////////////////////////\n\n# REQUIRES DeepCopierMixin\n\nclass Point\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith DeepCopierMixin\n\n  x: null\n  y: null\n   \n  constructor: (@x = 0, @y = 0) ->\n\n  onlyContainingIntegers: ->\n    if Math.floor(@x) == @x and\n      Math.floor(@y) == @y\n        return true\n    else\n      return false\n\n  debugIfFloats: ->\n    if !@onlyContainingIntegers()\n      debugger\n  \n  # Point string representation: e.g. \'12@68\'\n  toString: ->\n    Math.round(@x) + "@" + Math.round(@y)\n\n  prepareBeforeSerialization: ->\n    @className = @constructor.name\n    @classVersion = "0.0.1"\n    @serializerVersion = "0.0.1"\n    for property of @\n      if @[property]?\n        if typeof @[property] == \'object\'\n          if !@[property].className?\n            if @[property].prepareBeforeSerialization?\n              @[property].prepareBeforeSerialization()\n  \n  # Point copying:\n  copy: ->\n    new @constructor(@x, @y)\n  \n  # Point comparison:\n  eq: (aPoint) ->\n    # ==\n    @x is aPoint.x and @y is aPoint.y\n  \n  lt: (aPoint) ->\n    # <\n    @x < aPoint.x and @y < aPoint.y\n  \n  gt: (aPoint) ->\n    # >\n    @x > aPoint.x and @y > aPoint.y\n  \n  ge: (aPoint) ->\n    # >=\n    @x >= aPoint.x and @y >= aPoint.y\n  \n  le: (aPoint) ->\n    # <=\n    @x <= aPoint.x and @y <= aPoint.y\n  \n  max: (aPoint) ->\n    @debugIfFloats()\n    new @constructor(Math.max(@x, aPoint.x), Math.max(@y, aPoint.y))\n  \n  min: (aPoint) ->\n    @debugIfFloats()\n    new @constructor(Math.min(@x, aPoint.x), Math.min(@y, aPoint.y))\n  \n  \n  # Point conversion:\n  round: ->\n    new @constructor(Math.round(@x), Math.round(@y))\n  \n  abs: ->\n    @debugIfFloats()\n    new @constructor(Math.abs(@x), Math.abs(@y))\n  \n  neg: ->\n    @debugIfFloats()\n    new @constructor(-@x, -@y)\n  \n  mirror: ->\n    @debugIfFloats()\n    new @constructor(@y, @x)\n  \n  floor: ->\n    new @constructor(Math.max(Math.floor(@x), 0), Math.max(Math.floor(@y), 0))\n  \n  ceil: ->\n    new @constructor(Math.ceil(@x), Math.ceil(@y))\n  \n  \n  # Point arithmetic:\n  add: (other) ->\n    @debugIfFloats()\n    return new @constructor(@x + other.x, @y + other.y)  if other instanceof Point\n    new @constructor(@x + other, @y + other)\n  \n  subtract: (other) ->\n    @debugIfFloats()\n    return new @constructor(@x - other.x, @y - other.y)  if other instanceof Point\n    new @constructor(@x - other, @y - other)\n  \n  multiplyBy: (other) ->\n    @debugIfFloats()\n    return new @constructor(@x * other.x, @y * other.y)  if other instanceof Point\n    new @constructor(@x * other, @y * other)\n  \n  divideBy: (other) ->\n    @debugIfFloats()\n    return new @constructor(@x / other.x, @y / other.y)  if other instanceof Point\n    new @constructor(@x / other, @y / other)\n  \n  floorDivideBy: (other) ->\n    @debugIfFloats()\n    if other instanceof Point\n      return new @constructor(Math.floor(@x / other.x), Math.floor(@y / other.y))\n    new @constructor(Math.floor(@x / other), Math.floor(@y / other))\n  \n  \n  # Point polar coordinates:\n  r: ->\n    t = (@multiplyBy(@))\n    Math.sqrt t.x + t.y\n  \n  degrees: ->\n    #\n    #    answer the angle I make with origin in degrees.\n    #    Right is 0, down is 90\n    #\n    if @x is 0\n      return 90  if @y >= 0\n      return 270\n    tan = @y / @x\n    theta = Math.atan(tan)\n    if @x >= 0\n      return radiansToDegrees(theta)  if @y >= 0\n      return 360 + (radiansToDegrees(theta))\n    180 + radiansToDegrees(theta)\n  \n  theta: ->\n    #\n    #    answer the angle I make with origin in radians.\n    #    Right is 0, down is 90\n    #\n    if @x is 0\n      return degreesToRadians(90)  if @y >= 0\n      return degreesToRadians(270)\n    tan = @y / @x\n    theta = Math.atan(tan)\n    if @x >= 0\n      return theta  if @y >= 0\n      return degreesToRadians(360) + theta\n    degreesToRadians(180) + theta\n  \n  \n  # Point functions:\n  distanceTo: (aPoint) ->\n    (aPoint.subtract(@)).r()\n  \n  rotate: (direction, center) ->\n    # direction must be \'right\', \'left\' or \'pi\'\n    offset = @subtract(center)\n    return new @constructor(-offset.y, offset.y).add(center)  if direction is "right"\n    return new @constructor(offset.y, -offset.y).add(center)  if direction is "left"\n\n    # direction === \'pi\'\n    center.subtract offset\n  \n  flip: (direction, center) ->\n    # direction must be \'vertical\' or \'horizontal\'\n    return new @constructor(@x, center.y * 2 - @y)  if direction is "vertical"\n\n    # direction === \'horizontal\'\n    new @constructor(center.x * 2 - @x, @y)\n  \n  distanceAngle: (dist, angle) ->\n    deg = angle\n    if deg > 270\n      deg = deg - 360\n    else deg = deg + 360  if deg < -270\n    if -90 <= deg and deg <= 90\n      x = Math.sin(degreesToRadians(deg)) * dist\n      y = Math.sqrt((dist * dist) - (x * x))\n      return new @constructor(x + @x, @y - y)\n    x = Math.sin(degreesToRadians(180 - deg)) * dist\n    y = Math.sqrt((dist * dist) - (x * x))\n    new @constructor(x + @x, @y + y)\n  \n  \n  # Point transforming:\n  scaleBy: (scalePoint) ->\n    @multiplyBy scalePoint\n  \n  translateBy: (deltaPoint) ->\n    @add deltaPoint\n  \n  rotateBy: (angle, centerPoint) ->\n    center = centerPoint or new @constructor(0, 0)\n    p = @subtract(center)\n    r = p.r()\n    theta = angle - p.theta()\n    new @constructor(center.x + (r * Math.cos(theta)), center.y - (r * Math.sin(theta)))\n  \n  \n  # Point conversion:\n  asArray: ->\n    [@x, @y]\n  \n  # creating Rectangle instances from Points:\n  corner: (cornerPoint) ->\n    # answer a new Rectangle\n    new Rectangle(@x, @y, cornerPoint.x, cornerPoint.y)\n  \n  rectangle: (aPoint) ->\n    # answer a new Rectangle\n    org = @min(aPoint)\n    crn = @max(aPoint)\n    new Rectangle(org.x, org.y, crn.x, crn.y)\n  \n  extent: (aPoint) ->\n    #answer a new Rectangle\n    crn = @add(aPoint)\n    new Rectangle(@x, @y, crn.x, crn.y)';

  return Point;

})();

Rectangle = (function() {
  namedClasses[Rectangle.name] = Rectangle.prototype;

  Rectangle.augmentWith(DeepCopierMixin);

  Rectangle.prototype.origin = null;

  Rectangle.prototype.corner = null;

  function Rectangle(left, top, right, bottom) {
    this.origin = new Point(left || 0, top || 0);
    this.corner = new Point(right || 0, bottom || 0);
  }

  Rectangle.prototype.toString = function() {
    return "[" + this.origin + " | " + this.extent() + "]";
  };

  Rectangle.prototype.onlyContainingIntegers = function() {
    if (Math.floor(this.origin.x) === this.origin.x && Math.floor(this.origin.y) === this.origin.y && Math.floor(this.corner.x) === this.corner.x && Math.floor(this.corner.y) === this.corner.y) {
      return true;
    } else {
      return false;
    }
  };

  Rectangle.prototype.debugIfFloats = function() {
    if (!this.onlyContainingIntegers()) {
      debugger;
    }
  };

  Rectangle.prototype.prepareBeforeSerialization = function() {
    var property, _results;
    this.debugIfFloats();
    this.className = this.constructor.name;
    this.classVersion = "0.0.1";
    this.serializerVersion = "0.0.1";
    _results = [];
    for (property in this) {
      if (this[property] != null) {
        if (typeof this[property] === 'object') {
          if (this[property].className == null) {
            if (this[property].prepareBeforeSerialization != null) {
              _results.push(this[property].prepareBeforeSerialization());
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Rectangle.prototype.copy = function() {
    this.debugIfFloats();
    return new this.constructor(this.left(), this.top(), this.right(), this.bottom());
  };

  Rectangle.prototype.setTo = function(left, top, right, bottom) {
    this.debugIfFloats();
    this.origin = new Point(left || (left === 0 ? 0 : this.left()), top || (top === 0 ? 0 : this.top()));
    return this.corner = new Point(right || (right === 0 ? 0 : this.right()), bottom || (bottom === 0 ? 0 : this.bottom()));
  };

  Rectangle.prototype.area = function() {
    var w;
    this.debugIfFloats();
    w = this.width();
    if (w < 0) {
      return 0;
    }
    return Math.max(w * this.height(), 0);
  };

  Rectangle.prototype.bottom = function() {
    this.debugIfFloats();
    return this.corner.y;
  };

  Rectangle.prototype.bottomCenter = function() {
    this.debugIfFloats();
    return new Point(this.center().x, this.bottom());
  };

  Rectangle.prototype.bottomLeft = function() {
    this.debugIfFloats();
    return new Point(this.origin.x, this.corner.y);
  };

  Rectangle.prototype.bottomRight = function() {
    this.debugIfFloats();
    return this.corner.copy();
  };

  Rectangle.prototype.boundingBox = function() {
    this.debugIfFloats();
    return this;
  };

  Rectangle.prototype.center = function() {
    this.debugIfFloats();
    return this.origin.add(this.corner.subtract(this.origin).floorDivideBy(2));
  };

  Rectangle.prototype.corners = function() {
    this.debugIfFloats();
    return [this.origin, this.bottomLeft(), this.corner, this.topRight()];
  };

  Rectangle.prototype.extent = function() {
    this.debugIfFloats();
    return this.corner.subtract(this.origin);
  };

  Rectangle.prototype.isEmpty = function() {
    var theExtent;
    this.debugIfFloats();
    theExtent = this.corner.subtract(this.origin);
    return theExtent.x = 0 || (theExtent.y = 0);
  };

  Rectangle.prototype.isNotEmpty = function() {
    var theExtent;
    this.debugIfFloats();
    theExtent = this.corner.subtract(this.origin);
    return theExtent.x > 0 && theExtent.y > 0;
  };

  Rectangle.prototype.height = function() {
    this.debugIfFloats();
    return this.corner.y - this.origin.y;
  };

  Rectangle.prototype.left = function() {
    this.debugIfFloats();
    return this.origin.x;
  };

  Rectangle.prototype.leftCenter = function() {
    this.debugIfFloats();
    return new Point(this.left(), this.center().y);
  };

  Rectangle.prototype.right = function() {
    this.debugIfFloats();
    return this.corner.x;
  };

  Rectangle.prototype.rightCenter = function() {
    this.debugIfFloats();
    return new Point(this.right(), this.center().y);
  };

  Rectangle.prototype.top = function() {
    this.debugIfFloats();
    return this.origin.y;
  };

  Rectangle.prototype.topCenter = function() {
    this.debugIfFloats();
    return new Point(this.center().x, this.top());
  };

  Rectangle.prototype.topLeft = function() {
    this.debugIfFloats();
    return this.origin;
  };

  Rectangle.prototype.topRight = function() {
    this.debugIfFloats();
    return new Point(this.corner.x, this.origin.y);
  };

  Rectangle.prototype.width = function() {
    this.debugIfFloats();
    return this.corner.x - this.origin.x;
  };

  Rectangle.prototype.position = function() {
    this.debugIfFloats();
    return this.origin;
  };

  Rectangle.prototype.eq = function(aRect) {
    this.debugIfFloats();
    return this.origin.eq(aRect.origin) && this.corner.eq(aRect.corner);
  };

  Rectangle.prototype.abs = function() {
    var newCorner, newOrigin;
    this.debugIfFloats();
    newOrigin = this.origin.abs();
    newCorner = this.corner.max(newOrigin);
    return newOrigin.corner(newCorner);
  };

  Rectangle.prototype.insetBy = function(delta) {
    var result;
    this.debugIfFloats();
    result = new this.constructor();
    result.origin = this.origin.add(delta);
    result.corner = this.corner.subtract(delta);
    result.debugIfFloats();
    return result;
  };

  Rectangle.prototype.expandBy = function(delta) {
    var result;
    this.debugIfFloats();
    result = new this.constructor();
    result.origin = this.origin.subtract(delta);
    result.corner = this.corner.add(delta);
    result.debugIfFloats();
    return result;
  };

  Rectangle.prototype.growBy = function(delta) {
    var result;
    this.debugIfFloats();
    result = new this.constructor();
    result.origin = this.origin.copy();
    result.corner = this.corner.add(delta);
    result.debugIfFloats();
    return result;
  };

  Rectangle.prototype.intersect = function(aRect) {
    var result;
    this.debugIfFloats();
    result = new this.constructor();
    result.origin = this.origin.max(aRect.origin);
    result.corner = this.corner.min(aRect.corner);
    result.debugIfFloats();
    return result;
  };

  Rectangle.prototype.merge = function(aRect) {
    var result;
    this.debugIfFloats();
    result = new this.constructor();
    result.origin = this.origin.min(aRect.origin);
    result.corner = this.corner.max(aRect.corner);
    result.debugIfFloats();
    return result;
  };

  Rectangle.prototype.round = function() {
    this.debugIfFloats();
    return this.origin.round().corner(this.corner.round());
  };

  Rectangle.prototype.spread = function() {
    this.debugIfFloats();
    return this.origin.floor().corner(this.corner.ceil());
  };

  Rectangle.prototype.amountToTranslateWithin = function(aRect) {
    var dx, dy;
    this.debugIfFloats();
    if (this.right() > aRect.right()) {
      dx = aRect.right() - this.right();
    }
    if (this.bottom() > aRect.bottom()) {
      dy = aRect.bottom() - this.bottom();
    }
    if ((this.left() + dx) < aRect.left()) {
      dx = aRect.left() - this.left();
    }
    if ((this.top() + dy) < aRect.top()) {
      dy = aRect.top() - this.top();
    }
    return new Point(dx, dy);
  };

  Rectangle.prototype.containsPoint = function(aPoint) {
    this.debugIfFloats();
    return this.origin.le(aPoint) && aPoint.lt(this.corner);
  };

  Rectangle.prototype.containsRectangle = function(aRect) {
    this.debugIfFloats();
    return aRect.origin.gt(this.origin) && aRect.corner.lt(this.corner);
  };

  Rectangle.prototype.intersects = function(aRect) {
    var rc, ro;
    this.debugIfFloats();
    ro = aRect.origin;
    rc = aRect.corner;
    return (rc.x >= this.origin.x) && (rc.y >= this.origin.y) && (ro.x <= this.corner.x) && (ro.y <= this.corner.y);
  };

  Rectangle.prototype.scaleBy = function(scale) {
    var c, o;
    this.debugIfFloats();
    o = this.origin.multiplyBy(scale);
    c = this.corner.multiplyBy(scale);
    return new this.constructor(o.x, o.y, c.x, c.y);
  };

  Rectangle.prototype.translateBy = function(factor) {
    var c, o;
    this.debugIfFloats();
    o = this.origin.add(factor);
    c = this.corner.add(factor);
    return new this.constructor(o.x, o.y, c.x, c.y);
  };

  Rectangle.prototype.asArray = function() {
    this.debugIfFloats();
    return [this.left(), this.top(), this.right(), this.bottom()];
  };

  Rectangle.prototype.asArray_xywh = function() {
    this.debugIfFloats();
    return [this.left(), this.top(), this.width(), this.height()];
  };

  Rectangle.coffeeScriptSourceOfThisClass = '# Rectangles //////////////////////////////////////////////////////////\n\n# REQUIRES DeepCopierMixin\n\nclass Rectangle\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith DeepCopierMixin\n\n  origin: null\n  corner: null\n  \n  constructor: (left, top, right, bottom) ->\n    \n    @origin = new Point((left or 0), (top or 0))\n    @corner = new Point((right or 0), (bottom or 0))\n  \n  \n  # Rectangle string representation: e.g. \'[0@0 | 160@80]\'\n  toString: ->\n    "[" + @origin + " | " + @extent() + "]"\n\n  onlyContainingIntegers: ->\n    if Math.floor(@origin.x) == @origin.x and\n      Math.floor(@origin.y) == @origin.y and\n      Math.floor(@corner.x) == @corner.x and\n      Math.floor(@corner.y) == @corner.y\n        return true\n    else\n      return false\n\n  debugIfFloats: ->\n    if !@onlyContainingIntegers()\n      debugger\n\n  prepareBeforeSerialization: ->\n    @debugIfFloats()\n    @className = @constructor.name\n    @classVersion = "0.0.1"\n    @serializerVersion = "0.0.1"\n    for property of @\n      if @[property]?\n        if typeof @[property] == \'object\'\n          if !@[property].className?\n            if @[property].prepareBeforeSerialization?\n              @[property].prepareBeforeSerialization()\n  \n  # Rectangle copying:\n  copy: ->\n    @debugIfFloats()\n    new @constructor(@left(), @top(), @right(), @bottom())\n  \n  # Rectangle accessing - setting:\n  setTo: (left, top, right, bottom) ->\n    @debugIfFloats()\n    # note: all inputs are optional and can be omitted\n    @origin = new Point(\n      left or ((if (left is 0) then 0 else @left())),\n      top or ((if (top is 0) then 0 else @top())))\n    @corner = new Point(\n      right or ((if (right is 0) then 0 else @right())),\n      bottom or ((if (bottom is 0) then 0 else @bottom())))\n  \n  # Rectangle accessing - getting:\n  area: ->\n    @debugIfFloats()\n    #requires width() and height() to be defined\n    w = @width()\n    return 0  if w < 0\n    Math.max w * @height(), 0\n  \n  bottom: ->\n    @debugIfFloats()\n    @corner.y\n  \n  bottomCenter: ->\n    @debugIfFloats()\n    new Point(@center().x, @bottom())\n  \n  bottomLeft: ->\n    @debugIfFloats()\n    new Point(@origin.x, @corner.y)\n  \n  bottomRight: ->\n    @debugIfFloats()\n    @corner.copy()\n  \n  boundingBox: ->\n    @debugIfFloats()\n    @\n  \n  center: ->\n    @debugIfFloats()\n    @origin.add @corner.subtract(@origin).floorDivideBy(2)\n  \n  corners: ->\n    @debugIfFloats()\n    [@origin, @bottomLeft(), @corner, @topRight()]\n  \n  extent: ->\n    @debugIfFloats()\n    @corner.subtract @origin\n  \n  isEmpty: ->\n    @debugIfFloats()\n    # The subtract method creates a new Point\n    theExtent = @corner.subtract @origin\n    theExtent.x = 0 or theExtent.y = 0\n\n  isNotEmpty: ->\n    @debugIfFloats()\n    # The subtract method creates a new Point\n    theExtent = @corner.subtract @origin\n    theExtent.x > 0 and theExtent.y > 0\n  \n  height: ->\n    @debugIfFloats()\n    @corner.y - @origin.y\n  \n  left: ->\n    @debugIfFloats()\n    @origin.x\n  \n  leftCenter: ->\n    @debugIfFloats()\n    new Point(@left(), @center().y)\n  \n  right: ->\n    @debugIfFloats()\n    @corner.x\n  \n  rightCenter: ->\n    @debugIfFloats()\n    new Point(@right(), @center().y)\n  \n  top: ->\n    @debugIfFloats()\n    @origin.y\n  \n  topCenter: ->\n    @debugIfFloats()\n    new Point(@center().x, @top())\n  \n  topLeft: ->\n    @debugIfFloats()\n    @origin\n  \n  topRight: ->\n    @debugIfFloats()\n    new Point(@corner.x, @origin.y)\n  \n  width: ->\n    @debugIfFloats()\n    @corner.x - @origin.x\n  \n  position: ->\n    @debugIfFloats()\n    @origin\n  \n  # Rectangle comparison:\n  eq: (aRect) ->\n    @debugIfFloats()\n    @origin.eq(aRect.origin) and @corner.eq(aRect.corner)\n  \n  abs: ->\n    @debugIfFloats()\n    newOrigin = @origin.abs()\n    newCorner = @corner.max(newOrigin)\n    newOrigin.corner newCorner\n  \n  # Rectangle functions:\n  insetBy: (delta) ->\n    @debugIfFloats()\n    # delta can be either a Point or a Number\n    result = new @constructor()\n    result.origin = @origin.add(delta)\n    result.corner = @corner.subtract(delta)\n    result.debugIfFloats()\n    result\n  \n  expandBy: (delta) ->\n    @debugIfFloats()\n    # delta can be either a Point or a Number\n    result = new @constructor()\n    result.origin = @origin.subtract(delta)\n    result.corner = @corner.add(delta)\n    result.debugIfFloats()\n    result\n  \n  growBy: (delta) ->\n    @debugIfFloats()\n    # delta can be either a Point or a Number\n    result = new @constructor()\n    result.origin = @origin.copy()\n    result.corner = @corner.add(delta)\n    result.debugIfFloats()\n    result\n  \n  intersect: (aRect) ->\n    @debugIfFloats()\n    result = new @constructor()\n    result.origin = @origin.max(aRect.origin)\n    result.corner = @corner.min(aRect.corner)\n    result.debugIfFloats()\n    result\n  \n  merge: (aRect) ->\n    @debugIfFloats()\n    result = new @constructor()\n    result.origin = @origin.min(aRect.origin)\n    result.corner = @corner.max(aRect.corner)\n    result.debugIfFloats()\n    result\n  \n  round: ->\n    @debugIfFloats()\n    @origin.round().corner @corner.round()\n  \n  spread: ->\n    @debugIfFloats()\n    # round me by applying floor() to my origin and ceil() to my corner\n    @origin.floor().corner @corner.ceil()\n  \n  amountToTranslateWithin: (aRect) ->\n    @debugIfFloats()\n    #\n    #    Answer a Point, delta, such that self + delta is forced within\n    #    aRectangle. when all of me cannot be made to fit, prefer to keep\n    #    my topLeft inside. Taken from Squeak.\n    #\n    dx = aRect.right() - @right()  if @right() > aRect.right()\n    dy = aRect.bottom() - @bottom()  if @bottom() > aRect.bottom()\n    dx = aRect.left() - @left()  if (@left() + dx) < aRect.left()\n    dy = aRect.top() - @top()  if (@top() + dy) < aRect.top()\n    new Point(dx, dy)\n  \n  \n  # Rectangle testing:\n  containsPoint: (aPoint) ->\n    @debugIfFloats()\n    @origin.le(aPoint) and aPoint.lt(@corner)\n  \n  containsRectangle: (aRect) ->\n    @debugIfFloats()\n    aRect.origin.gt(@origin) and aRect.corner.lt(@corner)\n  \n  intersects: (aRect) ->\n    @debugIfFloats()\n    ro = aRect.origin\n    rc = aRect.corner\n    (rc.x >= @origin.x) and\n      (rc.y >= @origin.y) and\n      (ro.x <= @corner.x) and\n      (ro.y <= @corner.y)\n  \n  \n  # Rectangle transforming:\n  scaleBy: (scale) ->\n    @debugIfFloats()\n    # scale can be either a Point or a scalar\n    o = @origin.multiplyBy(scale)\n    c = @corner.multiplyBy(scale)\n    new @constructor(o.x, o.y, c.x, c.y)\n  \n  translateBy: (factor) ->\n    @debugIfFloats()\n    # factor can be either a Point or a scalar\n    o = @origin.add(factor)\n    c = @corner.add(factor)\n    new @constructor(o.x, o.y, c.x, c.y)\n  \n  \n  # Rectangle converting:\n  asArray: ->\n    @debugIfFloats()\n    [@left(), @top(), @right(), @bottom()]\n  \n  asArray_xywh: ->\n    @debugIfFloats()\n    [@left(), @top(), @width(), @height()]';

  return Rectangle;

})();

LayoutMorph = (function(_super) {
  __extends(LayoutMorph, _super);

  namedClasses[LayoutMorph.name] = LayoutMorph.prototype;

  LayoutMorph.prototype.instanceVariableNames = 'direction separation padding';

  LayoutMorph.prototype.classVariableNames = '';

  LayoutMorph.prototype.poolDictionaries = '';

  LayoutMorph.prototype.category = 'Morphic-Layouts';

  LayoutMorph.prototype.direction = "";

  LayoutMorph.prototype.padding = 0;

  LayoutMorph.prototype.separation = null;

  LayoutMorph.prototype.layoutNeeded = false;

  function LayoutMorph() {
    LayoutMorph.__super__.constructor.call(this);
    this.separation = new Point(0, 0);
  }

  LayoutMorph.newColumn = function() {
    var newLayoutMorph;
    newLayoutMorph = new this();
    newLayoutMorph.beColumn();
    return newLayoutMorph;
  };

  LayoutMorph.newRow = function() {
    var newLayoutMorph;
    newLayoutMorph = new this();
    newLayoutMorph.beRow();
    return newLayoutMorph;
  };

  LayoutMorph.prototype.beColumn = function() {
    this.direction = "#vertical";
    return this.setPadding("#center");
  };

  LayoutMorph.prototype.beRow = function() {
    this.direction = "#horizontal";
    return this.setPadding = "#left";
  };

  LayoutMorph.prototype.defaultColor = function() {
    return Color.transparent();
  };

  LayoutMorph.prototype.setPadding = function(howMuchPadding) {
    switch (howMuchPadding) {
      case "#top":
        return this.padding = 0.0;
      case "#left":
        return this.padding = 0.0;
      case "#center":
        return this.padding = 0.5;
      case "#right":
        return this.padding = 1.0;
      case "#bottom":
        return this.padding = 1.0;
      default:
        return this.padding = howMuchPadding;
    }
  };

  LayoutMorph.prototype.setSeparation = function(howMuchSeparation) {
    return this.separation = howMuchSeparation;
  };

  LayoutMorph.prototype.xSeparation = function() {
    return this.separation.x;
  };

  LayoutMorph.prototype.ySeparation = function() {
    return this.separation.y;
  };

  LayoutMorph.prototype.layoutSubmorphs = function() {
    console.log("layoutSubmorphs in LayoutMorph");
    if (this.children.length === 0) {
      this.layoutNeeded = false;
      return this;
    }
    if (this.direction === "#horizontal") {
      this.layoutSubmorphsHorizontallyIn(this.bounds);
    }
    if (this.direction === "#vertical") {
      this.layoutSubmorphsVerticallyIn(this.bounds);
    }
    return this.layoutNeeded = false;
  };

  LayoutMorph.prototype.layoutSubmorphsHorizontallyIn = function(boundsForLayout) {
    var availableForPropWidth, boundsRight, boundsTop, h, i, l, ls, m, normalizationFactor, sumOfFixed, sumOfWidths, t, usableHeight, usableWidth, w, widths, xSep, ySep, _i, _ref, _results;
    xSep = this.xSeparation();
    ySep = this.ySeparation();
    usableWidth = boundsForLayout.width() - ((this.children.length + 1) * xSep);
    sumOfFixed = 0;
    this.children.forEach((function(_this) {
      return function(child) {
        if (child.layoutSpec != null) {
          if (child.layoutSpec.fixedWidth != null) {
            return sumOfFixed += child.layoutSpec.getFixedWidth();
          }
        }
      };
    })(this));
    availableForPropWidth = usableWidth - sumOfFixed;
    normalizationFactor = this.proportionalWidthNormalizationFactor();
    availableForPropWidth = availableForPropWidth * normalizationFactor;
    widths = [];
    sumOfWidths = 0;
    this.children.forEach((function(_this) {
      return function(child) {
        var theWidth;
        if (child.layoutSpec != null) {
          theWidth = child.layoutSpec.widthFor(availableForPropWidth);
          sumOfWidths += theWidth;
          return widths.push(theWidth);
        }
      };
    })(this));
    l = ((usableWidth - sumOfWidths) * this.padding + Math.max(xSep, 0)) + boundsForLayout.left();
    usableHeight = boundsForLayout.height() - Math.max(2 * ySep, 0);
    boundsTop = boundsForLayout.top();
    boundsRight = boundsForLayout.right();
    _results = [];
    for (i = _i = _ref = this.children.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
      m = this.children[i];
      w = widths[i];
      ls = m.layoutSpec;
      if (ls == null) {
        continue;
      }
      h = Math.min(usableHeight, ls.heightFor(usableHeight));
      t = (usableHeight - h) * ls.minorDirectionPadding + ySep + boundsTop;
      m.setPosition(new Point(l, t));
      m.setExtent(new Point(Math.min(w, boundsForLayout.width()), h));
      if (w > 0) {
        _results.push(l = Math.min(l + w + xSep, boundsRight));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  LayoutMorph.prototype.layoutSubmorphsVerticallyIn = function(boundsForLayout) {
    var availableForPropHeight, boundsBottom, boundsLeft, h, heights, i, l, ls, m, normalizationFactor, sumOfFixed, sumOfHeights, t, usableHeight, usableWidth, w, xSep, ySep, _i, _ref, _results;
    xSep = this.xSeparation();
    ySep = this.ySeparation();
    usableHeight = boundsForLayout.height() - ((this.children.length + 1) * ySep);
    sumOfFixed = 0;
    this.children.forEach((function(_this) {
      return function(child) {
        if (child.layoutSpec != null) {
          if (child.layoutSpec.fixedWidth != null) {
            return sumOfFixed += child.layoutSpec.fixedHeight;
          }
        }
      };
    })(this));
    availableForPropHeight = usableHeight - sumOfFixed;
    normalizationFactor = this.proportionalHeightNormalizationFactor;
    availableForPropHeight = availableForPropHeight * normalizationFactor;
    heights = [];
    sumOfHeights = 0;
    this.children.forEach((function(_this) {
      return function(child) {
        var theHeight;
        if (child.layoutSpec != null) {
          theHeight = child.layoutSpec.heightFor(availableForPropHeight);
          sumOfHeights += theHeight;
          return heights.push(theHeight);
        }
      };
    })(this));
    t = ((usableHeight - sumOfHeights) * this.padding + Math.max(ySep, 0)) + boundsForLayout.top();
    usableWidth = boundsForLayout.width() - Math.max(2 * xSep, 0);
    boundsBottom = boundsForLayout.bottom();
    boundsLeft = boundsForLayout.left();
    _results = [];
    for (i = _i = _ref = this.children.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
      m = this.children[i];
      h = heights[i];
      ls = m.layoutSpec;
      w = Math.min(usableWidth, ls.widthFor(usableWidth));
      l = (usableWidth - w) * ls.minorDirectionPadding() + xSep + boundsLeft;
      m.setPosition(new Point(l, t));
      m.setExtent(Math.min(w, boundsForLayout.height()), h);
      if (h > 0) {
        _results.push(t = Math.min(t + h + ySep, boundsBottom));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  LayoutMorph.prototype.addAdjusterMorph = function() {
    var thickness;
    thickness = 4;
    if (this.direction === "#horizontal") {
      this.addMorph(new LayoutAdjustingMorph());
      this.layoutSpec = LayoutSpec.fixedWidth(thickness);
    }
    if (this.direction === "#vertical") {
      this.addMorph(new LayoutAdjustingMorph());
      return this.layoutSpec = LayoutSpec.fixedHeight(thickness);
    }
  };

  LayoutMorph.prototype.addMorphWithLayoutSpec = function(aMorph, aLayoutSpec) {
    aMorph.layoutSpec = aLayoutSpec;
    return this.addMorph(aMorph);
  };

  LayoutMorph.prototype.minPaneHeightForReframe = function() {
    return 20;
  };

  LayoutMorph.prototype.minPaneWidthForReframe = function() {
    return 40;
  };

  LayoutMorph.prototype.proportionalHeightNormalizationFactor = function() {
    var sumOfProportional;
    sumOfProportional = 0;
    this.children.forEach((function(_this) {
      return function(child) {
        if (child.layoutSpec != null) {
          return sumOfProportional += child.layoutSpec.proportionalHeight();
        }
      };
    })(this));
    return 1.0 / Math.max(sumOfProportional, 1.0);
  };

  LayoutMorph.prototype.proportionalWidthNormalizationFactor = function() {
    var sumOfProportional;
    sumOfProportional = 0;
    this.children.forEach((function(_this) {
      return function(child) {
        if (child.layoutSpec != null) {
          return sumOfProportional += child.layoutSpec.getProportionalWidth();
        }
      };
    })(this));
    return 1.0 / Math.max(sumOfProportional, 1.0);
  };

  LayoutMorph.prototype.adjustByAt = function(aLayoutAdjustMorph, aPoint) {
    if (this.direction === "#horizontal") {
      this.adjustHorizontallyByAt(aLayoutAdjustMorph, aPoint);
    }
    if (this.direction === "#vertical") {
      return this.adjustVerticallyByAt(aLayoutAdjustMorph, aPoint);
    }
  };

  LayoutMorph.prototype.adjustHorizontallyByAt = function(aLayoutAdjustMorph, aPoint) {
    var delta, doNotResizeBelow, i, l, lCurrentWidth, lNewWidth, ls, r, rCurrentWidth, rNewWidth, rs;
    doNotResizeBelow = this.minPaneWidthForReframe;
    i = this.children[aLayoutAdjustMorph];
    l = this.children[i + 1];
    ls = l.layoutSpec;
    lCurrentWidth = Math.max(l.morphWidth(), 1);
    r = this.children[i - 1];
    rs = r.layoutSpec;
    rCurrentWidth = Math.max(r.morphWidth(), 1);
    delta = aPoint.x - aLayoutAdjustMorph.position().x;
    delta = Math.max(delta, doNotResizeBelow - lCurrentWidth);
    delta = Math.min(delta, rCurrentWidth - doNotResizeBelow);
    if (delta === 0) {
      return this;
    }
    rNewWidth = rCurrentWidth - delta;
    lNewWidth = lCurrentWidth + delta;
    if (ls.isProportionalWidth() && rs.isProportionalWidth()) {
      ls.setProportionalWidth(1.0 * lNewWidth / lCurrentWidth * ls.proportionalWidth());
      rs.setProportionalWidth(1.0 * rNewWidth / rCurrentWidth * rs.proportionalWidth());
    } else {
      if (!ls.isProportionalWidth()) {
        ls.fixedOrMorphWidth(lNewWidth);
      }
      if (!rs.isProportionalWidth()) {
        rs.fixedOrMorphWidth(rNewWidth);
      }
    }
    return this.layoutSubmorphs();
  };

  LayoutMorph.prototype.adjustVerticallyByAt = function(aLayoutAdjustMorph, aPoint) {
    var b, bCurrentHeight, bNewHeight, bs, delta, doNotResizeBelow, i, t, tCurrentHeight, tNewHeight, ts;
    doNotResizeBelow = this.minPaneHeightForReframe();
    i = this.children[aLayoutAdjustMorph];
    t = this.children[i + 1];
    ts = t.layoutSpec();
    tCurrentHeight = Math.max(t.morphHeight(), 1);
    b = this.children[i - 1];
    bs = b.layoutSpec;
    bCurrentHeight = Math.max(b.morphHeight(), 1);
    delta = aPoint.y - aLayoutAdjustMorph.position().y;
    delta = Math.max(delta, doNotResizeBelow - tCurrentHeight);
    delta = Math.min(delta, bCurrentHeight - doNotResizeBelow);
    if (delta === 0) {
      return this;
    }
    tNewHeight = tCurrentHeight + delta;
    bNewHeight = bCurrentHeight - delta;
    if (ts.isProportionalHeight() && bs.isProportionalHeight()) {
      ts.setProportionalHeight(1.0 * tNewHeight / tCurrentHeight * ts.proportionalHeight());
      bs.setProportionalHeight(1.0 * bNewHeight / bCurrentHeight * bs.proportionalHeight());
    } else {
      if (!ts.isProportionalHeight()) {
        ts.fixedOrMorphHeight(tNewHeight);
      }
      if (!bs.isProportionalHeight()) {
        bs.fixedOrMorphHeight(bNewHeight);
      }
    }
    return this.layoutSubmorphs();
  };

  LayoutMorph.prototype.addAdjusterAndMorphFixedHeight = function(aMorph, aNumber) {
    return this.addAdjusterAndMorphLayoutSpec(aMorph, LayoutSpec.newWithFixedHeight(aNumber));
  };

  LayoutMorph.prototype.addAdjusterAndMorphLayoutSpec = function(aMorph, aLayoutSpec) {
    this.addAdjusterMorph();
    return this.addMorphLayoutSpec(aMorph, aLayoutSpec);
  };

  LayoutMorph.prototype.addAdjusterAndMorphProportionalHeight = function(aMorph, aNumber) {
    return this.addAdjusterAndMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalHeight(aNumber));
  };

  LayoutMorph.prototype.addAdjusterAndMorphProportionalWidth = function(aMorph, aNumber) {
    return this.addAdjusterAndMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalWidth(aNumber));
  };

  LayoutMorph.prototype.addMorphFixedHeight = function(aMorph, aNumber) {
    return this.addMorphLayoutSpec(aMorph, LayoutSpec.newWithFixedHeight(aNumber));
  };

  LayoutMorph.prototype.addMorphFixedWidth = function(aMorph, aNumber) {
    return this.addMorphLayoutSpec(aMorph, LayoutSpec.newWithFixedWidth(aNumber));
  };

  LayoutMorph.prototype.addMorphLayoutSpec = function(aMorph, aLayoutSpec) {
    aMorph.layoutSpec = aLayoutSpec;
    return this.add(aMorph);
  };

  LayoutMorph.prototype.addMorphProportionalHeight = function(aMorph, aNumber) {
    return this.addMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalHeight(aNumber));
  };

  LayoutMorph.prototype.addMorphProportionalWidth = function(aMorph, aNumber) {
    return this.addMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalWidth(aNumber));
  };

  LayoutMorph.prototype.addMorphUseAll = function(aMorph) {
    return this.addMorphLayoutSpec(aMorph, LayoutSpec.useAll());
  };

  LayoutMorph.prototype.addMorphs = function(morphs) {
    return morphs.forEach((function(_this) {
      return function(morph) {
        return _this.addMorphProportionalWidth(morph, 1);
      };
    })(this));
  };

  LayoutMorph.prototype.addMorphsWidthProportionalTo = function(morphs, widths) {
    return morphs.forEach((function(_this) {
      return function(morph) {
        return _this.addMorphProportionalWidth(morph, widths);
      };
    })(this));
  };

  LayoutMorph.prototype.is = function(aSymbol) {
    return aSymbol === "#LayoutMorph";
  };

  LayoutMorph.test1 = function() {
    var handle, rect1, rect2, row;
    rect1 = new RectangleMorph(new Point(20, 20), new Color(255, 0, 0));
    rect2 = new RectangleMorph(new Point(20, 20), new Color(0, 255, 0));
    row = LayoutMorph.newRow();
    row.addMorphProportionalWidth(rect1, 2);
    row.addMorphProportionalWidth(rect2, 1);
    row.layoutSubmorphs();
    row.setPosition(world.hand.position());
    row.keepWithin(world);
    world.add(row);
    row.changed();
    handle = new HandleMorph();
    handle.isfloatDraggable = false;
    handle.target = row;
    handle.updateBackingStore();
    return handle.noticesTransparentClick = true;
  };

  LayoutMorph.test2 = function() {
    var handle, rect3, rect4, row2;
    rect3 = new RectangleMorph(new Point(20, 20), new Color(255, 0, 0));
    rect4 = new RectangleMorph(new Point(20, 20), new Color(0, 255, 0));
    row2 = LayoutMorph.newRow();
    row2.addMorphFixedWidth(rect3, 10);
    row2.addMorphProportionalWidth(rect4, 1);
    row2.layoutSubmorphs();
    row2.setPosition(world.hand.position());
    row2.keepWithin(world);
    world.add(row2);
    row2.changed();
    handle = new HandleMorph();
    handle.isfloatDraggable = false;
    handle.target = row2;
    handle.updateBackingStore();
    return handle.noticesTransparentClick = true;
  };

  LayoutMorph.test3 = function() {
    var handle, rect5, rect6, rect7, row3;
    rect5 = new RectangleMorph(new Point(20, 20), new Color(255, 0, 0));
    rect6 = new RectangleMorph(new Point(20, 20), new Color(0, 255, 0));
    rect7 = new RectangleMorph(new Point(20, 20), new Color(0, 0, 255));
    row3 = LayoutMorph.newRow();
    row3.addMorphProportionalWidth(rect6, 2);
    row3.addMorphFixedWidth(rect5, 10);
    row3.addMorphProportionalWidth(rect7, 1);
    row3.layoutSubmorphs();
    row3.setPosition(world.hand.position());
    row3.keepWithin(world);
    world.add(row3);
    row3.changed();
    handle = new HandleMorph();
    handle.isfloatDraggable = false;
    handle.target = row3;
    handle.updateBackingStore();
    return handle.noticesTransparentClick = true;
  };

  LayoutMorph.test4 = function() {
    var handle, rect5, rect6, rect7, row3;
    rect5 = new RectangleMorph(new Point(20, 20), new Color(255, 0, 0));
    rect6 = new RectangleMorph(new Point(20, 20), new Color(0, 255, 0));
    rect7 = new RectangleMorph(new Point(20, 20), new Color(0, 0, 255));
    row3 = LayoutMorph.newRow();
    row3.addMorphProportionalHeight(rect6, 0.5);
    row3.addMorphFixedHeight(rect5, 200);
    row3.addMorphProportionalHeight(rect7, 1.1);
    row3.layoutSubmorphs();
    row3.setPosition(world.hand.position());
    row3.keepWithin(world);
    world.add(row3);
    row3.changed();
    handle = new HandleMorph();
    handle.isfloatDraggable = false;
    handle.target = row3;
    handle.updateBackingStore();
    return handle.noticesTransparentClick = true;
  };

  LayoutMorph.coffeeScriptSourceOfThisClass = '# LayoutMorph\n\n# this comment below is needed to figure our dependencies between classes\n# REQUIRES Color\n# REQUIRES Point\n# REQUIRES Rectangle\n\n# This is a port of the\n# respective Cuis Smalltalk classes (version 4.2-1766)\n# Cuis is by Juan Vuletich\n\n# A row or column of widgets, does layout by placing\n# them either horizontally or vertically.\n\n# Submorphs might specify a LayoutSpec.\n# If some don\'t, then, for a column, the column\n# width is taken as the width, and any morph height\n# is kept. Same for rows: submorph width would be\n# maintained, and submorph height would be made\n# equal to row height.\n\nclass LayoutMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  instanceVariableNames: \'direction separation padding\'\n  classVariableNames: \'\'\n  poolDictionaries: \'\'\n  category: \'Morphic-Layouts\'\n\n  direction: ""\n  padding: 0\n  separation: null # contains a Point\n  layoutNeeded: false\n\n  constructor: ->\n    super()\n    @separation = new Point 0,0\n  \n  @newColumn: ->\n    newLayoutMorph =  new @()\n    newLayoutMorph.beColumn()\n    return newLayoutMorph\n\n  @newRow: ->\n    #debugger\n    newLayoutMorph =  new @()\n    newLayoutMorph.beRow()\n    return newLayoutMorph\n\n  beColumn: ->\n    @direction = "#vertical"\n    @setPadding "#center"\n\n  beRow: ->\n    @direction = "#horizontal"\n    @setPadding= "#left"\n\n  defaultColor: ->\n    return Color.transparent()\n\n  # This sets how extra space is used when doing layout.\n  # For example, a column might have extra , un-needed\n  # vertical space. #top means widgets are set close\n  # to the top, and extra space is at bottom. Conversely,\n  # #bottom means widgets are set close to the bottom,\n  # and extra space is at top. Valid values include\n  # #left and #right (for rows) and #center. Alternatively,\n  # any number between 0.0 and 1.0 might be used.\n  #   self new padding: #center\n  #   self new padding: 0.9\n  setPadding: (howMuchPadding) ->\n    switch howMuchPadding\n      when "#top" then @padding = 0.0\n      when "#left" then @padding = 0.0\n      when "#center" then @padding = 0.5\n      when "#right" then @padding = 1.0\n      when "#bottom" then @padding = 1.0\n      else @padding = howMuchPadding\n\n  setSeparation: (howMuchSeparation) ->\n    @separation = howMuchSeparation\n\n  xSeparation: ->\n    return @separation.x\n\n  ySeparation: ->\n    return @separation.y\n\n  # Compute a new layout based on the given layout bounds\n  layoutSubmorphs: ->\n    console.log "layoutSubmorphs in LayoutMorph"\n    #debugger\n    if @children.length == 0\n      @layoutNeeded = false\n      return @\n\n    if @direction == "#horizontal"\n      @layoutSubmorphsHorizontallyIn @bounds\n\n    if @direction == "#vertical"\n      @layoutSubmorphsVerticallyIn @bounds\n\n    @layoutNeeded = false\n\n  # Compute a new layout based on the given layout bounds.\n  layoutSubmorphsHorizontallyIn: (boundsForLayout) ->\n    #| xSep ySep usableWidth sumOfFixed normalizationFactor availableForPropWidth widths l usableHeight boundsTop boundsRight t |\n    xSep = @xSeparation()\n    ySep = @ySeparation()\n    usableWidth = boundsForLayout.width() - ((@children.length + 1) * xSep)\n    sumOfFixed = 0\n    @children.forEach (child) =>\n      if child.layoutSpec?\n        if child.layoutSpec.fixedWidth?\n          sumOfFixed += child.layoutSpec.getFixedWidth()\n    availableForPropWidth = usableWidth - sumOfFixed\n    normalizationFactor = @proportionalWidthNormalizationFactor()\n    availableForPropWidth = availableForPropWidth * normalizationFactor\n    widths = []\n    sumOfWidths = 0\n    @children.forEach (child) =>\n      if child.layoutSpec?\n        #debugger\n        theWidth = child.layoutSpec.widthFor availableForPropWidth\n        sumOfWidths += theWidth\n        widths.push theWidth\n    l = ((usableWidth - sumOfWidths) * @padding + Math.max(xSep, 0)) +  boundsForLayout.left()\n    usableHeight = boundsForLayout.height() - Math.max(2*ySep,0)\n    boundsTop = boundsForLayout.top()\n    boundsRight = boundsForLayout.right()\n    for i in [@children.length-1 .. 0]\n      m = @children[i]\n      # major direction\n      w = widths[i]\n      # minor direction\n      ls = m.layoutSpec\n      if not ls?\n        # there might be submorphs that don\'t have a layout.\n        # for example, currently, the HandleMorph can be attached\n        # to the LayoutMorph without a layoutSpec.\n        # just skip those. The HandleMorph does its own\n        # layouting.\n        continue\n      h = Math.min(usableHeight, ls.heightFor(usableHeight))\n      t = (usableHeight - h) * ls.minorDirectionPadding + ySep + boundsTop\n      # Set bounds and adjust major direction for next step\n      # self flag: #jmvVer2.\n      # should extent be set in m\'s coordinate system? what if its scale is not 1?\n      m.setPosition(new Point(l,t))\n      #debugger\n      m.setExtent(new Point(Math.min(w,boundsForLayout.width()),h))\n      if w>0\n        l = Math.min(l + w + xSep, boundsRight)\n\n  # this is the symmetric of the previous method\n  layoutSubmorphsVerticallyIn: (boundsForLayout) ->\n    # usableHeight boundsTop boundsRight t |\n    xSep = @xSeparation()\n    ySep = @ySeparation()\n    usableHeight = boundsForLayout.height() - ((@children.length + 1) * ySep)\n    sumOfFixed = 0\n    @children.forEach (child) =>\n      if child.layoutSpec?\n        if child.layoutSpec.fixedWidth?\n          sumOfFixed += child.layoutSpec.fixedHeight\n    availableForPropHeight = usableHeight - sumOfFixed\n    normalizationFactor = @proportionalHeightNormalizationFactor\n    availableForPropHeight = availableForPropHeight * normalizationFactor\n    heights = []\n    sumOfHeights = 0\n    @children.forEach (child) =>\n      if child.layoutSpec?\n        theHeight = child.layoutSpec.heightFor availableForPropHeight\n        sumOfHeights += theHeight\n        heights.push theHeight\n    t = ((usableHeight - sumOfHeights) * @padding + Math.max(ySep, 0)) +  boundsForLayout.top()\n    usableWidth = boundsForLayout.width() - Math.max(2*xSep,0)\n    boundsBottom = boundsForLayout.bottom()\n    boundsLeft = boundsForLayout.left()\n    for i in [@children.length-1 .. 0]\n      m = @children[i]\n      # major direction\n      h = heights[i]\n      # minor direction\n      ls = m.layoutSpec\n      w = Math.min(usableWidth, ls.widthFor(usableWidth))\n      l = (usableWidth - w) * ls.minorDirectionPadding() + xSep + boundsLeft\n      # Set bounds and adjust major direction for next step\n      # self flag: #jmvVer2.\n      # should extent be set in m\'s coordinate system? what if its scale is not 1?\n      m.setPosition(new Point(l,t))\n      m.setExtent(Math.min(w,boundsForLayout.height()),h)\n      if h>0\n        t = Math.min(t + h + ySep, boundsBottom)\n\n  # So the user can adjust layout\n  addAdjusterMorph: ->\n    thickness = 4\n\n    if @direction == "#horizontal"\n      @addMorph( new LayoutAdjustingMorph() )\n      @layoutSpec = LayoutSpec.fixedWidth(thickness)\n\n    if @direction == "#vertical"\n      @addMorph( new LayoutAdjustingMorph() )\n      @layoutSpec = LayoutSpec.fixedHeight(thickness)\n\n  #"Add a submorph, at the bottom or right, with aLayoutSpec"\n  addMorphWithLayoutSpec: (aMorph, aLayoutSpec) ->\n    aMorph.layoutSpec = aLayoutSpec\n    @addMorph aMorph\n\n  minPaneHeightForReframe: ->\n    return 20\n\n  minPaneWidthForReframe: ->\n    return 40\n\n  proportionalHeightNormalizationFactor: ->\n    sumOfProportional = 0\n    @children.forEach (child) =>\n      if child.layoutSpec?\n        sumOfProportional += child.layoutSpec.proportionalHeight()\n    return 1.0/Math.max(sumOfProportional, 1.0)\n\n  proportionalWidthNormalizationFactor: ->\n    sumOfProportional = 0\n    @children.forEach (child) =>\n      if child.layoutSpec?\n        sumOfProportional += child.layoutSpec.getProportionalWidth()\n    return 1.0/Math.max(sumOfProportional, 1.0)\n\n  adjustByAt: (aLayoutAdjustMorph, aPoint) ->\n    if @direction == "#horizontal"\n      @adjustHorizontallyByAt aLayoutAdjustMorph, aPoint\n\n    if @direction == "#vertical"\n      @adjustVerticallyByAt aLayoutAdjustMorph, aPoint\n\n  adjustHorizontallyByAt: (aLayoutAdjustMorph, aPoint) ->\n    # | delta l ls r rs lNewWidth rNewWidth i lCurrentWidth rCurrentWidth doNotResizeBelow |\n    doNotResizeBelow =  @minPaneWidthForReframe\n    i = @children[aLayoutAdjustMorph]\n    l = @children[i+1]\n    ls = l.layoutSpec\n    lCurrentWidth = Math.max(l.morphWidth(),1) # avoid division by zero\n    r = @children[i - 1]\n    rs = r.layoutSpec\n    rCurrentWidth = Math.max(r.morphWidth(),1) # avoid division by zero\n    delta = aPoint.x - aLayoutAdjustMorph.position().x\n    delta = Math.max(delta, doNotResizeBelow - lCurrentWidth)\n    delta = Math.min(delta, rCurrentWidth - doNotResizeBelow)\n    if delta == 0 then return @\n    rNewWidth = rCurrentWidth - delta\n    lNewWidth = lCurrentWidth + delta\n    if ls.isProportionalWidth() and rs.isProportionalWidth()\n      # If both proportional, update them\n      ls.setProportionalWidth 1.0 * lNewWidth / lCurrentWidth * ls.proportionalWidth()\n      rs.setProportionalWidth 1.0 * rNewWidth / rCurrentWidth * rs.proportionalWidth()\n    else\n      # If at least one is fixed, update only the fixed\n      if !ls.isProportionalWidth()\n          ls.fixedOrMorphWidth lNewWidth\n      if !rs.isProportionalWidth()\n          rs.fixedOrMorphWidth rNewWidth\n    @layoutSubmorphs()\n\n  adjustVerticallyByAt: (aLayoutAdjustMorph, aPoint) ->\n    # | delta t ts b bs tNewHeight bNewHeight i tCurrentHeight bCurrentHeight doNotResizeBelow |\n    doNotResizeBelow = @minPaneHeightForReframe()\n    i = @children[aLayoutAdjustMorph]\n    t = @children[i+1]\n    ts = t.layoutSpec()\n    tCurrentHeight = Math.max(t.morphHeight(),1) # avoid division by zero\n    b = @children[i - 1]\n    bs = b.layoutSpec\n    bCurrentHeight = Math.max(b.morphHeight(),1) # avoid division by zero\n    delta = aPoint.y - aLayoutAdjustMorph.position().y\n    delta = Math.max(delta, doNotResizeBelow - tCurrentHeight)\n    delta = Math.min(delta, bCurrentHeight - doNotResizeBelow)\n    if delta == 0 then return @\n    tNewHeight = tCurrentHeight + delta\n    bNewHeight = bCurrentHeight - delta\n    if ts.isProportionalHeight() and bs.isProportionalHeight()\n      # If both proportional, update them\n      ts.setProportionalHeight 1.0 * tNewHeight / tCurrentHeight * ts.proportionalHeight()\n      bs.setProportionalHeight 1.0 * bNewHeight / bCurrentHeight * bs.proportionalHeight()\n    else\n      # If at least one is fixed, update only the fixed\n      if !ts.isProportionalHeight()\n          ts.fixedOrMorphHeight tNewHeight\n      if !bs.isProportionalHeight()\n          bs.fixedOrMorphHeight bNewHeight\n    @layoutSubmorphs()\n\n  #####################\n  # convenience methods\n  #####################\n\n  addAdjusterAndMorphFixedHeight: (aMorph,aNumber) ->\n    @addAdjusterAndMorphLayoutSpec(aMorph, LayoutSpec.newWithFixedHeight aNumber)\n\n  addAdjusterAndMorphLayoutSpec: (aMorph, aLayoutSpec) ->\n    #Add a submorph, at the bottom or right, with aLayoutSpec"\n    @addAdjusterMorph()\n    @addMorphLayoutSpec(aMorph, aLayoutSpec)\n\n  addAdjusterAndMorphProportionalHeight: (aMorph, aNumber) ->\n    @addAdjusterAndMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalHeight(aNumber))\n\n  addAdjusterAndMorphProportionalWidth: (aMorph, aNumber) ->\n    @addAdjusterAndMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalWidth(aNumber))\n\n  addMorphFixedHeight: (aMorph, aNumber) ->\n    @addMorphLayoutSpec(aMorph, LayoutSpec.newWithFixedHeight(aNumber))\n\n  addMorphFixedWidth: (aMorph, aNumber) ->\n    @addMorphLayoutSpec(aMorph, LayoutSpec.newWithFixedWidth(aNumber))\n\n  addMorphLayoutSpec: (aMorph, aLayoutSpec) ->\n    # Add a submorph, at the bottom or right, with aLayoutSpec\n    aMorph.layoutSpec = aLayoutSpec\n    @add aMorph\n\n  addMorphProportionalHeight: (aMorph, aNumber) ->\n    @addMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalHeight(aNumber))\n\n  addMorphProportionalWidth: (aMorph, aNumber) ->\n    @addMorphLayoutSpec(aMorph, LayoutSpec.newWithProportionalWidth(aNumber))\n\n  addMorphUseAll: (aMorph) ->\n    @addMorphLayoutSpec(aMorph, LayoutSpec.useAll())\n\n  addMorphs: (morphs) ->\n    morphs.forEach (morph) =>\n      @addMorphProportionalWidth(morph,1)\n\n  addMorphsWidthProportionalTo: (morphs, widths) ->\n    morphs.forEach (morph) =>\n      @addMorphProportionalWidth(morph, widths)\n\n  # unclear how to translate this one for the time being\n  is: (aSymbol) ->\n    return aSymbol == "#LayoutMorph" # or [ super is: aSymbol ]\n\n  @test1: ->\n    rect1 = new RectangleMorph(new Point(20,20), new Color(255,0,0));\n    rect2 = new RectangleMorph(new Point(20,20), new Color(0,255,0));\n    row = LayoutMorph.newRow()\n    row.addMorphProportionalWidth(rect1,2)\n    row.addMorphProportionalWidth(rect2,1)\n    row.layoutSubmorphs()\n    row.setPosition(world.hand.position());\n    row.keepWithin(world);\n    world.add(row);\n    row.changed();\n\n    # attach a HandleMorph to it so that\n    # we can check how it resizes\n    handle = new HandleMorph()\n    handle.isfloatDraggable = false\n    handle.target = row\n    handle.updateBackingStore()\n    handle.noticesTransparentClick = true\n\n  @test2: ->\n    rect3 = new RectangleMorph(new Point(20,20), new Color(255,0,0));\n    rect4 = new RectangleMorph(new Point(20,20), new Color(0,255,0));\n    row2 = LayoutMorph.newRow()\n    row2.addMorphFixedWidth(rect3,10)\n    row2.addMorphProportionalWidth(rect4,1)\n    row2.layoutSubmorphs()\n    row2.setPosition(world.hand.position());\n    row2.keepWithin(world);\n    world.add(row2);\n    row2.changed();\n\n    # attach a HandleMorph to it so that\n    # we can check how it resizes\n    handle = new HandleMorph()\n    handle.isfloatDraggable = false\n    handle.target = row2\n    handle.updateBackingStore()\n    handle.noticesTransparentClick = true\n\n  @test3: ->\n    rect5 = new RectangleMorph(new Point(20,20), new Color(255,0,0));\n    rect6 = new RectangleMorph(new Point(20,20), new Color(0,255,0));\n    rect7 = new RectangleMorph(new Point(20,20), new Color(0,0,255));\n    row3 = LayoutMorph.newRow()\n    row3.addMorphProportionalWidth(rect6,2)\n    row3.addMorphFixedWidth(rect5,10)\n    row3.addMorphProportionalWidth(rect7,1)\n    row3.layoutSubmorphs()\n    row3.setPosition(world.hand.position());\n    row3.keepWithin(world);\n    world.add(row3);\n    row3.changed();\n\n    # attach a HandleMorph to it so that\n    # we can check how it resizes\n    handle = new HandleMorph()\n    handle.isfloatDraggable = false\n    handle.target = row3\n    handle.updateBackingStore()\n    handle.noticesTransparentClick = true\n\n  @test4: ->\n    # //////////////////////////////////////////////////\n    # note how the vertical spacing in the horizontal layout\n    # is different. the vertical size is not adjusted considering\n    # all other morphs. A proportional of 1.1 is proportional to the\n    # container, not to the other layouts.\n    # Equivalent smalltalk code:\n    # | pane rect1 rect2 |\n    # pane _ LayoutMorph newRow separation: 5. "3"\n    # pane addMorph: (StringMorph contents: \'3\').\n    # \n    # rect1 := BorderedRectMorph new color: (Color lightOrange).\n    # pane addMorph: rect1 \n    #          layoutSpec: (LayoutSpec  fixedWidth: 20 proportionalHeight: 1.1 minorDirectionPadding: #center).\n    # rect2 := BorderedRectMorph new color: (Color cyan);\n    #   layoutSpec: (LayoutSpec  fixedWidth: 20 proportionalHeight: 0.5 minorDirectionPadding: #center).\n    # pane addMorph: rect2.\n    # pane\n    #   color: Color lightGreen;\n    #   openInWorld;\n    #   morphPosition: 520 @ 50;\n    #   morphExtent: 180 @ 100\n    # //////////////////////////////////////////////////\n\n    rect5 = new RectangleMorph(new Point(20,20), new Color(255,0,0));\n    rect6 = new RectangleMorph(new Point(20,20), new Color(0,255,0));\n    rect7 = new RectangleMorph(new Point(20,20), new Color(0,0,255));\n    row3 = LayoutMorph.newRow()\n    row3.addMorphProportionalHeight(rect6,0.5)\n    row3.addMorphFixedHeight(rect5,200)\n    row3.addMorphProportionalHeight(rect7,1.1)\n    row3.layoutSubmorphs()\n    row3.setPosition(world.hand.position());\n    row3.keepWithin(world);\n    world.add(row3);\n    row3.changed();\n\n    # attach a HandleMorph to it so that\n    # we can check how it resizes\n    handle = new HandleMorph()\n    handle.isfloatDraggable = false\n    handle.target = row3\n    handle.updateBackingStore()\n    handle.noticesTransparentClick = true #';

  return LayoutMorph;

})(Morph);

LayoutSpec = (function() {
  namedClasses[LayoutSpec.name] = LayoutSpec.prototype;

  LayoutSpec.prototype.morph = null;

  LayoutSpec.prototype.minorDirectionPadding = 0.5;

  LayoutSpec.prototype.fixedWidth = 0;

  LayoutSpec.prototype.fixedHeight = 0;

  LayoutSpec.prototype.proportionalWidth = 1.0;

  LayoutSpec.prototype.proportionalHeight = 1.0;

  function LayoutSpec() {}

  LayoutSpec.newWithFixedExtent = function(aPoint) {
    return this.newWithFixedWidthFixedHeight(aPoint.x, aPoint.y);
  };

  LayoutSpec.newWithFixedHeight = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setFixedHeight(aNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithFixedWidth = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setFixedWidth(aNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithFixedWidthFixedHeight = function(aNumber, otherNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setFixedWidth(aNumber);
    layoutSpec.setFixedHeight(otherNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithFixedWidthFixedHeightMinorDirectionPadding = function(aNumber, otherNumber, aSymbolOrNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setFixedWidth(aNumber);
    layoutSpec.setFixedHeight(otherNumber);
    layoutSpec.setMinorDirectionPadding(aSymbolOrNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithFixedWidthProportionalHeight = function(aNumber, otherNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setFixedWidth(aNumber);
    layoutSpec.setProportionalHeight(otherNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithFixedWidthProportionalHeightMinorDirectionPadding = function(aNumber, otherNumber, aSymbolOrNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setFixedWidth(aNumber);
    layoutSpec.setProportionalHeight(otherNumber);
    layoutSpec.setMinorDirectionPadding(aSymbolOrNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithKeepMorphExtent = function() {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.useMorphWidth;
    layoutSpec.useMorphHeight;
    return layoutSpec;
  };

  LayoutSpec.newWithMorphHeightFixedWidth = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setFixedWidth(aNumber);
    layoutSpec.useMorphHeight;
    return layoutSpec;
  };

  LayoutSpec.newWithMorphHeightProportionalWidth = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setProportionalWidth(aNumber);
    layoutSpec.useMorphHeight();
    return layoutSpec;
  };

  LayoutSpec.newWithMorphWidthFixedHeight = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.useMorphWidth();
    layoutSpec.setFixedHeight(aNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithMorphWidthProportionalHeight = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.useMorphWidth();
    layoutSpec.setProportionalHeight(aNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithProportionalHeight = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setProportionalHeight(aNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithProportionalWidth = function(aNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setProportionalWidth(aNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithProportionalWidthFixedHeight = function(aNumber, otherNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setProportionalWidth(aNumber);
    layoutSpec.setFixedHeight(otherNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithProportionalWidthFixedHeightMinorDirectionPadding = function(aNumber, otherNumber, aSymbolOrNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setProportionalWidth(aNumber);
    layoutSpec.setFixedHeight(otherNumber);
    layoutSpec.setMinorDirectionPadding(aSymbolOrNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithProportionalWidthProportionalHeight = function(aNumber, otherNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setProportionalWidth(aNumber);
    layoutSpec.setProportionalHeight(otherNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithProportionalWidthProportionalHeightMinorDirectionPadding = function(aNumber, otherNumber, aSymbolOrNumber) {
    var layoutSpec;
    layoutSpec = new this();
    layoutSpec.setProportionalWidth(aNumber);
    layoutSpec.setProportionalHeight(otherNumber);
    layoutSpec.setMinorDirectionPadding(aSymbolOrNumber);
    return layoutSpec;
  };

  LayoutSpec.newWithUseAll = function() {
    return new this();
  };

  LayoutSpec.prototype.setFixedHeight = function(aNumber) {
    this.fixedHeight = aNumber;
    return this.proportionalHeight = null;
  };

  LayoutSpec.prototype.setFixedOrMorphHeight = function(aNumber) {
    if (this.fixedHeight != null) {
      this.fixedHeight = aNumber;
    } else {
      this.morph.setHeight(aNumber);
    }
    return this.proportionalHeight = null;
  };

  LayoutSpec.prototype.setFixedOrMorphWidth = function(aNumber) {
    if (this.fixedWidth != null) {
      this.fixedWidth = aNumber;
    } else {
      this.morph.setWidth(aNumber);
    }
    return this.proportionalWidth = null;
  };

  LayoutSpec.prototype.setFixedWidth = function(aNumber) {
    this.fixedWidth = aNumber;
    return this.proportionalWidth = null;
  };

  LayoutSpec.prototype.setMinorDirectionPadding = function(howMuchPadding) {
    switch (howMuchPadding) {
      case "#top":
        return this.minorDirectionPadding = 0.0;
      case "#left":
        return this.minorDirectionPadding = 0.0;
      case "#center":
        return this.minorDirectionPadding = 0.5;
      case "#right":
        return this.minorDirectionPadding = 1.0;
      case "#bottom":
        return this.minorDirectionPadding = 1.0;
      default:
        return this.minorDirectionPadding = howMuchPadding;
    }
  };

  LayoutSpec.prototype.setProportionalHeight = function(aNumber) {
    return this.setProportionalHeightMinimum(aNumber, 0.0);
  };

  LayoutSpec.prototype.setProportionalHeightMinimum = function(aNumberOrNil, otherNumberOrNil) {
    this.proportionalHeight = aNumberOrNil;
    return this.fixedHeight = otherNumberOrNil;
  };

  LayoutSpec.prototype.setProportionalWidth = function(aNumber) {
    return this.setProportionalWidthMinimum(aNumber, 0);
  };

  LayoutSpec.prototype.setProportionalWidthMinimum = function(aNumberOrNil, otherNumberOrNil) {
    this.proportionalWidth = aNumberOrNil;
    return this.fixedWidth = otherNumberOrNil;
  };

  LayoutSpec.prototype.setProportionalHeight = function(aNumberOrNil) {
    return this.proportionalHeight = aNumberOrNil;
  };

  LayoutSpec.prototype.setProportionalWidth = function(aNumberOrNil) {
    return this.proportionalWidth = aNumberOrNil;
  };

  LayoutSpec.prototype.useMorphHeight = function() {
    this.fixedHeight = null;
    return this.proportionalHeight = null;
  };

  LayoutSpec.prototype.useMorphWidth = function() {
    this.fixedWidth = null;
    return this.proportionalWidth = null;
  };

  LayoutSpec.prototype.getFixedHeight = function() {
    if (this.proportionalHeight != null) {
      return 0;
    }
    if (this.fixedHeight == null) {
      return this.morph.height();
    }
  };

  LayoutSpec.prototype.getFixedWidth = function() {
    if (this.proportionalWidth != null) {
      return 0;
    }
    if (this.fixedWidth == null) {
      return this.morph.width();
    }
  };

  LayoutSpec.prototype.heightFor = function(availableSpace) {
    if (this.proportionalHeight != null) {
      return Math.max(this.fixedHeight, Math.round(this.proportionalHeight * availableSpace));
    }
    return this.getFixedHeight();
  };

  LayoutSpec.prototype.getFixedHeight = function() {
    if (this.fixedHeight == null) {
      return 0;
    } else {
      return this.fixedHeight;
    }
  };

  LayoutSpec.prototype.getFixedWidth = function() {
    if (this.fixedWidth == null) {
      return 0;
    } else {
      return this.fixedWidth;
    }
  };

  LayoutSpec.prototype.getProportionalHeight = function() {
    if (this.proportionalHeight == null) {
      return 0;
    } else {
      return this.proportionalHeight;
    }
  };

  LayoutSpec.prototype.getProportionalWidth = function() {
    if (this.proportionalWidth == null) {
      return 0;
    } else {
      return this.proportionalWidth;
    }
  };

  LayoutSpec.prototype.widthFor = function(availableSpace) {
    if (this.proportionalWidth != null) {
      return Math.max(this.fixedWidth, Math.round(this.proportionalWidth * availableSpace));
    }
    return this.getFixedWidth();
  };

  LayoutSpec.prototype.isProportionalHeight = function() {
    return this.proportionalHeight != null;
  };

  LayoutSpec.prototype.isProportionalWidth = function() {
    return this.proportionalWidth != null;
  };

  LayoutSpec.coffeeScriptSourceOfThisClass = '# LayoutSpec\n\n# this comment below is needed to figure our dependencies between classes\n\n# This is a port of the\n# respective Cuis Smalltalk classes (version 4.2-1766)\n# Cuis is by Juan Vuletich\n\n# LayoutSpecs are the basis for the layout mechanism.\n# Any Morph can be given a LayoutSpec, but in order to honor it,\n# its owner must be a LayoutMorph.\n\n# A LayoutSpec specifies how a morph wants to be laid out.\n# It can specify either a fixed width or a fraction of some\n# available owner width. Same goes for height. If a fraction\n# is specified, a minimum extent is also possible.\n\n\n# Alternatives:\n#  - proportionalWidth notNil, fixedWidth notNil ->    Use fraction of available space, take fixedWidth as minimum desired width\n#  - proportionalWidth isNil, fixedWidth isNil   ->    Use current morph width\n#  - proportionalWidth isNil, fixedWidth notNil    ->    Use fixedWidth\n#  - proportionalWidth notNil, fixedWidth isNil    ->    NOT VALID\n\n#Same goes for proportionalHeight and fixedHeight\n\nclass LayoutSpec\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  morph: null\n  minorDirectionPadding: 0.5\n  fixedWidth: 0\n  fixedHeight: 0\n  proportionalWidth: 1.0\n  proportionalHeight: 1.0\n\n\n  # Just some reasonable defaults, use all available space\n  constructor: ->\n\n  @newWithFixedExtent: (aPoint) ->\n    @newWithFixedWidthFixedHeight(aPoint.x, aPoint.y)\n\n  @newWithFixedHeight: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setFixedHeight aNumber\n   return layoutSpec\n\n  @newWithFixedWidth: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setFixedWidth aNumber\n   return layoutSpec\n\n  @newWithFixedWidthFixedHeight: (aNumber, otherNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setFixedWidth aNumber\n   layoutSpec.setFixedHeight otherNumber\n   return layoutSpec\n\n  @newWithFixedWidthFixedHeightMinorDirectionPadding: (aNumber, otherNumber, aSymbolOrNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setFixedWidth aNumber\n   layoutSpec.setFixedHeight otherNumber\n   layoutSpec.setMinorDirectionPadding aSymbolOrNumber\n   return layoutSpec\n\n  @newWithFixedWidthProportionalHeight: (aNumber, otherNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setFixedWidth aNumber\n   layoutSpec.setProportionalHeight otherNumber\n   return layoutSpec\n\n  @newWithFixedWidthProportionalHeightMinorDirectionPadding: (aNumber, otherNumber, aSymbolOrNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setFixedWidth aNumber\n   layoutSpec.setProportionalHeight otherNumber\n   layoutSpec.setMinorDirectionPadding aSymbolOrNumber\n   return layoutSpec\n\n  @newWithKeepMorphExtent: ->\n   layoutSpec = new @()\n   layoutSpec.useMorphWidth\n   layoutSpec.useMorphHeight\n   return layoutSpec\n\n  @newWithMorphHeightFixedWidth: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setFixedWidth aNumber\n   layoutSpec.useMorphHeight\n   return layoutSpec\n\n  @newWithMorphHeightProportionalWidth: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setProportionalWidth aNumber\n   layoutSpec.useMorphHeight()\n   return layoutSpec\n\n  @newWithMorphWidthFixedHeight: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.useMorphWidth()\n   layoutSpec.setFixedHeight aNumber\n   return layoutSpec\n\n  @newWithMorphWidthProportionalHeight: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.useMorphWidth()\n   layoutSpec.setProportionalHeight aNumber\n   return layoutSpec\n\n  # Will use all available width\n  @newWithProportionalHeight: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setProportionalHeight aNumber\n   return layoutSpec\n\n  # Will use all available height\n  @newWithProportionalWidth: (aNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setProportionalWidth aNumber\n   return layoutSpec\n\n  @newWithProportionalWidthFixedHeight: (aNumber, otherNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setProportionalWidth aNumber\n   layoutSpec.setFixedHeight otherNumber\n   return layoutSpec\n\n  @newWithProportionalWidthFixedHeightMinorDirectionPadding: (aNumber, otherNumber, aSymbolOrNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setProportionalWidth aNumber\n   layoutSpec.setFixedHeight otherNumber\n   layoutSpec.setMinorDirectionPadding aSymbolOrNumber\n   return layoutSpec\n\n  @newWithProportionalWidthProportionalHeight: (aNumber, otherNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setProportionalWidth aNumber\n   layoutSpec.setProportionalHeight otherNumber\n   return layoutSpec\n\n  @newWithProportionalWidthProportionalHeightMinorDirectionPadding: (aNumber, otherNumber, aSymbolOrNumber) ->\n   layoutSpec = new @()\n   layoutSpec.setProportionalWidth aNumber\n   layoutSpec.setProportionalHeight otherNumber\n   layoutSpec.setMinorDirectionPadding aSymbolOrNumber\n   return layoutSpec\n\n  # Use all available space\n  @newWithUseAll: ->\n   return new @()\n\n  setFixedHeight: (aNumber) ->\n   # aNumber is taken as the fixed height to use.\n   # No proportional part.\n   @fixedHeight = aNumber\n   @proportionalHeight = null\n\n  setFixedOrMorphHeight: (aNumber) ->\n    # aNumber is taken as the fixed height to use.\n    # No proportional part.\n    if @fixedHeight?\n      @fixedHeight = aNumber\n    else\n      @morph.setHeight aNumber\n    @proportionalHeight = null\n\n  setFixedOrMorphWidth: (aNumber) ->\n    # aNumber is taken as the fixed width to use.\n    # No proportional part.\n    if @fixedWidth?\n      @fixedWidth = aNumber\n    else\n      @morph.setWidth aNumber\n    @proportionalWidth = null\n\n  setFixedWidth: (aNumber) ->\n    # aNumber is taken as the fixed width to use.\n    # No proportional part.\n    @fixedWidth = aNumber\n    @proportionalWidth = null\n\n  setMinorDirectionPadding: (howMuchPadding) ->\n    # This sets how padding is done in the secondary direction.\n    # For instance, if the owning morph is set in a row,\n    # the row will control horizontal layout. But if there\n    # is unused vertical space, it will be used according to\n    # this parameter. For instance, #top sets the owning morph\n    # at the top. Same for #bottom and #center. If the owner is\n    # contained in a column, #left, #center or #right should be\n    # used. Alternatively, any number between 0.0 and 1.0 can be\n    # used.\n    #  self new minorDirectionPadding: #center\n    #  self new minorDirectionPadding: 0.9\n\n    switch howMuchPadding\n      when "#top" then @minorDirectionPadding = 0.0\n      when "#left" then @minorDirectionPadding = 0.0\n      when "#center" then @minorDirectionPadding = 0.5\n      when "#right" then @minorDirectionPadding = 1.0\n      when "#bottom" then @minorDirectionPadding = 1.0\n      else @minorDirectionPadding = howMuchPadding\n\n  setProportionalHeight: (aNumber) ->\n   @setProportionalHeightMinimum(aNumber, 0.0)\n\n  setProportionalHeightMinimum: (aNumberOrNil, otherNumberOrNil) ->\n    # Alternatives: same as in #proportionalWidth:minimum:\n    # see comment there\n    @proportionalHeight = aNumberOrNil\n    @fixedHeight = otherNumberOrNil\n\n  setProportionalWidth: (aNumber) ->\n    return @setProportionalWidthMinimum aNumber, 0\n\n  setProportionalWidthMinimum: (aNumberOrNil, otherNumberOrNil) ->\n    # Alternatives:\n    #  - proportionalWidth notNil, fixedWidth notNil ->    Use fraction of available space, take fixedWidth as minimum desired width\n    #  - proportionalWidth isNil, fixedWidth isNil   ->    Use current morph width\n    #  - proportionalWidth isNil, fixedWidth notNil  ->    Use fixedWidth\n    #  - proportionalWidth notNil, fixedWidth isNil  ->    NOT VALID\n    @proportionalWidth = aNumberOrNil\n    @fixedWidth = otherNumberOrNil\n\n  setProportionalHeight: (aNumberOrNil) ->\n   # Alternatives: same as in #proportionalWidth:minimum:, see comment there\n   @proportionalHeight = aNumberOrNil\n\n  setProportionalWidth: (aNumberOrNil) ->\n    # Alternatives:\n    #  - proportionalWidth notNil, fixedWidth notNil ->    Use fraction of available space, take fixedWidth as minimum desired width\n    #  - proportionalWidth isNil, fixedWidth isNil   ->    Use current morph width\n    #  - proportionalWidth isNil, fixedWidth notNil  ->    Use fixedWidth\n    #  - proportionalWidth notNil, fixedWidth isNil  ->    NOT VALID"\n    @proportionalWidth = aNumberOrNil\n\n  useMorphHeight: ->\n    # Do not attempt to layout height. Use current morph height if at all possible\n    @fixedHeight = null\n    @proportionalHeight = null\n\n  useMorphWidth: ->\n    # Do not attempt to layout width. Use current morph width if at all possible\n    @fixedWidth = null\n    @proportionalWidth = null\n\n  getFixedHeight: ->\n    # If proportional is zero, answer stored fixed extent,\n    # or actual morph extent if undefined. (no proportional extent is computed)\n    # Otherwise, we do proportional layout, and the stored extent is\n    # a minimum extent, so we don\'t  really a fixed extent.\n    if @proportionalHeight?\n      return 0\n    if not @fixedHeight?\n      return @morph.height()\n\n  getFixedWidth: ->\n    # If proportional is zero, answer stored fixed extent,\n    # or actual morph extent if undefined. (no proportional extent is computed)\n    # Otherwise, we do proportional layout, and the stored extent is\n    # a minimum extent, so we don\'t  really a fixed extent.\n    if @proportionalWidth?\n      return 0\n    if not @fixedWidth?\n      return @morph.width()\n\n  heightFor: (availableSpace) ->\n    # If proportional is zero, answer stored fixed extent,\n    # or actual morph extent if undefined.\n    # Otherwise, we do proportional layout, and the stored\n    # extent is a minimum extent.\n    # If there is no minimum extent, it should be set to zero.\n\n    if @proportionalHeight?\n      return Math.max( @fixedHeight, Math.round(@proportionalHeight * availableSpace) )\n    return @getFixedHeight()\n\n  getFixedHeight: ->\n    if not @fixedHeight?\n      return 0\n    else\n      @fixedHeight\n\n  getFixedWidth: ->\n    if not @fixedWidth?\n      return 0\n    else\n      @fixedWidth\n\n  getProportionalHeight: ->\n    if not @proportionalHeight?\n      return 0\n    else\n      @proportionalHeight\n\n  getProportionalWidth: ->\n    if not @proportionalWidth?\n      return 0\n    else\n      @proportionalWidth\n\n  widthFor: (availableSpace) ->\n    # If proportional is zero, answer stored fixed extent,\n    # or actual morph extent if undefined.\n    # Otherwise, we do proportional layout, and the\n    # stored extent is a minimum extent.\n    # If there is no minimum extent, it should be set to zero.\n    if @proportionalWidth?\n      return Math.max( @fixedWidth, Math.round(@proportionalWidth * availableSpace) )\n    return @getFixedWidth()\n\n  isProportionalHeight: ->\n    return @proportionalHeight?\n\n  isProportionalWidth: ->\n    return @proportionalWidth?  ';

  return LayoutSpec;

})();

ScrollFrameMorph = (function(_super) {
  __extends(ScrollFrameMorph, _super);

  namedClasses[ScrollFrameMorph.name] = ScrollFrameMorph.prototype;

  ScrollFrameMorph.prototype.autoScrollTrigger = null;

  ScrollFrameMorph.prototype.hasVelocity = true;

  ScrollFrameMorph.prototype.padding = 0;

  ScrollFrameMorph.prototype.growth = 0;

  ScrollFrameMorph.prototype.isTextLineWrapping = false;

  ScrollFrameMorph.prototype.isScrollingByfloatDragging = true;

  ScrollFrameMorph.prototype.scrollBarSize = null;

  ScrollFrameMorph.prototype.contents = null;

  ScrollFrameMorph.prototype.vBar = null;

  ScrollFrameMorph.prototype.hBar = null;

  function ScrollFrameMorph(contents, scrollBarSize, sliderColor) {
    this.contents = contents;
    this.sliderColor = sliderColor;
    this.alpha = 0;
    ScrollFrameMorph.__super__.constructor.call(this);
    this.scrollBarSize = scrollBarSize || WorldMorph.preferencesAndSettings.scrollBarSize;
    if (this.contents == null) {
      this.contents = new FrameMorph(this);
    }
    this.add(this.contents);
    this.color = this.contents.color;
    this.alpha = this.contents.alpha;
    this.hBar = new SliderMorph(null, null, null, null, "horizontal", this.sliderColor);
    this.hBar.setHeight(this.scrollBarSize);
    this.hBar.isfloatDraggable = false;
    this.hBar.target = this;
    this.add(this.hBar);
    this.vBar = new SliderMorph(null, null, null, null, "vertical", this.sliderColor);
    this.vBar.setWidth(this.scrollBarSize);
    this.vBar.isfloatDraggable = false;
    this.vBar.target = this;
    this.add(this.vBar);
    this.hBar.target = this;
    this.hBar.action = "adjustContentsBasedOnHBar";
    this.vBar.target = this;
    this.vBar.action = "adjustContentsBasedOnVBar";
    this.adjustScrollBars();
  }

  ScrollFrameMorph.prototype.adjustContentsBasedOnHBar = function(num) {
    this.contents.setPosition(new Point(this.left() - num, this.contents.position().y));
    this.adjustContentsBounds();
    return this.adjustScrollBars();
  };

  ScrollFrameMorph.prototype.adjustContentsBasedOnVBar = function(num) {
    this.contents.setPosition(new Point(this.contents.position().x, this.top() - num));
    this.adjustContentsBounds();
    return this.adjustScrollBars();
  };

  ScrollFrameMorph.prototype.setColor = function(aColorOrAMorphGivingAColor, morphGivingColor) {
    var aColor;
    aColor = ScrollFrameMorph.__super__.setColor.call(this, aColorOrAMorphGivingAColor, morphGivingColor);
    if (this.scrollFrame) {
      return this.scrollFrame.color = aColor;
    }
  };

  ScrollFrameMorph.prototype.setAlphaScaled = function(alpha) {
    this.alpha = this.calculateAlphaScaled(alpha);
    return this.contents.setAlphaScaled(alpha);
  };

  ScrollFrameMorph.prototype.adjustScrollBars = function() {
    var hWidth, stopValue, vHeight;
    hWidth = this.width() - this.scrollBarSize;
    vHeight = this.height() - this.scrollBarSize;
    this.changed();
    if (this.hBar.target === this) {
      if (this.contents.width() >= this.width() + 1) {
        this.hBar.show();
        if (this.hBar.width() !== hWidth) {
          this.hBar.setWidth(hWidth);
        }
        if (this.hBar.parent === this) {
          this.hBar.setPosition(new Point(this.left(), this.bottom() - this.hBar.height()));
        }
        stopValue = this.contents.width() - this.width();
        this.hBar.updateSpecs(0, stopValue, this.left() - this.contents.left(), this.width() / this.contents.width() * stopValue);
      } else {
        this.hBar.hide();
      }
    }
    if (this.vBar.target === this) {
      if (this.contents.height() >= this.height() + 1) {
        this.vBar.show();
        if (this.vBar.height() !== vHeight) {
          this.vBar.setHeight(vHeight);
        }
        if (this.vBar.parent === this) {
          this.vBar.setPosition(new Point(this.right() - this.vBar.width(), this.top()));
        }
        stopValue = this.contents.height() - this.height();
        return this.vBar.updateSpecs(0, stopValue, this.top() - this.contents.top(), this.height() / this.contents.height() * stopValue);
      } else {
        return this.vBar.hide();
      }
    }
  };

  ScrollFrameMorph.prototype.addContents = function(aMorph) {
    this.contents.add(aMorph);
    this.adjustContentsBounds();
    return this.adjustScrollBars();
  };

  ScrollFrameMorph.prototype.setContents = function(aMorph, extraPadding) {
    this.extraPadding = extraPadding;
    this.contents.destroyAll();
    aMorph.setPosition(this.position().add(this.padding + this.extraPadding));
    return this.addContents(aMorph);
  };

  ScrollFrameMorph.prototype.setExtent = function(aPoint) {
    if (this.isTextLineWrapping) {
      this.contents.setPosition(this.position().copy());
    }
    ScrollFrameMorph.__super__.setExtent.call(this, aPoint);
    this.contents.setExtent(aPoint);
    this.adjustContentsBounds();
    return this.adjustScrollBars();
  };

  ScrollFrameMorph.prototype.reactToDropOf = function() {
    this.adjustContentsBounds();
    return this.adjustScrollBars();
  };

  ScrollFrameMorph.prototype.reactToGrabOf = function() {
    this.adjustContentsBounds();
    return this.adjustScrollBars();
  };

  ScrollFrameMorph.prototype.adjustContentsBounds = function() {
    var newBounds, subBounds;
    if (this.isTextLineWrapping) {
      this.contents.children.forEach((function(_this) {
        return function(morph) {
          var totalPadding;
          if (morph instanceof TextMorph) {
            totalPadding = 2 * (_this.extraPadding + _this.padding);
            morph.maxWidth = 0;
            morph.setWidth(_this.contents.width() - totalPadding);
            morph.maxWidth = _this.contents.width() - totalPadding;
            return _this.contents.setHeight(Math.max(morph.height(), _this.height() - totalPadding));
          }
        };
      })(this));
    }
    subBounds = this.contents.submorphBounds();
    if (subBounds) {
      newBounds = subBounds.expandBy(this.padding + this.extraPadding).growBy(this.growth).merge(this.bounds);
    } else {
      newBounds = this.bounds.copy();
    }
    if (!this.contents.bounds.eq(newBounds)) {
      this.contents.bounds = newBounds;
      this.contents.setLayoutBeforeUpdatingBackingStore();
      this.contents.updateBackingStore();
      return this.keepContentsInScrollFrame();
    }
  };

  ScrollFrameMorph.prototype.keepContentsInScrollFrame = function() {
    if (this.contents.left() > this.left()) {
      this.contents.moveBy(new Point(this.left() - this.contents.left(), 0));
    }
    if (this.contents.right() < this.right()) {
      this.contents.moveBy(new Point(this.right() - this.contents.right(), 0));
    }
    if (this.contents.top() > this.top()) {
      this.contents.moveBy(new Point(0, this.top() - this.contents.top()));
    }
    if (this.contents.bottom() < this.bottom()) {
      return this.contents.moveBy(0, new Point(this.bottom() - this.contents.bottom(), 0));
    }
  };

  ScrollFrameMorph.prototype.scrollX = function(steps) {
    var cl, cw, l, newX, r;
    cl = this.contents.left();
    l = this.left();
    cw = this.contents.width();
    r = this.right();
    newX = cl + steps;
    if (newX + cw < r) {
      newX = r - cw;
    }
    if (newX > l) {
      newX = l;
    }
    if (newX !== cl) {
      this.contents.setLeft(newX);
      return true;
    } else {
      return false;
    }
  };

  ScrollFrameMorph.prototype.scrollY = function(steps) {
    var b, ch, ct, newY, t;
    ct = this.contents.top();
    t = this.top();
    ch = this.contents.height();
    b = this.bottom();
    newY = ct + steps;
    if (newY + ch < b) {
      newY = b - ch;
    }
    if (newY > t) {
      newY = t;
    }
    if (newY !== ct) {
      this.contents.setTop(newY);
      return true;
    } else {
      return false;
    }
  };

  ScrollFrameMorph.prototype.mouseDownLeft = function(pos) {
    var deltaX, deltaY, friction, oldPos, world;
    if (!this.isScrollingByfloatDragging) {
      return null;
    }
    world = this.root();
    oldPos = pos;
    deltaX = 0;
    deltaY = 0;
    friction = 0.8;
    return this.step = (function(_this) {
      return function() {
        var newPos, scrollbarJustChanged;
        scrollbarJustChanged = false;
        if (world.hand.mouseButton && (!world.hand.floatDraggingSomething()) && (_this.bounds.containsPoint(world.hand.position()))) {
          newPos = world.hand.bounds.origin;
          if (_this.hBar.isVisible) {
            deltaX = newPos.x - oldPos.x;
            if (deltaX !== 0) {
              scrollbarJustChanged = scrollbarJustChanged || _this.scrollX(deltaX);
            }
          }
          if (_this.vBar.isVisible) {
            deltaY = newPos.y - oldPos.y;
            if (deltaY !== 0) {
              scrollbarJustChanged = scrollbarJustChanged || _this.scrollY(deltaY);
            }
          }
          oldPos = newPos;
        } else {
          if (!_this.hasVelocity) {
            _this.step = noOperation;
          } else {
            if ((Math.abs(deltaX) < 0.5) && (Math.abs(deltaY) < 0.5)) {
              _this.step = noOperation;
            } else {
              if (_this.hBar.isVisible) {
                deltaX = deltaX * friction;
                if (deltaX !== 0) {
                  scrollbarJustChanged = scrollbarJustChanged || _this.scrollX(Math.round(deltaX));
                }
              }
              if (_this.vBar.isVisible) {
                deltaY = deltaY * friction;
                if (deltaY !== 0) {
                  scrollbarJustChanged = scrollbarJustChanged || _this.scrollY(Math.round(deltaY));
                }
              }
            }
          }
        }
        if (scrollbarJustChanged) {
          _this.adjustContentsBounds();
          return _this.adjustScrollBars();
        }
      };
    })(this);
  };

  ScrollFrameMorph.prototype.startAutoScrolling = function() {
    var hand, inset, world;
    inset = WorldMorph.preferencesAndSettings.scrollBarSize * 3;
    world = this.world();
    if (!world) {
      return null;
    }
    hand = world.hand;
    if (!this.autoScrollTrigger) {
      this.autoScrollTrigger = Date.now();
    }
    return this.step = (function(_this) {
      return function() {
        var inner, pos;
        pos = hand.bounds.origin;
        inner = _this.bounds.insetBy(inset);
        if ((_this.bounds.containsPoint(pos)) && (!(inner.containsPoint(pos))) && (hand.floatDraggingSomething())) {
          return _this.autoScroll(pos);
        } else {
          _this.step = noOperation;
          return _this.autoScrollTrigger = null;
        }
      };
    })(this);
  };

  ScrollFrameMorph.prototype.autoScroll = function(pos) {
    var area, inset, scrollbarJustChanged;
    if (Date.now() - this.autoScrollTrigger < 500) {
      return null;
    }
    inset = WorldMorph.preferencesAndSettings.scrollBarSize * 3;
    area = this.topLeft().extent(new Point(this.width(), inset));
    scrollbarJustChanged = false;
    if (area.containsPoint(pos)) {
      scrollbarJustChanged = scrollbarJustChanged || this.scrollY(inset - (pos.y - this.top()));
    }
    area = this.topLeft().extent(new Point(inset, this.height()));
    if (area.containsPoint(pos)) {
      scrollbarJustChanged = scrollbarJustChanged || this.scrollX(inset - (pos.x - this.left()));
    }
    area = (new Point(this.right() - inset, this.top())).extent(new Point(inset, this.height()));
    if (area.containsPoint(pos)) {
      scrollbarJustChanged = scrollbarJustChanged || this.scrollX(-(inset - (this.right() - pos.x)));
    }
    area = (new Point(this.left(), this.bottom() - inset)).extent(new Point(this.width(), inset));
    if (area.containsPoint(pos)) {
      scrollbarJustChanged = scrollbarJustChanged || this.scrollY(-(inset - (this.bottom() - pos.y)));
    }
    if (scrollbarJustChanged) {
      this.adjustContentsBounds();
      return this.adjustScrollBars();
    }
  };

  ScrollFrameMorph.prototype.scrollCaretIntoView = function(caretMorph) {
    var fb, fl, fr, ft, offset, txt;
    txt = caretMorph.target;
    offset = txt.position().subtract(this.contents.position());
    ft = this.top() + this.padding;
    fb = this.bottom() - this.padding;
    fl = this.left() + this.padding;
    fr = this.right() - this.padding;
    this.adjustContentsBounds();
    if (caretMorph.top() < ft) {
      this.contents.setTop(this.contents.top() + ft - caretMorph.top());
      caretMorph.setTop(ft);
    } else if (caretMorph.bottom() > fb) {
      this.contents.setBottom(this.contents.bottom() + fb - caretMorph.bottom());
      caretMorph.setBottom(fb);
    }
    if (caretMorph.left() < fl) {
      this.contents.setLeft(this.contents.left() + fl - caretMorph.left());
      caretMorph.setLeft(fl);
    } else if (caretMorph.right() > fr) {
      this.contents.setRight(this.contents.right() + fr - caretMorph.right());
      caretMorph.setRight(fr);
    }
    this.adjustContentsBounds();
    return this.adjustScrollBars();
  };

  ScrollFrameMorph.prototype.mouseScroll = function(y, x) {
    var scrollbarJustChanged;
    scrollbarJustChanged = false;
    if (y) {
      scrollbarJustChanged = scrollbarJustChanged || this.scrollY(y * WorldMorph.preferencesAndSettings.mouseScrollAmount);
    }
    if (x) {
      scrollbarJustChanged = scrollbarJustChanged || this.scrollX(x * WorldMorph.preferencesAndSettings.mouseScrollAmount);
    }
    if (scrollbarJustChanged) {
      this.adjustContentsBounds();
      return this.adjustScrollBars();
    }
  };

  ScrollFrameMorph.prototype.developersMenu = function() {
    var menu;
    menu = ScrollFrameMorph.__super__.developersMenu.call(this);
    if (this.isTextLineWrapping) {
      menu.addItem("auto line wrap off...", true, this, "toggleTextLineWrapping", "turn automatic\nline wrapping\noff");
    } else {
      menu.addItem("auto line wrap on...", true, this, "toggleTextLineWrapping", "enable automatic\nline wrapping");
    }
    return menu;
  };

  ScrollFrameMorph.prototype.toggleTextLineWrapping = function() {
    return this.isTextLineWrapping = !this.isTextLineWrapping;
  };

  ScrollFrameMorph.coffeeScriptSourceOfThisClass = '# ScrollFrameMorph ////////////////////////////////////////////////////\n\n# this comment below is needed to figure our dependencies between classes\n# REQUIRES globalFunctions\n\nclass ScrollFrameMorph extends FrameMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  autoScrollTrigger: null\n  hasVelocity: true # dto.\n  padding: 0 # around the scrollable area\n  growth: 0 # pixels or Point to grow right/left when near edge\n  isTextLineWrapping: false\n  isScrollingByfloatDragging: true\n  scrollBarSize: null\n  contents: null\n  vBar: null\n  hBar: null\n\n  constructor: (@contents, scrollBarSize, @sliderColor) ->\n    # super() paints the scrollframe, which we don\'t want,\n    # so we set 0 opacity here.\n    @alpha = 0\n    super()\n    @scrollBarSize = scrollBarSize or WorldMorph.preferencesAndSettings.scrollBarSize\n\n    @contents = new FrameMorph(@) unless @contents?\n    @add @contents\n\n    # the scrollFrame is never going to paint itself,\n    # but its values are going to mimick the values of the\n    # contained frame\n    @color = @contents.color\n    @alpha = @contents.alpha\n    \n    #@setColor = @contents.setColor\n    #@setAlphaScaled = @contents.setAlphaScaled\n\n    @hBar = new SliderMorph(null, null, null, null, "horizontal", @sliderColor)\n    @hBar.setHeight @scrollBarSize\n\n    @hBar.isfloatDraggable = false\n    @hBar.target = @\n    @add @hBar\n\n    @vBar = new SliderMorph(null, null, null, null, "vertical", @sliderColor)\n    @vBar.setWidth @scrollBarSize\n    @vBar.isfloatDraggable = false\n    @vBar.target = @\n    @add @vBar\n\n    @hBar.target = @\n    @hBar.action = "adjustContentsBasedOnHBar"\n    @vBar.target = @\n    @vBar.action = "adjustContentsBasedOnVBar"\n\n    @adjustScrollBars()\n\n  adjustContentsBasedOnHBar: (num) ->\n    @contents.setPosition new Point(@left() - num, @contents.position().y)\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n  adjustContentsBasedOnVBar: (num) ->\n    @contents.setPosition new Point(@contents.position().x, @top() - num)\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n  setColor: (aColorOrAMorphGivingAColor, morphGivingColor) ->\n    aColor = super(aColorOrAMorphGivingAColor, morphGivingColor)\n    # keep in synch the value of the container scrollFrame\n    # if there is one. Note that the container scrollFrame\n    # is actually not painted.\n    if @scrollFrame\n      @scrollFrame.color = aColor\n\n  setAlphaScaled: (alpha) ->\n    # update the alpha of the scrollFrame - note\n    # that we are never going to paint the scrollFrame\n    # we are updating the alpha so that its value is the same as the\n    # contained frame\n    @alpha = @calculateAlphaScaled(alpha)\n    @contents.setAlphaScaled(alpha)\n\n  adjustScrollBars: ->\n    hWidth = @width() - @scrollBarSize\n    vHeight = @height() - @scrollBarSize\n    @changed()\n\n    # this check is to see whether the bar actually belongs to this\n    # scrollframe. The reason why the bar could belong to another\n    # scrollframe is the following: the bar could have been detached\n    # from a scrollframe A. The scrollframe A (which is still fully\n    # working albeit detached) is then duplicated into\n    # a scrollframe B. What happens is that because the bar is not\n    # a child of A (rather, it\'s only referenced as a property),\n    # the duplication mechanism does not duplicate the bar and it does\n    # not update the reference to it. This is correct because one cannot\n    # just change all the references to other objects that are not children\n    # , a good example being the targets, i.e. if you duplicate a colorPicker\n    # which targets a Morph you want the duplication of the colorPicker to\n    # still change color of that same Morph.\n    # So: the scrollframe B could still reference the scrollbar\n    # detached from A and that causes a problem because changes to B would\n    # change the dimensions and hiding/unhiding of the scrollbar.\n    # So here we avoid that by actually checking what the scrollbar is\n    # attached to.\n    if @hBar.target == @ \n      if @contents.width() >= @width() + 1\n        @hBar.show()\n        @hBar.setWidth hWidth  if @hBar.width() isnt hWidth\n        # we check whether the bar has been detached. If it\'s still\n        # attached then we possibly move it, together with the\n        # scrollframe, otherwise we don\'t move it.\n        if @hBar.parent == @\n          @hBar.setPosition new Point(@left(), @bottom() - @hBar.height())\n        stopValue = @contents.width() - @width()\n        @hBar.updateSpecs(\n          0, # start\n          stopValue, # stop\n          @left() - @contents.left(), # value\n          @width() / @contents.width() * stopValue # size\n        )\n      else\n        @hBar.hide()\n\n    # see comment on equivalent if line above.\n    if @vBar.target == @ \n      if @contents.height() >= @height() + 1\n        @vBar.show()\n        @vBar.setHeight vHeight  if @vBar.height() isnt vHeight\n        # we check whether the bar has been detached. If it\'s still\n        # attached then we possibly move it, together with the\n        # scrollframe, otherwise we don\'t move it.\n        if @vBar.parent == @\n          @vBar.setPosition new Point(@right() - @vBar.width(), @top())\n        stopValue = @contents.height() - @height()\n        @vBar.updateSpecs(\n          0, # start\n          stopValue, # stop\n          @top() - @contents.top(), # value\n          @height() / @contents.height() * stopValue # size\n        )\n      else\n        @vBar.hide()\n  \n  addContents: (aMorph) ->\n    @contents.add aMorph\n    @adjustContentsBounds()\n    @adjustScrollBars()\n  \n  setContents: (aMorph, extraPadding) ->\n    @extraPadding = extraPadding\n    @contents.destroyAll()\n\n    aMorph.setPosition @position().add(@padding + @extraPadding)\n    @addContents aMorph\n  \n  setExtent: (aPoint) ->\n    @contents.setPosition @position().copy()  if @isTextLineWrapping\n    super aPoint\n    @contents.setExtent(aPoint)\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n\n  reactToDropOf: ->\n    @adjustContentsBounds()\n    @adjustScrollBars()\n  \n  reactToGrabOf: ->\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n  adjustContentsBounds: ->\n    # if FrameMorph is of type isTextLineWrapping\n    # it means that you don\'t want the TextMorph to\n    # extend indefinitely as you are typing. Rather,\n    # the width will be constrained and the text will\n    # wrap.\n    if @isTextLineWrapping\n      @contents.children.forEach (morph) =>\n        if morph instanceof TextMorph\n          totalPadding =  2*(@extraPadding + @padding)\n          # this re-layouts the text to fit the width.\n          # The new height of the TextMorph will then be used\n          # to redraw the vertical slider.\n          morph.maxWidth = 0\n          morph.setWidth @contents.width() - totalPadding\n          morph.maxWidth = @contents.width() - totalPadding\n          @contents.setHeight Math.max(morph.height(), @height() - totalPadding)\n\n    subBounds = @contents.submorphBounds()\n    if subBounds\n      newBounds = subBounds.expandBy(@padding + @extraPadding).growBy(@growth).merge(@bounds)\n    else\n      newBounds = @bounds.copy()\n\n    unless @contents.bounds.eq(newBounds)\n      @contents.bounds = newBounds\n      @contents.setLayoutBeforeUpdatingBackingStore()\n      @contents.updateBackingStore()\n      @keepContentsInScrollFrame()\n\n  keepContentsInScrollFrame: ->\n    if @contents.left() > @left()\n      @contents.moveBy new Point(@left() - @contents.left(), 0)\n    if @contents.right() < @right()\n      @contents.moveBy new Point(@right() - @contents.right(), 0)  \n    if @contents.top() > @top()\n      @contents.moveBy new Point(0, @top() - @contents.top())  \n    if @contents.bottom() < @bottom()\n      @contents.moveBy 0, new Point(@bottom() - @contents.bottom(), 0)\n  \n  # ScrollFrameMorph scrolling by floatDragging:\n  scrollX: (steps) ->\n    cl = @contents.left()\n    l = @left()\n    cw = @contents.width()\n    r = @right()\n    newX = cl + steps\n    newX = r - cw  if newX + cw < r\n    newX = l  if newX > l\n    # return true if any movement of\n    # the scrollbar button is\n    # actually happening, otherwise\n    # false. We use this to figure\n    # out in some places whether\n    # we need to trigger a bunch of\n    # updates of the content and scrollbars\n    # or not.\n    if newX isnt cl\n      @contents.setLeft newX\n      return true\n    else\n      return false\n  \n  scrollY: (steps) ->\n    ct = @contents.top()\n    t = @top()\n    ch = @contents.height()\n    b = @bottom()\n    newY = ct + steps\n    if newY + ch < b\n      newY = b - ch\n    # prevents content to be scrolled to the frame\'s\n    # bottom if the content is otherwise empty\n    newY = t  if newY > t\n    # return true if any movement of\n    # the scrollbar button is\n    # actually happening, otherwise\n    # false. We use this to figure\n    # out in some places whether\n    # we need to trigger a bunch of\n    # updates of the content and scrollbars\n    # or not.\n    if newY isnt ct\n      @contents.setTop newY\n      return true\n    else\n      return false\n  \n  # sometimes you can scroll the contents of a scrollframe\n  # by floatDragging its contents. This is particularly\n  # useful in touch devices.\n  mouseDownLeft: (pos) ->\n    return null  unless @isScrollingByfloatDragging\n    world = @root()\n    oldPos = pos\n    deltaX = 0\n    deltaY = 0\n    friction = 0.8\n    @step = =>\n      scrollbarJustChanged = false\n      if world.hand.mouseButton and\n        (!world.hand.floatDraggingSomething()) and\n        (@bounds.containsPoint(world.hand.position()))\n          newPos = world.hand.bounds.origin\n          if @hBar.isVisible\n            deltaX = newPos.x - oldPos.x\n            if deltaX isnt 0\n              scrollbarJustChanged = scrollbarJustChanged || @scrollX deltaX\n          if @vBar.isVisible\n            deltaY = newPos.y - oldPos.y\n            if deltaY isnt 0\n              scrollbarJustChanged = scrollbarJustChanged || @scrollY deltaY\n          oldPos = newPos\n      else\n        unless @hasVelocity\n          @step = noOperation\n        else\n          if (Math.abs(deltaX) < 0.5) and (Math.abs(deltaY) < 0.5)\n            @step = noOperation\n          else\n            if @hBar.isVisible\n              deltaX = deltaX * friction\n              if deltaX isnt 0\n                scrollbarJustChanged = scrollbarJustChanged || @scrollX Math.round(deltaX)\n            if @vBar.isVisible\n              deltaY = deltaY * friction\n              if deltaY isnt 0\n                scrollbarJustChanged = scrollbarJustChanged || @scrollY Math.round(deltaY)\n      if scrollbarJustChanged\n        @adjustContentsBounds()\n        @adjustScrollBars()\n  \n  startAutoScrolling: ->\n    inset = WorldMorph.preferencesAndSettings.scrollBarSize * 3\n    world = @world()\n    return null  unless world\n    hand = world.hand\n    @autoScrollTrigger = Date.now()  unless @autoScrollTrigger\n    @step = =>\n      pos = hand.bounds.origin\n      inner = @bounds.insetBy(inset)\n      if (@bounds.containsPoint(pos)) and\n        (not (inner.containsPoint(pos))) and\n        (hand.floatDraggingSomething())\n          @autoScroll pos\n      else\n        @step = noOperation\n        @autoScrollTrigger = null\n  \n  autoScroll: (pos) ->\n    return null  if Date.now() - @autoScrollTrigger < 500\n    inset = WorldMorph.preferencesAndSettings.scrollBarSize * 3\n    area = @topLeft().extent(new Point(@width(), inset))\n    scrollbarJustChanged = false\n    if area.containsPoint(pos)\n      scrollbarJustChanged = scrollbarJustChanged ||\n        @scrollY inset - (pos.y - @top())\n    area = @topLeft().extent(new Point(inset, @height()))\n    if area.containsPoint(pos)\n      scrollbarJustChanged = scrollbarJustChanged ||\n        @scrollX inset - (pos.x - @left())\n    area = (new Point(@right() - inset, @top())).extent(new Point(inset, @height()))\n    if area.containsPoint(pos)\n      scrollbarJustChanged = scrollbarJustChanged ||\n        @scrollX -(inset - (@right() - pos.x))\n    area = (new Point(@left(), @bottom() - inset)).extent(new Point(@width(), inset))\n    if area.containsPoint(pos)\n      scrollbarJustChanged = scrollbarJustChanged ||\n        @scrollY -(inset - (@bottom() - pos.y))\n    if scrollbarJustChanged\n      @adjustContentsBounds()\n      @adjustScrollBars()  \n  \n  # ScrollFrameMorph scrolling when editing text\n  # so to bring the caret fully into view.\n  scrollCaretIntoView: (caretMorph) ->\n    txt = caretMorph.target\n    offset = txt.position().subtract(@contents.position())\n    ft = @top() + @padding\n    fb = @bottom() - @padding\n    fl = @left() + @padding\n    fr = @right() - @padding\n    @adjustContentsBounds()\n    if caretMorph.top() < ft\n      @contents.setTop @contents.top() + ft - caretMorph.top()\n      caretMorph.setTop ft\n    else if caretMorph.bottom() > fb\n      @contents.setBottom @contents.bottom() + fb - caretMorph.bottom()\n      caretMorph.setBottom fb\n    if caretMorph.left() < fl\n      @contents.setLeft @contents.left() + fl - caretMorph.left()\n      caretMorph.setLeft fl\n    else if caretMorph.right() > fr\n      @contents.setRight @contents.right() + fr - caretMorph.right()\n      caretMorph.setRight fr\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n  # ScrollFrameMorph events:\n  mouseScroll: (y, x) ->\n    scrollbarJustChanged = false\n    if y\n      scrollbarJustChanged = scrollbarJustChanged || @scrollY y * WorldMorph.preferencesAndSettings.mouseScrollAmount\n    if x\n      scrollbarJustChanged = scrollbarJustChanged || @scrollX x * WorldMorph.preferencesAndSettings.mouseScrollAmount  \n    if scrollbarJustChanged\n      @adjustContentsBounds()\n      @adjustScrollBars()\n  \n  \n  developersMenu: ->\n    menu = super()\n    if @isTextLineWrapping\n      menu.addItem "auto line wrap off...", true, @, "toggleTextLineWrapping", "turn automatic\nline wrapping\noff"\n    else\n      menu.addItem "auto line wrap on...", true, @, "toggleTextLineWrapping", "enable automatic\nline wrapping"\n    menu\n  \n  toggleTextLineWrapping: ->\n    @isTextLineWrapping = not @isTextLineWrapping';

  return ScrollFrameMorph;

})(FrameMorph);

ListMorph = (function(_super) {
  __extends(ListMorph, _super);

  namedClasses[ListMorph.name] = ListMorph.prototype;

  ListMorph.prototype.elements = null;

  ListMorph.prototype.labelGetter = null;

  ListMorph.prototype.format = null;

  ListMorph.prototype.listContents = null;

  ListMorph.prototype.selected = null;

  ListMorph.prototype.active = null;

  ListMorph.prototype.action = null;

  ListMorph.prototype.target = null;

  ListMorph.prototype.doubleClickAction = null;

  function ListMorph(target, action, elements, labelGetter, format, doubleClickAction) {
    this.target = target;
    this.action = action;
    this.elements = elements != null ? elements : [];
    this.format = format != null ? format : [];
    this.doubleClickAction = doubleClickAction != null ? doubleClickAction : null;
    ListMorph.__super__.constructor.call(this);
    this.contents.acceptsDrops = false;
    this.color = new Color(255, 255, 255);
    this.labelGetter = labelGetter || function(element) {
      if (isString(element)) {
        return element;
      }
      if (element.toSource) {
        return element.toSource();
      }
      return element.toString();
    };
    this.buildAndConnectChildren();
  }

  ListMorph.prototype.buildAndConnectChildren = function() {
    if (this.listContents) {
      this.listContents = this.listContents.destroy();
    }
    this.listContents = new MenuMorph(true, this, false, false, null, null);
    if (!this.elements.length) {
      this.elements = ["(empty)"];
    }
    this.elements.forEach((function(_this) {
      return function(element) {
        var bold, color, italic;
        color = null;
        bold = false;
        italic = false;
        _this.format.forEach(function(pair) {
          if (pair[1].call(null, element)) {
            if (pair[0] === 'bold') {
              return bold = true;
            } else if (pair[0] === 'italic') {
              return italic = true;
            } else {
              return color = pair[0];
            }
          }
        });
        return _this.listContents.addItem(_this.labelGetter(element), true, _this, "select", null, color, bold, italic, _this.doubleClickAction);
      };
    })(this));
    this.listContents.setPosition(this.contents.position());
    this.listContents.setLayoutBeforeUpdatingBackingStore();
    this.listContents.updateBackingStore();
    return this.addContents(this.listContents);
  };

  ListMorph.prototype.select = function(item, trigger) {
    this.selected = item;
    this.active = trigger;
    if (this.action) {
      if (typeof this.action === "function") {
        console.log("listmorph selection invoked with function");
        debugger;
        return this.action.call(this.target, item.labelString);
      } else {
        return this.target[this.action].call(this.target, item.labelString);
      }
    }
  };

  ListMorph.prototype.setExtent = function(aPoint) {
    var lb, nb;
    lb = this.listContents.bounds;
    nb = this.bounds.origin.copy().corner(this.bounds.origin.add(aPoint));
    if (nb.right() > lb.right() && nb.width() <= lb.width()) {
      this.listContents.setRight(nb.right());
    }
    if (nb.bottom() > lb.bottom() && nb.height() <= lb.height()) {
      this.listContents.setBottom(nb.bottom());
    }
    return ListMorph.__super__.setExtent.call(this, aPoint);
  };

  ListMorph.coffeeScriptSourceOfThisClass = '# ListMorph ///////////////////////////////////////////////////////////\n\nclass ListMorph extends ScrollFrameMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n  \n  elements: null\n  labelGetter: null\n  format: null\n  listContents: null # a MenuMorph with the contents of the list\n  selected: null # actual element currently selected\n  active: null # menu item representing the selected element\n  action: null\n  target: null\n  doubleClickAction: null\n\n  constructor: (@target, @action, @elements = [], labelGetter, @format = [], @doubleClickAction = null) ->\n    #\n    #    passing a format is optional. If the format parameter is specified\n    #    it has to be of the following pattern:\n    #\n    #        [\n    #            [<color>, <single-argument predicate>],\n    #            [\'bold\', <single-argument predicate>],\n    #            [\'italic\', <single-argument predicate>],\n    #            ...\n    #        ]\n    #\n    #    multiple conditions can be passed in such a format list, the\n    #    last predicate to evaluate true when given the list element sets\n    #    the given format category (color, bold, italic).\n    #    If no condition is met, the default format (color black, non-bold,\n    #    non-italic) will be assigned.\n    #    \n    #    An example of how to use formats can be found in the InspectorMorph\'s\n    #    "markOwnProperties" mechanism.\n    #\n    #debugger\n    super()\n    @contents.acceptsDrops = false\n    @color = new Color(255, 255, 255)\n    @labelGetter = labelGetter or (element) ->\n        return element  if isString(element)\n        return element.toSource()  if element.toSource\n        element.toString()\n    @buildAndConnectChildren() # builds the list contents\n    # it\'s important to leave the step as the default noOperation\n    # instead of null because the scrollbars (inherited from scrollframe)\n    # need the step function to react to mouse floatDrag.\n  \n  # builds the list contents\n  buildAndConnectChildren: ->\n    if @listContents\n      @listContents = @listContents.destroy()\n    @listContents = new MenuMorph(true, @, false, false, null, null)\n    @elements = ["(empty)"]  if !@elements.length\n    @elements.forEach (element) =>\n      color = null\n      bold = false\n      italic = false\n      @format.forEach (pair) ->\n        if pair[1].call(null, element)\n          if pair[0] == \'bold\'\n            bold = true\n          else if pair[0] == \'italic\'\n            italic = true\n          else # assume it\'s a color\n            color = pair[0]\n\n      #labelString,\n      #action,\n      #hint,\n      #color,\n      #bold = false,\n      #italic = false,\n      #doubleClickAction # optional, when used as list contents\n\n      @listContents.addItem(\n        @labelGetter(element), # labelString\n        true,\n        @, # target\n        "select", # action\n        null, # hint\n        color, # color\n        bold, # bold\n        italic, # italic\n        @doubleClickAction # doubleClickAction\n      )\n\n    @listContents.setPosition @contents.position()\n    @listContents.setLayoutBeforeUpdatingBackingStore()\n    @listContents.updateBackingStore()\n    @addContents @listContents\n  \n  select: (item, trigger) ->\n    @selected = item\n    @active = trigger\n    if @action\n      if typeof @action is "function"\n        console.log "listmorph selection invoked with function"\n        debugger\n        @action.call @target, item.labelString\n      else # assume it\'s a String\n        @target[@action].call @target, item.labelString\n  \n  setExtent: (aPoint) ->\n    lb = @listContents.bounds\n    nb = @bounds.origin.copy().corner(@bounds.origin.add(aPoint))\n    if nb.right() > lb.right() and nb.width() <= lb.width()\n      @listContents.setRight nb.right()\n    if nb.bottom() > lb.bottom() and nb.height() <= lb.height()\n      @listContents.setBottom nb.bottom()\n    super aPoint';

  return ListMorph;

})(ScrollFrameMorph);

TriggerMorph = (function(_super) {
  __extends(TriggerMorph, _super);

  namedClasses[TriggerMorph.name] = TriggerMorph.prototype;

  TriggerMorph.augmentWith(BackingStoreMixin);

  TriggerMorph.prototype.target = null;

  TriggerMorph.prototype.action = null;

  TriggerMorph.prototype.dataSourceMorphForTarget = null;

  TriggerMorph.prototype.morphEnv = null;

  TriggerMorph.prototype.label = null;

  TriggerMorph.prototype.labelString = null;

  TriggerMorph.prototype.labelColor = null;

  TriggerMorph.prototype.labelBold = null;

  TriggerMorph.prototype.labelItalic = null;

  TriggerMorph.prototype.doubleClickAction = null;

  TriggerMorph.prototype.argumentToAction1 = null;

  TriggerMorph.prototype.argumentToAction2 = null;

  TriggerMorph.prototype.hint = null;

  TriggerMorph.prototype.fontSize = null;

  TriggerMorph.prototype.fontStyle = null;

  TriggerMorph.prototype.highlightColor = new Color(192, 192, 192);

  TriggerMorph.prototype.highlightImage = null;

  TriggerMorph.prototype.pressColor = new Color(128, 128, 128);

  TriggerMorph.prototype.normalImage = null;

  TriggerMorph.prototype.pressImage = null;

  TriggerMorph.prototype.centered = false;

  TriggerMorph.prototype.closesUnpinnedMenus = true;

  function TriggerMorph(closesUnpinnedMenus, target, action, labelString, fontSize, fontStyle, centered, dataSourceMorphForTarget, morphEnv, hint, labelColor, labelBold, labelItalic, doubleClickAction, argumentToAction1, argumentToAction2) {
    this.closesUnpinnedMenus = closesUnpinnedMenus != null ? closesUnpinnedMenus : true;
    this.target = target != null ? target : null;
    this.action = action != null ? action : null;
    this.labelString = labelString != null ? labelString : null;
    this.centered = centered != null ? centered : false;
    this.dataSourceMorphForTarget = dataSourceMorphForTarget != null ? dataSourceMorphForTarget : null;
    this.morphEnv = morphEnv;
    this.hint = hint != null ? hint : null;
    this.labelBold = labelBold != null ? labelBold : false;
    this.labelItalic = labelItalic != null ? labelItalic : false;
    this.doubleClickAction = doubleClickAction != null ? doubleClickAction : null;
    this.argumentToAction1 = argumentToAction1 != null ? argumentToAction1 : null;
    this.argumentToAction2 = argumentToAction2 != null ? argumentToAction2 : null;
    this.fontSize = fontSize || WorldMorph.preferencesAndSettings.menuFontSize;
    this.fontStyle = fontStyle || "sans-serif";
    this.labelColor = labelColor || new Color(0, 0, 0);
    TriggerMorph.__super__.constructor.call(this);
    this.color = new Color(255, 255, 255);
    if (this.labelString != null) {
      this.layoutSubmorphs();
    }
  }

  TriggerMorph.prototype.layoutSubmorphs = function() {
    if (this.label == null) {
      this.createLabel();
    }
    if (this.centered) {
      return this.label.setPosition(this.center().subtract(this.label.extent().floorDivideBy(2)));
    }
  };

  TriggerMorph.prototype.getTextDescription = function() {
    var textWithoutLocationOrInstanceNo;
    if (this.textDescription != null) {
      return this.textDescription + " (adhoc description of button)";
    }
    if (this.labelString) {
      textWithoutLocationOrInstanceNo = this.labelString.replace(/\[\d*@\d*[ ]*\|[ ]*\d*@\d*\]/, "");
      textWithoutLocationOrInstanceNo = textWithoutLocationOrInstanceNo.replace(/#\d*/, "");
      return textWithoutLocationOrInstanceNo + " (text in button)";
    } else {
      return TriggerMorph.__super__.getTextDescription.call(this);
    }
  };

  TriggerMorph.prototype.setLabel = function(labelString) {
    this.labelString = labelString;
    if (this.label != null) {
      this.label = this.label.destroy();
    }
    return this.layoutSubmorphs();
  };

  TriggerMorph.prototype.alignCenter = function() {
    if (!this.centered) {
      this.centered = true;
      return this.layoutSubmorphs();
    }
  };

  TriggerMorph.prototype.alignLeft = function() {
    if (this.centered) {
      this.centered = false;
      return this.layoutSubmorphs();
    }
  };

  TriggerMorph.prototype.updateBackingStore = function() {
    var context, extent;
    extent = this.extent();
    this.normalImage = newCanvas(extent.scaleBy(pixelRatio));
    context = this.normalImage.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    context.fillStyle = this.color.toString();
    context.fillRect(0, 0, extent.x, extent.y);
    this.highlightImage = newCanvas(extent.scaleBy(pixelRatio));
    context = this.highlightImage.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    context.fillStyle = this.highlightColor.toString();
    context.fillRect(0, 0, extent.x, extent.y);
    this.pressImage = newCanvas(extent.scaleBy(pixelRatio));
    context = this.pressImage.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    context.fillStyle = this.pressColor.toString();
    context.fillRect(0, 0, extent.x, extent.y);
    return this.image = this.normalImage;
  };

  TriggerMorph.prototype.createLabel = function() {
    this.label = new StringMorph(this.labelString || "", this.fontSize, this.fontStyle, this.labelBold, this.labelItalic, false, this.labelColor);
    return this.add(this.label);
  };

  TriggerMorph.prototype.trigger = function() {
    if (this.action) {
      if (typeof this.action === "function") {
        console.log("trigger invoked with function");
        debugger;
        return this.action.call(this.target, this.dataSourceMorphForTarget);
      } else {
        return this.target[this.action].call(this.target, this.dataSourceMorphForTarget, this.morphEnv, this.argumentToAction1, this.argumentToAction2);
      }
    }
  };

  TriggerMorph.prototype.triggerDoubleClick = function() {
    if (!this.doubleClickAction) {
      return;
    }
    if (typeof this.target === "function") {
      if (typeof this.doubleClickAction === "function") {
        return this.target.call(this.dataSourceMorphForTarget, this.doubleClickAction.call(), this);
      } else {
        return this.target.call(this.dataSourceMorphForTarget, this.doubleClickAction, this);
      }
    } else {
      if (typeof this.doubleClickAction === "function") {
        return this.doubleClickAction.call(this.target);
      } else {
        return this.target[this.doubleClickAction]();
      }
    }
  };

  TriggerMorph.prototype.mouseEnter = function() {
    this.image = this.highlightImage;
    this.changed();
    if (this.hint) {
      return this.startCountdownForBubbleHelp(this.hint);
    }
  };

  TriggerMorph.prototype.mouseLeave = function() {
    this.image = this.normalImage;
    this.changed();
    if (this.hint) {
      return this.world().hand.destroyTemporaries();
    }
  };

  TriggerMorph.prototype.mouseDownLeft = function() {
    this.image = this.pressImage;
    return this.changed();
  };

  TriggerMorph.prototype.mouseClickLeft = function() {
    TriggerMorph.__super__.mouseClickLeft.call(this);
    this.image = this.highlightImage;
    this.changed();
    if (this.closesUnpinnedMenus) {
      this.propagateKillMenus();
    }
    return this.trigger();
  };

  TriggerMorph.prototype.mouseDoubleClick = function() {
    return this.triggerDoubleClick();
  };

  TriggerMorph.prototype.rootForGrab = function() {
    if (this.isfloatDraggable) {
      return TriggerMorph.__super__.rootForGrab.call(this);
    }
    return null;
  };

  TriggerMorph.prototype.startCountdownForBubbleHelp = function(contents) {
    return SpeechBubbleMorph.createInAWhileIfHandStillContainedInMorph(this, contents);
  };

  TriggerMorph.coffeeScriptSourceOfThisClass = '# TriggerMorph ////////////////////////////////////////////////////////\n\n# I provide basic button functionality.\n# All menu items and buttons are TriggerMorphs.\n# The handling of the triggering is not\n# trivial, as the concepts of\n# dataSourceMorphForTarget, target and action\n# are used - see comments.\n# REQUIRES BackingStoreMixin\n\nclass TriggerMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith BackingStoreMixin\n\n  target: null\n  action: null\n  dataSourceMorphForTarget: null\n  morphEnv: null\n  label: null\n  labelString: null\n  labelColor: null\n  labelBold: null\n  labelItalic: null\n  doubleClickAction: null\n  argumentToAction1: null\n  argumentToAction2: null\n  hint: null\n  fontSize: null\n  fontStyle: null\n  # careful: this Color object is shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  highlightColor: new Color(192, 192, 192)\n  highlightImage: null\n  # careful: this Color object is shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  pressColor: new Color(128, 128, 128)\n  normalImage: null\n  pressImage: null\n  centered: false\n  closesUnpinnedMenus: true\n\n  constructor: (\n      @closesUnpinnedMenus = true,\n      @target = null,\n      @action = null,\n      @labelString = null,\n      fontSize,\n      fontStyle,\n      @centered = false,\n      @dataSourceMorphForTarget = null,\n      @morphEnv,\n      @hint = null,\n      labelColor,\n      @labelBold = false,\n      @labelItalic = false,\n      @doubleClickAction = null,\n      @argumentToAction1 = null,\n      @argumentToAction2 = null\n      ) ->\n\n    # additional properties:\n    @fontSize = fontSize or WorldMorph.preferencesAndSettings.menuFontSize\n    @fontStyle = fontStyle or "sans-serif"\n    @labelColor = labelColor or new Color(0, 0, 0)\n\n    super()\n\n    #@color = new Color(255, 152, 152)\n    @color = new Color(255, 255, 255)\n    if @labelString?\n      @layoutSubmorphs()\n  \n  layoutSubmorphs: ->\n    if not @label?\n      @createLabel()\n    if @centered\n      @label.setPosition @center().subtract(@label.extent().floorDivideBy(2))\n\n  getTextDescription: ->\n    if @textDescription?\n      return @textDescription + " (adhoc description of button)"\n    if @labelString\n      textWithoutLocationOrInstanceNo = @labelString.replace(/\[\d*@\d*[ ]*\|[ ]*\d*@\d*\]/,"")\n      textWithoutLocationOrInstanceNo = textWithoutLocationOrInstanceNo.replace(/#\d*/,"")\n      return textWithoutLocationOrInstanceNo + " (text in button)"\n    else\n      return super()\n\n\n  setLabel: (@labelString) ->\n    # just recreated the label\n    # from scratch\n    if @label?\n      @label = @label.destroy()\n    @layoutSubmorphs()\n\n  alignCenter: ->\n    if !@centered\n      @centered = true\n      @layoutSubmorphs()\n\n  alignLeft: ->\n    if @centered\n      @centered = false\n      @layoutSubmorphs()\n  \n  # no changes of position or extent\n  updateBackingStore: ->\n    extent = @extent()\n    @normalImage = newCanvas(extent.scaleBy pixelRatio)\n    context = @normalImage.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    context.fillStyle = @color.toString()\n    context.fillRect 0, 0, extent.x, extent.y\n    @highlightImage = newCanvas(extent.scaleBy pixelRatio)\n    context = @highlightImage.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    context.fillStyle = @highlightColor.toString()\n    context.fillRect 0, 0, extent.x, extent.y\n    @pressImage = newCanvas(extent.scaleBy pixelRatio)\n    context = @pressImage.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    context.fillStyle = @pressColor.toString()\n    context.fillRect 0, 0, extent.x, extent.y\n    @image = @normalImage\n  \n  createLabel: ->\n    # bold\n    # italic\n    # numeric\n    # shadow offset\n    # shadow color\n    @label = new StringMorph(\n      @labelString or "",\n      @fontSize,\n      @fontStyle,\n      @labelBold,\n      @labelItalic,\n      false,\n      @labelColor      \n    )\n    @add @label\n    \n  \n  # TriggerMorph action:\n  trigger: ->\n    if @action\n      if typeof @action is "function"\n        console.log "trigger invoked with function"\n        debugger\n        @action.call @target, @dataSourceMorphForTarget\n      else # assume it\'s a String\n        @target[@action].call @target, @dataSourceMorphForTarget, @morphEnv, @argumentToAction1, @argumentToAction2\n\n  triggerDoubleClick: ->\n    # same as trigger() but use doubleClickAction instead of action property\n    # note that specifying a doubleClickAction is optional\n    return  unless @doubleClickAction\n    if typeof @target is "function"\n      if typeof @doubleClickAction is "function"\n        @target.call @dataSourceMorphForTarget, @doubleClickAction.call(), this\n      else\n        @target.call @dataSourceMorphForTarget, @doubleClickAction, this\n    else\n      if typeof @doubleClickAction is "function"\n        @doubleClickAction.call @target\n      else # assume it\'s a String\n        @target[@doubleClickAction]()  \n  \n  # TriggerMorph events:\n  mouseEnter: ->\n    @image = @highlightImage\n    @changed()\n    @startCountdownForBubbleHelp @hint  if @hint\n  \n  mouseLeave: ->\n    @image = @normalImage\n    @changed()\n    @world().hand.destroyTemporaries()  if @hint\n  \n  mouseDownLeft: ->\n    @image = @pressImage\n    @changed()\n  \n  mouseClickLeft: ->\n    super()\n    @image = @highlightImage\n    @changed()\n    if @closesUnpinnedMenus\n      @propagateKillMenus()\n    @trigger()\n\n  mouseDoubleClick: ->\n    @triggerDoubleClick()\n\n  # Disable floatDragging compound Morphs by Triggers\n  # User can still move the trigger itself though\n  # (it it\'s unlocked)\n  rootForGrab: ->\n    if @isfloatDraggable\n      return super()\n    null\n  \n  # TriggerMorph bubble help:\n  startCountdownForBubbleHelp: (contents) ->\n    SpeechBubbleMorph.createInAWhileIfHandStillContainedInMorph @, contents';

  return TriggerMorph;

})(Morph);

MenuItemMorph = (function(_super) {
  __extends(MenuItemMorph, _super);

  namedClasses[MenuItemMorph.name] = MenuItemMorph.prototype;

  function MenuItemMorph(closesUnpinnedMenus, target, action, labelString, fontSize, fontStyle, centered, environment, morphEnv, hint, color, bold, italic, doubleClickAction, argumentToAction1, argumentToAction2) {
    MenuItemMorph.__super__.constructor.call(this, closesUnpinnedMenus, target, action, labelString, fontSize, fontStyle, centered, environment, morphEnv, hint, color, bold, italic, doubleClickAction, argumentToAction1, argumentToAction2);
  }

  MenuItemMorph.prototype.getTextDescription = function() {
    var textWithoutLocationOrInstanceNo;
    if (this.textDescription != null) {
      return this.textDescription + " (adhoc description of menu item)";
    }
    if (this.labelString) {
      textWithoutLocationOrInstanceNo = this.labelString.replace(/\[\d*@\d*[ ]*\|[ ]*\d*@\d*\]/, "");
      textWithoutLocationOrInstanceNo = textWithoutLocationOrInstanceNo.replace(/#\d*/, "");
      return textWithoutLocationOrInstanceNo + " (text in button)";
    } else {
      return MenuItemMorph.__super__.getTextDescription.call(this);
    }
  };

  MenuItemMorph.prototype.createLabel = function() {
    var icon, lbl, np, w;
    if (this.label != null) {
      this.label = this.label.destroy();
    }
    if (isString(this.labelString)) {
      this.label = this.createLabelString(this.labelString);
    } else if (this.labelString instanceof Array) {
      this.label = new Morph();
      this.label.alpha = 0;
      icon = this.createIcon(this.labelString[0]);
      this.label.add(icon);
      lbl = this.createLabelString(this.labelString[1]);
      this.label.add(lbl);
      lbl.setCenter(icon.center());
      lbl.setLeft(icon.right() + 4);
      this.label.bounds = icon.bounds.merge(lbl.bounds);
    } else {
      this.label = this.createIcon(this.labelString);
    }
    this.add(this.label);
    w = this.width();
    this.silentSetExtent(this.label.extent().add(new Point(8, 0)));
    this.silentSetWidth(w);
    np = this.position().add(new Point(4, 0));
    return this.label.bounds = np.extent(this.label.extent());
  };

  MenuItemMorph.prototype.createIcon = function(source) {
    var context, icon, src;
    icon = new Morph();
    icon.image = (source instanceof Morph ? source.fullImage() : source);
    if (source instanceof Morph && source.getShadow()) {
      src = icon.image;
      icon.image = newCanvas(source.fullBounds().extent().subtract(this.shadowBlur * (WorldMorph.preferencesAndSettings.useBlurredShadows ? 1 : 2)).scaleBy(pixelRatio));
      context = icon.image.getContext("2d");
      context.drawImage(src, 0, 0);
    }
    icon.silentSetWidth(icon.image.width);
    icon.silentSetHeight(icon.image.height);
    return icon;
  };

  MenuItemMorph.prototype.createLabelString = function(string) {
    var lbl;
    lbl = new TextMorph(string, this.fontSize, this.fontStyle);
    lbl.setColor(this.labelColor);
    return lbl;
  };

  MenuItemMorph.prototype.mouseEnter = function() {
    if (!this.isListItem()) {
      this.image = this.highlightImage;
      this.changed();
    }
    if (this.hint) {
      return this.startCountdownForBubbleHelp(this.hint);
    }
  };

  MenuItemMorph.prototype.mouseLeave = function() {
    if (!this.isListItem()) {
      this.image = this.normalImage;
      this.changed();
    }
    if (this.hint) {
      return world.hand.destroyTemporaries();
    }
  };

  MenuItemMorph.prototype.mouseDownLeft = function(pos) {
    if (this.isListItem()) {
      this.parent.unselectAllItems();
      this.escalateEvent("mouseDownLeft", pos);
    }
    this.image = this.pressImage;
    return this.changed();
  };

  MenuItemMorph.prototype.mouseMove = function() {
    if (this.isListItem()) {
      return this.escalateEvent("mouseMove");
    }
  };

  MenuItemMorph.prototype.isListItem = function() {
    if (this.parent) {
      return this.parent.isListContents;
    }
    return false;
  };

  MenuItemMorph.prototype.isSelectedListItem = function() {
    if (this.isListItem()) {
      return this.image === this.pressImage;
    }
    return false;
  };

  MenuItemMorph.coffeeScriptSourceOfThisClass = '# MenuItemMorph ///////////////////////////////////////////////////////\n\n# I automatically determine my bounds\n\nclass MenuItemMorph extends TriggerMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  # labelString can also be a Morph or a Canvas or a tuple: [icon, string]\n  constructor: (closesUnpinnedMenus, target, action, labelString, fontSize, fontStyle, centered, environment, morphEnv, hint, color, bold, italic, doubleClickAction, argumentToAction1, argumentToAction2) ->\n    #console.log "menuitem constructing"\n    super closesUnpinnedMenus, target, action, labelString, fontSize, fontStyle, centered, environment, morphEnv, hint, color, bold, italic, doubleClickAction, argumentToAction1, argumentToAction2 \n\n  getTextDescription: ->\n    if @textDescription?\n      return @textDescription + " (adhoc description of menu item)"\n    if @labelString\n      textWithoutLocationOrInstanceNo = @labelString.replace(/\[\d*@\d*[ ]*\|[ ]*\d*@\d*\]/,"")\n      textWithoutLocationOrInstanceNo = textWithoutLocationOrInstanceNo.replace(/#\d*/,"")\n      return textWithoutLocationOrInstanceNo + " (text in button)"\n    else\n      return super()\n  \n  createLabel: ->\n    # console.log "menuitem createLabel"\n    if @label?\n      @label = @label.destroy()\n\n    if isString(@labelString)\n      @label = @createLabelString(@labelString)\n    else if @labelString instanceof Array      \n      # assume its pattern is: [icon, string] \n      @label = new Morph()\n      @label.alpha = 0 # transparent\n\n      icon = @createIcon(@labelString[0])\n      @label.add icon\n      lbl = @createLabelString(@labelString[1])\n      @label.add lbl\n\n      lbl.setCenter icon.center()\n      lbl.setLeft icon.right() + 4\n      @label.bounds = (icon.bounds.merge(lbl.bounds))\n    else # assume it\'s either a Morph or a Canvas\n      @label = @createIcon(@labelString)\n\n    @add @label\n  \n    w = @width()\n    @silentSetExtent @label.extent().add(new Point(8, 0))\n    @silentSetWidth w\n    np = @position().add(new Point(4, 0))\n    @label.bounds = np.extent(@label.extent())\n  \n  createIcon: (source) ->\n    # source can be either a Morph or an HTMLCanvasElement\n    icon = new Morph()\n    icon.image = (if source instanceof Morph then source.fullImage() else source)\n\n    # adjust shadow dimensions\n    if source instanceof Morph and source.getShadow()\n      src = icon.image\n      icon.image = newCanvas(\n        source.fullBounds().extent().subtract(\n          @shadowBlur * ((if WorldMorph.preferencesAndSettings.useBlurredShadows then 1 else 2))).scaleBy pixelRatio)\n      context = icon.image.getContext("2d")\n      #context.scale pixelRatio, pixelRatio\n      context.drawImage src, 0, 0\n\n    icon.silentSetWidth icon.image.width\n    icon.silentSetHeight icon.image.height\n    icon\n\n  createLabelString: (string) ->\n    # console.log "menuitem createLabelString"\n    lbl = new TextMorph(string, @fontSize, @fontStyle)\n    lbl.setColor @labelColor\n    lbl  \n\n  # MenuItemMorph events:\n  mouseEnter: ->\n    unless @isListItem()\n      @image = @highlightImage\n      @changed()\n    if @hint\n      @startCountdownForBubbleHelp @hint\n  \n  mouseLeave: ->\n    unless @isListItem()\n      @image = @normalImage\n      @changed()\n    world.hand.destroyTemporaries()  if @hint\n  \n  mouseDownLeft: (pos) ->\n    if @isListItem()\n      @parent.unselectAllItems()\n      @escalateEvent "mouseDownLeft", pos\n    @image = @pressImage\n    @changed()\n  \n  mouseMove: ->\n    @escalateEvent "mouseMove"  if @isListItem()\n  \n  \n  isListItem: ->\n    return @parent.isListContents  if @parent\n    false\n  \n  isSelectedListItem: ->\n    return @image is @pressImage  if @isListItem()\n    false';

  return MenuItemMorph;

})(TriggerMorph);

MenuMorph = (function(_super) {
  __extends(MenuMorph, _super);

  namedClasses[MenuMorph.name] = MenuMorph.prototype;

  MenuMorph.prototype.target = null;

  MenuMorph.prototype.title = null;

  MenuMorph.prototype.environment = null;

  MenuMorph.prototype.fontSize = null;

  MenuMorph.prototype.items = null;

  MenuMorph.prototype.label = null;

  MenuMorph.prototype.isListContents = false;

  MenuMorph.prototype.killThisMenuIfClickOnDescendantsTriggers = true;

  MenuMorph.prototype.killThisMenuIfClickOutsideDescendants = true;

  MenuMorph.prototype.tempPromptEntryField = null;

  function MenuMorph(isListContents, target, killThisMenuIfClickOutsideDescendants, killThisMenuIfClickOnDescendantsTriggers, title, environment, fontSize) {
    this.isListContents = isListContents != null ? isListContents : false;
    this.target = target;
    this.killThisMenuIfClickOutsideDescendants = killThisMenuIfClickOutsideDescendants != null ? killThisMenuIfClickOutsideDescendants : true;
    this.killThisMenuIfClickOnDescendantsTriggers = killThisMenuIfClickOnDescendantsTriggers != null ? killThisMenuIfClickOnDescendantsTriggers : true;
    this.title = title != null ? title : null;
    this.environment = environment != null ? environment : null;
    this.fontSize = fontSize != null ? fontSize : null;
    this.items = [];
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.IDLE && AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism) {
      world.alignIDsOfNextMorphsInSystemTests();
    }
    if (!this.isListContents) {
      if (this.killThisMenuIfClickOutsideDescendants) {
        this.onClickOutsideMeOrAnyOfMyChildren("destroy");
      }
    }
    this.isfloatDraggable = true;
    MenuMorph.__super__.constructor.call(this);
    this.border = null;
    if (!this.isListContents) {
      world.freshlyCreatedMenus.push(this);
      world.openMenus.push(this);
    }
  }

  MenuMorph.prototype.propagateKillMenus = function() {
    if (this.killThisMenuIfClickOnDescendantsTriggers) {
      if (this.parent != null) {
        this.parent.propagateKillMenus();
      }
      return this.markForDestruction();
    }
  };

  MenuMorph.prototype.isPinned = function() {
    return !(this.killThisMenuIfClickOnDescendantsTriggers || this.killThisMenuIfClickOutsideDescendants);
  };

  MenuMorph.prototype.pin = function() {
    this.killThisMenuIfClickOnDescendantsTriggers = false;
    this.killThisMenuIfClickOutsideDescendants = false;
    this.onClickOutsideMeOrAnyOfMyChildren(null);
    return world.add(this);
  };

  MenuMorph.prototype.developersMenu = function() {
    var menu;
    menu = MenuMorph.__super__.developersMenu.call(this);
    menu.addLine();
    menu.addItem("pin", false, this, "pin");
    return menu;
  };

  MenuMorph.prototype.addItem = function(labelString, closesUnpinnedMenus, target, action, hint, color, bold, italic, doubleClickAction, argumentToAction1, argumentToAction2) {
    if (closesUnpinnedMenus == null) {
      closesUnpinnedMenus = true;
    }
    if (bold == null) {
      bold = false;
    }
    if (italic == null) {
      italic = false;
    }
    return this.items.push([localize(labelString || "close"), closesUnpinnedMenus, target, action, hint, color, bold, italic, doubleClickAction, argumentToAction1, argumentToAction2]);
  };

  MenuMorph.prototype.prependItem = function(labelString, closesUnpinnedMenus, target, action, hint, color, bold, italic, doubleClickAction, argumentToAction1, argumentToAction2) {
    if (bold == null) {
      bold = false;
    }
    if (italic == null) {
      italic = false;
    }
    return this.items.unshift([localize(labelString || "close"), closesUnpinnedMenus, target, action, hint, color, bold, italic, doubleClickAction, argumentToAction1, argumentToAction2]);
  };

  MenuMorph.prototype.addLine = function(width) {
    return this.items.push([0, width || 1]);
  };

  MenuMorph.prototype.prependLine = function(width) {
    return this.items.unshift([0, width || 1]);
  };

  MenuMorph.prototype.createLabel = function() {
    var text;
    if (this.label != null) {
      this.label = this.label.destroy();
    }
    text = new TextMorph(localize(this.title), this.fontSize || WorldMorph.preferencesAndSettings.menuFontSize, WorldMorph.preferencesAndSettings.menuFontName, true, false, "center");
    text.alignment = "center";
    text.color = new Color(255, 255, 255);
    text.backgroundColor = new Color(60, 60, 60);
    this.label = new BoxMorph(3, 0);
    this.label.add(text);
    if (WorldMorph.preferencesAndSettings.isFlat) {
      this.label.edge = 0;
    }
    this.label.color = new Color(60, 60, 60);
    this.label.setExtent(text.extent().add(4));
    return this.label.text = text;
  };

  MenuMorph.prototype.setLayoutBeforeUpdatingBackingStore = function() {
    var fb, isLine, x, y;
    isLine = false;
    this.destroyAll();
    if (!this.isListContents) {
      this.edge = WorldMorph.preferencesAndSettings.isFlat ? 0 : 5;
      this.border = WorldMorph.preferencesAndSettings.isFlat ? 1 : 2;
    }
    this.color = new Color(255, 255, 255);
    this.silentSetExtent(new Point(0, 0));
    y = this.top() + 2;
    x = this.left() + 4;
    if (!this.isListContents) {
      if (this.title) {
        this.createLabel();
        this.label.setPosition(this.bounds.origin.add(4));
        this.add(this.label);
        y = this.label.bottom();
      } else {
        y = this.top() + 4;
      }
    }
    y += 1;
    this.items.forEach((function(_this) {
      return function(tuple) {
        var item;
        isLine = false;
        if (tuple instanceof StringFieldMorph || tuple instanceof ColorPickerMorph || tuple instanceof SliderMorph) {
          item = tuple;
        } else if (tuple[0] === 0) {
          isLine = true;
          item = new Morph();
          item.color = new Color(60, 60, 60);
          item.setHeight(tuple[1]);
        } else {
          item = new MenuItemMorph(tuple[1], tuple[2], tuple[3], tuple[0], _this.fontSize || WorldMorph.preferencesAndSettings.menuFontSize, WorldMorph.preferencesAndSettings.menuFontName, false, _this.target, _this.environment, tuple[4], tuple[5], tuple[6], tuple[7], tuple[8], tuple[9], tuple[10]);
          if (_this.environment == null) {
            item.dataSourceMorphForTarget = item;
            item.morphEnv = _this.target;
          }
        }
        if (isLine) {
          y += 1;
        }
        item.setPosition(new Point(x, y));
        _this.silentAdd(item);
        y = y + item.height();
        if (isLine) {
          return y += 1;
        }
      };
    })(this));
    this.adjustWidthsOfMenuEntries();
    fb = this.boundsIncludingChildren();
    return this.silentSetExtent(fb.extent().add(4));
  };

  MenuMorph.prototype.maxWidth = function() {
    var w;
    w = 0;
    this.children.forEach(function(item) {
      if (item instanceof MenuItemMorph) {
        return w = Math.max(w, item.children[0].width() + 8);
      } else if ((item instanceof StringFieldMorph) || (item instanceof ColorPickerMorph) || (item instanceof SliderMorph)) {
        return w = Math.max(w, item.width());
      }
    });
    if (this.label) {
      w = Math.max(w, this.label.width());
    }
    return w;
  };

  MenuMorph.prototype.adjustWidthsOfMenuEntries = function() {
    var w;
    w = this.maxWidth();
    return this.children.forEach((function(_this) {
      return function(item) {
        var isSelected;
        Morph.prototype.trackChanges = false;
        item.setWidth(w);
        if (item instanceof MenuItemMorph) {
          isSelected = item.image === item.pressImage;
          if (isSelected) {
            item.image = item.pressImage;
          }
        } else {
          if (item === _this.label) {
            item.text.setPosition(item.center().subtract(item.text.extent().floorDivideBy(2)));
          }
        }
        return Morph.prototype.trackChanges = true;
      };
    })(this));
  };

  MenuMorph.prototype.unselectAllItems = function() {
    this.children.forEach(function(item) {
      if (item instanceof MenuItemMorph) {
        return item.image = item.normalImage;
      }
    });
    return this.changed();
  };

  MenuMorph.prototype.destroy = function() {
    var index;
    MenuMorph.__super__.destroy.call(this);
    if (!this.isListContents) {
      index = world.openMenus.indexOf(this);
      if (index >= 0) {
        return world.openMenus.splice(index, 1);
      }
    }
  };

  MenuMorph.prototype.itemSelected = function() {
    if (!this.isListContents) {
      return this.destroy();
    }
  };

  MenuMorph.prototype.popup = function(morphToAttachTo, pos) {
    this.silentSetPosition(pos);
    morphToAttachTo.add(this);
    this.keepWithin(world);
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.IDLE && AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism) {
      world.alignIDsOfNextMorphsInSystemTests();
    }
    this.addShadow();
    return this.fullChanged();
  };

  MenuMorph.prototype.addShadow = function(offset, alpha, color) {
    if (offset == null) {
      offset = new Point(2, 2);
    }
    if (alpha == null) {
      alpha = 0.8;
    }
    return MenuMorph.__super__.addShadow.call(this, offset, alpha, color);
  };

  MenuMorph.prototype.popUpAtHand = function(morphToAttachTo) {
    if (morphToAttachTo == null) {
      morphToAttachTo = world;
    }
    return this.popup(morphToAttachTo, world.hand.position());
  };

  MenuMorph.prototype.popUpCenteredAtHand = function(world) {
    var wrrld;
    wrrld = world || this.world();
    return this.popup(wrrld, wrrld.hand.position().subtract(this.extent().floorDivideBy(2)));
  };

  MenuMorph.prototype.popUpCenteredInWorld = function(world) {
    var wrrld;
    wrrld = world || this.world();
    return this.popup(wrrld, wrrld.center().subtract(this.extent().floorDivideBy(2)));
  };

  MenuMorph.coffeeScriptSourceOfThisClass = '# MenuMorph ///////////////////////////////////////////////////////////\n\nclass MenuMorph extends BoxMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  target: null\n  title: null\n  environment: null\n  fontSize: null\n  items: null\n  label: null\n  isListContents: false\n  killThisMenuIfClickOnDescendantsTriggers: true\n  killThisMenuIfClickOutsideDescendants: true\n  tempPromptEntryField: null\n\n  constructor: (@isListContents = false, @target, @killThisMenuIfClickOutsideDescendants = true, @killThisMenuIfClickOnDescendantsTriggers = true, @title = null, @environment = null, @fontSize = null) ->\n    # console.log "menu constructor"\n    @items = []\n    # console.log "menu super"\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n    if !@isListContents\n      if @killThisMenuIfClickOutsideDescendants\n        @onClickOutsideMeOrAnyOfMyChildren("destroy")\n    @isfloatDraggable = true\n    super()\n\n    @border = null # the Box Morph constructor puts this to 2\n    if !@isListContents\n      world.freshlyCreatedMenus.push @\n      world.openMenus.push @\n    # important not to traverse all the children for stepping through, because\n    # there could be a lot of entries for example in the inspector the number\n    # of properties of an object - there could be a 100 of those and we don\'t\n    # want to traverse them all. Setting step to null (as opposed to nop)\n    # achieves that.      \n\n  propagateKillMenus: ->\n    if @killThisMenuIfClickOnDescendantsTriggers\n      if @parent?\n        @parent.propagateKillMenus()\n      @markForDestruction()\n\n  isPinned: ->\n    return !(@killThisMenuIfClickOnDescendantsTriggers or @killThisMenuIfClickOutsideDescendants)\n\n  pin: ->\n    @killThisMenuIfClickOnDescendantsTriggers = false\n    @killThisMenuIfClickOutsideDescendants = false\n    @onClickOutsideMeOrAnyOfMyChildren null\n    world.add @\n\n  # StringMorph menus:\n  developersMenu: ->\n    menu = super()\n    menu.addLine()\n    menu.addItem "pin", false, @, "pin"\n    menu\n  \n  addItem: (\n      labelString,\n      closesUnpinnedMenus = true,\n      target,\n      action,\n      hint,\n      color,\n      bold = false,\n      italic = false,\n      doubleClickAction, # optional, when used as list contents\n      argumentToAction1,\n      argumentToAction2\n      ) ->\n    # labelString is normally a single-line string. But it can also be one\n    # of the following:\n    #     * a multi-line string (containing line breaks)\n    #     * an icon (either a Morph or a Canvas)\n    #     * a tuple of format: [icon, string]\n    @items.push [\n      localize(labelString or "close"),\n      closesUnpinnedMenus,\n      target,\n      action,\n      hint,\n      color,\n      bold,\n      italic,\n      doubleClickAction,\n      argumentToAction1,\n      argumentToAction2\n    ]\n\n  prependItem: (\n      labelString,\n      closesUnpinnedMenus,\n      target,\n      action,\n      hint,\n      color,\n      bold = false,\n      italic = false,\n      doubleClickAction, # optional, when used as list contents\n      argumentToAction1,\n      argumentToAction2\n      ) ->\n    # labelString is normally a single-line string. But it can also be one\n    # of the following:\n    #     * a multi-line string (containing line breaks)\n    #     * an icon (either a Morph or a Canvas)\n    #     * a tuple of format: [icon, string]\n    @items.unshift [\n      localize(labelString or "close"),\n      closesUnpinnedMenus,\n      target,\n      action,\n      hint,\n      color,\n      bold,\n      italic,\n      doubleClickAction,\n      argumentToAction1,\n      argumentToAction2\n    ]\n  \n\n  addLine: (width) ->\n    @items.push [0, width or 1]\n\n  prependLine: (width) ->\n    @items.unshift [0, width or 1]\n  \n  createLabel: ->\n    # console.log "menu create label"\n    if @label?\n      @label = @label.destroy()\n    text = new TextMorph(localize(@title),\n      @fontSize or WorldMorph.preferencesAndSettings.menuFontSize,\n      WorldMorph.preferencesAndSettings.menuFontName, true, false, "center")\n    text.alignment = "center"\n    text.color = new Color(255, 255, 255)\n    text.backgroundColor = new Color 60,60,60\n\n    @label = new BoxMorph(3, 0)\n    @label.add text\n    if WorldMorph.preferencesAndSettings.isFlat\n      @label.edge = 0\n    @label.color = new Color 60,60,60\n    @label.setExtent text.extent().add(4) # here!\n    @label.text = text\n\n  setLayoutBeforeUpdatingBackingStore: ->\n    # console.log "menu update rendering"\n    isLine = false\n    @destroyAll()\n\n    unless @isListContents\n      @edge = if WorldMorph.preferencesAndSettings.isFlat then 0 else 5\n      @border = if WorldMorph.preferencesAndSettings.isFlat then 1 else 2\n    @color = new Color(255, 255, 255)\n    @silentSetExtent new Point(0, 0)\n    y = @top() + 2\n    x = @left() + 4\n\n\n    unless @isListContents\n      if @title\n        @createLabel()\n        @label.setPosition @bounds.origin.add(4)\n        @add @label\n        y = @label.bottom()\n      else\n        y = @top() + 4\n    y += 1\n\n    # note that menus can contain:\n    # strings, colorpickers,\n    # sliders, menuItems (which are buttons)\n    # and lines.\n    # console.log "menu @items.length " + @items.length\n    @items.forEach (tuple) =>\n      isLine = false\n      # string, color picker and slider\n      if tuple instanceof StringFieldMorph or\n        tuple instanceof ColorPickerMorph or\n        tuple instanceof SliderMorph\n          item = tuple\n      # line. A thin Morph is used\n      # to draw the line.\n      else if tuple[0] is 0\n        isLine = true\n        item = new Morph()\n        item.color = new Color 60,60,60\n        item.setHeight tuple[1]\n      # menuItem\n      else\n        # console.log "menu creating MenuItemMorph "\n        item = new MenuItemMorph(\n          tuple[1], # closes unpinned menus\n          tuple[2], # target\n          tuple[3], # action\n          tuple[0], # label\n          @fontSize or WorldMorph.preferencesAndSettings.menuFontSize,\n          WorldMorph.preferencesAndSettings.menuFontName,\n          false,\n          @target, # environment\n          @environment, # environment2\n          tuple[4], # bubble help hint\n          tuple[5], # color\n          tuple[6], # bold\n          tuple[7], # italic\n          tuple[8],  # doubleclick action\n          tuple[9],  # argument to action 1\n          tuple[10]  # argument to action 2\n          )\n        if !@environment?\n          item.dataSourceMorphForTarget = item\n          item.morphEnv = @target\n        #if tuple[1] == null\n        #  debugger\n        #  item.environment = item\n      y += 1  if isLine\n      item.setPosition new Point(x, y)\n      # we do a silentAdd here because we are going\n      # to update all the morphs again later in\n      # adjustWidthsOfMenuEntries\n      # (cause we need to know the maximum width first)\n      @silentAdd item\n      #console.log "item added: " + item.bounds\n      y = y + item.height()\n      y += 1  if isLine\n  \n    @adjustWidthsOfMenuEntries()\n    fb = @boundsIncludingChildren()\n    #console.log "fb: " + fb\n    @silentSetExtent fb.extent().add(4)\n  \n  maxWidth: ->\n    w = 0\n    #if @parent instanceof FrameMorph\n    #  if @parent.scrollFrame instanceof ScrollFrameMorph\n    #    w = @parent.scrollFrame.width()    \n    @children.forEach (item) ->\n      if (item instanceof MenuItemMorph)\n        w = Math.max(w, item.children[0].width() + 8)\n      else if (item instanceof StringFieldMorph) or\n        (item instanceof ColorPickerMorph) or\n        (item instanceof SliderMorph)\n          w = Math.max(w, item.width())\n      #console.log "maxWidth: width of item " + item + " : " + w\n\n    if @label\n      w = Math.max(w, @label.width())\n      #console.log "maxWidth: label width : " + w\n    w\n  \n  # makes all the elements of this menu the\n  # right width.\n  adjustWidthsOfMenuEntries: ->\n    w = @maxWidth()\n    #console.log "maxwidth " + w\n    @children.forEach (item) =>\n      Morph::trackChanges = false\n      item.setWidth w\n      if item instanceof MenuItemMorph\n        isSelected = (item.image == item.pressImage)\n        if isSelected then item.image = item.pressImage          \n      else\n        if item is @label\n          item.text.setPosition item.center().subtract(item.text.extent().floorDivideBy(2))\n      #console.log "new width of " + item + " : " + item.width()\n      Morph::trackChanges = true\n\n  \n  unselectAllItems: ->\n    @children.forEach (item) ->\n      item.image = item.normalImage  if item instanceof MenuItemMorph\n\n    @changed()\n\n  destroy: ->\n    super()\n    if !@isListContents\n      index = world.openMenus.indexOf @\n      if index >= 0\n        world.openMenus.splice index, 1\n\n\n  itemSelected: ->\n    unless @isListContents\n      @destroy()\n  \n  popup: (morphToAttachTo, pos) ->\n    # console.log "menu popup"\n    @silentSetPosition pos\n    morphToAttachTo.add @\n    # the @keepWithin method\n    # needs to know the extent of the morph\n    # so it must be called after the morphToAttachTo.add\n    # method. If you call before, there is\n    # nopainting happening and the morph doesn\'t\n    # know its extent.\n    @keepWithin world\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n    # shadow must be added after the morph\n    # has been placed somewhere because\n    # otherwise there is no visible image\n    # to base the shadow on\n    # P.S. this is the thing that causes the MenuMorph buffer\n    # to be painted after the creation.\n    @addShadow()\n    @fullChanged()\n\n  # shadow is added to a morph by\n  # the HandMorph while floatDragging\n  addShadow: (offset = new Point(2, 2), alpha = 0.8, color) ->\n    super offset, alpha, color\n  \n  popUpAtHand: (morphToAttachTo)->\n    if !morphToAttachTo?\n      morphToAttachTo = world\n    @popup morphToAttachTo, world.hand.position()\n  \n  popUpCenteredAtHand: (world) ->\n    wrrld = world or @world()\n    @popup wrrld, wrrld.hand.position().subtract(@extent().floorDivideBy(2))\n  \n  popUpCenteredInWorld: (world) ->\n    wrrld = world or @world()\n    @popup wrrld, wrrld.center().subtract(@extent().floorDivideBy(2))\n';

  return MenuMorph;

})(BoxMorph);

MorphsListMorph = (function(_super) {
  __extends(MorphsListMorph, _super);

  namedClasses[MorphsListMorph.name] = MorphsListMorph.prototype;

  MorphsListMorph.prototype.morphsList = null;

  MorphsListMorph.prototype.buttonClose = null;

  MorphsListMorph.prototype.resizer = null;

  function MorphsListMorph(target) {
    MorphsListMorph.__super__.constructor.call(this);
    this.silentSetExtent(new Point(WorldMorph.preferencesAndSettings.handleSize * 10, WorldMorph.preferencesAndSettings.handleSize * 20 * 2 / 3));
    this.isfloatDraggable = true;
    this.border = 1;
    this.edge = 5;
    this.color = new Color(60, 60, 60);
    this.buildAndConnectChildren();
  }

  MorphsListMorph.prototype.setTarget = function(target) {
    this.target = target;
    this.currentProperty = null;
    return this.buildAndConnectChildren();
  };

  MorphsListMorph.prototype.buildAndConnectChildren = function() {
    var ListOfMorphs, theWordMorph;
    this.attribs = [];
    this.destroyAll();
    this.label = new TextMorph("Morphs List");
    this.label.fontSize = WorldMorph.preferencesAndSettings.menuFontSize;
    this.label.isBold = true;
    this.label.color = new Color(255, 255, 255);
    this.add(this.label);
    theWordMorph = "Morph";
    ListOfMorphs = (Object.keys(window)).filter(function(i) {
      return i.indexOf(theWordMorph, i.length - theWordMorph.length) !== -1;
    });
    this.morphsList = new ListMorph(ListOfMorphs, null);
    this.morphsList.hBar.alpha = 0.6;
    this.morphsList.vBar.alpha = 0.6;
    this.add(this.morphsList);
    this.buttonClose = new TriggerMorph(true, this);
    this.buttonClose.setLabel("close");
    this.buttonClose.action = "destroy";
    this.add(this.buttonClose);
    this.resizer = new HandleMorph(this, 150, 100, this.edge, this.edge);
    return this.layoutSubmorphs();
  };

  MorphsListMorph.prototype.layoutSubmorphs = function() {
    var b, h, r, w, x, y;
    Morph.prototype.trackChanges = false;
    x = this.left() + this.edge;
    y = this.top() + this.edge;
    r = this.right() - this.edge;
    w = r - x;
    this.label.setPosition(new Point(x, y));
    this.label.setWidth(w);
    if (this.label.height() > (this.height() - 50)) {
      this.setHeight(this.label.height() + 50);
      this.changed();
    }
    y = this.label.bottom() + 2;
    w = this.width() - this.edge;
    w -= this.edge;
    b = this.bottom() - (2 * this.edge) - WorldMorph.preferencesAndSettings.handleSize;
    h = b - y;
    this.morphsList.setPosition(new Point(x, y));
    this.morphsList.setExtent(new Point(w, h));
    x = this.morphsList.left();
    y = this.morphsList.bottom() + this.edge;
    h = WorldMorph.preferencesAndSettings.handleSize;
    w = this.morphsList.width() - h - this.edge;
    this.buttonClose.setPosition(new Point(x, y));
    this.buttonClose.setExtent(new Point(w, h));
    Morph.prototype.trackChanges = true;
    return this.changed();
  };

  MorphsListMorph.prototype.setExtent = function(aPoint) {
    return MorphsListMorph.__super__.setExtent.call(this, aPoint);
  };

  MorphsListMorph.coffeeScriptSourceOfThisClass = '# MorphsListMorph //////////////////////////////////////////////////////\n\nclass MorphsListMorph extends BoxMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  # panes:\n  morphsList: null\n  buttonClose: null\n  resizer: null\n\n  constructor: (target) ->\n    super()\n\n    @silentSetExtent new Point(\n      WorldMorph.preferencesAndSettings.handleSize * 10,\n      WorldMorph.preferencesAndSettings.handleSize * 20 * 2 / 3)\n    @isfloatDraggable = true\n    @border = 1\n    @edge = 5\n    @color = new Color(60, 60, 60)\n    @buildAndConnectChildren()\n  \n  setTarget: (target) ->\n    @target = target\n    @currentProperty = null\n    @buildAndConnectChildren()\n  \n  buildAndConnectChildren: ->\n    @attribs = []\n\n    # remove existing panes\n    @destroyAll()\n\n    # label\n    @label = new TextMorph("Morphs List")\n    @label.fontSize = WorldMorph.preferencesAndSettings.menuFontSize\n    @label.isBold = true\n    @label.color = new Color(255, 255, 255)\n    @add @label\n\n    # Check which objects end with the word Morph\n    theWordMorph = "Morph"\n    ListOfMorphs = (Object.keys(window)).filter (i) ->\n      i.indexOf(theWordMorph, i.length - theWordMorph.length) isnt -1\n    @morphsList = new ListMorph(ListOfMorphs, null)\n\n    # so far nothing happens when items are selected\n    #@morphsList.action = (selected) ->\n    #  val = myself.target[selected]\n    #  myself.currentProperty = val\n    #  if val is null\n    #    txt = "NULL"\n    #  else if isString(val)\n    #    txt = val\n    #  else\n    #    txt = val.toString()\n    #  cnts = new TextMorph(txt)\n    #  cnts.isEditable = true\n    #  cnts.enableSelecting()\n    #  cnts.setReceiver myself.target\n    #  myself.detail.setContents cnts\n\n    @morphsList.hBar.alpha = 0.6\n    @morphsList.vBar.alpha = 0.6\n    @add @morphsList\n\n    # close button\n    @buttonClose = new TriggerMorph(true, @)\n    @buttonClose.setLabel "close"\n    @buttonClose.action = "destroy"\n\n    @add @buttonClose\n\n    # resizer\n    @resizer = new HandleMorph(@, 150, 100, @edge, @edge)\n\n    # update layout\n    @layoutSubmorphs()\n  \n  layoutSubmorphs: ->\n    Morph::trackChanges = false\n\n    # label\n    x = @left() + @edge\n    y = @top() + @edge\n    r = @right() - @edge\n    w = r - x\n    @label.setPosition new Point(x, y)\n    @label.setWidth w\n    if @label.height() > (@height() - 50)\n      @setHeight @label.height() + 50\n      @changed()\n      #@resizer.updateBackingStore()\n\n    # morphsList\n    y = @label.bottom() + 2\n    w = @width() - @edge\n    w -= @edge\n    b = @bottom() - (2 * @edge) - WorldMorph.preferencesAndSettings.handleSize\n    h = b - y\n    @morphsList.setPosition new Point(x, y)\n    @morphsList.setExtent new Point(w, h)\n\n    # close button\n    x = @morphsList.left()\n    y = @morphsList.bottom() + @edge\n    h = WorldMorph.preferencesAndSettings.handleSize\n    w = @morphsList.width() - h - @edge\n    @buttonClose.setPosition new Point(x, y)\n    @buttonClose.setExtent new Point(w, h)\n    Morph::trackChanges = true\n    @changed()\n  \n  setExtent: (aPoint) ->\n    super aPoint';

  return MorphsListMorph;

})(BoxMorph);

MouseSensorMorph = (function(_super) {
  __extends(MouseSensorMorph, _super);

  namedClasses[MouseSensorMorph.name] = MouseSensorMorph.prototype;

  function MouseSensorMorph(edge, border) {
    MouseSensorMorph.__super__.constructor.apply(this, arguments);
    this.edge = edge || 4;
    this.border = border || 2;
    this.color = new Color(255, 255, 255);
    this.isTouched = false;
    this.upStep = 0.05;
    this.downStep = 0.02;
    this.noticesTransparentClick = false;
  }

  MouseSensorMorph.prototype.touch = function() {
    if (!this.isTouched) {
      this.isTouched = true;
      this.alpha = 0.6;
      return this.step = (function(_this) {
        return function() {
          if (_this.isTouched) {
            if (_this.alpha < 1) {
              _this.alpha = _this.alpha + _this.upStep;
            }
          } else if (_this.alpha > _this.downStep) {
            _this.alpha = _this.alpha - _this.downStep;
          } else {
            _this.alpha = 0;
            _this.step = null;
          }
          return _this.changed();
        };
      })(this);
    }
  };

  MouseSensorMorph.prototype.unTouch = function() {
    return this.isTouched = false;
  };

  MouseSensorMorph.prototype.mouseEnter = function() {
    return this.touch();
  };

  MouseSensorMorph.prototype.mouseLeave = function() {
    return this.unTouch();
  };

  MouseSensorMorph.prototype.mouseDownLeft = function() {
    return this.touch();
  };

  MouseSensorMorph.prototype.mouseClickLeft = function() {
    return this.unTouch();
  };

  MouseSensorMorph.coffeeScriptSourceOfThisClass = '# MouseSensorMorph ////////////////////////////////////////////////////\n\n# for demo and debugging purposes only, to be removed later\nclass MouseSensorMorph extends BoxMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  constructor: (edge, border) ->\n    super\n    @edge = edge or 4\n    @border = border or 2\n    @color = new Color(255, 255, 255)\n    @isTouched = false\n    @upStep = 0.05\n    @downStep = 0.02\n    @noticesTransparentClick = false\n  \n  touch: ->\n    unless @isTouched\n      @isTouched = true\n      @alpha = 0.6\n      @step = =>\n        if @isTouched\n          @alpha = @alpha + @upStep  if @alpha < 1\n        else if @alpha > (@downStep)\n          @alpha = @alpha - @downStep\n        else\n          @alpha = 0\n          @step = null\n        @changed()\n  \n  unTouch: ->\n    @isTouched = false\n  \n  mouseEnter: ->\n    @touch()\n  \n  mouseLeave: ->\n    @unTouch()\n  \n  mouseDownLeft: ->\n    @touch()\n  \n  mouseClickLeft: ->\n    @unTouch()';

  return MouseSensorMorph;

})(BoxMorph);


/*
Copyright 2013 Craig Campbell
coffeescript port by Davide Della Casa

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Mousetrap is a simple keyboard shortcut library for Javascript with
no external dependencies

@version 1.3.1
@url craig.is/killing/mice
 */


/*
mapping of special keycodes to their corresponding keys

everything in this dictionary cannot use keypress events
so it has to be here to map to the correct keycodes for
keyup/keydown events

@type {Object}
 */

_MAP = {
  8: "backspace",
  9: "tab",
  13: "enter",
  16: "shift",
  17: "ctrl",
  18: "alt",
  20: "capslock",
  27: "esc",
  32: "space",
  33: "pageup",
  34: "pagedown",
  35: "end",
  36: "home",
  37: "left",
  38: "up",
  39: "right",
  40: "down",
  45: "ins",
  46: "del",
  91: "meta",
  93: "meta",
  224: "meta"
};


/*
mapping for special characters so they can support

this dictionary is only used incase you want to bind a
keyup or keydown event to one of these keys

@type {Object}
 */

_KEYCODE_MAP = {
  106: "*",
  107: "+",
  109: "-",
  110: ".",
  111: "/",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};


/*
this is a mapping of keys that require shift on a US keypad
back to the non shift equivelents

this is so you can use keyup events with these keys

note that this will only work reliably on US keyboards

@type {Object}
 */

_SHIFT_MAP = {
  "~": "`",
  "!": "1",
  "@": "2",
  "#": "3",
  $: "4",
  "%": "5",
  "^": "6",
  "&": "7",
  "*": "8",
  "(": "9",
  ")": "0",
  _: "-",
  "+": "=",
  ":": ";",
  "\"": "'",
  "<": ",",
  ">": ".",
  "?": "/",
  "|": "\\"
};


/*
this is a list of special strings you can use to map
to modifier keys when you specify your keyboard shortcuts

@type {Object}
 */

_SPECIAL_ALIASES = {
  option: "alt",
  command: "meta",
  "return": "enter",
  escape: "esc"
};


/*
variable to store the flipped version of _MAP from above
needed to check if we should use keypress or not when no action
is specified

@type {Object|undefined}
 */

_REVERSE_MAP = void 0;


/*
a list of all the callbacks setup via Mousetrap.bind()

@type {Object}
 */

_callbacks = {};


/*
direct map of string combinations to callbacks used for trigger()

@type {Object}
 */

_directMap = {};


/*
keeps track of what level each sequence is at since multiple
sequences can start out with the same sequence

@type {Object}
 */

_sequenceLevels = {};


/*
variable to store the setTimeout call

@type {null|number}
 */

_resetTimer = void 0;


/*
temporary state where we will ignore the next keyup

@type {boolean|string}
 */

_ignoreNextKeyup = false;


/*
are we currently inside of a sequence?
type of action ("keyup" or "keydown" or "keypress") or false

@type {boolean|string}
 */

_sequenceType = false;


/*
loop through the f keys, f1 to f19 and add them to the map
programmatically
 */

i = 1;

while (i < 20) {
  _MAP[111 + i] = "f" + i;
  ++i;
}


/*
loop through to map numbers on the numeric keypad
 */

i = 0;

while (i <= 9) {
  _MAP[i + 96] = i;
  ++i;
}


/*
cross browser add event method

@param {Element|HTMLDocument} object
@param {string} type
@param {Function} callback
@returns void
 */

_addEvent = function(object, type, callback) {
  if (object.addEventListener) {
    object.addEventListener(type, callback, false);
    return;
  }
  return object.attachEvent("on" + type, callback);
};


/*
takes the event and returns the key character

@param {Event} e
@return {string}
 */

_characterFromEvent = function(e) {
  if (e.type === "keypress") {
    return String.fromCharCode(e.which);
  }
  if (_MAP[e.which]) {
    return _MAP[e.which];
  }
  if (_KEYCODE_MAP[e.which]) {
    return _KEYCODE_MAP[e.which];
  }
  return String.fromCharCode(e.which).toLowerCase();
};


/*
checks if two arrays are equal

@param {Array} modifiers1
@param {Array} modifiers2
@returns {boolean}
 */

_modifiersMatch = function(modifiers1, modifiers2) {
  return modifiers1.sort().join(",") === modifiers2.sort().join(",");
};


/*
resets all sequence counters except for the ones passed in

@param {Object} doNotReset
@returns void
 */

_resetSequences = function(doNotReset, maxLevel) {
  var activeSequences, key;
  doNotReset = doNotReset || {};
  activeSequences = false;
  key = void 0;
  for (key in _sequenceLevels) {
    if (doNotReset[key] && _sequenceLevels[key] > maxLevel) {
      activeSequences = true;
      continue;
    }
    _sequenceLevels[key] = 0;
  }
  if (!activeSequences) {
    return _sequenceType = false;
  }
};


/*
finds all callbacks that match based on the keycode, modifiers,
and action

@param {string} character
@param {Array} modifiers
@param {Event|Object} e
@param {boolean=} remove - should we remove any matches
@param {string=} combination
@returns {Array}
 */

_getMatches = function(character, modifiers, e, remove, combination) {
  var action, callback, matches, _i, _ref;
  i = void 0;
  callback = void 0;
  matches = [];
  action = e.type;
  if (!_callbacks[character]) {
    return [];
  }
  if (action === "keyup" && _isModifier(character)) {
    modifiers = [character];
  }
  for (i = _i = 0, _ref = _callbacks[character].length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    callback = _callbacks[character][i];
    if (callback.seq && _sequenceLevels[callback.seq] !== callback.level) {
      continue;
    }
    if (action !== callback.action) {
      continue;
    }
    if ((action === "keypress" && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {
      if (remove && callback.combo === combination) {
        _callbacks[character].splice(i, 1);
      }
      matches.push(callback);
    }
  }
  return matches;
};


/*
takes a key event and figures out what the modifiers are

@param {Event} e
@returns {Array}
 */

_eventModifiers = function(e) {
  var modifiers;
  modifiers = [];
  if (e.shiftKey) {
    modifiers.push("shift");
  }
  if (e.altKey) {
    modifiers.push("alt");
  }
  if (e.ctrlKey) {
    modifiers.push("ctrl");
  }
  if (e.metaKey) {
    modifiers.push("meta");
  }
  return modifiers;
};


/*
actually calls the callback function

if your callback function returns false this will use the jquery
convention - prevent default and stop propagation on the event

@param {Function} callback
@param {Event} e
@returns void
 */

_fireCallback = function(callback, e, combo) {
  if (Mousetrap.stopCallback(e, e.target || e.srcElement, combo)) {
    return;
  }
  if (callback(e, combo) === false) {
    if (e.preventDefault) {
      e.preventDefault();
    }
    if (e.stopPropagation) {
      e.stopPropagation();
    }
    e.returnValue = false;
    return e.cancelBubble = true;
  }
};


/*
handles a character key event

@param {string} character
@param {Event} e
@returns void
 */

_handleCharacter = function(character, e) {
  var callbacks, doNotReset, maxLevel, processedSequenceCallback;
  callbacks = _getMatches(character, _eventModifiers(e), e);
  i = void 0;
  doNotReset = {};
  maxLevel = 0;
  processedSequenceCallback = false;
  i = 0;
  while (i < callbacks.length) {
    if (callbacks[i].seq) {
      processedSequenceCallback = true;
      maxLevel = Math.max(maxLevel, callbacks[i].level);
      doNotReset[callbacks[i].seq] = 1;
      _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
      continue;
    }
    if (!processedSequenceCallback && !_sequenceType) {
      _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
    }
    ++i;
  }
  if (e.type === _sequenceType && !_isModifier(character)) {
    return _resetSequences(doNotReset, maxLevel);
  }
};


/*
handles a keydown event

@param {Event} e
@returns void
 */

_handleKey = function(e) {
  var character;
  if (typeof e.which !== "number") {
    e.which = e.keyCode;
  }
  character = _characterFromEvent(e);
  if (!character) {
    return;
  }
  if (e.type === "keyup" && _ignoreNextKeyup === character) {
    _ignoreNextKeyup = false;
    return;
  }
  return _handleCharacter(character, e);
};


/*
determines if the keycode specified is a modifier key or not

@param {string} key
@returns {boolean}
 */

_isModifier = function(key) {
  return key === "shift" || key === "ctrl" || key === "alt" || key === "meta";
};


/*
called to set a 1 second timeout on the specified sequence

this is so after each key press in the sequence you have 1 second
to press the next key before you have to start over

@returns void
 */

_resetSequenceTimer = function() {
  clearTimeout(_resetTimer);
  return _resetTimer = setTimeout(_resetSequences, 1000);
};


/*
reverses the map lookup so that we can look for specific keys
to see what can and can't use keypress

@return {Object}
 */

_getReverseMap = function() {
  var key;
  if (!_REVERSE_MAP) {
    _REVERSE_MAP = {};
    for (key in _MAP) {
      if (key > 95 && key < 112) {
        continue;
      }
      if (_MAP.hasOwnProperty(key)) {
        _REVERSE_MAP[_MAP[key]] = key;
      }
    }
  }
  return _REVERSE_MAP;
};


/*
picks the best action based on the key combination

@param {string} key - character for key
@param {Array} modifiers
@param {string=} action passed in
 */

_pickBestAction = function(key, modifiers, action) {
  if (!action) {
    action = (_getReverseMap()[key] ? "keydown" : "keypress");
  }
  if (action === "keypress" && modifiers.length) {
    action = "keydown";
  }
  return action;
};


/*
binds a key sequence to an event

@param {string} combo - combo specified in bind call
@param {Array} keys
@param {Function} callback
@param {string=} action
@returns void
 */

_bindSequence = function(combo, keys, callback, action) {
  var _callbackAndReset, _increaseSequence, _results;
  _sequenceLevels[combo] = 0;
  if (!action) {
    action = _pickBestAction(keys[0], []);
  }

  /*
  callback to increase the sequence level for this sequence and reset
  all other sequences that were active
  
  @param {Event} e
  @returns void
   */
  _increaseSequence = function() {
    _sequenceType = action;
    ++_sequenceLevels[combo];
    return _resetSequenceTimer();
  };

  /*
  wraps the specified callback inside of another function in order
  to reset all sequence counters as soon as this sequence is done
  
  @param {Event} e
  @returns void
   */
  _callbackAndReset = function(e) {
    _fireCallback(callback, e, combo);
    if (action !== "keyup") {
      _ignoreNextKeyup = _characterFromEvent(e);
    }
    return setTimeout(_resetSequences, 10);
  };
  i = void 0;
  i = 0;
  _results = [];
  while (i < keys.length) {
    _bindSingle(keys[i], (i < keys.length - 1 ? _increaseSequence : _callbackAndReset), action, combo, i);
    _results.push(++i);
  }
  return _results;
};


/*
binds a single keyboard combination

@param {string} combination
@param {Function} callback
@param {string=} action
@param {string=} sequenceName - name of sequence if part of sequence
@param {number=} level - what part of the sequence the command is
@returns void
 */

_bindSingle = function(combination, callback, action, sequenceName, level) {
  var key, keys, modifiers, sequence;
  _directMap[combination + ":" + action] = callback;
  combination = combination.replace(/\s+/g, " ");
  sequence = combination.split(" ");
  i = void 0;
  key = void 0;
  keys = void 0;
  modifiers = [];
  if (sequence.length > 1) {
    _bindSequence(combination, sequence, callback, action);
    return;
  }
  keys = (combination === "+" ? ["+"] : combination.split("+"));
  i = 0;
  while (i < keys.length) {
    key = keys[i];
    if (_SPECIAL_ALIASES[key]) {
      key = _SPECIAL_ALIASES[key];
    }
    if (action && action !== "keypress" && _SHIFT_MAP[key]) {
      key = _SHIFT_MAP[key];
      modifiers.push("shift");
    }
    if (_isModifier(key)) {
      modifiers.push(key);
    }
    ++i;
  }
  action = _pickBestAction(key, modifiers, action);
  if (!_callbacks[key]) {
    _callbacks[key] = [];
  }
  _getMatches(key, modifiers, {
    type: action
  }, !sequenceName, combination);
  return _callbacks[key][(sequenceName ? "unshift" : "push")]({
    callback: callback,
    modifiers: modifiers,
    action: action,
    seq: sequenceName,
    level: level,
    combo: combination
  });
};


/*
binds multiple combinations to the same callback

@param {Array} combinations
@param {Function} callback
@param {string|undefined} action
@returns void
 */

_bindMultiple = function(combinations, callback, action) {
  var _results;
  i = 0;
  _results = [];
  while (i < combinations.length) {
    _bindSingle(combinations[i], callback, action);
    _results.push(++i);
  }
  return _results;
};

_addEvent(document, "keypress", _handleKey);

_addEvent(document, "keydown", _handleKey);

_addEvent(document, "keyup", _handleKey);

Mousetrap = {

  /*
  binds an event to mousetrap
  
  can be a single key, a combination of keys separated with +,
  an array of keys, or a sequence of keys separated by spaces
  
  be sure to list the modifier keys first to make sure that the
  correct key ends up getting bound (the last key in the pattern)
  
  @param {string|Array} keys
  @param {Function} callback
  @param {string=} action - 'keypress', 'keydown', or 'keyup'
  @returns void
   */
  bind: function(keys, callback, action) {
    keys = (keys instanceof Array ? keys : [keys]);
    _bindMultiple(keys, callback, action);
    return this;
  },

  /*
  unbinds an event to mousetrap
  
  the unbinding sets the callback function of the specified key combo
  to an empty function and deletes the corresponding key in the
  _directMap dict.
  
  TODO: actually remove this from the _callbacks dictionary instead
  of binding an empty function
  
  the keycombo+action has to be exactly the same as
  it was defined in the bind method
  
  @param {string|Array} keys
  @param {string} action
  @returns void
   */
  unbind: function(keys, action) {
    return Mousetrap.bind(keys, (function() {}), action);
  },

  /*
  triggers an event that has already been bound
  
  @param {string} keys
  @param {string=} action
  @returns void
   */
  trigger: function(keys, action) {
    if (_directMap[keys + ":" + action]) {
      _directMap[keys + ":" + action]({}, keys);
    }
    return this;
  },

  /*
  resets the library back to its initial state.  this is useful
  if you want to clear out the current keyboard shortcuts and bind
  new ones - for example if you switch to another page
  
  @returns void
   */
  reset: function() {
    _callbacks = {};
    _directMap = {};
    return this;
  },

  /*
  should we stop this event before firing off callbacks
  
  @param {Event} e
  @param {Element} element
  @return {boolean}
   */
  stopCallback: function(e, element) {
    if ((" " + element.className + " ").indexOf(" mousetrap ") > -1) {
      return false;
    }
    return element.tagName === "INPUT" || element.tagName === "SELECT" || element.tagName === "TEXTAREA" || (element.contentEditable && element.contentEditable === "true");
  }
};

window.Mousetrap = Mousetrap;

PenMorph = (function(_super) {
  __extends(PenMorph, _super);

  namedClasses[PenMorph.name] = PenMorph.prototype;

  PenMorph.augmentWith(BackingStoreMixin);

  PenMorph.prototype.heading = 0;

  PenMorph.prototype.penSize = null;

  PenMorph.prototype.isWarped = false;

  PenMorph.prototype.isDown = true;

  PenMorph.prototype.wantsRedraw = false;

  PenMorph.prototype.penPoint = 'tip';

  function PenMorph() {
    this.penSize = WorldMorph.preferencesAndSettings.handleSize * 4;
    PenMorph.__super__.constructor.call(this);
    this.setExtent(new Point(this.penSize, this.penSize));
    this.penSize = 1;
  }

  PenMorph.staticVariable = 1;

  PenMorph.staticFunction = function() {
    return 3.14;
  };

  PenMorph.prototype.imBeingAddedTo = function(newParentMorph) {
    if (!(newParentMorph instanceof HandMorph || newParentMorph instanceof CanvasMorph)) {
      return this.inform("a pen will only\nwork on a canvas...");
    }
  };

  PenMorph.prototype.changed = function() {
    var w;
    if (this.isWarped === false) {
      w = this.root();
      if (w instanceof WorldMorph && (this instanceof WorldMorph || (this.parent != null))) {
        w.broken.push(this.visibleBounds().spread());
      }
      if (this.parent) {
        return this.parent.childChanged(this);
      }
    }
  };

  PenMorph.prototype.updateBackingStore = function(facing) {
    var context, dest, direction, left, len, right, start;
    direction = facing || this.heading;
    if (this.isWarped) {
      this.wantsRedraw = true;
      return;
    }
    this.image = newCanvas(this.extent().scaleBy(pixelRatio));
    context = this.image.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    len = this.width() / 2;
    start = this.center().subtract(this.bounds.origin);
    if (this.penPoint === "tip") {
      dest = start.distanceAngle(len * 0.75, direction - 180);
      left = start.distanceAngle(len, direction + 195);
      right = start.distanceAngle(len, direction - 195);
    } else {
      dest = start.distanceAngle(len * 0.75, direction);
      left = start.distanceAngle(len * 0.33, direction + 230);
      right = start.distanceAngle(len * 0.33, direction - 230);
    }
    context.fillStyle = this.color.toString();
    context.beginPath();
    context.moveTo(start.x, start.y);
    context.lineTo(left.x, left.y);
    context.lineTo(dest.x, dest.y);
    context.lineTo(right.x, right.y);
    context.closePath();
    context.strokeStyle = "white";
    context.lineWidth = 3;
    context.stroke();
    context.strokeStyle = "black";
    context.lineWidth = 1;
    context.stroke();
    context.fill();
    return this.wantsRedraw = false;
  };

  PenMorph.prototype.setHeading = function(degrees) {
    this.heading = parseFloat(degrees) % 360;
    this.updateBackingStore();
    return this.changed();
  };

  PenMorph.prototype.drawLine = function(start, dest) {
    var context, from, to;
    if (this.parent.penTrails == null) {
      return;
    }
    context = this.parent.penTrails().getContext("2d");
    from = start.subtract(this.parent.bounds.origin);
    to = dest.subtract(this.parent.bounds.origin);
    if (this.isDown) {
      context.lineWidth = this.penSize;
      context.strokeStyle = this.color.toString();
      context.lineCap = "round";
      context.lineJoin = "round";
      context.beginPath();
      context.moveTo(from.x, from.y);
      context.lineTo(to.x, to.y);
      context.stroke();
      if (this.isWarped === false && (this instanceof WorldMorph || (this.parent != null))) {
        return this.world().broken.push(start.rectangle(dest).expandBy(Math.max(this.penSize / 2, 1)).intersect(this.parent.visibleBounds()).spread());
      }
    }
  };

  PenMorph.prototype.turn = function(degrees) {
    return this.setHeading(this.heading + parseFloat(degrees));
  };

  PenMorph.prototype.forward = function(steps) {
    var dest, dist, start;
    start = this.center();
    dist = parseFloat(steps);
    if (dist >= 0) {
      dest = this.position().distanceAngle(dist, this.heading);
    } else {
      dest = this.position().distanceAngle(Math.abs(dist), this.heading - 180);
    }
    this.setPosition(dest);
    return this.drawLine(start, this.center());
  };

  PenMorph.prototype.down = function() {
    return this.isDown = true;
  };

  PenMorph.prototype.up = function() {
    return this.isDown = false;
  };

  PenMorph.prototype.clear = function() {
    this.parent.updateBackingStore();
    return this.parent.changed();
  };

  PenMorph.prototype.startWarp = function() {
    this.wantsRedraw = false;
    return this.isWarped = true;
  };

  PenMorph.prototype.endWarp = function() {
    this.isWarped = false;
    if (this.wantsRedraw) {
      this.updateBackingStore();
      this.wantsRedraw = false;
    }
    return this.parent.changed();
  };

  PenMorph.prototype.warp = function(fun) {
    this.startWarp();
    fun.call(this);
    return this.endWarp();
  };

  PenMorph.prototype.warpOp = function(selector, argsArray) {
    this.startWarp();
    this[selector].apply(this, argsArray);
    return this.endWarp();
  };

  PenMorph.prototype.warpSierpinski = function(length, min) {
    return this.warpOp("sierpinski", [length, min]);
  };

  PenMorph.prototype.sierpinski = function(length, min) {
    var _i, _results;
    if (length > min) {
      _results = [];
      for (i = _i = 0; _i < 3; i = ++_i) {
        this.sierpinski(length * 0.5, min);
        this.turn(120);
        _results.push(this.forward(length));
      }
      return _results;
    }
  };

  PenMorph.prototype.warpTree = function(level, length, angle) {
    return this.warpOp("tree", [level, length, angle]);
  };

  PenMorph.prototype.tree = function(level, length, angle) {
    if (level > 0) {
      this.penSize = level;
      this.forward(length);
      this.turn(angle);
      this.tree(level - 1, length * 0.75, angle);
      this.turn(angle * -2);
      this.tree(level - 1, length * 0.75, angle);
      this.turn(angle);
      return this.forward(-length);
    }
  };

  PenMorph.coffeeScriptSourceOfThisClass = '# PenMorph ////////////////////////////////////////////////////////////\n\n# I am a simple LOGO-wise turtle. Note that this morph\'s graphical\n# representation is ONLY the turtle, not the graphics that come\n# out of it. The graphics generated by the pan are located in the\n# canvas it was attached to when the graphics happened.\n# REQUIRES BackingStoreMixin\n\nclass PenMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith BackingStoreMixin\n  \n  heading: 0\n  penSize: null\n  isWarped: false # internal optimization\n  isDown: true\n  wantsRedraw: false # internal optimization\n  penPoint: \'tip\' # or \'center\'\n  \n  constructor: ->\n    @penSize = WorldMorph.preferencesAndSettings.handleSize * 4\n    super()\n    @setExtent new Point(@penSize, @penSize)\n    # todo we need to change the size two times, for getting the right size\n    # of the arrow and of the line. Probably should make the two distinct\n    @penSize = 1\n    #alert @morphMethod() # works\n    # doesn\'t work cause coffeescript doesn\'t support static inheritance\n    #alert @morphStaticMethod()\n\n    # no need to call @updateBackingStore() because @setExtent does it.\n    # (should it?)\n    #@updateBackingStore()\n\n\n  @staticVariable: 1\n  @staticFunction: -> 3.14\n\n  imBeingAddedTo: (newParentMorph) ->\n    if !(newParentMorph instanceof HandMorph or newParentMorph instanceof CanvasMorph)\n      @inform "a pen will only\nwork on a canvas..."\n\n    \n  # PenMorph updating - optimized for warping, i.e atomic recursion\n  changed: ->\n    if @isWarped is false\n      w = @root()\n      # unless we are the main desktop, then if the morph has no parent\n      # don\'t add the broken rect since the morph is not visible\n      if w instanceof WorldMorph and (@ instanceof WorldMorph or @parent?)\n        w.broken.push @visibleBounds().spread()\n      @parent.childChanged @  if @parent\n  \n  \n  # PenMorph display:\n  # no changes of position or extent\n  updateBackingStore: (facing) ->\n    #\n    #    my orientation can be overridden with the "facing" parameter to\n    #    implement Scratch-style rotation styles\n    #    \n    #\n    direction = facing or @heading\n    if @isWarped\n      @wantsRedraw = true\n      return\n    @image = newCanvas(@extent().scaleBy pixelRatio)\n    context = @image.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    len = @width() / 2\n    start = @center().subtract(@bounds.origin)\n\n    if @penPoint is "tip"\n      dest = start.distanceAngle(len * 0.75, direction - 180)\n      left = start.distanceAngle(len, direction + 195)\n      right = start.distanceAngle(len, direction - 195)\n    else # \'middle\'\n      dest = start.distanceAngle(len * 0.75, direction)\n      left = start.distanceAngle(len * 0.33, direction + 230)\n      right = start.distanceAngle(len * 0.33, direction - 230)\n\n    context.fillStyle = @color.toString()\n    context.beginPath()\n\n    context.moveTo start.x, start.y\n    context.lineTo left.x, left.y\n    context.lineTo dest.x, dest.y\n    context.lineTo right.x, right.y\n\n    context.closePath()\n    context.strokeStyle = "white"\n    context.lineWidth = 3\n    context.stroke()\n    context.strokeStyle = "black"\n    context.lineWidth = 1\n    context.stroke()\n    context.fill()\n    @wantsRedraw = false\n  \n  \n  # PenMorph access:\n  setHeading: (degrees) ->\n    @heading = parseFloat(degrees) % 360\n    @updateBackingStore()\n    @changed()\n  \n  \n  # PenMorph drawing:\n  drawLine: (start, dest) ->\n\n    if !@parent.penTrails?\n      return\n\n    context = @parent.penTrails().getContext("2d")\n    # by default penTrails() is to answer the normal\n    # morph image.\n    # The implication is that by default every Morph in the system\n    # (including the World) is able to act as turtle canvas and can\n    # display pen trails.\n    # BUT also this means that pen trails will be lost whenever\n    # the trail\'s morph (the pen\'s parent) performs a "drawNew()"\n    # operation. If you want to create your own pen trails canvas,\n    # you may wish to modify its **penTrails()** property, so that\n    # it keeps a separate offscreen canvas for pen trails\n    # (and doesn\'t lose these on redraw).\n\n    from = start.subtract(@parent.bounds.origin)\n    to = dest.subtract(@parent.bounds.origin)\n    if @isDown\n      context.lineWidth = @penSize\n      context.strokeStyle = @color.toString()\n      context.lineCap = "round"\n      context.lineJoin = "round"\n      context.beginPath()\n      context.moveTo from.x, from.y\n      context.lineTo to.x, to.y\n      context.stroke()\n      # unless we are the main desktop, then if the morph has no parent\n      # don\'t add the broken rect since the morph is not visible\n      if @isWarped is false and (@ instanceof WorldMorph or @parent?)\n        @world().broken.push start.rectangle(dest).expandBy(Math.max(@penSize / 2, 1)).intersect(@parent.visibleBounds()).spread()\n  \n  \n  # PenMorph turtle ops:\n  turn: (degrees) ->\n    @setHeading @heading + parseFloat(degrees)\n  \n  forward: (steps) ->\n    start = @center()\n    dist = parseFloat(steps)\n    if dist >= 0\n      dest = @position().distanceAngle(dist, @heading)\n    else\n      dest = @position().distanceAngle(Math.abs(dist), (@heading - 180))\n    @setPosition dest\n    @drawLine start, @center()\n  \n  down: ->\n    @isDown = true\n  \n  up: ->\n    @isDown = false\n  \n  clear: ->\n    @parent.updateBackingStore()\n    @parent.changed()\n  \n  \n  # PenMorph optimization for atomic recursion:\n  startWarp: ->\n    @wantsRedraw = false\n    @isWarped = true\n  \n  endWarp: ->\n    @isWarped = false\n    if @wantsRedraw\n      @updateBackingStore()\n      @wantsRedraw = false\n    @parent.changed()\n  \n  warp: (fun) ->\n    @startWarp()\n    fun.call @\n    @endWarp()\n  \n  warpOp: (selector, argsArray) ->\n    @startWarp()\n    @[selector].apply @, argsArray\n    @endWarp()\n  \n  \n  # PenMorph demo ops:\n  # try these with WARP eg.: this.warp(function () {tree(12, 120, 20)})\n  warpSierpinski: (length, min) ->\n    @warpOp "sierpinski", [length, min]\n  \n  sierpinski: (length, min) ->\n    if length > min\n      for i in [0...3]\n        @sierpinski length * 0.5, min\n        @turn 120\n        @forward length\n  \n  warpTree: (level, length, angle) ->\n    @warpOp "tree", [level, length, angle]\n  \n  tree: (level, length, angle) ->\n    if level > 0\n      @penSize = level\n      @forward length\n      @turn angle\n      @tree level - 1, length * 0.75, angle\n      @turn angle * -2\n      @tree level - 1, length * 0.75, angle\n      @turn angle\n      @forward -length';

  return PenMorph;

})(Morph);

Point2 = (function() {
  Point2.prototype.x = null;

  Point2.prototype.y = null;

  function Point2(x, y) {
    this.x = x != null ? x : 0;
    this.y = y != null ? y : 0;
  }

  Point2.prototype.toString = function() {
    return Math.round(this.x) + "@" + Math.round(this.y);
  };

  Point2.prototype.copy = function() {
    return new this.constructor(this.x, this.y);
  };

  Point2.prototype.eq = function(aPoint2) {
    return this.x === aPoint2.x && this.y === aPoint2.y;
  };

  Point2.prototype.lt = function(aPoint2) {
    return this.x < aPoint2.x && this.y < aPoint2.y;
  };

  Point2.prototype.gt = function(aPoint2) {
    return this.x > aPoint2.x && this.y > aPoint2.y;
  };

  Point2.prototype.ge = function(aPoint2) {
    return this.x >= aPoint2.x && this.y >= aPoint2.y;
  };

  Point2.prototype.le = function(aPoint2) {
    return this.x <= aPoint2.x && this.y <= aPoint2.y;
  };

  Point2.prototype.max = function(aPoint2) {
    this.x = Math.max(this.x, aPoint2.x);
    return this.y = Math.max(this.y, aPoint2.y);
  };

  Point2.prototype.min = function(aPoint2) {
    this.x = Math.min(this.x, aPoint2.x);
    return this.y = Math.min(this.y, aPoint2.y);
  };

  Point2.prototype.round = function() {
    this.x = Math.round(this.x);
    return this.y = Math.round(this.y);
  };

  Point2.prototype.abs = function() {
    this.x = Math.abs(this.x);
    return this.y = Math.abs(this.y);
  };

  Point2.prototype.neg = function() {
    this.x = -this.x;
    return this.y = -this.y;
  };

  Point2.prototype.mirror = function() {
    var tmpValueForSwappingXAndY;
    tmpValueForSwappingXAndY = this.x;
    this.x = this.y;
    return this.y = tmpValueForSwappingXAndY;
  };

  Point2.prototype.floor = function() {
    this.x = Math.max(Math.floor(this.x), 0);
    return this.y = Math.max(Math.floor(this.y), 0);
  };

  Point2.prototype.ceil = function() {
    this.x = Math.ceil(this.x);
    return this.y = Math.ceil(this.y);
  };

  Point2.prototype.add = function(other) {
    if (other instanceof Point2) {
      this.x = this.x + other.x;
      this.y = this.y + other.y;
      return;
    }
    this.x = this.x + other;
    return this.y = this.y + other;
  };

  Point2.prototype.subtract = function(other) {
    if (other instanceof Point2) {
      this.x = this.x - other.x;
      this.y = this.y - other.y;
      return;
    }
    this.x = this.x - other;
    return this.y = this.y - other;
  };

  Point2.prototype.multiplyBy = function(other) {
    if (other instanceof Point2) {
      this.x = this.x * other.x;
      this.y = this.y * other.y;
      return;
    }
    this.x = this.x * other;
    return this.y = this.y * other;
  };

  Point2.prototype.divideBy = function(other) {
    if (other instanceof Point2) {
      this.x = this.x / other.x;
      this.y = this.y / other.y;
      return;
    }
    this.x = this.x / other;
    return this.y = this.y / other;
  };

  Point2.prototype.floorDivideBy = function(other) {
    if (other instanceof Point2) {
      this.x = Math.floor(this.x / other.x);
      this.y = Math.floor(this.y / other.y);
      return;
    }
    this.x = Math.floor(this.x / other);
    return this.y = Math.floor(this.y / other);
  };

  Point2.prototype.r = function() {
    var t;
    t = this.copy();
    t.multiplyBy(t);
    return Math.sqrt(t.x + t.y);
  };

  Point2.prototype.degrees = function() {
    var tan, theta;
    if (this.x === 0) {
      if (this.y >= 0) {
        return 90;
      }
      return 270;
    }
    tan = this.y / this.x;
    theta = Math.atan(tan);
    if (this.x >= 0) {
      if (this.y >= 0) {
        return degrees(theta);
      }
      return 360 + (degrees(theta));
    }
    return 180 + degrees(theta);
  };

  Point2.prototype.theta = function() {
    var tan, theta;
    if (this.x === 0) {
      if (this.y >= 0) {
        return radians(90);
      }
      return radians(270);
    }
    tan = this.y / this.x;
    theta = Math.atan(tan);
    if (this.x >= 0) {
      if (this.y >= 0) {
        return theta;
      }
      return radians(360) + theta;
    }
    return radians(180) + theta;
  };

  Point2.prototype.distanceTo = function(aPoint2) {
    return (aPoint2.copy().subtract(this)).r();
  };

  Point2.prototype.rotate = function(direction, center) {
    var offset, tmpPointForRotate;
    offset = this.copy().subtract(center);
    if (direction === "right") {
      this.x = -offset.y + center.x;
      this.y = offset.y + center.y;
      return;
    }
    if (direction === "left") {
      this.x = offset.y + center.x;
      this.y = -offset.y + center.y;
      return;
    }
    tmpPointForRotate = center.copy().subtract(offset);
    this.x = tmpPointForRotate.x;
    return this.y = tmpPointForRotate.y;
  };

  Point2.prototype.flip = function(direction, center) {
    if (direction === "vertical") {
      this.y = center.y * 2 - this.y;
      return;
    }
    return this.x = center.x * 2 - this.x;
  };

  Point2.prototype.distanceAngle = function(dist, angle) {
    var deg, x, y;
    deg = angle;
    if (deg > 270) {
      deg = deg - 360;
    } else {
      if (deg < -270) {
        deg = deg + 360;
      }
    }
    if (-90 <= deg && deg <= 90) {
      x = Math.sin(radians(deg)) * dist;
      y = Math.sqrt((dist * dist) - (x * x));
      this.x = x + this.x;
      this.y = this.y - y;
      return;
    }
    x = Math.sin(radians(180 - deg)) * dist;
    y = Math.sqrt((dist * dist) - (x * x));
    this.x = x + this.x;
    return this.y = this.y + y;
  };

  Point2.prototype.scaleBy = function(scalePoint2) {
    return this.multiplyBy(scalePoint2);
  };

  Point2.prototype.translateBy = function(deltaPoint2) {
    return this.add(deltaPoint2);
  };

  Point2.prototype.rotateBy = function(angle, centerPoint2) {
    var center, p, r, theta;
    center = centerPoint2 || new this.constructor(0, 0);
    p = this.copy().subtract(center);
    r = p.r();
    theta = angle - p.theta();
    this.x = center.x + (r * Math.cos(theta));
    return this.y = center.y - (r * Math.sin(theta));
  };

  Point2.prototype.asArray = function() {
    return [this.x, this.y];
  };

  Point2.prototype.corner = function(cornerPoint2) {
    return new Rectangle(this.x, this.y, cornerPoint2.x, cornerPoint2.y);
  };

  Point2.prototype.rectangle = function(aPoint2) {
    var crn, org;
    org = this.copy().min(aPoint2);
    crn = this.copy().max(aPoint2);
    return new Rectangle(org.x, org.y, crn.x, crn.y);
  };

  Point2.prototype.extent = function(aPoint2) {
    var crn;
    crn = this.copy().add(aPoint2);
    return new Rectangle(this.x, this.y, crn.x, crn.y);
  };

  Point2.coffeeScriptSourceOfThisClass = '# Point2 //////////////////////////////////////////////////////////////\n# like Point, but it tries not to create new objects like there is\n# no tomorrow. Any operation that returned a new point now directly\n# modifies the current point.\n# Note that the arguments passed to any of these functions are never\n# modified.\n\nclass Point2\n\n  x: null\n  y: null\n   \n  constructor: (@x = 0, @y = 0) ->\n  \n  # Point2 string representation: e.g. \'12@68\'\n  toString: ->\n    Math.round(@x) + "@" + Math.round(@y)\n  \n  # Point2 copying:\n  copy: ->\n    new @constructor(@x, @y)\n  \n  # Point2 comparison:\n  eq: (aPoint2) ->\n    # ==\n    @x is aPoint2.x and @y is aPoint2.y\n  \n  lt: (aPoint2) ->\n    # <\n    @x < aPoint2.x and @y < aPoint2.y\n  \n  gt: (aPoint2) ->\n    # >\n    @x > aPoint2.x and @y > aPoint2.y\n  \n  ge: (aPoint2) ->\n    # >=\n    @x >= aPoint2.x and @y >= aPoint2.y\n  \n  le: (aPoint2) ->\n    # <=\n    @x <= aPoint2.x and @y <= aPoint2.y\n  \n  max: (aPoint2) ->\n    #new @constructor(Math.max(@x, aPoint2.x), Math.max(@y, aPoint2.y))\n    @x = Math.max(@x, aPoint2.x)\n    @y = Math.max(@y, aPoint2.y)\n  \n  min: (aPoint2) ->\n    #new @constructor(Math.min(@x, aPoint2.x), Math.min(@y, aPoint2.y))\n    @x = Math.min(@x, aPoint2.x)\n    @y = Math.min(@y, aPoint2.y)\n  \n  \n  # Point2 conversion:\n  round: ->\n    #new @constructor(Math.round(@x), Math.round(@y))\n    @x = Math.round(@x)\n    @y = Math.round(@y)\n  \n  abs: ->\n    #new @constructor(Math.abs(@x), Math.abs(@y))\n    @x = Math.abs(@x)\n    @y = Math.abs(@y)\n  \n  neg: ->\n    #new @constructor(-@x, -@y)\n    @x = -@x\n    @y = -@y\n  \n  mirror: ->\n    #new @constructor(@y, @x)\n    # note that coffeescript would allow [@x,@y] = [@y,@x]\n    # but we want to be faster here\n    tmpValueForSwappingXAndY = @x\n    @x = @y\n    @y = tmpValueForSwappingXAndY \n  \n  floor: ->\n    #new @constructor(Math.max(Math.floor(@x), 0), Math.max(Math.floor(@y), 0))\n    @x = Math.max(Math.floor(@x), 0)\n    @y = Math.max(Math.floor(@y), 0)\n  \n  ceil: ->\n    #new @constructor(Math.ceil(@x), Math.ceil(@y))\n    @x = Math.ceil(@x)\n    @y = Math.ceil(@y)\n  \n  \n  # Point2 arithmetic:\n  add: (other) ->\n    if other instanceof Point2\n      @x = @x + other.x\n      @y = @y + other.y\n      return\n    @x = @x + other\n    @y = @y + other\n  \n  subtract: (other) ->\n    if other instanceof Point2\n      @x = @x - other.x\n      @y = @y - other.y\n      return\n    @x = @x - other\n    @y = @y - other\n  \n  multiplyBy: (other) ->\n    if other instanceof Point2\n      @x = @x * other.x\n      @y = @y * other.y\n      return\n    @x = @x * other\n    @y = @y * other\n  \n  divideBy: (other) ->\n    if other instanceof Point2\n      @x = @x / other.x\n      @y = @y / other.y\n      return\n    @x = @x / other\n    @y = @y / other\n  \n  floorDivideBy: (other) ->\n    if other instanceof Point2\n      @x = Math.floor(@x / other.x)\n      @y = Math.floor(@y / other.y)\n      return\n    @x = Math.floor(@x / other)\n    @y = Math.floor(@y / other)\n  \n  \n  # Point2 polar coordinates:\n  # distance from the origin\n  r: ->\n    t = @copy()\n    t.multiplyBy(t)\n    Math.sqrt t.x + t.y\n  \n  degrees: ->\n    #\n    #    answer the angle I make with origin in degrees.\n    #    Right is 0, down is 90\n    #\n    if @x is 0\n      return 90  if @y >= 0\n      return 270\n    tan = @y / @x\n    theta = Math.atan(tan)\n    if @x >= 0\n      return degrees(theta)  if @y >= 0\n      return 360 + (degrees(theta))\n    180 + degrees(theta)\n  \n  theta: ->\n    #\n    #    answer the angle I make with origin in radians.\n    #    Right is 0, down is 90\n    #\n    if @x is 0\n      return radians(90)  if @y >= 0\n      return radians(270)\n    tan = @y / @x\n    theta = Math.atan(tan)\n    if @x >= 0\n      return theta  if @y >= 0\n      return radians(360) + theta\n    radians(180) + theta\n  \n  \n  # Point2 functions:\n    \n  distanceTo: (aPoint2) ->\n    (aPoint2.copy().subtract(@)).r()\n  \n  rotate: (direction, center) ->\n    # direction must be \'right\', \'left\' or \'pi\'\n    offset = @copy().subtract(center)\n    if direction is "right"\n      @x = -offset.y + center.x\n      @y = offset.y + center.y\n      return\n    if direction is "left"\n      @x = offset.y + center.x\n      @y = -offset.y + center.y\n      return\n\n    # direction === \'pi\'\n    tmpPointForRotate = center.copy().subtract offset\n    @x = tmpPointForRotate.x\n    @y = tmpPointForRotate.y\n  \n  flip: (direction, center) ->\n    # direction must be \'vertical\' or \'horizontal\'\n    if direction is "vertical"\n      @y = center.y * 2 - @y\n      return\n\n    # direction === \'horizontal\'\n    @x = center.x * 2 - @x\n  \n  distanceAngle: (dist, angle) ->\n    deg = angle\n    if deg > 270\n      deg = deg - 360\n    else deg = deg + 360  if deg < -270\n    if -90 <= deg and deg <= 90\n      x = Math.sin(radians(deg)) * dist\n      y = Math.sqrt((dist * dist) - (x * x))\n      @x = x + @x\n      @y = @y - y\n      return\n    x = Math.sin(radians(180 - deg)) * dist\n    y = Math.sqrt((dist * dist) - (x * x))\n    @x = x + @x\n    @y = @y + y\n  \n  \n  # Point2 transforming:\n  scaleBy: (scalePoint2) ->\n    @multiplyBy scalePoint2\n  \n  translateBy: (deltaPoint2) ->\n    @add deltaPoint2\n  \n  rotateBy: (angle, centerPoint2) ->\n    center = centerPoint2 or new @constructor(0, 0)\n    p = @copy().subtract(center)\n    r = p.r()\n    theta = angle - p.theta()\n    @x = center.x + (r * Math.cos(theta))\n    @y = center.y - (r * Math.sin(theta))\n  \n  \n  # Point2 conversion:\n  asArray: ->\n    [@x, @y]\n  \n  # creating Rectangle instances from Point2:\n  corner: (cornerPoint2) ->\n    # answer a new Rectangle\n    new Rectangle(@x, @y, cornerPoint2.x, cornerPoint2.y)\n  \n  rectangle: (aPoint2) ->\n    # answer a new Rectangle\n    org = @copy().min(aPoint2)\n    crn = @copy().max(aPoint2)\n    new Rectangle(org.x, org.y, crn.x, crn.y)\n  \n  extent: (aPoint2) ->\n    #answer a new Rectangle\n    crn = @copy().add(aPoint2)\n    new Rectangle(@x, @y, crn.x, crn.y)';

  return Point2;

})();

PreferencesAndSettings = (function() {
  namedClasses[PreferencesAndSettings.name] = PreferencesAndSettings.prototype;

  PreferencesAndSettings.augmentWith(DeepCopierMixin);

  PreferencesAndSettings.INPUT_MODE_MOUSE = 0;

  PreferencesAndSettings.INPUT_MODE_TOUCH = 1;

  PreferencesAndSettings.prototype.useBlurredShadows = null;

  PreferencesAndSettings.prototype.inputMode = null;

  PreferencesAndSettings.prototype.minimumFontHeight = null;

  PreferencesAndSettings.prototype.globalFontFamily = null;

  PreferencesAndSettings.prototype.menuFontName = null;

  PreferencesAndSettings.prototype.menuFontSize = null;

  PreferencesAndSettings.prototype.bubbleHelpFontSize = null;

  PreferencesAndSettings.prototype.prompterFontName = null;

  PreferencesAndSettings.prototype.prompterFontSize = null;

  PreferencesAndSettings.prototype.prompterSliderSize = null;

  PreferencesAndSettings.prototype.handleSize = null;

  PreferencesAndSettings.prototype.scrollBarSize = null;

  PreferencesAndSettings.prototype.mouseScrollAmount = null;

  PreferencesAndSettings.prototype.useSliderForInput = null;

  PreferencesAndSettings.prototype.useVirtualKeyboard = null;

  PreferencesAndSettings.prototype.isTouchDevice = null;

  PreferencesAndSettings.prototype.rasterizeSVGs = null;

  PreferencesAndSettings.prototype.isFlat = null;

  PreferencesAndSettings.prototype.printoutsReactiveValuesCode = true;

  function PreferencesAndSettings() {
    this.useBlurredShadows = getBlurredShadowSupport();
    this.setMouseInputMode();
    console.log("constructing PreferencesAndSettings");
  }

  PreferencesAndSettings.prototype.toggleBlurredShadows = function() {
    return this.useBlurredShadows = !this.useBlurredShadows;
  };

  PreferencesAndSettings.prototype.toggleInputMode = function() {
    if (this.inputMode === PreferencesAndSettings.INPUT_MODE_MOUSE) {
      return this.setTouchInputMode();
    } else {
      return this.setMouseInputMode();
    }
  };

  PreferencesAndSettings.prototype.setMouseInputMode = function() {
    this.inputMode = PreferencesAndSettings.INPUT_MODE_MOUSE;
    this.minimumFontHeight = getMinimumFontHeight();
    this.globalFontFamily = "";
    this.menuFontName = "sans-serif";
    this.menuFontSize = 12;
    this.bubbleHelpFontSize = 10;
    this.prompterFontName = "sans-serif";
    this.prompterFontSize = 12;
    this.prompterSliderSize = 10;
    this.handleSize = 15;
    this.scrollBarSize = 10;
    this.mouseScrollAmount = 40;
    this.useSliderForInput = false;
    this.useVirtualKeyboard = true;
    this.isTouchDevice = false;
    this.rasterizeSVGs = false;
    return this.isFlat = false;
  };

  PreferencesAndSettings.prototype.setTouchInputMode = function() {
    this.inputMode = PreferencesAndSettings.INPUT_MODE_TOUCH;
    this.minimumFontHeight = getMinimumFontHeight();
    this.globalFontFamily = "";
    this.menuFontName = "sans-serif";
    this.menuFontSize = 24;
    this.bubbleHelpFontSize = 18;
    this.prompterFontName = "sans-serif";
    this.prompterFontSize = 24;
    this.prompterSliderSize = 20;
    this.handleSize = 26;
    this.scrollBarSize = 24;
    this.mouseScrollAmount = 40;
    this.useSliderForInput = true;
    this.useVirtualKeyboard = true;
    this.isTouchDevice = false;
    this.rasterizeSVGs = false;
    return this.isFlat = false;
  };

  PreferencesAndSettings.coffeeScriptSourceOfThisClass = '# World-wide preferences and settings ///////////////////////////////////\n\n# Contains all possible preferences and settings for a World.\n# So it\'s World-wide values.\n# It belongs to a world, each world may have different settings.\n# this comment below is needed to figure our dependencies between classes\n# REQUIRES globalFunctions\n\nclass PreferencesAndSettings\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith DeepCopierMixin\n\n  @INPUT_MODE_MOUSE: 0\n  @INPUT_MODE_TOUCH: 1\n\n  useBlurredShadows: null\n  \n  # all these properties can be modified\n  # by the input mode.\n  inputMode: null\n  minimumFontHeight: null\n  globalFontFamily: null\n  menuFontName: null\n  menuFontSize: null\n  bubbleHelpFontSize: null\n  prompterFontName: null\n  prompterFontSize: null\n  prompterSliderSize: null\n  handleSize: null\n  scrollBarSize: null\n  mouseScrollAmount: null\n  useSliderForInput: null\n  useVirtualKeyboard: null\n  isTouchDevice: null\n  rasterizeSVGs: null\n  isFlat: null\n\n  printoutsReactiveValuesCode: true\n\n  constructor: ->\n    @useBlurredShadows = getBlurredShadowSupport() # check for Chrome-bug\n    @setMouseInputMode()\n    console.log("constructing PreferencesAndSettings")\n\n  toggleBlurredShadows: ->\n    @useBlurredShadows = not @useBlurredShadows\n\n  toggleInputMode: ->\n    if @inputMode == PreferencesAndSettings.INPUT_MODE_MOUSE\n      @setTouchInputMode()\n    else\n      @setMouseInputMode()\n\n  setMouseInputMode: ->\n    @inputMode = PreferencesAndSettings.INPUT_MODE_MOUSE\n    @minimumFontHeight = getMinimumFontHeight() # browser settings\n    @globalFontFamily = ""\n    @menuFontName = "sans-serif"\n    @menuFontSize = 12\n    @bubbleHelpFontSize = 10\n    @prompterFontName = "sans-serif"\n    @prompterFontSize = 12\n    @prompterSliderSize = 10\n    @handleSize = 15\n    @scrollBarSize = 10\n    @mouseScrollAmount = 40\n    @useSliderForInput = false\n    @useVirtualKeyboard = true\n    @isTouchDevice = false # turned on by touch events, don\'t set\n    @rasterizeSVGs = false\n    @isFlat = false\n\n  setTouchInputMode: ->\n    @inputMode = PreferencesAndSettings.INPUT_MODE_TOUCH\n    @minimumFontHeight = getMinimumFontHeight()\n    @globalFontFamily = ""\n    @menuFontName = "sans-serif"\n    @menuFontSize = 24\n    @bubbleHelpFontSize = 18\n    @prompterFontName = "sans-serif"\n    @prompterFontSize = 24\n    @prompterSliderSize = 20\n    @handleSize = 26\n    @scrollBarSize = 24\n    @mouseScrollAmount = 40\n    @useSliderForInput = true\n    @useVirtualKeyboard = true\n    @isTouchDevice = false\n    @rasterizeSVGs = false\n    @isFlat = false\n';

  return PreferencesAndSettings;

})();

ProfilingDataCollector = (function() {
  function ProfilingDataCollector() {}

  ProfilingDataCollector.shortSessionCumulativeNumberOfBrokenRects = 0;

  ProfilingDataCollector.shortSessionMaxNumberOfBrokenRects = 0;

  ProfilingDataCollector.shortSessionCumulativeNumberOfAllocatedCanvases = 0;

  ProfilingDataCollector.shortSessionMaxNumberOfAllocatedCanvases = 0;

  ProfilingDataCollector.shortSessionCumulativeSizeOfAllocatedCanvases = 0;

  ProfilingDataCollector.shortSessionCumulativeNumberOfBlitOperations = 0;

  ProfilingDataCollector.shortSessionMaxNumberOfBlits = 0;

  ProfilingDataCollector.shortSessionCumulativeAreaOfBlits = 0;

  ProfilingDataCollector.shortSessionMaxAreaOfBlits = 0;

  ProfilingDataCollector.shortSessionBiggestBlitArea = 0;

  ProfilingDataCollector.shortSessionCumulativeTimeSpentRedrawing = 0;

  ProfilingDataCollector.shortSessionMaxTimeSpentRedrawing = 0;

  ProfilingDataCollector.profileBrokenRects = function(numberOfBrokenRects) {
    this.shortSessionCumulativeNumberOfBrokenRects += numberOfBrokenRects;
    if (numberOfBrokenRects > this.shortSessionMaxNumberOfBrokenRects) {
      return this.shortSessionMaxNumberOfBrokenRects = numberOfBrokenRects;
    }
  };

  ProfilingDataCollector.coffeeScriptSourceOfThisClass = '# Data collected at run time ///////////////////////////////////\n\n\nclass ProfilingDataCollector\n\n  @shortSessionCumulativeNumberOfBrokenRects: 0\n  @shortSessionMaxNumberOfBrokenRects: 0\n\n  @shortSessionCumulativeNumberOfAllocatedCanvases: 0\n  @shortSessionMaxNumberOfAllocatedCanvases: 0\n\n  @shortSessionCumulativeSizeOfAllocatedCanvases: 0\n\n  @shortSessionCumulativeNumberOfBlitOperations: 0\n  @shortSessionMaxNumberOfBlits: 0\n\n  @shortSessionCumulativeAreaOfBlits: 0\n  @shortSessionMaxAreaOfBlits: 0\n\n  @shortSessionBiggestBlitArea: 0\n\n  @shortSessionCumulativeTimeSpentRedrawing: 0\n  @shortSessionMaxTimeSpentRedrawing: 0\n  \n\n  @profileBrokenRects: (numberOfBrokenRects) ->\n    @shortSessionCumulativeNumberOfBrokenRects += numberOfBrokenRects\n    if numberOfBrokenRects > @shortSessionMaxNumberOfBrokenRects\n      @shortSessionMaxNumberOfBrokenRects =\n        numberOfBrokenRects';

  return ProfilingDataCollector;

})();

ReactiveValuesTestsRectangleMorph = (function(_super) {
  __extends(ReactiveValuesTestsRectangleMorph, _super);

  ReactiveValuesTestsRectangleMorph.prototype.count = 1;

  ReactiveValuesTestsRectangleMorph.prototype.countVal = null;

  ReactiveValuesTestsRectangleMorph.prototype.countOfDirectRectangleChildren = null;

  function ReactiveValuesTestsRectangleMorph(extent, color) {
    var countOfDirectRectangleChildrenContent, countValContent, functionToRecalculate;
    ReactiveValuesTestsRectangleMorph.__super__.constructor.call(this);
    if (extent != null) {
      this.silentSetExtent(extent);
    }
    if (color != null) {
      this.color = color;
    }
    countValContent = {
      "content": this.count,
      "signature": hashCode(this.count + "")
    };
    this.countVal = new GroundVal("countVal", countValContent, this);
    countOfDirectRectangleChildrenContent = {
      "content": 0,
      "signature": hashCode(0 + "")
    };
    functionToRecalculate = function(argById, localArgByName, parentArgByName, childrenArgByName, childrenArgByNameCount) {
      var allCounts, theCount;
      theCount = 0;
      for (allCounts in childrenArgByName["countVal"]) {
        theCount++;
      }
      console.log("recalculating the number of rectangles to: " + theCount);
      return {
        "content": theCount,
        "signature": hashCode(theCount + "")
      };
    };
    this.countOfDirectRectangleChildren = new BasicCalculatedVal("countOfDirectRectangleChildren", functionToRecalculate, [], [], ["countVal"], this);
  }

  ReactiveValuesTestsRectangleMorph.coffeeScriptSourceOfThisClass = '# ReactiveValuesTestsRectangleMorph /////////////////////////////////\n\n\nclass ReactiveValuesTestsRectangleMorph extends Morph\n\n  count: 1\n  countVal: null\n  countOfDirectRectangleChildren: null\n\n  constructor: (extent, color) ->\n    super()\n    @silentSetExtent(extent) if extent?\n    @color = color if color?\n\n    countValContent = {"content": @count, "signature": hashCode(@count + "")}\n    @countVal = new GroundVal("countVal", countValContent, @)\n\n    countOfDirectRectangleChildrenContent = {"content": 0, "signature": hashCode(0 + "")}\n\n    functionToRecalculate = (argById, localArgByName, parentArgByName, childrenArgByName, childrenArgByNameCount) ->\n        theCount = 0\n        for allCounts of childrenArgByName["countVal"]\n            theCount++\n\n        console.log "recalculating the number of rectangles to: " + theCount\n\n        return {\n            "content": theCount,\n            "signature": hashCode(theCount + "")\n            }\n\n    #constructor: (@valName, @functionToRecalculate, @localInputVals, parentArgsNames, childrenArgsNames, @ownerMorph)\n    #debugger\n    @countOfDirectRectangleChildren = new BasicCalculatedVal("countOfDirectRectangleChildren", functionToRecalculate, [], [], ["countVal"], @)\n';

  return ReactiveValuesTestsRectangleMorph;

})(Morph);

ReactiveValuesTests = (function() {
  function ReactiveValuesTests() {}

  ReactiveValuesTests.runTests = function() {
    var firstReactValRect, secondReactValRect;
    firstReactValRect = new ReactiveValuesTestsRectangleMorph();
    if (ProfilerData.reactiveValues_createdGroundVals !== 1) {
      console.log("ERROR createdGroundVals should be 1 it's " + ProfilerData.reactiveValues_createdGroundVals);
    }
    if (ProfilerData.reactiveValues_createdBasicCalculatedValues !== 1) {
      console.log("ERROR createdBasicCalculatedValues should be 1 it's " + ProfilerData.reactiveValues_createdBasicCalculatedValues);
    }
    firstReactValRect.setPosition(new Point(10, 10));
    world.add(firstReactValRect);
    secondReactValRect = new ReactiveValuesTestsRectangleMorph();
    if (ProfilerData.reactiveValues_createdGroundVals !== 2) {
      console.log("ERROR createdGroundVals should be 2 it's " + ProfilerData.reactiveValues_createdGroundVals);
    }
    if (ProfilerData.reactiveValues_createdBasicCalculatedValues !== 2) {
      console.log("ERROR createdBasicCalculatedValues should be 2 it's " + ProfilerData.reactiveValues_createdBasicCalculatedValues);
    }
    secondReactValRect.setPosition(new Point(40, 40));
    world.add(secondReactValRect);
    if (firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContentMaybeOutdated !== true) {
      console.log("ERROR firstReactValRect.countOfDirectRectangleChildren should be dirty and it isn't");
    }
    firstReactValRect.add(secondReactValRect);
    if (firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContentMaybeOutdated !== true) {
      console.log("ERROR firstReactValRect.countOfDirectRectangleChildren should be dirty and it isn't");
    }
    firstReactValRect.countOfDirectRectangleChildren.fetchVal();
    if (firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContentMaybeOutdated !== false) {
      console.log("ERROR firstReactValRect.countOfDirectRectangleChildren should be clean and it isn't");
    }
    if (firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContent.content !== 1) {
      return console.log("ERROR firstReactValRect.countOfDirectRectangleChildren should contain 1 and it doesn't");
    }
  };

  ReactiveValuesTests.coffeeScriptSourceOfThisClass = '# A small harness to run tests around reactive values.\n# To run these, just open console and type\n#   ReactiveValuesTests.runTests()\n\n# REQUIRES ReactiveValuesTestsRectangleMorph\n\nclass ReactiveValuesTests\n  @runTests: ->\n\n    # create first rectangle\n    firstReactValRect = new ReactiveValuesTestsRectangleMorph()\n    if ProfilerData.reactiveValues_createdGroundVals != 1\n      console.log "ERROR createdGroundVals should be 1 it\'s " +\n        ProfilerData.reactiveValues_createdGroundVals\n    if ProfilerData.reactiveValues_createdBasicCalculatedValues != 1\n      console.log "ERROR createdBasicCalculatedValues should be 1 it\'s " +\n        ProfilerData.reactiveValues_createdBasicCalculatedValues\n    firstReactValRect.setPosition new Point(10, 10)\n    world.add firstReactValRect\n\n    # create second rectangle, slightly displaced to verlap\n    secondReactValRect = new ReactiveValuesTestsRectangleMorph()\n    if ProfilerData.reactiveValues_createdGroundVals != 2\n      console.log "ERROR createdGroundVals should be 2 it\'s " +\n        ProfilerData.reactiveValues_createdGroundVals\n    if ProfilerData.reactiveValues_createdBasicCalculatedValues != 2\n      console.log "ERROR createdBasicCalculatedValues should be 2 it\'s " +\n        ProfilerData.reactiveValues_createdBasicCalculatedValues\n    secondReactValRect.setPosition new Point(40, 40)\n    world.add secondReactValRect\n\n    if firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContentMaybeOutdated != true\n      console.log "ERROR firstReactValRect.countOfDirectRectangleChildren should be dirty and it isn\'t"\n\n    # now attach the second rectangle to the first\n    firstReactValRect.add secondReactValRect\n\n    if firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContentMaybeOutdated != true\n      console.log "ERROR firstReactValRect.countOfDirectRectangleChildren should be dirty and it isn\'t"\n\n    # now fetch the value of countOfDirectRectangleChildren in the\n    # first rectangle\n    firstReactValRect.countOfDirectRectangleChildren.fetchVal()\n\n    if firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContentMaybeOutdated != false\n      console.log "ERROR firstReactValRect.countOfDirectRectangleChildren should be clean and it isn\'t"\n\n    if firstReactValRect.countOfDirectRectangleChildren.lastCalculatedValContent.content != 1\n      console.log "ERROR firstReactValRect.countOfDirectRectangleChildren should contain 1 and it doesn\'t"\n\n    ';

  return ReactiveValuesTests;

})();

ShadowMorph = (function(_super) {
  __extends(ShadowMorph, _super);

  namedClasses[ShadowMorph.name] = ShadowMorph.prototype;

  ShadowMorph.prototype.targetMorph = null;

  ShadowMorph.prototype.offset = null;

  ShadowMorph.prototype.alpha = 0;

  ShadowMorph.prototype.color = null;

  function ShadowMorph(targetMorph, offset, alpha, color) {
    this.targetMorph = targetMorph;
    this.offset = offset != null ? offset : new Point(7, 7);
    this.alpha = alpha != null ? alpha : 0.2;
    this.color = color != null ? color : new Color(0, 0, 0);
    ShadowMorph.__super__.constructor.call(this);
    this.bounds.debugIfFloats();
    this.offset.debugIfFloats();
  }

  ShadowMorph.prototype.setLayoutBeforeUpdatingBackingStore = function() {
    var fb;
    fb = this.targetMorph.boundsIncludingChildrenNoShadow();
    this.silentSetExtent(fb.extent().add(this.targetMorph.shadowBlur * 2));
    if (WorldMorph.preferencesAndSettings.useBlurredShadows && !WorldMorph.preferencesAndSettings.isFlat) {
      this.silentSetPosition(fb.origin.add(this.offset).subtract(this.targetMorph.shadowBlur));
    } else {
      this.silentSetPosition(fb.origin.add(this.offset));
    }
    this.bounds.debugIfFloats();
    return this.offset.debugIfFloats();
  };

  ShadowMorph.prototype.isTransparentAt = function(aPoint) {
    var context, data, point;
    this.bounds.debugIfFloats();
    if (this.bounds.containsPoint(aPoint)) {
      if (this.texture) {
        return false;
      }
      point = aPoint.subtract(this.bounds.origin);
      context = this.image.getContext("2d");
      data = context.getImageData(Math.floor(point.x) * pixelRatio, Math.floor(point.y) * pixelRatio, 1, 1);
      return data.data[3] === 0;
    }
    return false;
  };

  ShadowMorph.prototype.updateBackingStore = function() {
    this.bounds.debugIfFloats();
    if (WorldMorph.preferencesAndSettings.useBlurredShadows && !WorldMorph.preferencesAndSettings.isFlat) {
      this.image = this.targetMorph.shadowImageBlurred(this.offset, this.color);
    } else {
      this.image = this.targetMorph.shadowImage(this.offset, this.color);
    }
    this.bounds.debugIfFloats();
    return this.offset.debugIfFloats();
  };

  ShadowMorph.prototype.blit = function(aCanvas, clippingRectangle) {
    var al, area, at, context, delta, h, randomB, randomG, randomR, sl, src, st, w;
    if (this.isMinimised || !this.isVisible || (this.image == null)) {
      return null;
    }
    area = clippingRectangle.intersect(this.bounds).round();
    if (area.isNotEmpty()) {
      delta = this.position().neg();
      src = area.copy().translateBy(delta).round();
      context = aCanvas.getContext("2d");
      context.globalAlpha = this.alpha;
      sl = src.left() * pixelRatio;
      st = src.top() * pixelRatio;
      al = area.left() * pixelRatio;
      at = area.top() * pixelRatio;
      w = Math.min(src.width() * pixelRatio, this.image.width - sl);
      h = Math.min(src.height() * pixelRatio, this.image.height - st);
      if (w < 1 || h < 1) {
        return null;
      }
      context.drawImage(this.image, Math.round(sl), Math.round(st), Math.round(w), Math.round(h), Math.round(al), Math.round(at), Math.round(w), Math.round(h));
      if (world.showRedraws) {
        randomR = Math.round(Math.random() * 255);
        randomG = Math.round(Math.random() * 255);
        randomB = Math.round(Math.random() * 255);
        context.globalAlpha = 0.5;
        context.fillStyle = "rgb(" + randomR + "," + randomG + "," + randomB + ")";
        context.fillRect(Math.round(al), Math.round(at), Math.round(w), Math.round(h));
      }
    }
    this.bounds.debugIfFloats();
    return this.offset.debugIfFloats();
  };

  ShadowMorph.coffeeScriptSourceOfThisClass = '# ShadowMorph /////////////////////////////////////////////////////////\n\nclass ShadowMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  targetMorph: null\n  offset: null\n  alpha: 0\n  color: null\n\n  # alpha should be between zero (transparent)\n  # and one (fully opaque)\n  constructor: (@targetMorph, @offset = new Point(7, 7), @alpha = 0.2, @color = new Color(0, 0, 0)) ->\n    # console.log "creating shadow morph"\n    super()\n    @bounds.debugIfFloats()\n    @offset.debugIfFloats()\n\n  setLayoutBeforeUpdatingBackingStore: ->\n    # console.log "shadow morph update rendering"\n    fb = @targetMorph.boundsIncludingChildrenNoShadow()\n    @silentSetExtent fb.extent().add(@targetMorph.shadowBlur * 2)\n    if WorldMorph.preferencesAndSettings.useBlurredShadows and  !WorldMorph.preferencesAndSettings.isFlat\n      @silentSetPosition fb.origin.add(@offset).subtract(@targetMorph.shadowBlur)\n    else\n      @silentSetPosition fb.origin.add(@offset)\n    @bounds.debugIfFloats()\n    @offset.debugIfFloats()\n\n  isTransparentAt: (aPoint) ->\n    @bounds.debugIfFloats()\n    if @bounds.containsPoint(aPoint)\n      return false  if @texture\n      point = aPoint.subtract(@bounds.origin)\n      context = @image.getContext("2d")\n      data = context.getImageData(Math.floor(point.x)*pixelRatio, Math.floor(point.y)*pixelRatio, 1, 1)\n      # check the 4th byte - the Alpha (RGBA)\n      return data.data[3] is 0\n    false\n\n  # no changes of position or extent\n  updateBackingStore: ->\n    @bounds.debugIfFloats()\n    if WorldMorph.preferencesAndSettings.useBlurredShadows and  !WorldMorph.preferencesAndSettings.isFlat\n      @image = @targetMorph.shadowImageBlurred(@offset, @color)\n    else\n      @image = @targetMorph.shadowImage(@offset, @color)\n    @bounds.debugIfFloats()\n    @offset.debugIfFloats()\n\n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by recursivelyBlit, which\n  # eventually invokes blit.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  blit: (aCanvas, clippingRectangle) ->\n    return null  if @isMinimised or !@isVisible or !@image?\n    area = clippingRectangle.intersect(@bounds).round()\n    # test whether anything that we are going to be drawing\n    # is visible (i.e. within the clippingRectangle)\n    if area.isNotEmpty()\n      delta = @position().neg()\n      src = area.copy().translateBy(delta).round()\n      context = aCanvas.getContext("2d")\n      context.globalAlpha = @alpha\n      sl = src.left() * pixelRatio\n      st = src.top() * pixelRatio\n      al = area.left() * pixelRatio\n      at = area.top() * pixelRatio\n      w = Math.min(src.width() * pixelRatio, @image.width - sl)\n      h = Math.min(src.height() * pixelRatio, @image.height - st)\n      return null  if w < 1 or h < 1\n\n      context.drawImage @image,\n        Math.round(sl),\n        Math.round(st),\n        Math.round(w),\n        Math.round(h),\n        Math.round(al),\n        Math.round(at),\n        Math.round(w),\n        Math.round(h)\n\n      if world.showRedraws\n        randomR = Math.round(Math.random()*255)\n        randomG = Math.round(Math.random()*255)\n        randomB = Math.round(Math.random()*255)\n        context.globalAlpha = 0.5\n        context.fillStyle = "rgb("+randomR+","+randomG+","+randomB+")";\n        context.fillRect(Math.round(al),Math.round(at),Math.round(w),Math.round(h));\n    @bounds.debugIfFloats()\n    @offset.debugIfFloats()';

  return ShadowMorph;

})(Morph);

SliderButtonMorph = (function(_super) {
  __extends(SliderButtonMorph, _super);

  namedClasses[SliderButtonMorph.name] = SliderButtonMorph.prototype;

  SliderButtonMorph.prototype.highlightColor = new Color(90, 90, 140);

  SliderButtonMorph.prototype.pressColor = new Color(80, 80, 160);

  SliderButtonMorph.prototype.is3D = false;

  function SliderButtonMorph(orientation) {
    this.color = new Color(80, 80, 80);
    SliderButtonMorph.__super__.constructor.call(this, orientation);
  }

  SliderButtonMorph.prototype.autoOrientation = function() {
    return noOperation;
  };

  SliderButtonMorph.prototype.setLayoutBeforeUpdatingBackingStore = function() {
    var bh, bw, posX, posY;
    if (this.parent != null) {
      this.orientation = this.parent.orientation;
      if (this.orientation === "vertical") {
        bw = this.parent.width() - 2;
        bh = Math.max(bw, Math.round(this.parent.height() * this.parent.ratio()));
        this.silentSetExtent(new Point(bw, bh));
        posX = 1;
        posY = Math.min(Math.round((this.parent.value - this.parent.start) * this.parent.unitSize()), this.parent.height() - this.height());
      } else {
        bh = this.parent.height() - 2;
        bw = Math.max(bh, Math.round(this.parent.width() * this.parent.ratio()));
        this.silentSetExtent(new Point(bw, bh));
        posY = 1;
        posX = Math.min(Math.round((this.parent.value - this.parent.start) * this.parent.unitSize()), this.parent.width() - this.width());
      }
      return this.silentSetPosition(new Point(posX, posY).add(this.parent.bounds.origin));
    }
  };

  SliderButtonMorph.prototype.updateBackingStore = function() {
    var colorBak;
    colorBak = this.color.copy();
    SliderButtonMorph.__super__.updateBackingStore.call(this);
    this.normalImage = this.image;
    this.color = this.highlightColor.copy();
    SliderButtonMorph.__super__.updateBackingStore.call(this);
    this.highlightImage = this.image;
    this.color = this.pressColor.copy();
    SliderButtonMorph.__super__.updateBackingStore.call(this);
    this.pressImage = this.image;
    this.color = colorBak;
    this.image = this.normalImage;
    return this.changed();
  };

  SliderButtonMorph.prototype.mouseEnter = function() {
    this.image = this.highlightImage;
    return this.changed();
  };

  SliderButtonMorph.prototype.mouseLeave = function() {
    this.image = this.normalImage;
    return this.changed();
  };

  SliderButtonMorph.prototype.mouseDownLeft = function(pos) {
    this.image = this.pressImage;
    this.changed();
    return this.escalateEvent("mouseDownLeft", pos);
  };

  SliderButtonMorph.prototype.mouseClickLeft = function() {
    SliderButtonMorph.__super__.mouseClickLeft.call(this);
    this.image = this.highlightImage;
    return this.changed();
  };

  SliderButtonMorph.prototype.mouseMove = function() {
    return noOperation;
  };

  SliderButtonMorph.coffeeScriptSourceOfThisClass = '# SliderButtonMorph ///////////////////////////////////////////////////\n# This is the handle in the middle of any slider.\n# Sliders (and hence this button)\n# are also used in the ScrollMorphs.\n\n# this comment below is needed to figure our dependencies between classes\n# REQUIRES globalFunctions\n\nclass SliderButtonMorph extends CircleBoxMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  # careful: this Color object is shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  highlightColor: new Color(90, 90, 140)\n  # careful: this Color object is shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  pressColor: new Color(80, 80, 160)\n  is3D: false\n\n  constructor: (orientation) ->\n    @color = new Color(80, 80, 80)\n    super orientation\n  \n  autoOrientation: ->\n      noOperation\n\n  setLayoutBeforeUpdatingBackingStore: ->\n    if @parent?\n      @orientation = @parent.orientation\n      if @orientation is "vertical"\n        bw = @parent.width() - 2\n        bh = Math.max(bw, Math.round(@parent.height() * @parent.ratio()))\n        @silentSetExtent new Point(bw, bh)\n        posX = 1\n        posY = Math.min(\n          Math.round((@parent.value - @parent.start) * @parent.unitSize()),\n          @parent.height() - @height())\n      else\n        bh = @parent.height() - 2\n        bw = Math.max(bh, Math.round(@parent.width() * @parent.ratio()))\n        @silentSetExtent new Point(bw, bh)\n        posY = 1\n        posX = Math.min(\n          Math.round((@parent.value - @parent.start) * @parent.unitSize()),\n          @parent.width() - @width())\n      @silentSetPosition new Point(posX, posY).add(@parent.bounds.origin)\n\n  # no changes of position or extent\n  updateBackingStore: ->\n    colorBak = @color.copy()\n    super()\n    @normalImage = @image\n    @color = @highlightColor.copy()\n    super()\n    @highlightImage = @image\n    @color = @pressColor.copy()\n    super()\n    @pressImage = @image\n    @color = colorBak\n    @image = @normalImage\n    @changed()\n    \n  \n  #SliderButtonMorph events:\n  mouseEnter: ->\n    @image = @highlightImage\n    @changed()\n  \n  mouseLeave: ->\n    @image = @normalImage\n    @changed()\n  \n  mouseDownLeft: (pos) ->\n    @image = @pressImage\n    @changed()\n    @escalateEvent "mouseDownLeft", pos\n  \n  mouseClickLeft: ->\n    super()\n    @image = @highlightImage\n    @changed()\n  \n  # prevent my parent from getting picked up\n  mouseMove: ->\n      noOperation';

  return SliderButtonMorph;

})(CircleBoxMorph);

SliderMorph = (function(_super) {
  __extends(SliderMorph, _super);

  namedClasses[SliderMorph.name] = SliderMorph.prototype;

  SliderMorph.augmentWith(ControllerMixin);

  SliderMorph.prototype.target = null;

  SliderMorph.prototype.action = null;

  SliderMorph.prototype.start = null;

  SliderMorph.prototype.stop = null;

  SliderMorph.prototype.value = null;

  SliderMorph.prototype.size = null;

  SliderMorph.prototype.offset = null;

  SliderMorph.prototype.button = null;

  SliderMorph.prototype.step = null;

  SliderMorph.prototype.argumentToAction = null;

  function SliderMorph(start, stop, value, size, orientation, color) {
    this.start = start != null ? start : 1;
    this.stop = stop != null ? stop : 100;
    this.value = value != null ? value : 50;
    this.size = size != null ? size : 10;
    this.button = new SliderButtonMorph();
    this.button.isfloatDraggable = false;
    this.button.color = new Color(0, 0, 0);
    this.button.highlightColor = new Color(110, 110, 110);
    this.button.pressColor = new Color(100, 100, 100);
    this.button.alpha = 0.4;
    SliderMorph.__super__.constructor.call(this, orientation);
    this.alpha = 0.1;
    this.color = color || new Color(0, 0, 0);
    this.silentSetExtent(new Point(20, 100));
    this.silentAdd(this.button);
  }

  SliderMorph.prototype.imBeingAddedTo = function(newParentMorph) {
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    if ((this.button != null) && this.button instanceof SliderButtonMorph) {
      this.button.setLayoutBeforeUpdatingBackingStore();
      this.button.updateBackingStore();
    }
    return this.changed();
  };

  SliderMorph.prototype.setExtent = function(a) {
    SliderMorph.__super__.setExtent.call(this, a);
    this.button.setLayoutBeforeUpdatingBackingStore();
    return this.button.updateBackingStore();
  };

  SliderMorph.prototype.autoOrientation = function() {
    return noOperation;
  };

  SliderMorph.prototype.rangeSize = function() {
    return this.stop - this.start;
  };

  SliderMorph.prototype.ratio = function() {
    return this.size / this.rangeSize();
  };

  SliderMorph.prototype.unitSize = function() {
    if (!((this.button != null) && this.button instanceof SliderButtonMorph)) {
      return 1;
    }
    if (this.orientation === "vertical") {
      return (this.height() - this.button.height()) / this.rangeSize();
    } else {
      return (this.width() - this.button.width()) / this.rangeSize();
    }
  };

  SliderMorph.prototype.updateValue = function() {
    var newvalue, relPos;
    if (this.orientation === "vertical") {
      relPos = this.button.top() - this.top();
    } else {
      relPos = this.button.left() - this.left();
    }
    newvalue = Math.round(relPos / this.unitSize() + this.start);
    if (this.value !== newvalue) {
      this.value = newvalue;
      return this.updateTarget();
    }
  };

  SliderMorph.prototype.updateTarget = function() {
    if (this.action) {
      if (typeof this.action === "function") {
        console.log("scrollbar invoked with function");
        debugger;
        return this.action.call(this.target, this.value, this.target);
      } else {
        return this.target[this.action].call(this.target, this.value, this.argumentToAction);
      }
    }
  };

  SliderMorph.prototype.developersMenu = function() {
    var menu;
    menu = SliderMorph.__super__.developersMenu.call(this);
    menu.addItem("show value", true, this, "showValue", "display a dialog box\nshowing the selected number");
    menu.addItem("floor...", true, this, (function() {
      return this.prompt(menu.title + "\nfloor:", this.setStart, this.start.toString(), null, 0, this.stop - this.size, true);
    }), "set the minimum value\nwhich can be selected");
    menu.addItem("ceiling...", true, this, (function() {
      return this.prompt(menu.title + "\nceiling:", this.setStop, this.stop.toString(), null, this.start + this.size, this.size * 100, true);
    }), "set the maximum value\nwhich can be selected");
    menu.addItem("button size...", true, this, (function() {
      return this.prompt(menu.title + "\nbutton size:", this.setSize, this.size.toString(), null, 1, this.stop - this.start, true);
    }), "set the range\ncovered by\nthe slider button");
    menu.addLine();
    menu.addItem("set target", true, this, "setTarget", "select another morph\nwhose numerical property\nwill be " + "controlled by this one");
    return menu;
  };

  SliderMorph.prototype.showValue = function() {
    return this.inform(this.value);
  };

  SliderMorph.prototype.userSetStart = function(num) {
    return this.start = Math.max(num, this.stop);
  };

  SliderMorph.prototype.updateSpecs = function(start, stop, value, size) {
    if (start != null) {
      this.start = start;
    }
    if (stop != null) {
      this.stop = stop;
    }
    if (value != null) {
      this.value = value;
    }
    if (size != null) {
      this.size = size;
    }
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    this.button.setLayoutBeforeUpdatingBackingStore();
    this.button.updateBackingStore();
    return this.changed();
  };

  SliderMorph.prototype.setStart = function(numOrMorphGivingNum) {
    var newStart, num;
    if (numOrMorphGivingNum.getValue != null) {
      num = numOrMorphGivingNum.getValue();
    } else {
      num = numOrMorphGivingNum;
    }
    if (typeof num === "number") {
      this.start = Math.min(Math.max(num, 0), this.stop - this.size);
    } else {
      newStart = parseFloat(num);
      if (!isNaN(newStart)) {
        this.start = Math.min(Math.max(newStart, 0), this.stop - this.size);
      }
    }
    this.value = Math.max(this.value, this.start);
    this.updateTarget();
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    this.button.setLayoutBeforeUpdatingBackingStore();
    this.button.updateBackingStore();
    return this.changed();
  };

  SliderMorph.prototype.setStop = function(numOrMorphGivingNum) {
    var newStop, num;
    if (numOrMorphGivingNum.getValue != null) {
      num = numOrMorphGivingNum.getValue();
    } else {
      num = numOrMorphGivingNum;
    }
    if (typeof num === "number") {
      this.stop = Math.max(num, this.start + this.size);
    } else {
      newStop = parseFloat(num);
      if (!isNaN(newStop)) {
        this.stop = Math.max(newStop, this.start + this.size);
      }
    }
    this.value = Math.min(this.value, this.stop);
    this.updateTarget();
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    this.button.setLayoutBeforeUpdatingBackingStore();
    this.button.updateBackingStore();
    return this.changed();
  };

  SliderMorph.prototype.setSize = function(sizeOrMorphGivingSize) {
    var newSize, size;
    if (sizeOrMorphGivingSize.getValue != null) {
      size = sizeOrMorphGivingSize.getValue();
    } else {
      size = sizeOrMorphGivingSize;
    }
    if (typeof size === "number") {
      this.size = Math.min(Math.max(size, 1), this.stop - this.start);
    } else {
      newSize = parseFloat(size);
      if (!isNaN(newSize)) {
        this.size = Math.min(Math.max(newSize, 1), this.stop - this.start);
      }
    }
    this.value = Math.min(this.value, this.stop - this.size);
    this.updateTarget();
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    this.button.setLayoutBeforeUpdatingBackingStore();
    this.button.updateBackingStore();
    return this.changed();
  };

  SliderMorph.prototype.swapTargetsTHISNAMEISRANDOM = function(ignored, ignored2, theTarget, each) {
    this.target = theTarget;
    return this.action = each;
  };

  SliderMorph.prototype.setTargetSetter = function(ignored, ignored2, theTarget) {
    var choices, menu;
    choices = theTarget.numericalSetters();
    menu = new MenuMorph(false, this, true, true, "choose target property:");
    choices.forEach((function(_this) {
      return function(each) {
        return menu.addItem(each, true, _this, "swapTargetsTHISNAMEISRANDOM", null, null, null, null, null, theTarget, each);
      };
    })(this));
    if (choices.length === 0) {
      menu = new MenuMorph(false, this, true, true, "no target properties available");
    }
    return menu.popUpAtHand(this.firstContainerMenu());
  };

  SliderMorph.prototype.numericalSetters = function() {
    var list;
    list = SliderMorph.__super__.numericalSetters.call(this);
    list.push("setStart", "setStop", "setSize");
    return list;
  };

  SliderMorph.prototype.mouseDownLeft = function(pos) {
    var world;
    if (!this.button.bounds.containsPoint(pos)) {
      this.offset = new Point();
    } else {
      this.offset = pos.subtract(this.button.bounds.origin);
    }
    world = this.root();
    return this.step = (function(_this) {
      return function() {
        var mousePos, newPosition, newX, newY, oldButtonPosition;
        if (world.hand.mouseButton && _this.isVisible) {
          mousePos = world.hand.bounds.origin;
          oldButtonPosition = _this.button.position();
          if (_this.orientation === "vertical") {
            newX = _this.button.bounds.origin.x;
            newY = Math.max(Math.min(mousePos.y - _this.offset.y, _this.bottom() - _this.button.height()), _this.top());
          } else {
            newY = _this.button.bounds.origin.y;
            newX = Math.max(Math.min(mousePos.x - _this.offset.x, _this.right() - _this.button.width()), _this.left());
          }
          newPosition = new Point(newX, newY);
          if (!oldButtonPosition.eq(newPosition)) {
            _this.button.setPosition(newPosition);
            return _this.updateValue();
          }
        } else {
          return _this.step = null;
        }
      };
    })(this);
  };

  SliderMorph.coffeeScriptSourceOfThisClass = '# SliderMorph ///////////////////////////////////////////////////\n# Sliders (and hence slider button morphs)\n# are also used in the ScrollMorphs .\n\n# this comment below is needed to figure our dependencies between classes\n# REQUIRES globalFunctions\n# REQUIRES ControllerMixin\n\nclass SliderMorph extends CircleBoxMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith ControllerMixin\n\n  target: null\n  action: null\n  start: null\n  stop: null\n  value: null\n  size: null\n  offset: null\n  button: null\n  step: null\n  argumentToAction: null\n\n  constructor: (@start = 1, @stop = 100, @value = 50, @size = 10, orientation, color) ->\n    @button = new SliderButtonMorph()\n    @button.isfloatDraggable = false\n    @button.color = new Color(0, 0, 0)\n    @button.highlightColor = new Color(110, 110, 110)\n    @button.pressColor = new Color(100, 100, 100)\n    @button.alpha = 0.4\n    super orientation # if null, then a vertical one will be created\n    @alpha = 0.1\n    @color = color or new Color(0, 0, 0)\n    @silentSetExtent new Point(20, 100)\n    @silentAdd @button\n\n  imBeingAddedTo: (newParentMorph) ->\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    # might happen in phase of deserialization that\n    # the button reference here is still a string\n    # so skip in that case\n    if @button? and @button instanceof SliderButtonMorph\n      @button.setLayoutBeforeUpdatingBackingStore()\n      @button.updateBackingStore()\n    @changed()\n\n  setExtent: (a) ->\n    super a\n    # my backing store had just been updated\n    # in the call of super, now\n    # it\'s the time of the button\n    @button.setLayoutBeforeUpdatingBackingStore()\n    @button.updateBackingStore()\n  \n  autoOrientation: ->\n      noOperation\n  \n  rangeSize: ->\n    @stop - @start\n  \n  ratio: ->\n    @size / @rangeSize()\n  \n  unitSize: ->\n    # might happen in phase of deserialization that\n    # the button reference here is still a string\n    # so skip in that case\n    if !(@button? and @button instanceof SliderButtonMorph)\n      return 1\n    if @orientation is "vertical"\n      return (@height() - @button.height()) / @rangeSize()\n    else\n      return (@width() - @button.width()) / @rangeSize()\n    \n  updateValue: ->\n    if @orientation is "vertical"\n      relPos = @button.top() - @top()\n    else\n      relPos = @button.left() - @left()\n    newvalue = Math.round(relPos / @unitSize() + @start)\n    if @value != newvalue\n      @value = newvalue\n      @updateTarget()\n  \n  updateTarget: ->\n    if @action\n      if typeof @action is "function"\n        console.log "scrollbar invoked with function"\n        debugger\n        @action.call @target, @value, @target\n      else # assume it\'s a String\n        @target[@action].call @target, @value, @argumentToAction\n    \n  \n  # SliderMorph menu:\n  developersMenu: ->\n    menu = super()\n    menu.addItem "show value", true, @, "showValue", "display a dialog box\nshowing the selected number"\n    menu.addItem "floor...", true, @, (->\n      @prompt menu.title + "\nfloor:",\n        @setStart,\n        @start.toString(),\n        null,\n        0,\n        @stop - @size,\n        true\n    ), "set the minimum value\nwhich can be selected"\n    menu.addItem "ceiling...", true, @, (->\n      @prompt menu.title + "\nceiling:",\n        @setStop,\n        @stop.toString(),\n        null,\n        @start + @size,\n        @size * 100,\n        true\n    ), "set the maximum value\nwhich can be selected"\n    menu.addItem "button size...", true, @, (->\n      @prompt menu.title + "\nbutton size:",\n        @setSize,\n        @size.toString(),\n        null,\n        1,\n        @stop - @start,\n        true\n    ), "set the range\ncovered by\nthe slider button"\n    menu.addLine()\n    menu.addItem "set target", true, @, "setTarget", "select another morph\nwhose numerical property\nwill be " + "controlled by this one"\n    menu\n  \n  showValue: ->\n    @inform @value\n  \n  userSetStart: (num) ->\n    # for context menu demo purposes\n    @start = Math.max(num, @stop)\n\n  \n  # once you set all the properties of a slider you\n  # call this method so it updates itself\n  updateSpecs: (start, stop, value, size)->\n    if start? then @start = start\n    if stop? then @stop = stop\n    if value? then @value = value\n    if size? then @size = size\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    @button.setLayoutBeforeUpdatingBackingStore()\n    @button.updateBackingStore()\n    @changed()\n  \n  setStart: (numOrMorphGivingNum) ->\n\n    if numOrMorphGivingNum.getValue?\n      num = numOrMorphGivingNum.getValue()\n    else\n      num = numOrMorphGivingNum\n\n    # for context menu demo purposes\n    if typeof num is "number"\n      @start = Math.min(Math.max(num, 0), @stop - @size)\n    else\n      newStart = parseFloat(num)\n      @start = Math.min(Math.max(newStart, 0), @stop - @size)  unless isNaN(newStart)\n    @value = Math.max(@value, @start)\n    @updateTarget()\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    @button.setLayoutBeforeUpdatingBackingStore()\n    @button.updateBackingStore()\n    @changed()\n  \n  setStop: (numOrMorphGivingNum) ->\n\n    if numOrMorphGivingNum.getValue?\n      num = numOrMorphGivingNum.getValue()\n    else\n      num = numOrMorphGivingNum\n\n    # for context menu demo purposes\n    if typeof num is "number"\n      @stop = Math.max(num, @start + @size)\n    else\n      newStop = parseFloat(num)\n      @stop = Math.max(newStop, @start + @size)  unless isNaN(newStop)\n    @value = Math.min(@value, @stop)\n    @updateTarget()\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    @button.setLayoutBeforeUpdatingBackingStore()\n    @button.updateBackingStore()\n    @changed()\n  \n  setSize: (sizeOrMorphGivingSize) ->\n    if sizeOrMorphGivingSize.getValue?\n      size = sizeOrMorphGivingSize.getValue()\n    else\n      size = sizeOrMorphGivingSize\n\n    # for context menu demo purposes\n    if typeof size is "number"\n      @size = Math.min(Math.max(size, 1), @stop - @start)\n    else\n      newSize = parseFloat(size)\n      @size = Math.min(Math.max(newSize, 1), @stop - @start)  unless isNaN(newSize)\n    @value = Math.min(@value, @stop - @size)\n    @updateTarget()\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    @button.setLayoutBeforeUpdatingBackingStore()\n    @button.updateBackingStore()\n    @changed()\n  \n  # setTarget: -> taken form the ControllerMixin\n\n  swapTargetsTHISNAMEISRANDOM: (ignored, ignored2, theTarget, each) ->\n    @target = theTarget\n    @action = each\n  \n  setTargetSetter: (ignored, ignored2, theTarget) ->\n    choices = theTarget.numericalSetters()\n    menu = new MenuMorph(false, @, true, true, "choose target property:")\n    choices.forEach (each) =>\n      menu.addItem each, true, @, "swapTargetsTHISNAMEISRANDOM", null, null, null, null, null,theTarget, each\n    if choices.length == 0\n      menu = new MenuMorph(false, @, true, true, "no target properties available")\n    menu.popUpAtHand(@firstContainerMenu())\n\n  \n  numericalSetters: ->\n    # for context menu demo purposes\n    list = super()\n    list.push "setStart", "setStop", "setSize"\n    list\n  \n  \n  # SliderMorph stepping:\n  mouseDownLeft: (pos) ->\n    unless @button.bounds.containsPoint(pos)\n      @offset = new Point() # return null;\n    else\n      @offset = pos.subtract(@button.bounds.origin)\n    world = @root()\n    # this is to create the "floatDrag the slider" effect\n    # basically if the mouse is pressing within the boundaries\n    # then in the next step you remember to check again where the mouse\n    # is and update the scrollbar. As soon as the mouse is unpressed\n    # then the step function is set to null to save cycles.\n    @step = =>\n      if world.hand.mouseButton and @isVisible\n        mousePos = world.hand.bounds.origin\n        oldButtonPosition = @button.position()\n        if @orientation is "vertical"\n          newX = @button.bounds.origin.x\n          newY = Math.max(\n            Math.min(mousePos.y - @offset.y,\n            @bottom() - @button.height()), @top())\n        else\n          newY = @button.bounds.origin.y\n          newX = Math.max(\n            Math.min(mousePos.x - @offset.x,\n            @right() - @button.width()), @left())\n        newPosition = new Point(newX, newY)\n        if !oldButtonPosition.eq newPosition\n          @button.setPosition newPosition\n          @updateValue()\n      else\n        @step = null';

  return SliderMorph;

})(CircleBoxMorph);

SpeechBubbleMorph = (function(_super) {
  __extends(SpeechBubbleMorph, _super);

  namedClasses[SpeechBubbleMorph.name] = SpeechBubbleMorph.prototype;

  SpeechBubbleMorph.prototype.isPointingRight = true;

  SpeechBubbleMorph.prototype.contents = null;

  SpeechBubbleMorph.prototype.padding = null;

  SpeechBubbleMorph.prototype.isThought = null;

  SpeechBubbleMorph.prototype.isClickable = false;

  SpeechBubbleMorph.prototype.morphInvokingThis = null;

  function SpeechBubbleMorph(contents, morphInvokingThis, color, edge, border, padding, isThought) {
    this.contents = contents != null ? contents : "";
    this.morphInvokingThis = morphInvokingThis;
    this.padding = padding != null ? padding : 0;
    this.isThought = isThought != null ? isThought : false;
    this.color = color || new Color(230, 230, 230);
    SpeechBubbleMorph.__super__.constructor.call(this, edge || 6, border || (border === 0 ? 0 : 1));
  }

  SpeechBubbleMorph.createBubbleHelpIfHandStillOnMorph = function(contents, morphInvokingThis) {
    var theBubble;
    if ((morphInvokingThis.world() != null) && morphInvokingThis.bounds.containsPoint(morphInvokingThis.world().hand.position())) {
      theBubble = new this(localize(contents), morphInvokingThis, null, null, 1);
      return theBubble.popUp(theBubble.morphInvokingThis.rightCenter().add(new Point(-8, 0)));
    }
  };

  SpeechBubbleMorph.createInAWhileIfHandStillContainedInMorph = function(morphInvokingThis, contents, delay) {
    if (delay == null) {
      delay = 500;
    }
    if (AutomatorRecorderAndPlayer.animationsPacingControl && AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.IDLE) {
      return this.createBubbleHelpIfHandStillOnMorph(contents, morphInvokingThis);
    } else {
      return setTimeout(((function(_this) {
        return function() {
          return _this.createBubbleHelpIfHandStillOnMorph(contents, morphInvokingThis);
        };
      })(this)), delay);
    }
  };

  SpeechBubbleMorph.prototype.popUp = function(pos, isClickable) {
    var world;
    world = this.morphInvokingThis.world();
    this.setPosition(pos.subtract(new Point(0, this.height())));
    this.keepWithin(world);
    this.buildAndConnectChildren();
    world.add(this);
    this.addShadow();
    this.fullChanged();
    world.hand.destroyTemporaries();
    world.hand.temporaries.push(this);
    if (isClickable) {
      return this.mouseEnter = function() {
        return this.destroy();
      };
    } else {
      return this.isClickable = false;
    }
  };

  SpeechBubbleMorph.prototype.buildAndConnectChildren = function() {
    if (this.contentsMorph) {
      this.contentsMorph = this.contentsMorph.destroy();
    }
    if (this.contents instanceof Morph) {
      this.contentsMorph = this.contents;
    } else if (isString(this.contents)) {
      this.contentsMorph = new TextMorph(this.contents, WorldMorph.preferencesAndSettings.bubbleHelpFontSize, null, false, true, "center");
    } else if (this.contents instanceof HTMLCanvasElement) {
      this.contentsMorph = new Morph();
      this.contentsMorph.silentSetWidth(this.contents.width);
      this.contentsMorph.silentSetHeight(this.contents.height);
      this.contentsMorph.image = this.contents;
    } else {
      this.contentsMorph = new TextMorph(this.contents.toString(), WorldMorph.preferencesAndSettings.bubbleHelpFontSize, null, false, true, "center");
    }
    this.add(this.contentsMorph);
    this.silentSetWidth(this.contentsMorph.width() + (this.padding ? this.padding * 2 : this.edge * 2));
    this.silentSetHeight(this.contentsMorph.height() + this.edge + this.border * 2 + this.padding * 2 + 2);
    return this.contentsMorph.setPosition(this.position().add(new Point(this.padding || this.edge, this.border + this.padding + 1)));
  };

  SpeechBubbleMorph.prototype.outlinePath = function(context, radius, inset) {
    var circle, h, offset, rad, w;
    circle = function(x, y, r) {
      context.moveTo(x + r, y);
      return context.arc(x, y, r, degreesToRadians(0), degreesToRadians(360));
    };
    offset = radius + inset;
    w = this.width();
    h = this.height();
    context.arc(offset, offset, radius, degreesToRadians(-180), degreesToRadians(-90), false);
    context.arc(w - offset, offset, radius, degreesToRadians(-90), degreesToRadians(-0), false);
    context.arc(w - offset, h - offset - radius, radius, degreesToRadians(0), degreesToRadians(90), false);
    if (!this.isThought) {
      if (this.isPointingRight) {
        context.lineTo(offset + radius, h - offset);
        context.lineTo(radius / 2 + inset, h - inset);
      } else {
        context.lineTo(w - (radius / 2 + inset), h - inset);
        context.lineTo(w - (offset + radius), h - offset);
      }
    }
    context.arc(offset, h - offset - radius, radius, degreesToRadians(90), degreesToRadians(180), false);
    if (this.isThought) {
      context.lineTo(inset, offset);
      if (this.isPointingRight) {
        rad = radius / 4;
        circle(rad + inset, h - rad - inset, rad);
        rad = radius / 3.2;
        circle(rad * 2 + inset, h - rad - inset * 2, rad);
        rad = radius / 2.8;
        return circle(rad * 3 + inset * 2, h - rad - inset * 4, rad);
      } else {
        rad = radius / 4;
        circle(w - (rad + inset), h - rad - inset, rad);
        rad = radius / 3.2;
        circle(w - (rad * 2 + inset), h - rad - inset * 2, rad);
        rad = radius / 2.8;
        return circle(w - (rad * 3 + inset * 2), h - rad - inset * 4, rad);
      }
    }
  };

  SpeechBubbleMorph.coffeeScriptSourceOfThisClass = '# SpeechBubbleMorph ///////////////////////////////////////////////////\n\n#\n#	I am a comic-style speech bubble that can display either a string,\n#	a Morph, a Canvas or a toString() representation of anything else.\n#	If I am invoked using popUp() I behave like a tool tip.\n#\n\nclass SpeechBubbleMorph extends BoxMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  isPointingRight: true # orientation of text\n  contents: null\n  padding: null # additional vertical pixels\n  isThought: null # draw "think" bubble\n  isClickable: false\n  morphInvokingThis: null\n\n  constructor: (\n    @contents="",\n    @morphInvokingThis,\n    color,\n    edge,\n    border,\n    @padding = 0,\n    @isThought = false) ->\n      # console.log "bubble super"\n      @color = color or new Color(230, 230, 230)\n      super edge or 6, border or ((if (border is 0) then 0 else 1))\n      # console.log @color\n  \n  @createBubbleHelpIfHandStillOnMorph: (contents, morphInvokingThis) ->\n    # console.log "bubble createBubbleHelpIfHandStillOnMorph"\n    # let\'s check that the item that the\n    # bubble is about is still actually there\n    # and the mouse is still over it, otherwise\n    # do nothing.\n    if morphInvokingThis.world()? and morphInvokingThis.bounds.containsPoint(morphInvokingThis.world().hand.position())\n      theBubble = new @(localize(contents), morphInvokingThis, null, null, 1)\n      theBubble.popUp theBubble.morphInvokingThis.rightCenter().add(new Point(-8, 0))\n\n  @createInAWhileIfHandStillContainedInMorph: (morphInvokingThis, contents, delay = 500) ->\n    # console.log "bubble createInAWhileIfHandStillContainedInMorph"\n    if AutomatorRecorderAndPlayer.animationsPacingControl and\n     AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE\n        @createBubbleHelpIfHandStillOnMorph contents, morphInvokingThis\n    else\n      setTimeout (=>\n        @createBubbleHelpIfHandStillOnMorph contents, morphInvokingThis\n        )\n        , delay\n  \n  # SpeechBubbleMorph invoking:\n  popUp: (pos, isClickable) ->\n    # console.log "bubble popup"\n    world = @morphInvokingThis.world()\n    @setPosition pos.subtract(new Point(0, @height()))\n    @keepWithin world\n\n    @buildAndConnectChildren()\n\n    world.add @\n    @addShadow()\n    @fullChanged()\n    world.hand.destroyTemporaries()\n    world.hand.temporaries.push @\n    if isClickable\n      @mouseEnter = ->\n        @destroy()\n    else\n      @isClickable = false\n    \n  buildAndConnectChildren: ->\n    # console.log "bubble buildAndConnectChildren"\n    # re-build my contents\n    if @contentsMorph\n      @contentsMorph = @contentsMorph.destroy()\n    if @contents instanceof Morph\n      @contentsMorph = @contents\n    else if isString(@contents)\n      @contentsMorph = new TextMorph(\n        @contents,\n        WorldMorph.preferencesAndSettings.bubbleHelpFontSize,\n        null,\n        false,\n        true,\n        "center")\n    else if @contents instanceof HTMLCanvasElement\n      @contentsMorph = new Morph()\n      @contentsMorph.silentSetWidth @contents.width\n      @contentsMorph.silentSetHeight @contents.height\n      @contentsMorph.image = @contents\n    else\n      @contentsMorph = new TextMorph(\n        @contents.toString(),\n        WorldMorph.preferencesAndSettings.bubbleHelpFontSize,\n        null,\n        false,\n        true,\n        "center")\n    @add @contentsMorph\n\n    # adjust my layout\n    @silentSetWidth @contentsMorph.width() + ((if @padding then @padding * 2 else @edge * 2))\n    @silentSetHeight @contentsMorph.height() + @edge + @border * 2 + @padding * 2 + 2\n\n    # draw my outline\n    #super()\n\n    # position my contents\n    @contentsMorph.setPosition @position().add(\n      new Point(@padding or @edge, @border + @padding + 1))\n\n\n  outlinePath: (context, radius, inset) ->\n    # console.log "bubble outlinePath"\n    circle = (x, y, r) ->\n      context.moveTo x + r, y\n      context.arc x, y, r, degreesToRadians(0), degreesToRadians(360)\n    offset = radius + inset\n    w = @width()\n    h = @height()\n\n    # top left:\n    context.arc offset, offset, radius, degreesToRadians(-180), degreesToRadians(-90), false\n\n    # top right:\n    context.arc w - offset, offset, radius, degreesToRadians(-90), degreesToRadians(-0), false\n\n    # bottom right:\n    context.arc w - offset, h - offset - radius, radius, degreesToRadians(0), degreesToRadians(90), false\n    unless @isThought # draw speech bubble hook\n      if @isPointingRight\n        context.lineTo offset + radius, h - offset\n        context.lineTo radius / 2 + inset, h - inset\n      else # pointing left\n        context.lineTo w - (radius / 2 + inset), h - inset\n        context.lineTo w - (offset + radius), h - offset\n\n    # bottom left:\n    context.arc offset, h - offset - radius, radius, degreesToRadians(90), degreesToRadians(180), false\n\n    if @isThought\n      # close large bubble:\n      context.lineTo inset, offset\n\n      # draw thought bubbles:\n      if @isPointingRight\n\n        # tip bubble:\n        rad = radius / 4\n        circle rad + inset, h - rad - inset, rad\n\n        # middle bubble:\n        rad = radius / 3.2\n        circle rad * 2 + inset, h - rad - inset * 2, rad\n\n        # top bubble:\n        rad = radius / 2.8\n        circle rad * 3 + inset * 2, h - rad - inset * 4, rad\n      else # pointing left\n        # tip bubble:\n        rad = radius / 4\n        circle w - (rad + inset), h - rad - inset, rad\n\n        # middle bubble:\n        rad = radius / 3.2\n        circle w - (rad * 2 + inset), h - rad - inset * 2, rad\n\n        # top bubble:\n        rad = radius / 2.8\n        circle w - (rad * 3 + inset * 2), h - rad - inset * 4, rad\n';

  return SpeechBubbleMorph;

})(BoxMorph);

StringFieldMorph = (function(_super) {
  __extends(StringFieldMorph, _super);

  namedClasses[StringFieldMorph.name] = StringFieldMorph.prototype;

  StringFieldMorph.prototype.defaultContents = null;

  StringFieldMorph.prototype.minWidth = null;

  StringFieldMorph.prototype.fontSize = null;

  StringFieldMorph.prototype.fontStyle = null;

  StringFieldMorph.prototype.isBold = null;

  StringFieldMorph.prototype.isItalic = null;

  StringFieldMorph.prototype.isNumeric = null;

  StringFieldMorph.prototype.text = null;

  StringFieldMorph.prototype.isEditable = true;

  function StringFieldMorph(defaultContents, minWidth, fontSize, fontStyle, isBold, isItalic, isNumeric) {
    this.defaultContents = defaultContents != null ? defaultContents : "";
    this.minWidth = minWidth != null ? minWidth : 100;
    this.fontSize = fontSize != null ? fontSize : 12;
    this.fontStyle = fontStyle != null ? fontStyle : "sans-serif";
    this.isBold = isBold != null ? isBold : false;
    this.isItalic = isItalic != null ? isItalic : false;
    this.isNumeric = isNumeric != null ? isNumeric : false;
    StringFieldMorph.__super__.constructor.call(this);
    this.color = new Color(255, 255, 255);
  }

  StringFieldMorph.prototype.setWidth = function(newWidth) {
    StringFieldMorph.__super__.setWidth.call(this, newWidth);
    return this.text.setWidth(newWidth);
  };

  StringFieldMorph.prototype.calculateAndUpdateExtent = function() {
    var text, txt;
    txt = (this.text ? this.getValue() : this.defaultContents);
    text = new StringMorph(txt, this.fontSize, this.fontStyle, this.isBold, this.isItalic, this.isNumeric);
    console.log("text morph extent: " + text.text + " : " + text.extent());
    this.setWidth(Math.max(this.minWidth, text.width()));
    return console.log("string fleid morph extent: " + this.extent());
  };

  StringFieldMorph.prototype.setLayoutBeforeUpdatingBackingStore = function() {
    var txt;
    txt = (this.text ? this.getValue() : this.defaultContents);
    this.text = null;
    this.destroyAll();
    this.text = new StringMorph(txt, this.fontSize, this.fontStyle, this.isBold, this.isItalic, this.isNumeric);
    this.text.isNumeric = this.isNumeric;
    this.text.setPosition(this.bounds.origin.copy());
    this.text.isEditable = this.isEditable;
    this.text.isfloatDraggable = false;
    this.text.enableSelecting();
    this.silentSetExtent(new Point(Math.max(this.width(), this.minWidth), this.text.height()));
    return this.add(this.text);
  };

  StringFieldMorph.prototype.getValue = function() {
    return this.text.text;
  };

  StringFieldMorph.prototype.mouseClickLeft = function(pos) {
    StringFieldMorph.__super__.mouseClickLeft.call(this);
    if (this.isEditable) {
      return this.text.edit();
    } else {
      return this.escalateEvent('mouseClickLeft', pos);
    }
  };

  StringFieldMorph.coffeeScriptSourceOfThisClass = '# StringFieldMorph ////////////////////////////////////////////////////\n\nclass StringFieldMorph extends FrameMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  defaultContents: null\n  minWidth: null\n  fontSize: null\n  fontStyle: null\n  isBold: null\n  isItalic: null\n  isNumeric: null\n  text: null\n  isEditable: true\n\n  constructor: (\n      @defaultContents = "",\n      @minWidth = 100,\n      @fontSize = 12,\n      @fontStyle = "sans-serif",\n      @isBold = false,\n      @isItalic = false,\n      @isNumeric = false\n      ) ->\n    super()\n    @color = new Color(255, 255, 255)\n\n  setWidth: (newWidth)->\n    super(newWidth)\n    @text.setWidth(newWidth)\n\n\n  calculateAndUpdateExtent: ->\n    txt = (if @text then @getValue() else @defaultContents)\n    text = new StringMorph(txt, @fontSize, @fontStyle, @isBold, @isItalic, @isNumeric)\n    console.log "text morph extent: " + text.text + " : " + text.extent()\n    @setWidth(Math.max(@minWidth,text.width()))\n    console.log "string fleid morph extent: " + @extent()\n\n  setLayoutBeforeUpdatingBackingStore: ->\n    txt = (if @text then @getValue() else @defaultContents)\n    @text = null\n    @destroyAll()\n    @text = new StringMorph(txt, @fontSize, @fontStyle, @isBold, @isItalic, @isNumeric)\n    @text.isNumeric = @isNumeric # for whichever reason...\n    @text.setPosition @bounds.origin.copy()\n    @text.isEditable = @isEditable\n    @text.isfloatDraggable = false\n    @text.enableSelecting()    \n    @silentSetExtent new Point(Math.max(@width(), @minWidth), @text.height())\n    @add @text\n\n  \n  getValue: ->\n    @text.text\n  \n  mouseClickLeft: (pos)->\n    super()\n    if @isEditable\n      @text.edit()\n    else\n      @escalateEvent \'mouseClickLeft\', pos\n  ';

  return StringFieldMorph;

})(FrameMorph);

SystemTestsControlPanelUpdater = (function() {
  SystemTestsControlPanelUpdater.prototype.SystemTestsControlPanelDiv = null;

  SystemTestsControlPanelUpdater.SystemTestsControlPanelOutputConsoleDiv = null;

  SystemTestsControlPanelUpdater.resetWorldLink = null;

  SystemTestsControlPanelUpdater.tieAnimations = null;

  SystemTestsControlPanelUpdater.alignMorphIDs = null;

  SystemTestsControlPanelUpdater.hideGeometry = null;

  SystemTestsControlPanelUpdater.hideMorphContentExtracts = null;

  SystemTestsControlPanelUpdater.hideMorphIDs = null;

  SystemTestsControlPanelUpdater.takeScreenshot = null;

  SystemTestsControlPanelUpdater.checkNumnberOfItems = null;

  SystemTestsControlPanelUpdater.checkMenuEntriesInOrder = null;

  SystemTestsControlPanelUpdater.checkMenuEntriesNotInOrder = null;

  SystemTestsControlPanelUpdater.addTestComment = null;

  SystemTestsControlPanelUpdater.stopTestRec = null;

  SystemTestsControlPanelUpdater.highlightOnLink = function(theElementName) {
    var theElement;
    theElement = document.getElementById(theElementName + "On");
    if (theElement != null) {
      theElement.style.backgroundColor = 'red';
    }
    theElement = document.getElementById(theElementName + "Off");
    if (theElement != null) {
      return theElement.style.backgroundColor = 'white';
    }
  };

  SystemTestsControlPanelUpdater.highlightOffLink = function(theElementName) {
    var theElement;
    theElement = document.getElementById(theElementName + "On");
    if (theElement != null) {
      theElement.style.backgroundColor = 'white';
    }
    theElement = document.getElementById(theElementName + "Off");
    if (theElement != null) {
      return theElement.style.backgroundColor = 'red';
    }
  };

  SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole = function(theText) {
    return SystemTestsControlPanelUpdater.SystemTestsControlPanelOutputConsoleDiv.innerHTML = SystemTestsControlPanelUpdater.SystemTestsControlPanelOutputConsoleDiv.innerHTML + theText + "</br>";
  };

  SystemTestsControlPanelUpdater.addMessageToTestCommentsConsole = function(theText) {
    return SystemTestsControlPanelUpdater.SystemTestsControlPanelTestCommentsOutputConsoleDiv.innerHTML = SystemTestsControlPanelUpdater.SystemTestsControlPanelTestCommentsOutputConsoleDiv.innerHTML + theText + "</br>";
  };

  SystemTestsControlPanelUpdater.blinkLink = function(theId) {
    var theElement;
    theElement = document.getElementById(theId);
    if (theElement != null) {
      theElement.style.backgroundColor = 'red';
      setTimeout(function() {
        return theElement.style.backgroundColor = 'white';
      }, 100);
    }
    setTimeout(function() {
      return theElement.style.backgroundColor = 'red';
    }, 200);
    return setTimeout(function() {
      return theElement.style.backgroundColor = 'white';
    }, 300);
  };

  SystemTestsControlPanelUpdater.prototype.addLink = function(theText, theFunction) {
    var aTag, br, linkID;
    aTag = document.createElement("a");
    linkID = theText.replace(/[^a-zA-Z0-9]/g, "");
    aTag.id = linkID;
    aTag.setAttribute("href", "#");
    aTag.innerHTML = theText;
    aTag.onclick = theFunction;
    this.SystemTestsControlPanelDiv.appendChild(aTag);
    br = document.createElement('br');
    this.SystemTestsControlPanelDiv.appendChild(br);
    return linkID;
  };

  SystemTestsControlPanelUpdater.prototype.addOnOffSwitchLink = function(theText, onShortcut, offShortcut, onAction, offAction) {
    var aLittleSpacerSpan, aLittleSpan, br, linkID, offLinkElement, onLinkElement;
    linkID = theText.replace(/[^a-zA-Z0-9]/g, "");
    aLittleSpan = document.createElement("span");
    aLittleSpan.innerHTML = theText + " ";
    aLittleSpacerSpan = document.createElement("span");
    aLittleSpacerSpan.innerHTML = " ";
    onLinkElement = document.createElement("a");
    onLinkElement.setAttribute("href", "#");
    onLinkElement.innerHTML = "on:" + onShortcut;
    onLinkElement.id = linkID + "On";
    onLinkElement.onclick = onAction;
    offLinkElement = document.createElement("a");
    offLinkElement.setAttribute("href", "#");
    offLinkElement.innerHTML = "off:" + offShortcut;
    offLinkElement.id = linkID + "Off";
    offLinkElement.onclick = offAction;
    this.SystemTestsControlPanelDiv.appendChild(aLittleSpan);
    this.SystemTestsControlPanelDiv.appendChild(onLinkElement);
    this.SystemTestsControlPanelDiv.appendChild(aLittleSpacerSpan);
    this.SystemTestsControlPanelDiv.appendChild(offLinkElement);
    br = document.createElement('br');
    this.SystemTestsControlPanelDiv.appendChild(br);
    return linkID;
  };

  SystemTestsControlPanelUpdater.prototype.addOutputPanel = function(nameOfPanel, css) {
    SystemTestsControlPanelUpdater[nameOfPanel] = document.createElement('div');
    SystemTestsControlPanelUpdater[nameOfPanel].id = nameOfPanel;
    SystemTestsControlPanelUpdater[nameOfPanel].style.cssText = css;
    return document.body.appendChild(SystemTestsControlPanelUpdater[nameOfPanel]);
  };

  function SystemTestsControlPanelUpdater() {
    var allTestsProgressBar, allTestsProgressBarWrap, allTestsProgressIndicator, elem, leftMouseButtonIndicator, mousePointerIndicator, numberOfTestsDoneIndicator, rightMouseButtonIndicator, singleTestProgressBar, singleTestProgressBarWrap, singleTestProgressIndicator, testTitleAndDescription, theCanvasDiv;
    document.getElementById("world").style.top = "25px";
    this.SystemTestsControlPanelDiv = document.createElement('div');
    this.SystemTestsControlPanelDiv.id = "SystemTestsControlPanel";
    this.SystemTestsControlPanelDiv.style.cssText = 'border: 1px solid green; overflow: hidden; font-size: x-small; top: 464px; left: 200px; position: absolute;';
    document.body.appendChild(this.SystemTestsControlPanelDiv);
    this.addOutputPanel("SystemTestsControlPanelOutputConsoleDiv", "height: 127px; width: 571px; border: 1px solid red; overflow-y: scroll; overflow-x: hidden; position: absolute; top: 464px; left: 386px;");
    this.addOutputPanel("SystemTestsControlPanelTestCommentsOutputConsoleDiv", "height: 128px; border: 1px solid red; overflow-y: scroll; overflow-x: hidden;position: absolute;top: 592px;width: 757px;left: 200px;");
    theCanvasDiv = document.getElementById('world');
    theCanvasDiv.style.styleFloat = 'left';
    theCanvasDiv.style.cssFloat = 'left';
    SystemTestsControlPanelUpdater.resetWorldLink = this.addLink("alt+d: reset world", (function() {
      return window.world.systemTestsRecorderAndPlayer.resetWorld();
    }));
    SystemTestsControlPanelUpdater.tieAnimations = this.addOnOffSwitchLink("tie animations to test step", "alt+e", "alt+u", (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOnAnimationsPacingControl();
    }), (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl();
    }));
    SystemTestsControlPanelUpdater.alignMorphIDs = this.addOnOffSwitchLink("periodically align Morph IDs", "-", "-", (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOnAlignmentOfMorphIDsMechanism();
    }), (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOffAlignmentOfMorphIDsMechanism();
    }));
    SystemTestsControlPanelUpdater.hideGeometry = this.addOnOffSwitchLink("hide Morph geometry in labels", "-", "-", (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOnHidingOfMorphsGeometryInfoInLabels();
    }), (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsGeometryInfoInLabels();
    }));
    SystemTestsControlPanelUpdater.hideMorphContentExtracts = this.addOnOffSwitchLink("hide Morph content extract in labels", "-", "-", (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOnHidingOfMorphsContentExtractInLabels();
    }), (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsContentExtractInLabels();
    }));
    SystemTestsControlPanelUpdater.hideMorphIDs = this.addOnOffSwitchLink("hide Morph number ID in labels", "-", "-", (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOnHidingOfMorphsNumberIDInLabels();
    }), (function() {
      return window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsNumberIDInLabels();
    }));
    SystemTestsControlPanelUpdater.takeScreenshot = this.addLink("alt+c: take screenshot", (function() {
      return window.world.systemTestsRecorderAndPlayer.takeScreenshot();
    }));
    SystemTestsControlPanelUpdater.checkNumnberOfItems = this.addLink("alt+k: check number of items in menu", (function() {
      return window.world.systemTestsRecorderAndPlayer.checkNumberOfItemsInMenu();
    }));
    SystemTestsControlPanelUpdater.checkMenuEntriesInOrder = this.addLink("alt+a: check menu entries (in order)", (function() {
      return window.world.systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderImportant();
    }));
    SystemTestsControlPanelUpdater.checkMenuEntriesNotInOrder = this.addLink("alt+z: check menu entries (any order)", (function() {
      return window.world.systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderUnimportant();
    }));
    SystemTestsControlPanelUpdater.addTestComment = this.addLink("alt+m: add test comment", (function() {
      return window.world.systemTestsRecorderAndPlayer.addTestComment();
    }));
    SystemTestsControlPanelUpdater.stopTestRec = this.addLink("alt+t: stop test recording", (function() {
      return window.world.systemTestsRecorderAndPlayer.stopTestRecording();
    }));
    mousePointerIndicator = document.createElement('div');
    mousePointerIndicator.id = "mousePointerIndicator";
    mousePointerIndicator.style.cssText = 'position: absolute; display:none;';
    document.body.appendChild(mousePointerIndicator);
    elem = document.createElement("img");
    elem.setAttribute("src", "icons/xPointerImage.png");
    elem.setAttribute("width", "40px");
    elem.setAttribute("height", "40px");
    document.getElementById("mousePointerIndicator").appendChild(elem);
    leftMouseButtonIndicator = document.createElement('div');
    leftMouseButtonIndicator.id = "leftMouseButtonIndicator";
    leftMouseButtonIndicator.style.cssText = 'position: absolute; left: 10px; top: 477px;';
    document.body.appendChild(leftMouseButtonIndicator);
    elem = document.createElement("img");
    elem.setAttribute("src", "icons/leftButtonPressed.png");
    document.getElementById("leftMouseButtonIndicator").appendChild(elem);
    fade('leftMouseButtonIndicator', 1, 0, 10, new Date().getTime());
    rightMouseButtonIndicator = document.createElement('div');
    rightMouseButtonIndicator.id = "rightMouseButtonIndicator";
    rightMouseButtonIndicator.style.cssText = 'position: absolute; left: 10px; top: 477px;';
    document.body.appendChild(rightMouseButtonIndicator);
    elem = document.createElement("img");
    elem.setAttribute("src", "icons/rightButtonPressed.png");
    document.getElementById("rightMouseButtonIndicator").appendChild(elem);
    fade('rightMouseButtonIndicator', 1, 0, 10, new Date().getTime());
    singleTestProgressBar = document.createElement('div');
    singleTestProgressBar.id = "singleTestProgressBar";
    singleTestProgressBar.style.cssText = 'position: absolute; left: 20%; top: 0px; font-size: xx-large; font-family: sans-serif; width: 100%; height: 50px; background: rgb(173, 173, 173);';
    singleTestProgressBarWrap = document.createElement('div');
    singleTestProgressBarWrap.id = "singleTestProgressBarWrap";
    singleTestProgressBarWrap.style.cssText = 'position: absolute; left: 5px; top: 5px; font-size: xx-large; font-family: sans-serif; width: 120px; height: 14px; overflow: hidden; background: rgb(0, 0, 0);';
    singleTestProgressBarWrap.appendChild(singleTestProgressBar);
    document.body.appendChild(singleTestProgressBarWrap);
    fade('singleTestProgressBarWrap', 1, 0, 10, new Date().getTime());
    singleTestProgressIndicator = document.createElement('div');
    singleTestProgressIndicator.id = "singleTestProgressIndicator";
    singleTestProgressIndicator.style.cssText = 'position: absolute; left: 10px; top: 7px; font-size: x-small; font-family: sans-serif; color: white;';
    document.body.appendChild(singleTestProgressIndicator);
    fade('singleTestProgressIndicator', 1, 0, 10, new Date().getTime());
    allTestsProgressBar = document.createElement('div');
    allTestsProgressBar.id = "allTestsProgressBar";
    allTestsProgressBar.style.cssText = 'position: absolute; left: 20%; top: 0px; font-size: xx-large; font-family: sans-serif; width: 100%; height: 50px; background: rgb(173, 173, 173);';
    allTestsProgressBarWrap = document.createElement('div');
    allTestsProgressBarWrap.id = "allTestsProgressBarWrap";
    allTestsProgressBarWrap.style.cssText = 'position: absolute; left: 135px; top: 5px; font-size: xx-large; font-family: sans-serif; width: 120px; height: 14px; overflow: hidden; background: rgb(0, 0, 0);';
    allTestsProgressBarWrap.appendChild(allTestsProgressBar);
    document.body.appendChild(allTestsProgressBarWrap);
    fade('allTestsProgressBarWrap', 1, 0, 10, new Date().getTime());
    allTestsProgressIndicator = document.createElement('div');
    allTestsProgressIndicator.id = "allTestsProgressIndicator";
    allTestsProgressIndicator.style.cssText = 'position: absolute; left: 140px; top: 7px; font-size: x-small; font-family: sans-serif; color: white;';
    document.body.appendChild(allTestsProgressIndicator);
    fade('allTestsProgressIndicator', 1, 0, 10, new Date().getTime());
    testTitleAndDescription = document.createElement('div');
    testTitleAndDescription.id = "testTitleAndDescription";
    testTitleAndDescription.style.cssText = 'position: absolute; left: 0px; top: 25px; font-size: 1.5em; font-family: sans-serif; background-color: rgba(128, 128, 128, 1); width: 860px; height: 340px; padding: 50px; color: white;';
    document.body.appendChild(testTitleAndDescription);
    fade('testTitleAndDescription', 1, 0, 10, new Date().getTime());
    numberOfTestsDoneIndicator = document.createElement('div');
    numberOfTestsDoneIndicator.id = "numberOfTestsDoneIndicator";
    numberOfTestsDoneIndicator.style.cssText = 'position: absolute; left: 265px; top: 7px; font-size: x-small; font-family: sans-serif; color: black;';
    document.body.appendChild(numberOfTestsDoneIndicator);
    fade('numberOfTestsDoneIndicator', 1, 0, 10, new Date().getTime());
  }

  SystemTestsControlPanelUpdater.coffeeScriptSourceOfThisClass = '# Manages the controls of the System Tests\n# e.g. all the links/buttons to trigger commands\n# when recording tests such as\n#  - start recording tests\n#  - stop recording tests\n#  - take screenshot\n#  - save test files\n#  - place the mouse over a morph with particular ID...\n\n\nclass SystemTestsControlPanelUpdater\n\n  # Create the div where the controls will go\n  # and make it float to the right of the canvas.\n  # This requires tweaking the css of the canvas\n  # as well.\n\n  SystemTestsControlPanelDiv: null\n  @SystemTestsControlPanelOutputConsoleDiv: null\n\n  @resetWorldLink: null\n  @tieAnimations: null\n  @alignMorphIDs: null\n  @hideGeometry: null\n  @hideMorphContentExtracts: null\n  @hideMorphIDs: null\n  @takeScreenshot: null\n  @checkNumnberOfItems: null\n  @checkMenuEntriesInOrder: null\n  @checkMenuEntriesNotInOrder: null\n  @addTestComment: null\n  @stopTestRec: null\n\n  @highlightOnLink: (theElementName) ->\n    theElement = document.getElementById(theElementName + "On")\n    if theElement?\n      theElement.style.backgroundColor = \'red\'\n    theElement = document.getElementById(theElementName + "Off")\n    if theElement?\n      theElement.style.backgroundColor = \'white\'\n\n  @highlightOffLink: (theElementName) ->\n    theElement = document.getElementById(theElementName + "On")\n    if theElement?\n      theElement.style.backgroundColor = \'white\'\n    theElement = document.getElementById(theElementName + "Off")\n    if theElement?\n      theElement.style.backgroundColor = \'red\'\n\n\n  @addMessageToSystemTestsConsole: (theText) ->\n    SystemTestsControlPanelUpdater.SystemTestsControlPanelOutputConsoleDiv.innerHTML = SystemTestsControlPanelUpdater.SystemTestsControlPanelOutputConsoleDiv.innerHTML + theText + "</br>";\n\n  @addMessageToTestCommentsConsole: (theText) ->\n    SystemTestsControlPanelUpdater.SystemTestsControlPanelTestCommentsOutputConsoleDiv.innerHTML = SystemTestsControlPanelUpdater.SystemTestsControlPanelTestCommentsOutputConsoleDiv.innerHTML + theText + "</br>";\n\n  @blinkLink: (theId) ->\n    theElement = document.getElementById(theId)\n\n    if theElement?\n        theElement.style.backgroundColor = \'red\'\n        setTimeout ->\n            theElement.style.backgroundColor = \'white\'\n          , 100\n        setTimeout ->\n            theElement.style.backgroundColor = \'red\'\n          , 200\n        setTimeout ->\n            theElement.style.backgroundColor = \'white\'\n          , 300\n\n\n  addLink: (theText, theFunction) ->\n    aTag = document.createElement("a")\n    linkID = theText.replace(/[^a-zA-Z0-9]/g, "")\n    aTag.id = linkID\n    aTag.setAttribute "href", "#"\n    aTag.innerHTML = theText\n    aTag.onclick = theFunction\n    @SystemTestsControlPanelDiv.appendChild aTag\n    br = document.createElement(\'br\')\n    @SystemTestsControlPanelDiv.appendChild(br)\n    return linkID\n\n  addOnOffSwitchLink: (theText, onShortcut, offShortcut, onAction, offAction) ->\n    #aLittleDiv = document.createElement("div")\n    \n    linkID = theText.replace(/[^a-zA-Z0-9]/g, "")\n    aLittleSpan = document.createElement("span")\n    aLittleSpan.innerHTML = theText + " "\n\n    aLittleSpacerSpan = document.createElement("span")\n    aLittleSpacerSpan.innerHTML = " "\n\n    onLinkElement = document.createElement("a")\n    onLinkElement.setAttribute "href", "#"\n    onLinkElement.innerHTML = "on:"+onShortcut\n    onLinkElement.id = linkID + "On"\n    onLinkElement.onclick = onAction\n\n    offLinkElement = document.createElement("a")\n    offLinkElement.setAttribute "href", "#"\n    offLinkElement.innerHTML = "off:"+offShortcut\n    offLinkElement.id = linkID + "Off"\n    offLinkElement.onclick = offAction\n\n    @SystemTestsControlPanelDiv.appendChild aLittleSpan\n    @SystemTestsControlPanelDiv.appendChild onLinkElement\n    @SystemTestsControlPanelDiv.appendChild aLittleSpacerSpan\n    @SystemTestsControlPanelDiv.appendChild offLinkElement\n\n    br = document.createElement(\'br\')\n    @SystemTestsControlPanelDiv.appendChild(br);\n    return linkID\n\n  addOutputPanel: (nameOfPanel, css) ->\n    SystemTestsControlPanelUpdater[nameOfPanel] = document.createElement(\'div\')\n    SystemTestsControlPanelUpdater[nameOfPanel].id = nameOfPanel\n    SystemTestsControlPanelUpdater[nameOfPanel].style.cssText = css\n    document.body.appendChild(SystemTestsControlPanelUpdater[nameOfPanel])\n\n  constructor: ->\n    \n    document.getElementById("world").style.top = "25px"\n\n    @SystemTestsControlPanelDiv = document.createElement(\'div\')\n    @SystemTestsControlPanelDiv.id = "SystemTestsControlPanel"\n    @SystemTestsControlPanelDiv.style.cssText = \'border: 1px solid green; overflow: hidden; font-size: x-small; top: 464px; left: 200px; position: absolute;\'\n    document.body.appendChild(@SystemTestsControlPanelDiv)\n\n    @addOutputPanel "SystemTestsControlPanelOutputConsoleDiv", "height: 127px; width: 571px; border: 1px solid red; overflow-y: scroll; overflow-x: hidden; position: absolute; top: 464px; left: 386px;"\n    @addOutputPanel "SystemTestsControlPanelTestCommentsOutputConsoleDiv", "height: 128px; border: 1px solid red; overflow-y: scroll; overflow-x: hidden;position: absolute;top: 592px;width: 757px;left: 200px;"\n\n    theCanvasDiv = document.getElementById(\'world\')\n    # one of these is for IE and the other one\n    # for everybody else\n    theCanvasDiv.style.styleFloat = \'left\';\n    theCanvasDiv.style.cssFloat = \'left\';\n\n    # The spirit of these links is that it would\n    # be really inconvenient to trigger\n    # these commands using menus during the test.\n    # For example it would be inconvenient to stop\n    # the tests recording by selecting the command\n    # via e menu: a bunch of mouse actions would be\n    # recorded, exposing as well to the risk of the\n    # menu items changing.\n    SystemTestsControlPanelUpdater.resetWorldLink = @addLink "alt+d: reset world", (-> window.world.systemTestsRecorderAndPlayer.resetWorld())\n    SystemTestsControlPanelUpdater.tieAnimations = @addOnOffSwitchLink "tie animations to test step", "alt+e", "alt+u", (-> window.world.systemTestsRecorderAndPlayer.turnOnAnimationsPacingControl()), (-> window.world.systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl())\n    SystemTestsControlPanelUpdater.alignMorphIDs = @addOnOffSwitchLink "periodically align Morph IDs", "-", "-", (-> window.world.systemTestsRecorderAndPlayer.turnOnAlignmentOfMorphIDsMechanism()), (-> window.world.systemTestsRecorderAndPlayer.turnOffAlignmentOfMorphIDsMechanism())\n    SystemTestsControlPanelUpdater.hideGeometry = @addOnOffSwitchLink "hide Morph geometry in labels", "-", "-", (-> window.world.systemTestsRecorderAndPlayer.turnOnHidingOfMorphsGeometryInfoInLabels()), (-> window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsGeometryInfoInLabels())\n\n    SystemTestsControlPanelUpdater.hideMorphContentExtracts = @addOnOffSwitchLink "hide Morph content extract in labels", "-", "-", (-> window.world.systemTestsRecorderAndPlayer.turnOnHidingOfMorphsContentExtractInLabels()), (-> window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsContentExtractInLabels())\n\n    SystemTestsControlPanelUpdater.hideMorphIDs = @addOnOffSwitchLink "hide Morph number ID in labels", "-", "-", (-> window.world.systemTestsRecorderAndPlayer.turnOnHidingOfMorphsNumberIDInLabels()), (-> window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsNumberIDInLabels())\n\n    SystemTestsControlPanelUpdater.takeScreenshot = @addLink "alt+c: take screenshot", (-> window.world.systemTestsRecorderAndPlayer.takeScreenshot())\n    SystemTestsControlPanelUpdater.checkNumnberOfItems = @addLink "alt+k: check number of items in menu", (-> window.world.systemTestsRecorderAndPlayer.checkNumberOfItemsInMenu())\n    SystemTestsControlPanelUpdater.checkMenuEntriesInOrder = @addLink "alt+a: check menu entries (in order)", (-> window.world.systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderImportant())\n    SystemTestsControlPanelUpdater.checkMenuEntriesNotInOrder = @addLink "alt+z: check menu entries (any order)", (-> window.world.systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderUnimportant())\n    SystemTestsControlPanelUpdater.addTestComment = @addLink "alt+m: add test comment", (-> window.world.systemTestsRecorderAndPlayer.addTestComment())\n    SystemTestsControlPanelUpdater.stopTestRec = @addLink "alt+t: stop test recording", (-> window.world.systemTestsRecorderAndPlayer.stopTestRecording())\n\n\n    # add the div with the fake mouse pointer\n    mousePointerIndicator = document.createElement(\'div\')\n    mousePointerIndicator.id = "mousePointerIndicator"\n    mousePointerIndicator.style.cssText = \'position: absolute; display:none;\'\n    document.body.appendChild(mousePointerIndicator)\n    elem = document.createElement("img");\n    elem.setAttribute("src", "icons/xPointerImage.png");\n    # this image is actually 160x160\n    # to make sure it looks crisp on\n    # higher-ppi displays\n    elem.setAttribute("width", "40px");\n    elem.setAttribute("height", "40px");\n    document.getElementById("mousePointerIndicator").appendChild(elem);\n\n    # add the div highlighting the state of the\n    # left mouse button\n    leftMouseButtonIndicator = document.createElement(\'div\')\n    leftMouseButtonIndicator.id = "leftMouseButtonIndicator"\n    leftMouseButtonIndicator.style.cssText = \'position: absolute; left: 10px; top: 477px;\'\n    document.body.appendChild(leftMouseButtonIndicator)\n    elem = document.createElement("img");\n    elem.setAttribute("src", "icons/leftButtonPressed.png");\n    document.getElementById("leftMouseButtonIndicator").appendChild(elem);\n    fade(\'leftMouseButtonIndicator\', 1, 0, 10, new Date().getTime());\n\n    # add the div highlighting the state of the\n    # right mouse button\n    rightMouseButtonIndicator = document.createElement(\'div\')\n    rightMouseButtonIndicator.id = "rightMouseButtonIndicator"\n    rightMouseButtonIndicator.style.cssText = \'position: absolute; left: 10px; top: 477px;\'\n    document.body.appendChild(rightMouseButtonIndicator)\n    elem = document.createElement("img");\n    elem.setAttribute("src", "icons/rightButtonPressed.png");\n    document.getElementById("rightMouseButtonIndicator").appendChild(elem);\n    fade(\'rightMouseButtonIndicator\', 1, 0, 10, new Date().getTime());\n\n\n    # ------------------------------------------------------\n    # add the progress bar, which is made of two nested divs\n    singleTestProgressBar = document.createElement(\'div\')\n    singleTestProgressBar.id = "singleTestProgressBar"\n    singleTestProgressBar.style.cssText = \'position: absolute; left: 20%; top: 0px; font-size: xx-large; font-family: sans-serif; width: 100%; height: 50px; background: rgb(173, 173, 173);\'\n\n    singleTestProgressBarWrap = document.createElement(\'div\')\n    singleTestProgressBarWrap.id = "singleTestProgressBarWrap"\n    singleTestProgressBarWrap.style.cssText = \'position: absolute; left: 5px; top: 5px; font-size: xx-large; font-family: sans-serif; width: 120px; height: 14px; overflow: hidden; background: rgb(0, 0, 0);\'\n    singleTestProgressBarWrap.appendChild(singleTestProgressBar)\n    document.body.appendChild(singleTestProgressBarWrap)\n    fade(\'singleTestProgressBarWrap\', 1, 0, 10, new Date().getTime());\n\n    # add the div highlighting the percentage progress of the test\n    singleTestProgressIndicator = document.createElement(\'div\')\n    singleTestProgressIndicator.id = "singleTestProgressIndicator"\n    singleTestProgressIndicator.style.cssText = \'position: absolute; left: 10px; top: 7px; font-size: x-small; font-family: sans-serif; color: white;\'\n    document.body.appendChild(singleTestProgressIndicator)\n    fade(\'singleTestProgressIndicator\', 1, 0, 10, new Date().getTime());\n\n\n    # ------------------------------------------------------\n    # add the progress bar, which is made of two nested divs\n    allTestsProgressBar = document.createElement(\'div\')\n    allTestsProgressBar.id = "allTestsProgressBar"\n    allTestsProgressBar.style.cssText = \'position: absolute; left: 20%; top: 0px; font-size: xx-large; font-family: sans-serif; width: 100%; height: 50px; background: rgb(173, 173, 173);\'\n\n    allTestsProgressBarWrap = document.createElement(\'div\')\n    allTestsProgressBarWrap.id = "allTestsProgressBarWrap"\n    allTestsProgressBarWrap.style.cssText = \'position: absolute; left: 135px; top: 5px; font-size: xx-large; font-family: sans-serif; width: 120px; height: 14px; overflow: hidden; background: rgb(0, 0, 0);\'\n    allTestsProgressBarWrap.appendChild(allTestsProgressBar)\n    document.body.appendChild(allTestsProgressBarWrap)\n    fade(\'allTestsProgressBarWrap\', 1, 0, 10, new Date().getTime());\n\n    # add the div highlighting the percentage progress of the test\n    allTestsProgressIndicator = document.createElement(\'div\')\n    allTestsProgressIndicator.id = "allTestsProgressIndicator"\n    allTestsProgressIndicator.style.cssText = \'position: absolute; left: 140px; top: 7px; font-size: x-small; font-family: sans-serif; color: white;\'\n    document.body.appendChild(allTestsProgressIndicator)\n    fade(\'allTestsProgressIndicator\', 1, 0, 10, new Date().getTime());\n\n\n    # ------------------------------------------------------\n    # add the div with title and description of the test\n    testTitleAndDescription = document.createElement(\'div\')\n    testTitleAndDescription.id = "testTitleAndDescription"\n    testTitleAndDescription.style.cssText = \'position: absolute; left: 0px; top: 25px; font-size: 1.5em; font-family: sans-serif; background-color: rgba(128, 128, 128, 1); width: 860px; height: 340px; padding: 50px; color: white;\'\n    document.body.appendChild(testTitleAndDescription)\n    fade(\'testTitleAndDescription\', 1, 0, 10, new Date().getTime());\n    #testTitleAndDescription.innerHTML = "Test asdasdasdasdasdakjhdasdasdasd"\n\n    # ------------------------------------------------------\n    # add the div highlighting the percentage progress of the test\n    numberOfTestsDoneIndicator = document.createElement(\'div\')\n    numberOfTestsDoneIndicator.id = "numberOfTestsDoneIndicator"\n    numberOfTestsDoneIndicator.style.cssText = \'position: absolute; left: 265px; top: 7px; font-size: x-small; font-family: sans-serif; color: black;\'\n    document.body.appendChild(numberOfTestsDoneIndicator)\n    fade(\'numberOfTestsDoneIndicator\', 1, 0, 10, new Date().getTime());\n\n\n    ';

  return SystemTestsControlPanelUpdater;

})();

WorldMorph = (function(_super) {
  __extends(WorldMorph, _super);

  namedClasses[WorldMorph.name] = WorldMorph.prototype;

  WorldMorph.prototype.mousedownEventListener = null;

  WorldMorph.prototype.touchstartEventListener = null;

  WorldMorph.prototype.mouseupEventListener = null;

  WorldMorph.prototype.touchendEventListener = null;

  WorldMorph.prototype.mousemoveEventListener = null;

  WorldMorph.prototype.touchmoveEventListener = null;

  WorldMorph.prototype.gesturestartEventListener = null;

  WorldMorph.prototype.gesturechangeEventListener = null;

  WorldMorph.prototype.contextmenuEventListener = null;

  WorldMorph.prototype.keydownEventListener = null;

  WorldMorph.prototype.keyupEventListener = null;

  WorldMorph.prototype.keypressEventListener = null;

  WorldMorph.prototype.mousewheelEventListener = null;

  WorldMorph.prototype.DOMMouseScrollEventListener = null;

  WorldMorph.prototype.copyEventListener = null;

  WorldMorph.prototype.pasteEventListener = null;

  WorldMorph.prototype.lastSerializationString = "";

  WorldMorph.prototype.inputDOMElementForVirtualKeyboardKeydownEventListener = null;

  WorldMorph.prototype.inputDOMElementForVirtualKeyboardKeyupEventListener = null;

  WorldMorph.prototype.inputDOMElementForVirtualKeyboardKeypressEventListener = null;

  WorldMorph.prototype.keyComboResetWorldEventListener = null;

  WorldMorph.prototype.keyComboTurnOnAnimationsPacingControl = null;

  WorldMorph.prototype.keyComboTurnOffAnimationsPacingControl = null;

  WorldMorph.prototype.keyComboTakeScreenshotEventListener = null;

  WorldMorph.prototype.keyComboStopTestRecordingEventListener = null;

  WorldMorph.prototype.keyComboTakeScreenshotEventListener = null;

  WorldMorph.prototype.keyComboCheckStringsOfItemsInMenuOrderImportant = null;

  WorldMorph.prototype.keyComboCheckStringsOfItemsInMenuOrderUnimportant = null;

  WorldMorph.prototype.keyComboAddTestCommentEventListener = null;

  WorldMorph.prototype.keyComboCheckNumberOfMenuItemsEventListener = null;

  WorldMorph.prototype.dragoverEventListener = null;

  WorldMorph.prototype.dropEventListener = null;

  WorldMorph.prototype.resizeEventListener = null;

  WorldMorph.prototype.otherTasksToBeRunOnStep = [];

  WorldMorph.preferencesAndSettings = null;

  WorldMorph.currentTime = null;

  WorldMorph.prototype.showRedraws = false;

  WorldMorph.prototype.systemTestsRecorderAndPlayer = null;

  WorldMorph.prototype.worldCanvas = null;

  WorldMorph.prototype.automaticallyAdjustToFillEntireBrowserAlsoOnResize = true;

  WorldMorph.KEYPAD_TAB_mappedToThaiKeyboard_A = "ฟ";

  WorldMorph.KEYPAD_SLASH_mappedToThaiKeyboard_B = "ิ";

  WorldMorph.KEYPAD_MULTIPLY_mappedToThaiKeyboard_C = "แ";

  WorldMorph.KEYPAD_DELETE_mappedToThaiKeyboard_D = "ก";

  WorldMorph.KEYPAD_7_mappedToThaiKeyboard_E = "ำ";

  WorldMorph.KEYPAD_8_mappedToThaiKeyboard_F = "ด";

  WorldMorph.KEYPAD_9_mappedToThaiKeyboard_G = "เ";

  WorldMorph.KEYPAD_MINUS_mappedToThaiKeyboard_H = "้";

  WorldMorph.KEYPAD_4_mappedToThaiKeyboard_I = "ร";

  WorldMorph.KEYPAD_5_mappedToThaiKeyboard_J = "่";

  WorldMorph.KEYPAD_6_mappedToThaiKeyboard_K = "า";

  WorldMorph.KEYPAD_PLUS_mappedToThaiKeyboard_L = "ส";

  WorldMorph.KEYPAD_1_mappedToThaiKeyboard_M = "ท";

  WorldMorph.KEYPAD_2_mappedToThaiKeyboard_N = "ท";

  WorldMorph.KEYPAD_3_mappedToThaiKeyboard_O = "ื";

  WorldMorph.KEYPAD_ENTER_mappedToThaiKeyboard_P = "น";

  WorldMorph.KEYPAD_0_mappedToThaiKeyboard_Q = "ย";

  WorldMorph.KEYPAD_DOT_mappedToThaiKeyboard_R = "พ";

  WorldMorph.prototype.morphsDetectingClickOutsideMeOrAnyOfMeChildren = [];

  WorldMorph.prototype.hierarchyOfClickedMorphs = [];

  WorldMorph.prototype.markedForDestruction = [];

  WorldMorph.prototype.freshlyCreatedMenus = [];

  WorldMorph.prototype.openMenus = [];

  WorldMorph.BOOT_COMPLETE = 2;

  WorldMorph.EXECUTING_URL_ACTIONS = 1;

  WorldMorph.JUST_STARTED = 0;

  WorldMorph.bootState = 0;

  WorldMorph.ongoingUrlActionNumber = 0;

  function WorldMorph(worldCanvas, automaticallyAdjustToFillEntireBrowserAlsoOnResize) {
    var colorName, colorValue, _ref;
    this.worldCanvas = worldCanvas;
    this.automaticallyAdjustToFillEntireBrowserAlsoOnResize = automaticallyAdjustToFillEntireBrowserAlsoOnResize != null ? automaticallyAdjustToFillEntireBrowserAlsoOnResize : true;
    _ref = Color.colourNamesValues;
    for (colorName in _ref) {
      colorValue = _ref[colorName];
      Color["" + colorName] = new Color(colorValue[0], colorValue[1], colorValue[2]);
    }
    delete Color.colourNamesValues;
    WorldMorph.__super__.constructor.call(this);
    WorldMorph.preferencesAndSettings = new PreferencesAndSettings();
    console.log(WorldMorph.preferencesAndSettings.menuFontName);
    this.color = new Color(205, 205, 205);
    this.alpha = 1;
    this.isMinimised = false;
    this.isfloatDraggable = false;
    this.stamp = Date.now();
    this.isDevMode = false;
    this.broken = [];
    this.hand = new HandMorph(this);
    this.keyboardEventsReceiver = null;
    this.lastEditedText = null;
    this.caret = null;
    this.activeHandle = null;
    this.inputDOMElementForVirtualKeyboard = null;
    if (this.automaticallyAdjustToFillEntireBrowserAlsoOnResize) {
      this.stretchWorldToFillEntirePage();
    }
    this.bounds = new Rectangle(0, 0, this.worldCanvas.width / pixelRatio, this.worldCanvas.height / pixelRatio);
    this.initEventListeners();
    this.systemTestsRecorderAndPlayer = new AutomatorRecorderAndPlayer(this, this.hand);
    this.changed();
    this.updateBackingStore();
  }

  WorldMorph.prototype.boot = function() {
    var startupActions;
    console.log("booting");
    WorldMorph.bootState = WorldMorph.JUST_STARTED;
    WorldMorph.ongoingUrlActionNumber = 0;
    startupActions = getParameterByName('startupActions');
    console.log("startupActions: " + startupActions);
    if (startupActions != null) {
      return this.nextStartupAction();
    }
  };

  WorldMorph.prototype.nextStartupAction = function() {
    var currentAction, startupActions;
    startupActions = JSON.parse(getParameterByName('startupActions'));
    if ((startupActions == null) || (WorldMorph.ongoingUrlActionNumber === startupActions.actions.length)) {
      WorldMorph.bootState = WorldMorph.BOOT_COMPLETE;
      WorldMorph.ongoingUrlActionNumber = 0;
      if (window.location.href.indexOf("worldWithSystemTestHarness") !== -1) {
        if (this.systemTestsRecorderAndPlayer.atLeastOneTestHasBeenRun) {
          if (this.systemTestsRecorderAndPlayer.allTestsPassedSoFar) {
            document.getElementById("background").style.background = "green";
          }
        }
      }
    }
    if (WorldMorph.bootState === WorldMorph.BOOT_COMPLETE) {
      return;
    }
    console.log("nextStartupAction " + (WorldMorph.ongoingUrlActionNumber + 1) + " / " + startupActions.actions.length);
    currentAction = startupActions.actions[WorldMorph.ongoingUrlActionNumber];
    if (currentAction.name === "runTests") {
      this.systemTestsRecorderAndPlayer.selectTestsFromTagsOrTestNames(currentAction.testsToRun);
      if (currentAction.numberOfGroups != null) {
        this.systemTestsRecorderAndPlayer.numberOfGroups = currentAction.numberOfGroups;
      } else {
        this.systemTestsRecorderAndPlayer.numberOfGroups = 1;
      }
      if (currentAction.groupToBeRun != null) {
        this.systemTestsRecorderAndPlayer.groupToBeRun = currentAction.groupToBeRun;
      } else {
        this.systemTestsRecorderAndPlayer.groupToBeRun = 0;
      }
      this.systemTestsRecorderAndPlayer.runAllSystemTests();
    }
    return WorldMorph.ongoingUrlActionNumber++;
  };

  WorldMorph.prototype.getMorphViaTextLabel = function(_arg) {
    var allCandidateMorphsWithSameTextDescription, numberOfOccurrences, occurrenceNumber, textDescription;
    textDescription = _arg[0], occurrenceNumber = _arg[1], numberOfOccurrences = _arg[2];
    allCandidateMorphsWithSameTextDescription = this.allChildrenTopToBottomSuchThat(function(m) {
      return m.getTextDescription() === textDescription;
    });
    return allCandidateMorphsWithSameTextDescription[occurrenceNumber];
  };

  WorldMorph.prototype.mostRecentlyCreatedMenu = function() {
    var eachMenu, mostRecentMenu, mostRecentMenuID, _i, _j, _len, _ref, _ref1;
    mostRecentMenu = null;
    mostRecentMenuID = -1;
    for (i = _i = _ref = this.openMenus.length - 1; _i >= 0; i = _i += -1) {
      if (!this.openMenus[i].isAttachedAnywhereToWorld()) {
        this.openMenus.splice(i, 1);
      }
    }
    _ref1 = this.openMenus;
    for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
      eachMenu = _ref1[_j];
      if (eachMenu.instanceNumericID >= mostRecentMenuID) {
        mostRecentMenu = eachMenu;
      }
    }
    return mostRecentMenu;
  };

  WorldMorph.prototype.alignIDsOfNextMorphsInSystemTests = function() {
    var eachMorphClass, listOfMorphsClasses, theWordMorph, _i, _len, _results;
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.IDLE) {
      theWordMorph = "Morph";
      listOfMorphsClasses = (Object.keys(window)).filter(function(i) {
        return i.indexOf(theWordMorph, i.length - theWordMorph.length) !== -1;
      });
      _results = [];
      for (_i = 0, _len = listOfMorphsClasses.length; _i < _len; _i++) {
        eachMorphClass = listOfMorphsClasses[_i];
        console.log("bumping up ID of class: " + eachMorphClass);
        if (window[eachMorphClass].roundNumericIDsToNextThousand != null) {
          _results.push(window[eachMorphClass].roundNumericIDsToNextThousand());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  WorldMorph.prototype.destroyMorphsMarkedForDestruction = function() {
    var eachMorph, _i, _len, _ref;
    _ref = this.markedForDestruction;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      eachMorph = _ref[_i];
      eachMorph.destroy();
    }
    return this.markedForDestruction = [];
  };

  WorldMorph.prototype.brokenFor = function(aMorph) {
    var fb;
    fb = aMorph.boundsIncludingChildren();
    return this.broken.filter(function(rect) {
      return rect.intersects(fb);
    });
  };

  WorldMorph.prototype.recursivelyBlit = function(aCanvas, aRect) {
    WorldMorph.__super__.recursivelyBlit.call(this, aCanvas, aRect);
    return this.hand.recursivelyBlit(aCanvas, aRect);
  };

  WorldMorph.prototype.updateBroken = function() {
    ProfilingDataCollector.profileBrokenRects(this.broken.length);
    this.broken.forEach((function(_this) {
      return function(rect) {
        if (rect.isNotEmpty()) {
          return _this.recursivelyBlit(_this.worldCanvas, rect);
        }
      };
    })(this));
    return this.broken = [];
  };

  WorldMorph.prototype.doOneCycle = function() {
    WorldMorph.currentTime = Date.now();
    this.runOtherTasksStepFunction();
    this.runChildrensStepFunction();
    return this.updateBroken();
  };

  WorldMorph.prototype.runOtherTasksStepFunction = function() {
    var task, _i, _len, _ref, _results;
    _ref = this.otherTasksToBeRunOnStep;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      task = _ref[_i];
      _results.push(task());
    }
    return _results;
  };

  WorldMorph.prototype.stretchWorldToFillEntirePage = function() {
    var clientHeight, clientWidth, pos;
    pos = getDocumentPositionOf(this.worldCanvas);
    clientHeight = window.innerHeight;
    clientWidth = window.innerWidth;
    if (pos.x > 0) {
      this.worldCanvas.style.position = "absolute";
      this.worldCanvas.style.left = "0px";
      pos.x = 0;
    }
    if (pos.y > 0) {
      this.worldCanvas.style.position = "absolute";
      this.worldCanvas.style.top = "0px";
      pos.y = 0;
    }
    if (document.body.scrollTop) {
      clientHeight = document.documentElement.clientHeight;
    }
    if (document.body.scrollLeft) {
      clientWidth = document.documentElement.clientWidth;
    }
    if (this.worldCanvas.width !== clientWidth) {
      this.worldCanvas.width = clientWidth;
      this.setWidth(clientWidth);
    }
    if (this.worldCanvas.height !== clientHeight) {
      this.worldCanvas.height = clientHeight;
      this.setHeight(clientHeight);
    }
    return this.children.forEach((function(_this) {
      return function(child) {
        return typeof child.reactToWorldResize === "function" ? child.reactToWorldResize(_this.bounds.copy()) : void 0;
      };
    })(this));
  };

  WorldMorph.prototype.getGlobalPixelColor = function(point) {
    var dta;
    dta = this.worldCanvas.getContext("2d").getImageData(point.x, point.y, 1, 1).data;
    return new Color(dta[0], dta[1], dta[2]);
  };

  WorldMorph.prototype.initVirtualKeyboard = function() {
    if (this.inputDOMElementForVirtualKeyboard) {
      document.body.removeChild(this.inputDOMElementForVirtualKeyboard);
      this.inputDOMElementForVirtualKeyboard = null;
    }
    if (!(WorldMorph.preferencesAndSettings.isTouchDevice && WorldMorph.preferencesAndSettings.useVirtualKeyboard)) {
      return;
    }
    this.inputDOMElementForVirtualKeyboard = document.createElement("input");
    this.inputDOMElementForVirtualKeyboard.type = "text";
    this.inputDOMElementForVirtualKeyboard.style.color = "transparent";
    this.inputDOMElementForVirtualKeyboard.style.backgroundColor = "transparent";
    this.inputDOMElementForVirtualKeyboard.style.border = "none";
    this.inputDOMElementForVirtualKeyboard.style.outline = "none";
    this.inputDOMElementForVirtualKeyboard.style.position = "absolute";
    this.inputDOMElementForVirtualKeyboard.style.top = "0px";
    this.inputDOMElementForVirtualKeyboard.style.left = "0px";
    this.inputDOMElementForVirtualKeyboard.style.width = "0px";
    this.inputDOMElementForVirtualKeyboard.style.height = "0px";
    this.inputDOMElementForVirtualKeyboard.autocapitalize = "none";
    document.body.appendChild(this.inputDOMElementForVirtualKeyboard);
    this.inputDOMElementForVirtualKeyboardKeydownEventListener = (function(_this) {
      return function(event) {
        if (_this.keyboardEventsReceiver) {
          _this.keyboardEventsReceiver.processKeyDown(event);
        }
        if (event.keyIdentifier === "U+0008" || event.keyIdentifier === "Backspace") {
          event.preventDefault();
        }
        if (event.keyIdentifier === "U+0009" || event.keyIdentifier === "Tab") {
          if (_this.keyboardEventsReceiver) {
            _this.keyboardEventsReceiver.processKeyPress(event);
          }
          return event.preventDefault();
        }
      };
    })(this);
    this.inputDOMElementForVirtualKeyboard.addEventListener("keydown", this.inputDOMElementForVirtualKeyboardKeydownEventListener, false);
    this.inputDOMElementForVirtualKeyboardKeyupEventListener = (function(_this) {
      return function(event) {
        if (_this.keyboardEventsReceiver) {
          if (_this.keyboardEventsReceiver.processKeyUp) {
            _this.keyboardEventsReceiver.processKeyUp(event);
          }
        }
        return event.preventDefault();
      };
    })(this);
    this.inputDOMElementForVirtualKeyboard.addEventListener("keyup", this.inputDOMElementForVirtualKeyboardKeyupEventListener, false);
    this.inputDOMElementForVirtualKeyboardKeypressEventListener = (function(_this) {
      return function(event) {
        if (_this.keyboardEventsReceiver) {
          _this.keyboardEventsReceiver.processKeyPress(event);
        }
        return event.preventDefault();
      };
    })(this);
    return this.inputDOMElementForVirtualKeyboard.addEventListener("keypress", this.inputDOMElementForVirtualKeyboardKeypressEventListener, false);
  };

  WorldMorph.prototype.getPointerAndMorphInfo = function() {
    var absoluteBoundsOfMorphRelativeToWorld, isPartOfListMorph, morphIdentifierViaTextLabel, morphPathRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, topMorphUnderPointer;
    topMorphUnderPointer = this.hand.topMorphUnderPointer();
    absoluteBoundsOfMorphRelativeToWorld = topMorphUnderPointer.bounds.asArray_xywh();
    morphIdentifierViaTextLabel = topMorphUnderPointer.identifyViaTextLabel();
    morphPathRelativeToWorld = topMorphUnderPointer.pathOfChildrenPositionsRelativeToWorld();
    pointerPositionFractionalInMorph = this.hand.pointerPositionFractionalInMorph(topMorphUnderPointer);
    pointerPositionPixelsInMorph = this.hand.pointerPositionPixelsInMorph(topMorphUnderPointer);
    pointerPositionPixelsInWorld = this.hand.position();
    isPartOfListMorph = (topMorphUnderPointer.parentThatIsA(ListMorph)) != null;
    return [topMorphUnderPointer.uniqueIDString(), morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph];
  };

  WorldMorph.prototype.addMouseChangeCommand = function(upOrDown, button, ctrlKey) {
    var pointerAndMorphInfo, _ref;
    pointerAndMorphInfo = this.getPointerAndMorphInfo();
    return (_ref = this.systemTestsRecorderAndPlayer).addMouseChangeCommand.apply(_ref, [upOrDown, button, ctrlKey].concat(__slice.call(pointerAndMorphInfo)));
  };

  WorldMorph.prototype.processMouseDown = function(button, ctrlKey) {
    this.addMouseChangeCommand("down", button, ctrlKey);
    return this.hand.processMouseDown(button, ctrlKey);
  };

  WorldMorph.prototype.processMouseUp = function(button) {
    this.addMouseChangeCommand("up");
    return this.hand.processMouseUp(button);
  };

  WorldMorph.prototype.processMouseMove = function(pageX, pageY) {
    var action, arr;
    this.hand.processMouseMove(pageX, pageY);
    if (this.hand.floatDraggingSomething()) {
      if (AutomatorRecorderAndPlayer.state === AutomatorRecorderAndPlayer.RECORDING) {
        action = "floatDrag";
        arr = window.world.systemTestsRecorderAndPlayer.tagsCollectedWhileRecordingTest;
        if ((arr.indexOf(action)) === -1) {
          arr.push(action);
        }
      }
    }
    return this.systemTestsRecorderAndPlayer.addMouseMoveCommand(pageX, pageY, this.hand.floatDraggingSomething());
  };

  WorldMorph.prototype.getChar = function(event) {
    if (event.which == null) {
      return String.fromCharCode(event.keyCode);
    } else if (event.which !== 0 && event.charCode !== 0) {
      return String.fromCharCode(event.which);
    } else {
      return null;
    }
  };

  WorldMorph.prototype.processKeydown = function(event, scanCode, shiftKey, ctrlKey, altKey, metaKey) {
    this.systemTestsRecorderAndPlayer.addKeyDownCommand(scanCode, shiftKey, ctrlKey, altKey, metaKey);
    if (this.keyboardEventsReceiver) {
      this.keyboardEventsReceiver.processKeyDown(scanCode, shiftKey, ctrlKey, altKey, metaKey);
    }
    if ((event != null) && scanCode === 8) {
      event.preventDefault();
    }
    if ((event != null) && scanCode === 9) {
      if (this.keyboardEventsReceiver) {
        this.keyboardEventsReceiver.processKeyPress(scanCode, "\t", shiftKey, ctrlKey, altKey, metaKey);
      }
      return event.preventDefault();
    }
  };

  WorldMorph.prototype.processKeyup = function(event, scanCode, shiftKey, ctrlKey, altKey, metaKey) {
    this.systemTestsRecorderAndPlayer.addKeyUpCommand(scanCode, shiftKey, ctrlKey, altKey, metaKey);
    if (this.keyboardEventsReceiver) {
      if (this.keyboardEventsReceiver.processKeyUp) {
        this.keyboardEventsReceiver.processKeyUp(scanCode, shiftKey, ctrlKey, altKey, metaKey);
      }
    }
    if (event != null) {
      return event.preventDefault();
    }
  };

  WorldMorph.prototype.processKeypress = function(event, charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) {
    this.systemTestsRecorderAndPlayer.addKeyPressCommand(charCode, symbol, shiftKey, ctrlKey, altKey, metaKey);
    if (event != null) {
      if (symbol === this.constructor.KEYPAD_0_mappedToThaiKeyboard_Q) {
        if (this.doublePressOfZeroKeypadKey == null) {
          this.doublePressOfZeroKeypadKey = 1;
          setTimeout(((function(_this) {
            return function() {
              if (_this.doublePressOfZeroKeypadKey === 1) {
                console.log("single keypress");
              }
              _this.doublePressOfZeroKeypadKey = null;
              event.keyCode = 0;
              return false;
            };
          })(this)), 300);
        } else {
          this.doublePressOfZeroKeypadKey = null;
          console.log("double keypress");
          event.keyCode = 0;
        }
        return false;
      }
    }
    if (this.keyboardEventsReceiver) {
      this.keyboardEventsReceiver.processKeyPress(charCode, symbol, shiftKey, ctrlKey, altKey, metaKey);
    }
    if (event != null) {
      return event.preventDefault();
    }
  };

  WorldMorph.prototype.processCopy = function(event) {
    var selectedText, setStatus;
    this.systemTestsRecorderAndPlayer.addCopyCommand;
    console.log("processing copy");
    if (this.caret) {
      selectedText = this.caret.target.selection();
      if (event.clipboardData) {
        event.preventDefault();
        setStatus = event.clipboardData.setData("text/plain", selectedText);
      }
      if (window.clipboardData) {
        event.returnValue = false;
        return setStatus = window.clipboardData.setData("Text", selectedText);
      }
    }
  };

  WorldMorph.prototype.processPaste = function(event, text) {
    if (this.caret) {
      if (event != null) {
        if (event.clipboardData) {
          text = event.clipboardData.getData("text/plain");
        }
        if (window.clipboardData) {
          text = window.clipboardData.getData("Text");
        }
      }
      console.log("about to insert text: " + text);
      this.systemTestsRecorderAndPlayer.addPasteCommand(text);
      return window.setTimeout(((function(_this) {
        return function() {
          return _this.caret.insert(text);
        };
      })(this)), 50, true);
    }
  };

  WorldMorph.prototype.initEventListeners = function() {
    var canvas;
    canvas = this.worldCanvas;
    this.mousedownEventListener = (function(_this) {
      return function(event) {
        return _this.processMouseDown(event.button, event.ctrlKey);
      };
    })(this);
    canvas.addEventListener("mousedown", this.mousedownEventListener, false);
    this.touchstartEventListener = (function(_this) {
      return function(event) {
        return _this.hand.processTouchStart(event);
      };
    })(this);
    canvas.addEventListener("touchstart", this.touchstartEventListener, false);
    this.mouseupEventListener = (function(_this) {
      return function(event) {
        return _this.processMouseUp(event.button);
      };
    })(this);
    canvas.addEventListener("mouseup", this.mouseupEventListener, false);
    this.touchendEventListener = (function(_this) {
      return function(event) {
        return _this.hand.processTouchEnd(event);
      };
    })(this);
    canvas.addEventListener("touchend", this.touchendEventListener, false);
    this.mousemoveEventListener = (function(_this) {
      return function(event) {
        var posInDocument, worldX, worldY;
        posInDocument = getDocumentPositionOf(_this.worldCanvas);
        worldX = event.pageX - posInDocument.x;
        worldY = event.pageY - posInDocument.y;
        return _this.processMouseMove(worldX, worldY);
      };
    })(this);
    canvas.addEventListener("mousemove", this.mousemoveEventListener, false);
    this.touchmoveEventListener = (function(_this) {
      return function(event) {
        return _this.hand.processTouchMove(event);
      };
    })(this);
    canvas.addEventListener("touchmove", this.touchmoveEventListener, false);
    this.gesturestartEventListener = (function(_this) {
      return function(event) {
        return event.preventDefault();
      };
    })(this);
    canvas.addEventListener("gesturestart", this.gesturestartEventListener, false);
    this.gesturechangeEventListener = (function(_this) {
      return function(event) {
        return event.preventDefault();
      };
    })(this);
    canvas.addEventListener("gesturechange", this.gesturechangeEventListener, false);
    this.contextmenuEventListener = function(event) {
      return event.preventDefault();
    };
    canvas.addEventListener("contextmenu", this.contextmenuEventListener, false);
    this.keydownEventListener = (function(_this) {
      return function(event) {
        return _this.processKeydown(event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey);
      };
    })(this);
    canvas.addEventListener("keydown", this.keydownEventListener, false);
    this.keyupEventListener = (function(_this) {
      return function(event) {
        return _this.processKeyup(event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey);
      };
    })(this);
    canvas.addEventListener("keyup", this.keyupEventListener, false);
    ({
      doublePressOfZeroKeypadKey: null
    });
    this.keypressEventListener = (function(_this) {
      return function(event) {
        return _this.processKeypress(event, event.keyCode, _this.getChar(event), event.shiftKey, event.ctrlKey, event.altKey, event.metaKey);
      };
    })(this);
    canvas.addEventListener("keypress", this.keypressEventListener, false);
    this.mousewheelEventListener = (function(_this) {
      return function(event) {
        _this.hand.processMouseScroll(event);
        return event.preventDefault();
      };
    })(this);
    canvas.addEventListener("mousewheel", this.mousewheelEventListener, false);
    this.DOMMouseScrollEventListener = (function(_this) {
      return function(event) {
        _this.hand.processMouseScroll(event);
        return event.preventDefault();
      };
    })(this);
    canvas.addEventListener("DOMMouseScroll", this.DOMMouseScrollEventListener, false);
    this.copyEventListener = (function(_this) {
      return function(event) {
        return _this.processCopy(event);
      };
    })(this);
    document.body.addEventListener("copy", this.copyEventListener, false);
    this.pasteEventListener = (function(_this) {
      return function(event) {
        return _this.processPaste(event);
      };
    })(this);
    document.body.addEventListener("paste", this.pasteEventListener, false);
    this.keyComboResetWorldEventListener = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.resetWorld();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+d"], this.keyComboResetWorldEventListener);
    this.keyComboTurnOnAnimationsPacingControl = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.turnOnAnimationsPacingControl();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+e"], this.keyComboTurnOnAnimationsPacingControl);
    this.keyComboTurnOffAnimationsPacingControl = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+u"], this.keyComboTurnOffAnimationsPacingControl);
    this.keyComboTakeScreenshotEventListener = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.takeScreenshot();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+c"], this.keyComboTakeScreenshotEventListener);
    this.keyComboStopTestRecordingEventListener = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.stopTestRecording();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+t"], this.keyComboStopTestRecordingEventListener);
    this.keyComboAddTestCommentEventListener = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.addTestComment();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+m"], this.keyComboAddTestCommentEventListener);
    this.keyComboCheckNumberOfMenuItemsEventListener = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.checkNumberOfItemsInMenu();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+k"], this.keyComboCheckNumberOfMenuItemsEventListener);
    this.keyComboCheckStringsOfItemsInMenuOrderImportant = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderImportant();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+a"], this.keyComboCheckStringsOfItemsInMenuOrderImportant);
    this.keyComboCheckStringsOfItemsInMenuOrderUnimportant = (function(_this) {
      return function(event) {
        _this.systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderUnimportant();
        return false;
      };
    })(this);
    Mousetrap.bind(["alt+z"], this.keyComboCheckStringsOfItemsInMenuOrderUnimportant);
    this.dragoverEventListener = function(event) {
      return event.preventDefault();
    };
    window.addEventListener("dragover", this.dragoverEventListener, false);
    this.dropEventListener = (function(_this) {
      return function(event) {
        _this.hand.processDrop(event);
        return event.preventDefault();
      };
    })(this);
    window.addEventListener("drop", this.dropEventListener, false);
    this.resizeEventListener = (function(_this) {
      return function() {
        if (_this.automaticallyAdjustToFillEntireBrowserAlsoOnResize) {
          return _this.stretchWorldToFillEntirePage();
        }
      };
    })(this);
    window.addEventListener("resize", this.resizeEventListener, false);
    return window.onbeforeunload = function(evt) {
      var e, msg;
      e = evt || window.event;
      msg = "Are you sure you want to leave?";
      if (e) {
        e.returnValue = msg;
      }
      return msg;
    };
  };

  WorldMorph.prototype.removeEventListeners = function() {
    var canvas;
    canvas = this.worldCanvas;
    canvas.removeEventListener('mousedown', this.mousedownEventListener);
    canvas.removeEventListener('touchstart', this.touchstartEventListener);
    canvas.removeEventListener('mouseup', this.mouseupEventListener);
    canvas.removeEventListener('touchend', this.touchendEventListener);
    canvas.removeEventListener('mousemove', this.mousemoveEventListener);
    canvas.removeEventListener('touchmove', this.touchmoveEventListener);
    canvas.removeEventListener('gesturestart', this.gesturestartEventListener);
    canvas.removeEventListener('gesturechange', this.gesturechangeEventListener);
    canvas.removeEventListener('contextmenu', this.contextmenuEventListener);
    canvas.removeEventListener('keydown', this.keydownEventListener);
    canvas.removeEventListener('keyup', this.keyupEventListener);
    canvas.removeEventListener('keypress', this.keypressEventListener);
    canvas.removeEventListener('mousewheel', this.mousewheelEventListener);
    canvas.removeEventListener('DOMMouseScroll', this.DOMMouseScrollEventListener);
    canvas.removeEventListener('copy', this.copyEventListener);
    canvas.removeEventListener('paste', this.pasteEventListener);
    Mousetrap.reset();
    canvas.removeEventListener('dragover', this.dragoverEventListener);
    canvas.removeEventListener('drop', this.dropEventListener);
    return canvas.removeEventListener('resize', this.resizeEventListener);
  };

  WorldMorph.prototype.mouseDownLeft = function() {
    return noOperation;
  };

  WorldMorph.prototype.mouseClickLeft = function() {
    return noOperation;
  };

  WorldMorph.prototype.mouseDownRight = function() {
    return noOperation;
  };

  WorldMorph.prototype.wantsDropOf = function() {
    return this.acceptsDrops;
  };

  WorldMorph.prototype.droppedImage = function() {
    return null;
  };

  WorldMorph.prototype.droppedSVG = function() {
    return null;
  };

  WorldMorph.prototype.nextTab = function(editField) {
    var next;
    next = this.nextEntryField(editField);
    if (next) {
      return this.switchTextFieldFocus(editField, next);
    }
  };

  WorldMorph.prototype.previousTab = function(editField) {
    var prev;
    prev = this.previousEntryField(editField);
    if (prev) {
      return this.switchTextFieldFocus(editField, prev);
    }
  };

  WorldMorph.prototype.switchTextFieldFocus = function(current, next) {
    current.clearSelection();
    next.bringToForegroud();
    next.selectAll();
    return next.edit();
  };

  WorldMorph.prototype.resetWorld = function() {
    this.hand.drop();
    this.hand.mouseOverList = [];
    this.destroyAll();
    this.setColor(new Color(205, 205, 205));
    return SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.resetWorldLink);
  };

  WorldMorph.prototype.destroyAll = function() {
    var ListOfMorphs, eachMorphClass, theWordMorph, _i, _len;
    theWordMorph = "Morph";
    ListOfMorphs = (Object.keys(window)).filter(function(i) {
      return i.indexOf(theWordMorph, i.length - theWordMorph.length) !== -1;
    });
    for (_i = 0, _len = ListOfMorphs.length; _i < _len; _i++) {
      eachMorphClass = ListOfMorphs[_i];
      if (eachMorphClass !== "WorldMorph") {
        console.log("resetting " + eachMorphClass + " from " + window[eachMorphClass].instancesCounter);
        window[eachMorphClass].lastBuiltInstanceNumericID = 0;
      }
    }
    window.world.systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl();
    window.world.systemTestsRecorderAndPlayer.turnOffAlignmentOfMorphIDsMechanism();
    window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsGeometryInfoInLabels();
    window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsContentExtractInLabels();
    window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsNumberIDInLabels();
    return WorldMorph.__super__.destroyAll.call(this);
  };

  WorldMorph.prototype.contextMenu = function() {
    var menu;
    if (this.isDevMode) {
      menu = new MenuMorph(false, this, true, true, this.constructor.name || this.constructor.toString().split(" ")[1].split("(")[0]);
    } else {
      menu = new MenuMorph(false, this, true, true, "Morphic");
    }
    if (this.isDevMode) {
      menu.addItem("demo ➜", false, this, "popUpDemoMenu", "sample morphs");
      menu.addLine();
      menu.addItem("show all", true, this, "showAllMinimised");
      menu.addItem("hide all", true, this, "minimiseAll");
      menu.addItem("delete all", true, this, "destroyAll");
      menu.addItem("move all inside", true, this, "keepAllSubmorphsWithin", "keep all submorphs\nwithin and visible");
      menu.addItem("inspect", true, this, "inspect", "open a window on\nall properties");
      menu.addItem("test menu ➜", false, this, "testMenu", "debugging and testing operations");
      menu.addLine();
      menu.addItem("restore display", true, this, "changed", "redraw the\nscreen once");
      menu.addItem("fit whole page", true, this, "stretchWorldToFillEntirePage", "let the World automatically\nadjust to browser resizings");
      menu.addItem("color...", true, this, "popUpColorSetter", "choose the World's\nbackground color");
      if (WorldMorph.preferencesAndSettings.inputMode === PreferencesAndSettings.INPUT_MODE_MOUSE) {
        menu.addItem("touch screen settings", true, WorldMorph.preferencesAndSettings, "toggleInputMode", "bigger menu fonts\nand sliders");
      } else {
        menu.addItem("standard settings", true, WorldMorph.preferencesAndSettings, "toggleInputMode", "smaller menu fonts\nand sliders");
      }
      menu.addLine();
    }
    if (window.location.href.indexOf("worldWithSystemTestHarness") !== -1) {
      menu.addItem("system tests ➜", false, this, "popUpSystemTestsMenu", "");
    }
    if (this.isDevMode) {
      menu.addItem("switch to user mode", true, this, "toggleDevMode", "disable developers'\ncontext menus");
    } else {
      menu.addItem("switch to dev mode", true, this, "toggleDevMode");
    }
    menu.addItem("about Zombie Kernel...", true, this, "about");
    return menu;
  };

  WorldMorph.prototype.popUpSystemTestsMenu = function() {
    var menu;
    menu = new MenuMorph(false, this, true, true, "system tests");
    menu.addItem("run system tests", true, this.systemTestsRecorderAndPlayer, "runAllSystemTests", "runs all the system tests");
    menu.addItem("start test recording", true, this.systemTestsRecorderAndPlayer, "startTestRecording", "start recording a test");
    menu.addItem("stop test recording", true, this.systemTestsRecorderAndPlayer, "stopTestRecording", "stop recording the test");
    menu.addItem("(re)play recorded test", true, this.systemTestsRecorderAndPlayer, "startTestPlaying", "start playing the test");
    menu.addItem("show test source", true, this.systemTestsRecorderAndPlayer, "showTestSource", "opens a window with the source of the latest test");
    menu.addItem("save recorded test", true, this.systemTestsRecorderAndPlayer, "saveTest", "save the recorded test");
    menu.addItem("save failed screenshots test", true, this.systemTestsRecorderAndPlayer, "saveFailedScreenshots", "save failed screenshots test");
    return menu.popUpAtHand(this.firstContainerMenu());
  };

  WorldMorph.prototype.create = function(aMorph) {
    aMorph.isfloatDraggable = true;
    return aMorph.pickUp();
  };

  WorldMorph.prototype.createNewRectangleMorph = function() {
    return this.create(new RectangleMorph());
  };

  WorldMorph.prototype.createNewBoxMorph = function() {
    return this.create(new BoxMorph());
  };

  WorldMorph.prototype.createNewCircleBoxMorph = function() {
    return this.create(new CircleBoxMorph());
  };

  WorldMorph.prototype.createNewSliderMorph = function() {
    return this.create(new SliderMorph());
  };

  WorldMorph.prototype.createNewFrameMorph = function() {
    var newMorph;
    newMorph = new FrameMorph();
    newMorph.setExtent(new Point(350, 250));
    return this.create(newMorph);
  };

  WorldMorph.prototype.createNewScrollFrameMorph = function() {
    var newMorph;
    newMorph = new ScrollFrameMorph();
    newMorph.contents.acceptsDrops = true;
    newMorph.adjustContentsBounds();
    newMorph.adjustScrollBars();
    newMorph.setExtent(new Point(350, 250));
    return this.create(newMorph);
  };

  WorldMorph.prototype.createNewCanvas = function() {
    var newMorph;
    newMorph = new CanvasMorph();
    newMorph.setExtent(new Point(350, 250));
    return this.create(newMorph);
  };

  WorldMorph.prototype.createNewHandle = function() {
    return this.create(new HandleMorph());
  };

  WorldMorph.prototype.createNewString = function() {
    var newMorph;
    newMorph = new StringMorph("Hello, World!");
    newMorph.isEditable = true;
    return this.create(newMorph);
  };

  WorldMorph.prototype.createNewText = function() {
    var newMorph;
    newMorph = new TextMorph("Ich weiß nicht, was soll es bedeuten, dass ich so " + "traurig bin, ein Märchen aus uralten Zeiten, das " + "kommt mir nicht aus dem Sinn. Die Luft ist kühl " + "und es dunkelt, und ruhig fließt der Rhein; der " + "Gipfel des Berges funkelt im Abendsonnenschein. " + "Die schönste Jungfrau sitzet dort oben wunderbar, " + "ihr gold'nes Geschmeide blitzet, sie kämmt ihr " + "goldenes Haar, sie kämmt es mit goldenem Kamme, " + "und singt ein Lied dabei; das hat eine wundersame, " + "gewalt'ge Melodei. Den Schiffer im kleinen " + "Schiffe, ergreift es mit wildem Weh; er schaut " + "nicht die Felsenriffe, er schaut nur hinauf in " + "die Höh'. Ich glaube, die Wellen verschlingen " + "am Ende Schiffer und Kahn, und das hat mit ihrem " + "Singen, die Loreley getan.");
    newMorph.isEditable = true;
    newMorph.maxWidth = 300;
    return this.create(newMorph);
  };

  WorldMorph.prototype.createNewSpeechBubbleMorph = function() {
    var newMorph;
    newMorph = new SpeechBubbleMorph("Hello, World!");
    return this.create(newMorph);
  };

  WorldMorph.prototype.createNewGrayPaletteMorph = function() {
    return this.create(new GrayPaletteMorph());
  };

  WorldMorph.prototype.createNewColorPaletteMorph = function() {
    return this.create(new ColorPaletteMorph());
  };

  WorldMorph.prototype.createNewColorPickerMorph = function() {
    return this.create(new ColorPickerMorph());
  };

  WorldMorph.prototype.createNewSensorDemo = function() {
    var newMorph;
    newMorph = new MouseSensorMorph();
    newMorph.setColor(new Color(230, 200, 100));
    newMorph.edge = 35;
    newMorph.border = 15;
    newMorph.alpha = 0.2;
    newMorph.setExtent(new Point(100, 100));
    return this.create(newMorph);
  };

  WorldMorph.prototype.createNewAnimationDemo = function() {
    var bar, baz, foo, fred, garply;
    foo = new BouncerMorph();
    foo.setPosition(new Point(50, 20));
    foo.setExtent(new Point(300, 200));
    foo.alpha = 0.9;
    foo.speed = 3;
    bar = new BouncerMorph();
    bar.setColor(new Color(50, 50, 50));
    bar.setPosition(new Point(80, 80));
    bar.setExtent(new Point(80, 250));
    bar.type = "horizontal";
    bar.direction = "right";
    bar.alpha = 0.9;
    bar.speed = 5;
    baz = new BouncerMorph();
    baz.setColor(new Color(20, 20, 20));
    baz.setPosition(new Point(90, 140));
    baz.setExtent(new Point(40, 30));
    baz.type = "horizontal";
    baz.direction = "right";
    baz.speed = 3;
    garply = new BouncerMorph();
    garply.setColor(new Color(200, 20, 20));
    garply.setPosition(new Point(90, 140));
    garply.setExtent(new Point(20, 20));
    garply.type = "vertical";
    garply.direction = "up";
    garply.speed = 8;
    fred = new BouncerMorph();
    fred.setColor(new Color(20, 200, 20));
    fred.setPosition(new Point(120, 140));
    fred.setExtent(new Point(20, 20));
    fred.type = "vertical";
    fred.direction = "down";
    fred.speed = 4;
    bar.add(garply);
    bar.add(baz);
    foo.add(fred);
    foo.add(bar);
    return this.create(foo);
  };

  WorldMorph.prototype.createNewPenMorph = function() {
    return this.create(new PenMorph());
  };

  WorldMorph.prototype.viewAll = function() {
    var newMorph;
    newMorph = new MorphsListMorph();
    return this.create(newMorph);
  };

  WorldMorph.prototype.closingWindow = function() {
    var newMorph;
    newMorph = new WorkspaceMorph();
    return this.create(newMorph);
  };

  WorldMorph.prototype.popUpDemoMenu = function(a, b, c, d) {
    var menu;
    menu = new MenuMorph(false, this, true, true, "make a morph");
    menu.addItem("rectangle", true, this, "createNewRectangleMorph");
    menu.addItem("box", true, this, "createNewBoxMorph");
    menu.addItem("circle box", true, this, "createNewCircleBoxMorph");
    menu.addLine();
    menu.addItem("slider", true, this, "createNewSliderMorph");
    menu.addItem("frame", true, this, "createNewFrameMorph");
    menu.addItem("scroll frame", true, this, "createNewScrollFrameMorph");
    menu.addItem("canvas", true, this, "createNewCanvas");
    menu.addItem("handle", true, this, "createNewHandle");
    menu.addLine();
    menu.addItem("string", true, this, "createNewString");
    menu.addItem("text", true, this, "createNewText");
    menu.addItem("speech bubble", true, this, "createNewSpeechBubbleMorph");
    menu.addLine();
    menu.addItem("gray scale palette", true, this, "createNewGrayPaletteMorph");
    menu.addItem("color palette", true, this, "createNewColorPaletteMorph");
    menu.addItem("color picker", true, this, "createNewColorPickerMorph");
    menu.addLine();
    menu.addItem("sensor demo", true, this, "createNewSensorDemo");
    menu.addItem("animation demo", true, this, "createNewAnimationDemo");
    menu.addItem("pen", true, this, "createNewPenMorph");
    menu.addLine();
    menu.addItem("layout tests ➜", false, this, "layoutTestsMenu", "sample morphs");
    menu.addLine();
    menu.addItem("view all...", true, this, "viewAll");
    menu.addItem("closing window", true, this, "closingWindow");
    return menu.popUpAtHand(a.firstContainerMenu());
  };

  WorldMorph.prototype.layoutTestsMenu = function(morphTriggeringThis) {
    var menu;
    menu = new MenuMorph(false, this, true, true, "Layout tests");
    menu.addItem("test1", true, LayoutMorph, "test1");
    menu.addItem("test2", true, LayoutMorph, "test2");
    menu.addItem("test3", true, LayoutMorph, "test3");
    menu.addItem("test4", true, LayoutMorph, "test4");
    return menu.popUpAtHand(morphTriggeringThis.firstContainerMenu());
  };

  WorldMorph.prototype.toggleDevMode = function() {
    return this.isDevMode = !this.isDevMode;
  };

  WorldMorph.prototype.minimiseAll = function() {
    return this.children.forEach(function(child) {
      return child.minimise();
    });
  };

  WorldMorph.prototype.showAllMinimised = function() {
    return this.forAllChildrenBottomToTop(function(child) {
      if (child.isMinimised) {
        return child.unminimise();
      }
    });
  };

  WorldMorph.prototype.about = function() {
    return this.inform("Zombie Kernel\n\n" + "a lively Web GUI\ninspired by Squeak\n" + morphicVersion + "\n\nby Davide Della Casa" + "\n\nbased on morphic.js by" + "\nJens Mönig (jens@moenig.org)");
  };

  WorldMorph.prototype.edit = function(aStringMorphOrTextMorph) {
    var pos;
    if (this.caret) {
      this.lastEditedText = this.caret.target;
      if (this.lastEditedText) {
        this.lastEditedText.clearSelection();
      }
      this.caret = this.caret.destroy();
    }
    this.caret = new CaretMorph(aStringMorphOrTextMorph);
    aStringMorphOrTextMorph.parent.add(this.caret);
    this.keyboardEventsReceiver = this.caret;
    if (WorldMorph.preferencesAndSettings.isTouchDevice && WorldMorph.preferencesAndSettings.useVirtualKeyboard) {
      this.initVirtualKeyboard();
      pos = getDocumentPositionOf(this.worldCanvas);
      this.inputDOMElementForVirtualKeyboard.style.top = this.caret.top() + pos.y + "px";
      this.inputDOMElementForVirtualKeyboard.style.left = this.caret.left() + pos.x + "px";
      this.inputDOMElementForVirtualKeyboard.focus();
    }
    if (WorldMorph.preferencesAndSettings.useSliderForInput) {
      if (!aStringMorphOrTextMorph.parentThatIsA(MenuMorph)) {
        return this.slide(aStringMorphOrTextMorph);
      }
    }
  };

  WorldMorph.prototype.stopEditing = function() {
    if (this.caret) {
      this.lastEditedText = this.caret.target;
      this.lastEditedText.clearSelection();
      this.lastEditedText.escalateEvent("reactToEdit", this.lastEditedText);
      this.caret = this.caret.destroy();
    }
    this.keyboardEventsReceiver = null;
    if (this.inputDOMElementForVirtualKeyboard) {
      this.inputDOMElementForVirtualKeyboard.blur();
      document.body.removeChild(this.inputDOMElementForVirtualKeyboard);
      this.inputDOMElementForVirtualKeyboard = null;
    }
    return this.worldCanvas.focus();
  };

  WorldMorph.prototype.slide = function(aStringMorphOrTextMorph) {
    var menu, slider, val;
    this.aStringMorphOrTextMorph = aStringMorphOrTextMorph;
    val = parseFloat(this.aStringMorphOrTextMorph.text);
    if (isNaN(val)) {
      val = 0;
    }
    menu = new MenuMorph(false);
    slider = new SliderMorph(val - 25, val + 25, val, 10, "horizontal");
    slider.alpha = 1;
    slider.color = new Color(225, 225, 225);
    slider.button.color = new Color(60, 60, 60);
    slider.button.highlightColor = slider.button.color.copy();
    slider.button.highlightColor.b += 100;
    slider.button.pressColor = slider.button.color.copy();
    slider.button.pressColor.b += 150;
    slider.silentSetHeight(WorldMorph.preferencesAndSettings.scrollBarSize);
    slider.silentSetWidth(WorldMorph.preferencesAndSettings.menuFontSize * 10);
    slider.setLayoutBeforeUpdatingBackingStore();
    slider.updateBackingStore();
    slider.action = "reactToSlide";
    menu.items.push(slider);
    return menu.popup(this, this.aStringMorphOrTextMorph.bottomLeft().add(new Point(0, 5)));
  };

  WorldMorph.prototype.reactToSlide = function(num) {
    this.aStringMorphOrTextMorph.changed();
    this.aStringMorphOrTextMorph.text = Math.round(num).toString();
    this.aStringMorphOrTextMorph.setLayoutBeforeUpdatingBackingStore();
    this.aStringMorphOrTextMorph.updateBackingStore();
    this.aStringMorphOrTextMorph.changed();
    return this.aStringMorphOrTextMorph.escalateEvent('reactToSliderEdit', this.aStringMorphOrTextMorph);
  };

  WorldMorph.coffeeScriptSourceOfThisClass = '# WorldMorph //////////////////////////////////////////////////////////\n\n# these comments below needed to figure our dependencies between classes\n# REQUIRES globalFunctions\n# REQUIRES PreferencesAndSettings\n# REQUIRES Color\n# REQUIRES ProfilingDataCollector\n# REQUIRES SystemTestsControlPanelUpdater\n\n# The WorldMorph takes over the canvas on the page\nclass WorldMorph extends FrameMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  # We need to add and remove\n  # the event listeners so we are\n  # going to put them all in properties\n  # here.\n  # dblclickEventListener: null\n  mousedownEventListener: null\n  touchstartEventListener: null\n  mouseupEventListener: null\n  touchendEventListener: null\n  mousemoveEventListener: null\n  touchmoveEventListener: null\n  gesturestartEventListener: null\n  gesturechangeEventListener: null\n  contextmenuEventListener: null\n  # Note how there can be two handlers for\n  # keyboard events.\n  # This one is attached\n  # to the canvas and reaches the currently\n  # blinking caret if there is one.\n  # See below for the other potential\n  # handler. See "initVirtualKeyboard"\n  # method to see where and when this input and\n  # these handlers are set up.\n  keydownEventListener: null\n  keyupEventListener: null\n  keypressEventListener: null\n  mousewheelEventListener: null\n  DOMMouseScrollEventListener: null\n  copyEventListener: null\n  pasteEventListener: null\n\n  # the string for the last serialised morph\n  # is kept in here, to make serialization\n  # and deserialization tests easier.\n  # The alternative would be to refresh and\n  # re-start the tests from where they left...\n  lastSerializationString: ""\n\n  # Note how there can be two handlers\n  # for keyboard events. This one is\n  # attached to a hidden\n  # "input" div which keeps track of the\n  # text that is being input.\n  inputDOMElementForVirtualKeyboardKeydownEventListener: null\n  inputDOMElementForVirtualKeyboardKeyupEventListener: null\n  inputDOMElementForVirtualKeyboardKeypressEventListener: null\n\n  keyComboResetWorldEventListener: null\n  keyComboTurnOnAnimationsPacingControl: null\n  keyComboTurnOffAnimationsPacingControl: null\n  keyComboTakeScreenshotEventListener: null\n  keyComboStopTestRecordingEventListener: null\n  keyComboTakeScreenshotEventListener: null\n  keyComboCheckStringsOfItemsInMenuOrderImportant: null\n  keyComboCheckStringsOfItemsInMenuOrderUnimportant: null\n  keyComboAddTestCommentEventListener: null\n  keyComboCheckNumberOfMenuItemsEventListener: null\n\n  dragoverEventListener: null\n  dropEventListener: null\n  resizeEventListener: null\n  otherTasksToBeRunOnStep: []\n\n  # these variables shouldn\'t be static to the WorldMorph, because\n  # in pure theory you could have multiple worlds in the same\n  # page with different settings\n  # (but anyways, it was global before, so it\'s not any worse than before)\n  @preferencesAndSettings: null\n  @currentTime: null\n  showRedraws: false\n  systemTestsRecorderAndPlayer: null\n\n  # this is the actual reference to the canvas\n  # on the html page, where the world is\n  # finally painted to.\n  worldCanvas: null\n\n  # By default the world will always fill\n  # the entire page, also when browser window\n  # is resized.\n  # When this flag is set, the onResize callback\n  # automatically adjusts the world size.\n  automaticallyAdjustToFillEntireBrowserAlsoOnResize: true\n\n  # keypad keys map to special characters\n  # so we can trigger test actions\n  # see more comments below\n  @KEYPAD_TAB_mappedToThaiKeyboard_A: "ฟ"\n  @KEYPAD_SLASH_mappedToThaiKeyboard_B: "ิ"\n  @KEYPAD_MULTIPLY_mappedToThaiKeyboard_C: "แ"\n  @KEYPAD_DELETE_mappedToThaiKeyboard_D: "ก"\n  @KEYPAD_7_mappedToThaiKeyboard_E: "ำ"\n  @KEYPAD_8_mappedToThaiKeyboard_F: "ด"\n  @KEYPAD_9_mappedToThaiKeyboard_G: "เ"\n  @KEYPAD_MINUS_mappedToThaiKeyboard_H: "้"\n  @KEYPAD_4_mappedToThaiKeyboard_I: "ร"\n  @KEYPAD_5_mappedToThaiKeyboard_J: "่" # looks like empty string but isn\'t :-)\n  @KEYPAD_6_mappedToThaiKeyboard_K: "า"\n  @KEYPAD_PLUS_mappedToThaiKeyboard_L: "ส" \n  @KEYPAD_1_mappedToThaiKeyboard_M: "ท"\n  @KEYPAD_2_mappedToThaiKeyboard_N: "ท"\n  @KEYPAD_3_mappedToThaiKeyboard_O: "ื"\n  @KEYPAD_ENTER_mappedToThaiKeyboard_P: "น"\n  @KEYPAD_0_mappedToThaiKeyboard_Q: "ย"\n  @KEYPAD_DOT_mappedToThaiKeyboard_R: "พ"\n\n  morphsDetectingClickOutsideMeOrAnyOfMeChildren: []\n  hierarchyOfClickedMorphs: []\n  markedForDestruction: []\n  freshlyCreatedMenus: []\n  openMenus: []\n\n  # boot-up state machine\n  @BOOT_COMPLETE: 2\n  @EXECUTING_URL_ACTIONS: 1\n  @JUST_STARTED: 0\n  @bootState: 0\n  @ongoingUrlActionNumber: 0\n\n  constructor: (\n      @worldCanvas,\n      @automaticallyAdjustToFillEntireBrowserAlsoOnResize = true\n      ) ->\n\n    # The WorldMorph is the very first morph to\n    # be created.\n\n    # We first need to initialise\n    # some Color constants, like\n    #   Color.red\n    # See the comment at the beginning of the\n    # color class on why this piece of code\n    # is here instead of somewhere else.\n    for colorName, colorValue of Color.colourNamesValues\n      Color["#{colorName}"] = new Color(colorValue[0],colorValue[1], colorValue[2])\n    # The colourNamesValues data structure is\n    # redundant at this point.\n    delete Color.colourNamesValues\n\n    super()\n    WorldMorph.preferencesAndSettings = new PreferencesAndSettings()\n    console.log WorldMorph.preferencesAndSettings.menuFontName\n    @color = new Color(205, 205, 205) # (130, 130, 130)\n    @alpha = 1\n    @isMinimised = false\n    @isfloatDraggable = false\n\n    # additional properties:\n    @stamp = Date.now() # reference in multi-world setups\n    @isDevMode = false\n    @broken = []\n    @hand = new HandMorph(@)\n    @keyboardEventsReceiver = null\n    @lastEditedText = null\n    @caret = null\n    @activeHandle = null\n    @inputDOMElementForVirtualKeyboard = null\n\n    if @automaticallyAdjustToFillEntireBrowserAlsoOnResize\n      @stretchWorldToFillEntirePage()\n\n    # @worldCanvas.width and height here are in phisical pixels\n    # so we want to bring them back to logical pixels\n    @bounds = new Rectangle(0, 0, @worldCanvas.width / pixelRatio, @worldCanvas.height / pixelRatio)\n\n    @initEventListeners()\n    @systemTestsRecorderAndPlayer = new AutomatorRecorderAndPlayer(@, @hand)\n\n    @changed()\n    @updateBackingStore()\n\n  boot: ->\n    # boot-up state machine\n    console.log "booting"\n    WorldMorph.bootState = WorldMorph.JUST_STARTED\n    WorldMorph.ongoingUrlActionNumber= 0\n    startupActions = getParameterByName(\'startupActions\');\n    console.log "startupActions: " + startupActions\n    if startupActions?\n      @nextStartupAction()\n\n  # some test urls:\n\n  # this one contains two actions, two tests each, but only\n  # the second test is run for the second group.\n  # file:///Users/daviddellacasa/Zombie-Kernel/Zombie-Kernel-builds/latest/worldWithSystemTestHarness.html?startupActions=%7B%0D%0A++%22paramsVersion%22%3A+0.1%2C%0D%0A++%22actions%22%3A+%5B%0D%0A++++%7B%0D%0A++++++%22name%22%3A+%22runTests%22%2C%0D%0A++++++%22testsToRun%22%3A+%5B%22bubble%22%5D%0D%0A++++%7D%2C%0D%0A++++%7B%0D%0A++++++%22name%22%3A+%22runTests%22%2C%0D%0A++++++%22testsToRun%22%3A+%5B%22shadow%22%2C+%22SystemTest_basicResize%22%5D%2C%0D%0A++++++%22numberOfGroups%22%3A+2%2C%0D%0A++++++%22groupToBeRun%22%3A+1%0D%0A++++%7D++%5D%0D%0A%7D\n  #\n  # just one simple quick test about shadows\n  #file:///Users/daviddellacasa/Zombie-Kernel/Zombie-Kernel-builds/latest/worldWithSystemTestHarness.html?startupActions=%7B%0A%20%20%22paramsVersion%22%3A%200.1%2C%0A%20%20%22actions%22%3A%20%5B%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%22name%22%3A%20%22runTests%22%2C%0A%20%20%20%20%20%20%22testsToRun%22%3A%20%5B%22shadow%22%5D%0A%20%20%20%20%7D%0A%20%20%5D%0A%7D\n\n  nextStartupAction: ->\n    startupActions = JSON.parse(getParameterByName(\'startupActions\'))\n\n    if (!startupActions?) or (WorldMorph.ongoingUrlActionNumber == startupActions.actions.length)\n      WorldMorph.bootState = WorldMorph.BOOT_COMPLETE\n      WorldMorph.ongoingUrlActionNumber= 0\n      if window.location.href.indexOf("worldWithSystemTestHarness") != -1\n        if @systemTestsRecorderAndPlayer.atLeastOneTestHasBeenRun\n          if @systemTestsRecorderAndPlayer.allTestsPassedSoFar\n            document.getElementById("background").style.background = "green"\n\n    if WorldMorph.bootState == WorldMorph.BOOT_COMPLETE\n      return\n\n    console.log "nextStartupAction " + (WorldMorph.ongoingUrlActionNumber+1) + " / " + startupActions.actions.length\n\n    currentAction = startupActions.actions[WorldMorph.ongoingUrlActionNumber]\n    if currentAction.name == "runTests"\n      @systemTestsRecorderAndPlayer.selectTestsFromTagsOrTestNames(currentAction.testsToRun)\n\n      if currentAction.numberOfGroups?\n        @systemTestsRecorderAndPlayer.numberOfGroups = currentAction.numberOfGroups\n      else\n        @systemTestsRecorderAndPlayer.numberOfGroups = 1\n      if currentAction.groupToBeRun?\n        @systemTestsRecorderAndPlayer.groupToBeRun = currentAction.groupToBeRun\n      else\n        @systemTestsRecorderAndPlayer.groupToBeRun = 0\n\n      @systemTestsRecorderAndPlayer.runAllSystemTests()\n    WorldMorph.ongoingUrlActionNumber++\n\n  getMorphViaTextLabel: ([textDescription, occurrenceNumber, numberOfOccurrences]) ->\n    allCandidateMorphsWithSameTextDescription = \n      @allChildrenTopToBottomSuchThat( (m) ->\n        m.getTextDescription() == textDescription\n      )\n    return allCandidateMorphsWithSameTextDescription[occurrenceNumber]\n\n  mostRecentlyCreatedMenu: ->\n    mostRecentMenu = null\n    mostRecentMenuID = -1\n\n    # we have to check which menus\n    # are actually open, because\n    # the destroy() function used\n    # everywhere is not recursive and\n    # that\'s where we update the @openMenus\n    # array so we have to doublecheck here\n    # note how we examine the array in reverse order\n    # because we might delete its elements\n    for i in [(@openMenus.length-1).. 0] by -1\n      if !@openMenus[i].isAttachedAnywhereToWorld()\n        @openMenus.splice i, 1\n\n    for eachMenu in @openMenus\n      if eachMenu.instanceNumericID >= mostRecentMenuID\n        mostRecentMenu = eachMenu\n    return mostRecentMenu\n\n  # see roundNumericIDsToNextThousand method in\n  # Morph for an explanation of why we need this\n  # method.\n  alignIDsOfNextMorphsInSystemTests: ->\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE\n      # Check which objects end with the word Morph\n      theWordMorph = "Morph"\n      listOfMorphsClasses = (Object.keys(window)).filter (i) ->\n        i.indexOf(theWordMorph, i.length - theWordMorph.length) isnt -1\n      for eachMorphClass in listOfMorphsClasses\n        console.log "bumping up ID of class: " + eachMorphClass\n        if window[eachMorphClass].roundNumericIDsToNextThousand?\n          window[eachMorphClass].roundNumericIDsToNextThousand()\n\n  destroyMorphsMarkedForDestruction: ->\n    for eachMorph in @markedForDestruction\n      eachMorph.destroy()\n    @markedForDestruction = []\n  \n  # World Morph display:\n  brokenFor: (aMorph) ->\n    # private\n    fb = aMorph.boundsIncludingChildren()\n    @broken.filter (rect) ->\n      rect.intersects fb\n  \n  \n  # recursivelyBlit results into actual blittings of pices of\n  # morphs done\n  # by the blit function.\n  # The blit function is defined in Morph and is not overriden by\n  # any morph.\n  recursivelyBlit: (aCanvas, aRect) ->\n    # invokes the Morph\'s recursivelyBlit, which has only three implementations:\n    #  * the default one by Morph which just invokes the blit of all children\n    #  * the interesting one in FrameMorph which a) narrows the dirty\n    #    rectangle (intersecting it with its border\n    #    since the FrameMorph clips at its border) and b) stops recursion on all\n    #    the children that are outside such intersection.\n    #  * this implementation which just takes into account that the hand\n    #    (which could contain a Morph being floatDragged)\n    #    is painted on top of everything.\n    super aCanvas, aRect\n    # the mouse cursor is always drawn on top of everything\n    # and it\'s not attached to the WorldMorph.\n    @hand.recursivelyBlit aCanvas, aRect\n  \n  updateBroken: ->\n    #console.log "number of broken rectangles: " + @broken.length\n    ProfilingDataCollector.profileBrokenRects @broken.length\n\n    # each broken rectangle requires traversing the scenegraph to\n    # redraw what\'s overlapping it. Not all Morphs are traversed\n    # in particular the following can stop the recursion:\n    #  - invisible Morphs\n    #  - FrameMorphs that don\'t overlap the broken rectangle\n    # Since potentially there is a lot of traversal ongoin for\n    # each broken rectangle, one might want to consolidate overlapping\n    # and nearby rectangles.\n\n    @broken.forEach (rect) =>\n      @recursivelyBlit @worldCanvas, rect  if rect.isNotEmpty()\n    @broken = []\n  \n  doOneCycle: ->\n    WorldMorph.currentTime = Date.now();\n    # console.log TextMorph.instancesCounter + " " + StringMorph.instancesCounter\n    @runOtherTasksStepFunction()\n    @runChildrensStepFunction()\n    @updateBroken()\n  \n  runOtherTasksStepFunction : ->\n    for task in @otherTasksToBeRunOnStep\n      #console.log "running a task: " + task\n      task()\n\n  stretchWorldToFillEntirePage: ->\n    pos = getDocumentPositionOf(@worldCanvas)\n    clientHeight = window.innerHeight\n    clientWidth = window.innerWidth\n    if pos.x > 0\n      @worldCanvas.style.position = "absolute"\n      @worldCanvas.style.left = "0px"\n      pos.x = 0\n    if pos.y > 0\n      @worldCanvas.style.position = "absolute"\n      @worldCanvas.style.top = "0px"\n      pos.y = 0\n    # scrolled down b/c of viewport scaling\n    clientHeight = document.documentElement.clientHeight  if document.body.scrollTop\n    # scrolled left b/c of viewport scaling\n    clientWidth = document.documentElement.clientWidth  if document.body.scrollLeft\n    if @worldCanvas.width isnt clientWidth\n      @worldCanvas.width = clientWidth\n      @setWidth clientWidth\n    if @worldCanvas.height isnt clientHeight\n      @worldCanvas.height = clientHeight\n      @setHeight clientHeight\n    @children.forEach (child) =>\n      child.reactToWorldResize? @bounds.copy()\n  \n  \n  \n  # WorldMorph global pixel access:\n  getGlobalPixelColor: (point) ->\n    \n    #\n    #	answer the color at the given point.\n    #\n    #	Note: for some strange reason this method works fine if the page is\n    #	opened via HTTP, but *not*, if it is opened from a local uri\n    #	(e.g. from a directory), in which case it\'s always null.\n    #\n    #	This behavior is consistent throughout several browsers. I have no\n    #	clue what\'s behind this, apparently the imageData attribute of\n    #	canvas context only gets filled with meaningful data if transferred\n    #	via HTTP ???\n    #\n    #	This is somewhat of a showstopper for color detection in a planned\n    #	offline version of Snap.\n    #\n    #	The issue has also been discussed at: (join lines before pasting)\n    #	http://stackoverflow.com/questions/4069400/\n    #	canvas-getimagedata-doesnt-work-when-running-locally-on-windows-\n    #	security-excep\n    #\n    #	The suggestion solution appears to work, since the settings are\n    #	applied globally.\n    #\n    dta = @worldCanvas.getContext("2d").getImageData(point.x, point.y, 1, 1).data\n    new Color(dta[0], dta[1], dta[2])\n  \n  \n  # WorldMorph events:\n  initVirtualKeyboard: ->\n    if @inputDOMElementForVirtualKeyboard\n      document.body.removeChild @inputDOMElementForVirtualKeyboard\n      @inputDOMElementForVirtualKeyboard = null\n    unless (WorldMorph.preferencesAndSettings.isTouchDevice and WorldMorph.preferencesAndSettings.useVirtualKeyboard)\n      return\n    @inputDOMElementForVirtualKeyboard = document.createElement("input")\n    @inputDOMElementForVirtualKeyboard.type = "text"\n    @inputDOMElementForVirtualKeyboard.style.color = "transparent"\n    @inputDOMElementForVirtualKeyboard.style.backgroundColor = "transparent"\n    @inputDOMElementForVirtualKeyboard.style.border = "none"\n    @inputDOMElementForVirtualKeyboard.style.outline = "none"\n    @inputDOMElementForVirtualKeyboard.style.position = "absolute"\n    @inputDOMElementForVirtualKeyboard.style.top = "0px"\n    @inputDOMElementForVirtualKeyboard.style.left = "0px"\n    @inputDOMElementForVirtualKeyboard.style.width = "0px"\n    @inputDOMElementForVirtualKeyboard.style.height = "0px"\n    @inputDOMElementForVirtualKeyboard.autocapitalize = "none" # iOS specific\n    document.body.appendChild @inputDOMElementForVirtualKeyboard\n\n    @inputDOMElementForVirtualKeyboardKeydownEventListener = (event) =>\n\n      @keyboardEventsReceiver.processKeyDown event  if @keyboardEventsReceiver\n\n      # Default in several browsers\n      # is for the backspace button to trigger\n      # the "back button", so we prevent that\n      # default here.\n      if event.keyIdentifier is "U+0008" or event.keyIdentifier is "Backspace"\n        event.preventDefault()  \n\n      # suppress tab override and make sure tab gets\n      # received by all browsers\n      if event.keyIdentifier is "U+0009" or event.keyIdentifier is "Tab"\n        @keyboardEventsReceiver.processKeyPress event  if @keyboardEventsReceiver\n        event.preventDefault()\n\n    @inputDOMElementForVirtualKeyboard.addEventListener "keydown",\n      @inputDOMElementForVirtualKeyboardKeydownEventListener, false\n\n    @inputDOMElementForVirtualKeyboardKeyupEventListener = (event) =>\n      # dispatch to keyboard receiver\n      if @keyboardEventsReceiver\n        # so far the caret is the only keyboard\n        # event handler and it has no keyup\n        # handler\n        if @keyboardEventsReceiver.processKeyUp\n          @keyboardEventsReceiver.processKeyUp event  \n      event.preventDefault()\n\n    @inputDOMElementForVirtualKeyboard.addEventListener "keyup",\n      @inputDOMElementForVirtualKeyboardKeyupEventListener, false\n\n    @inputDOMElementForVirtualKeyboardKeypressEventListener = (event) =>\n      @keyboardEventsReceiver.processKeyPress event  if @keyboardEventsReceiver\n      event.preventDefault()\n\n    @inputDOMElementForVirtualKeyboard.addEventListener "keypress",\n      @inputDOMElementForVirtualKeyboardKeypressEventListener, false\n\n  getPointerAndMorphInfo:  ->\n    # we might eliminate this command afterwards if\n    # we find out user is clicking on a menu item\n    # or right-clicking on a morph\n    topMorphUnderPointer = @hand.topMorphUnderPointer()\n    absoluteBoundsOfMorphRelativeToWorld = topMorphUnderPointer.bounds.asArray_xywh()\n    morphIdentifierViaTextLabel = topMorphUnderPointer.identifyViaTextLabel()\n    morphPathRelativeToWorld = topMorphUnderPointer.pathOfChildrenPositionsRelativeToWorld()\n    pointerPositionFractionalInMorph = @hand.pointerPositionFractionalInMorph topMorphUnderPointer\n    pointerPositionPixelsInMorph = @hand.pointerPositionPixelsInMorph topMorphUnderPointer\n    # note that this pointer position is in world\n    # coordinates not in page coordinates\n    pointerPositionPixelsInWorld = @hand.position()\n    isPartOfListMorph = (topMorphUnderPointer.parentThatIsA ListMorph)?\n    return [ topMorphUnderPointer.uniqueIDString(), morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph]\n\n\n  addMouseChangeCommand: (upOrDown, button, ctrlKey) ->\n    pointerAndMorphInfo = @getPointerAndMorphInfo()\n    @systemTestsRecorderAndPlayer.addMouseChangeCommand upOrDown, button, ctrlKey, pointerAndMorphInfo...\n\n\n  processMouseDown: (button, ctrlKey) ->\n    # the recording of the test command (in case we are\n    # recording a test) is handled inside the function\n    # here below.\n    # This is different from the other methods similar\n    # to this one but there is a little bit of\n    # logic we apply in case there is a right-click,\n    # or user left or right-clicks on a menu,\n    # in which case we record a more specific test\n    # commands.\n    @addMouseChangeCommand "down", button, ctrlKey\n\n\n    @hand.processMouseDown button, ctrlKey\n\n  processMouseUp: (button) ->\n    # event.preventDefault()\n\n    @addMouseChangeCommand "up"\n\n    @hand.processMouseUp button\n\n  processMouseMove: (pageX, pageY) ->\n    @hand.processMouseMove  pageX, pageY\n    # "@hand.processMouseMove" could cause a Grab\n    # command to be issued, so we want to\n    # add the mouse move command here *after* the\n    # potential grab command.\n\n    if @hand.floatDraggingSomething()\n      if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n        action = "floatDrag"\n        arr = window.world.systemTestsRecorderAndPlayer.tagsCollectedWhileRecordingTest\n        if (arr.indexOf action) == -1\n          arr.push action\n    \n    @systemTestsRecorderAndPlayer.addMouseMoveCommand(pageX, pageY, @hand.floatDraggingSomething())\n\n  # event.type must be keypress\n  getChar: (event) ->\n    unless event.which?\n      String.fromCharCode event.keyCode # IE\n    else if event.which isnt 0 and event.charCode isnt 0\n      String.fromCharCode event.which # the rest\n    else\n      null # special key\n\n  processKeydown: (event, scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    @systemTestsRecorderAndPlayer.addKeyDownCommand scanCode, shiftKey, ctrlKey, altKey, metaKey\n    if @keyboardEventsReceiver\n      @keyboardEventsReceiver.processKeyDown scanCode, shiftKey, ctrlKey, altKey, metaKey\n\n    # suppress backspace override\n    if event? and scanCode is 8\n      event.preventDefault()\n\n    # suppress tab override and make sure tab gets\n    # received by all browsers\n    if event? and scanCode is 9\n      if @keyboardEventsReceiver\n        @keyboardEventsReceiver.processKeyPress scanCode, "\t", shiftKey, ctrlKey, altKey, metaKey\n      event.preventDefault()\n\n  processKeyup: (event, scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    @systemTestsRecorderAndPlayer.addKeyUpCommand scanCode, shiftKey, ctrlKey, altKey, metaKey\n    # dispatch to keyboard receiver\n    if @keyboardEventsReceiver\n      # so far the caret is the only keyboard\n      # event handler and it has no keyup\n      # handler\n      if @keyboardEventsReceiver.processKeyUp\n        @keyboardEventsReceiver.processKeyUp scanCode, shiftKey, ctrlKey, altKey, metaKey    \n    if event?\n      event.preventDefault()\n\n  processKeypress: (event, charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) ->\n    @systemTestsRecorderAndPlayer.addKeyPressCommand charCode, symbol, shiftKey, ctrlKey, altKey, metaKey\n    # This if block adapted from:\n    # http://stackoverflow.com/a/16033129\n    # it rejects the\n    # characters from the special\n    # test-command-triggering external\n    # keypad. Also there is a "00" key\n    # in such keypads which is implemented\n    # buy just a double-press of the zero.\n    # We manage that case - if that key is\n    # pressed twice we understand that it\'s\n    # that particular key. Managing this\n    # special case within Zombie Kernel\n    # is not best, but there aren\'t any\n    # good alternatives.\n    if event?\n      # don\'t manage external keypad if we are playing back\n      # the tests (i.e. when event is null)\n      if symbol == @constructor.KEYPAD_0_mappedToThaiKeyboard_Q\n        unless @doublePressOfZeroKeypadKey?\n          @doublePressOfZeroKeypadKey = 1\n          setTimeout (=>\n            if @doublePressOfZeroKeypadKey is 1\n              console.log "single keypress"\n            @doublePressOfZeroKeypadKey = null\n            event.keyCode = 0\n            return false\n          ), 300\n        else\n          @doublePressOfZeroKeypadKey = null\n          console.log "double keypress"\n          event.keyCode = 0\n        return false\n\n    if @keyboardEventsReceiver\n      @keyboardEventsReceiver.processKeyPress charCode, symbol, shiftKey, ctrlKey, altKey, metaKey\n    if event?\n      event.preventDefault()\n\n  processCopy: (event) ->\n    @systemTestsRecorderAndPlayer.addCopyCommand\n    console.log "processing copy"\n    if @caret\n      selectedText = @caret.target.selection()\n      if event.clipboardData\n        event.preventDefault()\n        setStatus = event.clipboardData.setData("text/plain", selectedText)\n\n      if window.clipboardData\n        event.returnValue = false\n        setStatus = window.clipboardData.setData "Text", selectedText\n\n  processPaste: (event, text) ->\n    if @caret\n      if event?\n        if event.clipboardData\n          # Look for access to data if types array is missing\n          text = event.clipboardData.getData("text/plain")\n          #url = event.clipboardData.getData("text/uri-list")\n          #html = event.clipboardData.getData("text/html")\n          #custom = event.clipboardData.getData("text/xcustom")\n        # IE event is attached to the window object\n        if window.clipboardData\n          # The schema is fixed\n          text = window.clipboardData.getData("Text")\n          #url = window.clipboardData.getData("URL")\n      \n      # Needs a few msec to execute paste\n      console.log "about to insert text: " + text\n      @systemTestsRecorderAndPlayer.addPasteCommand text\n      window.setTimeout ( => (@caret.insert text)), 50, true\n\n\n  # note that we don\'t register the normal click,\n  # we figure that out independently.\n  initEventListeners: ->\n    canvas = @worldCanvas\n\n    # there is indeed a "dblclick" JS event\n    # but we reproduce it internally.\n    # The reason is that we do so for "click"\n    # because we want to check that the mouse\n    # button was released in the same morph\n    # where it was pressed (cause in the DOM you\'d\n    # be pressing and releasing on the same\n    # element i.e. the canvas anyways\n    # so we receive clicks even though they aren\'t\n    # so we have to take care of the processing\n    # ourselves).\n    # So we also do the same internal\n    # processing for dblclick.\n    # Hence, don\'t register this event listener\n    # below...\n    #@dblclickEventListener = (event) =>\n    #  event.preventDefault()\n    #  @hand.processDoubleClick event\n    #canvas.addEventListener "dblclick", @dblclickEventListener, false\n\n    @mousedownEventListener = (event) =>\n      @processMouseDown event.button, event.ctrlKey\n    canvas.addEventListener "mousedown", @mousedownEventListener, false\n\n    @touchstartEventListener = (event) =>\n      @hand.processTouchStart event\n    canvas.addEventListener "touchstart", @touchstartEventListener , false\n    \n    @mouseupEventListener = (event) =>\n      @processMouseUp event.button\n    canvas.addEventListener "mouseup", @mouseupEventListener, false\n    \n    @touchendEventListener = (event) =>\n      @hand.processTouchEnd event\n    canvas.addEventListener "touchend", @touchendEventListener, false\n    \n    @mousemoveEventListener = (event) =>\n      posInDocument = getDocumentPositionOf(@worldCanvas)\n      # events from JS arrive in page coordinates,\n      # we turn those into world coordinates\n      # instead.\n      worldX = event.pageX - posInDocument.x\n      worldY = event.pageY - posInDocument.y\n      @processMouseMove worldX, worldY\n    canvas.addEventListener "mousemove", @mousemoveEventListener, false\n    \n    @touchmoveEventListener = (event) =>\n      @hand.processTouchMove event\n    canvas.addEventListener "touchmove", @touchmoveEventListener, false\n    \n    @gesturestartEventListener = (event) =>\n      # Disable browser zoom\n      event.preventDefault()\n    canvas.addEventListener "gesturestart", @gesturestartEventListener, false\n    \n    @gesturechangeEventListener = (event) =>\n      # Disable browser zoom\n      event.preventDefault()\n    canvas.addEventListener "gesturechange", @gesturechangeEventListener, false\n    \n    @contextmenuEventListener = (event) ->\n      # suppress context menu for Mac-Firefox\n      event.preventDefault()\n    canvas.addEventListener "contextmenu", @contextmenuEventListener, false\n    \n    @keydownEventListener = (event) =>\n      @processKeydown event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey\n    canvas.addEventListener "keydown", @keydownEventListener, false\n\n    @keyupEventListener = (event) =>\n      @processKeyup event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey\n    canvas.addEventListener "keyup", @keyupEventListener, false\n\n    # This method also handles keypresses from a special\n    # external keypad which is used to\n    # record tests commands (such as capture screen, etc.).\n    # These external keypads are inexpensive\n    # so they are a good device for this kind\n    # of stuff.\n    # http://www.amazon.co.uk/Perixx-PERIPAD-201PLUS-Numeric-Keypad-Laptop/dp/B001R6FZLU/\n    # They keypad is mapped\n    # to Thai keyboard characters via an OSX app\n    # called keyremap4macbook (also one needs to add the\n    # Thai keyboard, which is just a click from System Preferences)\n    # Those Thai characters are used to trigger test\n    # commands. The only added complexity is about\n    # the "00" key of such keypads - see\n    # note below.\n    doublePressOfZeroKeypadKey: null\n    \n    @keypressEventListener = (event) =>\n      @processKeypress event, event.keyCode, @getChar(event), event.shiftKey, event.ctrlKey, event.altKey, event.metaKey\n    canvas.addEventListener "keypress", @keypressEventListener, false\n\n    # Safari, Chrome\n    \n    @mousewheelEventListener = (event) =>\n      @hand.processMouseScroll event\n      event.preventDefault()\n    canvas.addEventListener "mousewheel", @mousewheelEventListener, false\n    # Firefox\n    \n    @DOMMouseScrollEventListener = (event) =>\n      @hand.processMouseScroll event\n      event.preventDefault()\n    canvas.addEventListener "DOMMouseScroll", @DOMMouseScrollEventListener, false\n\n    # in theory there should be no scroll event on the page\n    # window.addEventListener "scroll", ((event) =>\n    #  nop # nothing to do, I just need this to set an interrupt point.\n    # ), false\n\n    # snippets of clipboard-handling code taken from\n    # http://codebits.glennjones.net/editing/setclipboarddata.htm\n    # Note that this works only in Chrome. Firefox and Safari need a piece of\n    # text to be selected in order to even trigger the copy event. Chrome does\n    # enable clipboard access instead even if nothing is selected.\n    # There are a couple of solutions to this - one is to keep a hidden textfield that\n    # handles all copy/paste operations.\n    # Another one is to not use a clipboard, but rather an internal string as\n    # local memory. So the OS clipboard wouldn\'t be used, but at least there would\n    # be some copy/paste working. Also one would need to intercept the copy/paste\n    # key combinations manually instead of from the copy/paste events.\n    \n    @copyEventListener = (event) =>\n      @processCopy event\n    document.body.addEventListener "copy", @copyEventListener, false\n\n    @pasteEventListener = (event) =>\n      @processPaste event\n    document.body.addEventListener "paste", @pasteEventListener, false\n\n    #console.log "binding via mousetrap"\n\n    @keyComboResetWorldEventListener = (event) =>\n      @systemTestsRecorderAndPlayer.resetWorld()\n      false\n    Mousetrap.bind ["alt+d"], @keyComboResetWorldEventListener\n\n    @keyComboTurnOnAnimationsPacingControl = (event) =>\n      @systemTestsRecorderAndPlayer.turnOnAnimationsPacingControl()\n      false\n    Mousetrap.bind ["alt+e"], @keyComboTurnOnAnimationsPacingControl\n\n    @keyComboTurnOffAnimationsPacingControl = (event) =>\n      @systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl()\n      false\n    Mousetrap.bind ["alt+u"], @keyComboTurnOffAnimationsPacingControl\n\n    @keyComboTakeScreenshotEventListener = (event) =>\n      @systemTestsRecorderAndPlayer.takeScreenshot()\n      false\n    Mousetrap.bind ["alt+c"], @keyComboTakeScreenshotEventListener\n\n    @keyComboStopTestRecordingEventListener = (event) =>\n      @systemTestsRecorderAndPlayer.stopTestRecording()\n      false\n    Mousetrap.bind ["alt+t"], @keyComboStopTestRecordingEventListener\n\n    @keyComboAddTestCommentEventListener = (event) =>\n      @systemTestsRecorderAndPlayer.addTestComment()\n      false\n    Mousetrap.bind ["alt+m"], @keyComboAddTestCommentEventListener\n\n    @keyComboCheckNumberOfMenuItemsEventListener = (event) =>\n      @systemTestsRecorderAndPlayer.checkNumberOfItemsInMenu()\n      false\n    Mousetrap.bind ["alt+k"], @keyComboCheckNumberOfMenuItemsEventListener\n\n    @keyComboCheckStringsOfItemsInMenuOrderImportant = (event) =>\n      @systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderImportant()\n      false\n    Mousetrap.bind ["alt+a"], @keyComboCheckStringsOfItemsInMenuOrderImportant\n\n    @keyComboCheckStringsOfItemsInMenuOrderUnimportant = (event) =>\n      @systemTestsRecorderAndPlayer.checkStringsOfItemsInMenuOrderUnimportant()\n      false\n    Mousetrap.bind ["alt+z"], @keyComboCheckStringsOfItemsInMenuOrderUnimportant\n\n    @dragoverEventListener = (event) ->\n      event.preventDefault()\n    window.addEventListener "dragover", @dragoverEventListener, false\n    \n    @dropEventListener = (event) =>\n      @hand.processDrop event\n      event.preventDefault()\n    window.addEventListener "drop", @dropEventListener, false\n    \n    @resizeEventListener = =>\n      @stretchWorldToFillEntirePage()  if @automaticallyAdjustToFillEntireBrowserAlsoOnResize\n    window.addEventListener "resize", @resizeEventListener, false\n    \n    window.onbeforeunload = (evt) ->\n      e = evt or window.event\n      msg = "Are you sure you want to leave?"\n\n      # For IE and Firefox\n      e.returnValue = msg  if e\n\n      # For Safari / chrome\n      msg\n  \n  removeEventListeners: ->\n    canvas = @worldCanvas\n    # canvas.removeEventListener \'dblclick\', @dblclickEventListener\n    canvas.removeEventListener \'mousedown\', @mousedownEventListener\n    canvas.removeEventListener \'touchstart\', @touchstartEventListener\n    canvas.removeEventListener \'mouseup\', @mouseupEventListener\n    canvas.removeEventListener \'touchend\', @touchendEventListener\n    canvas.removeEventListener \'mousemove\', @mousemoveEventListener\n    canvas.removeEventListener \'touchmove\', @touchmoveEventListener\n    canvas.removeEventListener \'gesturestart\', @gesturestartEventListener\n    canvas.removeEventListener \'gesturechange\', @gesturechangeEventListener\n    canvas.removeEventListener \'contextmenu\', @contextmenuEventListener\n    canvas.removeEventListener \'keydown\', @keydownEventListener\n    canvas.removeEventListener \'keyup\', @keyupEventListener\n    canvas.removeEventListener \'keypress\', @keypressEventListener\n    canvas.removeEventListener \'mousewheel\', @mousewheelEventListener\n    canvas.removeEventListener \'DOMMouseScroll\', @DOMMouseScrollEventListener\n    canvas.removeEventListener \'copy\', @copyEventListener\n    canvas.removeEventListener \'paste\', @pasteEventListener\n    Mousetrap.reset()\n    canvas.removeEventListener \'dragover\', @dragoverEventListener\n    canvas.removeEventListener \'drop\', @dropEventListener\n    canvas.removeEventListener \'resize\', @resizeEventListener\n  \n  mouseDownLeft: ->\n    noOperation\n  \n  mouseClickLeft: ->\n    noOperation\n  \n  mouseDownRight: ->\n    noOperation\n    \n  wantsDropOf: ->\n    # allow handle drops if any drops are allowed\n    @acceptsDrops\n  \n  droppedImage: ->\n    null\n\n  droppedSVG: ->\n    null  \n\n  # WorldMorph text field tabbing:\n  nextTab: (editField) ->\n    next = @nextEntryField(editField)\n    if next\n      @switchTextFieldFocus editField, next\n  \n  previousTab: (editField) ->\n    prev = @previousEntryField(editField)\n    if prev\n      @switchTextFieldFocus editField, prev\n\n  switchTextFieldFocus: (current, next) ->\n    current.clearSelection()\n    next.bringToForegroud()\n    next.selectAll()\n    next.edit()\n\n\n  resetWorld: ->\n    @hand.drop()\n    @hand.mouseOverList = []\n    @destroyAll()\n    # some tests might change the background\n    # color of the world so let\'s reset it.\n    @setColor(new Color(205, 205, 205))\n    SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.resetWorldLink)\n  \n  # There is something special that the\n  # "world" version of destroyAll does:\n  # it resets the counter used to count\n  # how many morphs exist of each Morph class.\n  # That counter is also used to determine the\n  # unique ID of a Morph. So, destroying\n  # all morphs from the world causes the\n  # counts and IDs of all the subsequent\n  # morphs to start from scratch again.\n  destroyAll: ->\n    # Check which objects end with the word Morph\n    theWordMorph = "Morph"\n    ListOfMorphs = (Object.keys(window)).filter (i) ->\n      i.indexOf(theWordMorph, i.length - theWordMorph.length) isnt -1\n    for eachMorphClass in ListOfMorphs\n      if eachMorphClass != "WorldMorph"\n        console.log "resetting " + eachMorphClass + " from " + window[eachMorphClass].instancesCounter\n        # the actual count is in another variable "instancesCounter"\n        # but all labels are built using instanceNumericID\n        # which is set based on lastBuiltInstanceNumericID\n        window[eachMorphClass].lastBuiltInstanceNumericID = 0\n\n    window.world.systemTestsRecorderAndPlayer.turnOffAnimationsPacingControl()\n    window.world.systemTestsRecorderAndPlayer.turnOffAlignmentOfMorphIDsMechanism()\n    window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsGeometryInfoInLabels()\n    window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsContentExtractInLabels()\n    window.world.systemTestsRecorderAndPlayer.turnOffHidingOfMorphsNumberIDInLabels()\n\n    super()\n\n  contextMenu: ->\n    if @isDevMode\n      menu = new MenuMorph(false, \n        @, true, true, @constructor.name or @constructor.toString().split(" ")[1].split("(")[0])\n    else\n      menu = new MenuMorph(false, @, true, true, "Morphic")\n    if @isDevMode\n      menu.addItem "demo ➜", false, @, "popUpDemoMenu", "sample morphs"\n      menu.addLine()\n      menu.addItem "show all", true, @, "showAllMinimised"\n      menu.addItem "hide all", true, @, "minimiseAll"\n      menu.addItem "delete all", true, @, "destroyAll"\n      menu.addItem "move all inside", true, @, "keepAllSubmorphsWithin", "keep all submorphs\nwithin and visible"\n      menu.addItem "inspect", true, @, "inspect", "open a window on\nall properties"\n      menu.addItem "test menu ➜", false, @, "testMenu", "debugging and testing operations"\n      menu.addLine()\n      menu.addItem "restore display", true, @, "changed", "redraw the\nscreen once"\n      menu.addItem "fit whole page", true, @, "stretchWorldToFillEntirePage", "let the World automatically\nadjust to browser resizings"\n      menu.addItem "color...", true, @, "popUpColorSetter", "choose the World\'s\nbackground color"\n      if WorldMorph.preferencesAndSettings.inputMode is PreferencesAndSettings.INPUT_MODE_MOUSE\n        menu.addItem "touch screen settings", true, WorldMorph.preferencesAndSettings, "toggleInputMode", "bigger menu fonts\nand sliders"\n      else\n        menu.addItem "standard settings", true, WorldMorph.preferencesAndSettings, "toggleInputMode", "smaller menu fonts\nand sliders"\n      menu.addLine()\n    \n    if window.location.href.indexOf("worldWithSystemTestHarness") != -1\n      menu.addItem "system tests ➜", false, @, "popUpSystemTestsMenu", ""\n    if @isDevMode\n      menu.addItem "switch to user mode", true, @, "toggleDevMode", "disable developers\'\ncontext menus"\n    else\n      menu.addItem "switch to dev mode", true, @, "toggleDevMode"\n    menu.addItem "about Zombie Kernel...", true, @, "about"\n    menu\n\n  popUpSystemTestsMenu: ->\n    menu = new MenuMorph(false, @, true, true, "system tests")\n\n    menu.addItem "run system tests", true, @systemTestsRecorderAndPlayer, "runAllSystemTests", "runs all the system tests"\n    menu.addItem "start test recording", true, @systemTestsRecorderAndPlayer, "startTestRecording", "start recording a test"\n    menu.addItem "stop test recording", true, @systemTestsRecorderAndPlayer, "stopTestRecording", "stop recording the test"\n    menu.addItem "(re)play recorded test", true, @systemTestsRecorderAndPlayer, "startTestPlaying", "start playing the test"\n    menu.addItem "show test source", true, @systemTestsRecorderAndPlayer, "showTestSource", "opens a window with the source of the latest test"\n    menu.addItem "save recorded test", true, @systemTestsRecorderAndPlayer, "saveTest", "save the recorded test"\n    menu.addItem "save failed screenshots test", true, @systemTestsRecorderAndPlayer, "saveFailedScreenshots", "save failed screenshots test"\n\n    menu.popUpAtHand(@firstContainerMenu())\n\n  create: (aMorph) ->\n    aMorph.isfloatDraggable = true\n    aMorph.pickUp()\n\n  createNewRectangleMorph: ->\n    @create new RectangleMorph()\n  createNewBoxMorph: ->\n    @create new BoxMorph()\n  createNewCircleBoxMorph: ->\n    @create new CircleBoxMorph()\n  createNewSliderMorph: ->\n    @create new SliderMorph()\n  createNewFrameMorph: ->\n    newMorph = new FrameMorph()\n    newMorph.setExtent new Point(350, 250)\n    @create newMorph\n  createNewScrollFrameMorph: ->\n    newMorph = new ScrollFrameMorph()\n    newMorph.contents.acceptsDrops = true\n    newMorph.adjustContentsBounds()\n    newMorph.adjustScrollBars()\n    newMorph.setExtent new Point(350, 250)\n    @create newMorph\n  createNewCanvas: ->\n    newMorph = new CanvasMorph()\n    newMorph.setExtent new Point(350, 250)\n    @create newMorph\n  createNewHandle: ->\n    @create new HandleMorph()\n  createNewString: ->\n    newMorph = new StringMorph("Hello, World!")\n    newMorph.isEditable = true\n    @create newMorph\n  createNewText: ->\n    newMorph = new TextMorph("Ich weiß nicht, was soll es bedeuten, dass ich so " +\n      "traurig bin, ein Märchen aus uralten Zeiten, das " +\n      "kommt mir nicht aus dem Sinn. Die Luft ist kühl " +\n      "und es dunkelt, und ruhig fließt der Rhein; der " +\n      "Gipfel des Berges funkelt im Abendsonnenschein. " +\n      "Die schönste Jungfrau sitzet dort oben wunderbar, " +\n      "ihr gold\'nes Geschmeide blitzet, sie kämmt ihr " +\n      "goldenes Haar, sie kämmt es mit goldenem Kamme, " +\n      "und singt ein Lied dabei; das hat eine wundersame, " +\n      "gewalt\'ge Melodei. Den Schiffer im kleinen " +\n      "Schiffe, ergreift es mit wildem Weh; er schaut " +\n      "nicht die Felsenriffe, er schaut nur hinauf in " +\n      "die Höh\'. Ich glaube, die Wellen verschlingen " +\n      "am Ende Schiffer und Kahn, und das hat mit ihrem " +\n      "Singen, die Loreley getan.")\n    newMorph.isEditable = true\n    newMorph.maxWidth = 300\n    @create newMorph\n  createNewSpeechBubbleMorph: ->\n    newMorph = new SpeechBubbleMorph("Hello, World!")\n    @create newMorph\n  createNewGrayPaletteMorph: ->\n    @create new GrayPaletteMorph()\n  createNewColorPaletteMorph: ->\n    @create new ColorPaletteMorph()\n  createNewColorPickerMorph: ->\n    @create new ColorPickerMorph()\n  createNewSensorDemo: ->\n    newMorph = new MouseSensorMorph()\n    newMorph.setColor new Color(230, 200, 100)\n    newMorph.edge = 35\n    newMorph.border = 15\n    newMorph.alpha = 0.2\n    newMorph.setExtent new Point(100, 100)\n    @create newMorph\n  createNewAnimationDemo: ->\n    foo = new BouncerMorph()\n    foo.setPosition new Point(50, 20)\n    foo.setExtent new Point(300, 200)\n    foo.alpha = 0.9\n    foo.speed = 3\n    bar = new BouncerMorph()\n    bar.setColor new Color(50, 50, 50)\n    bar.setPosition new Point(80, 80)\n    bar.setExtent new Point(80, 250)\n    bar.type = "horizontal"\n    bar.direction = "right"\n    bar.alpha = 0.9\n    bar.speed = 5\n    baz = new BouncerMorph()\n    baz.setColor new Color(20, 20, 20)\n    baz.setPosition new Point(90, 140)\n    baz.setExtent new Point(40, 30)\n    baz.type = "horizontal"\n    baz.direction = "right"\n    baz.speed = 3\n    garply = new BouncerMorph()\n    garply.setColor new Color(200, 20, 20)\n    garply.setPosition new Point(90, 140)\n    garply.setExtent new Point(20, 20)\n    garply.type = "vertical"\n    garply.direction = "up"\n    garply.speed = 8\n    fred = new BouncerMorph()\n    fred.setColor new Color(20, 200, 20)\n    fred.setPosition new Point(120, 140)\n    fred.setExtent new Point(20, 20)\n    fred.type = "vertical"\n    fred.direction = "down"\n    fred.speed = 4\n    bar.add garply\n    bar.add baz\n    foo.add fred\n    foo.add bar\n    @create foo\n  createNewPenMorph: ->\n    @create new PenMorph()\n  viewAll: ->\n    newMorph = new MorphsListMorph()\n    @create newMorph\n  closingWindow: ->\n    newMorph = new WorkspaceMorph()\n    @create newMorph\n\n\n  popUpDemoMenu: (a,b,c,d) ->\n    menu = new MenuMorph(false, @, true, true, "make a morph")\n    menu.addItem "rectangle", true, @, "createNewRectangleMorph"\n    menu.addItem "box", true, @, "createNewBoxMorph"\n    menu.addItem "circle box", true, @, "createNewCircleBoxMorph"\n    menu.addLine()\n    menu.addItem "slider", true, @, "createNewSliderMorph"\n    menu.addItem "frame", true, @, "createNewFrameMorph"\n    menu.addItem "scroll frame", true, @, "createNewScrollFrameMorph"\n    menu.addItem "canvas", true, @, "createNewCanvas"\n    menu.addItem "handle", true, @, "createNewHandle"\n    menu.addLine()\n    menu.addItem "string", true, @, "createNewString"\n    # this is "The Lorelei" poem (From German).\n    # see translation here:\n    # http://poemsintranslation.blogspot.co.uk/2009/11/heinrich-heine-lorelei-from-german.html\n    menu.addItem "text", true, @, "createNewText"\n    menu.addItem "speech bubble", true, @, "createNewSpeechBubbleMorph"\n    menu.addLine()\n    menu.addItem "gray scale palette", true, @, "createNewGrayPaletteMorph"\n    menu.addItem "color palette", true, @, "createNewColorPaletteMorph"\n    menu.addItem "color picker", true, @, "createNewColorPickerMorph"\n    menu.addLine()\n    menu.addItem "sensor demo", true, @, "createNewSensorDemo"\n    menu.addItem "animation demo", true, @, "createNewAnimationDemo"\n    menu.addItem "pen", true, @, "createNewPenMorph"\n      \n    menu.addLine()\n    menu.addItem "layout tests ➜", false, @, "layoutTestsMenu", "sample morphs"\n    menu.addLine()\n    menu.addItem "view all...", true, @, "viewAll"\n    menu.addItem "closing window", true, @, "closingWindow"\n    \n    menu.popUpAtHand(a.firstContainerMenu())\n\n  layoutTestsMenu: (morphTriggeringThis) ->\n    menu = new MenuMorph(false, @, true, true, "Layout tests")\n    menu.addItem "test1", true, LayoutMorph, "test1"\n    menu.addItem "test2", true, LayoutMorph, "test2"\n    menu.addItem "test3", true, LayoutMorph, "test3"\n    menu.addItem "test4", true, LayoutMorph, "test4"\n    menu.popUpAtHand(morphTriggeringThis.firstContainerMenu())\n    \n  \n  toggleDevMode: ->\n    @isDevMode = not @isDevMode\n  \n  minimiseAll: ->\n    @children.forEach (child) ->\n      child.minimise()\n  \n  showAllMinimised: ->\n    @forAllChildrenBottomToTop (child) ->\n      child.unminimise() if child.isMinimised\n  \n  about: ->\n    @inform "Zombie Kernel\n\n" +\n      "a lively Web GUI\ninspired by Squeak\n" +\n      morphicVersion +\n      "\n\nby Davide Della Casa" +\n      "\n\nbased on morphic.js by" +\n      "\nJens Mönig (jens@moenig.org)"\n  \n  edit: (aStringMorphOrTextMorph) ->\n    # first off, if the Morph is not editable\n    # then there is nothing to do\n    # return null  unless aStringMorphOrTextMorph.isEditable\n\n    # there is only one caret in the World, so destroy\n    # the previous one if there was one.\n    if @caret\n      # empty the previously ongoing selection\n      # if there was one.\n      @lastEditedText = @caret.target\n      @lastEditedText.clearSelection()  if @lastEditedText\n      @caret = @caret.destroy()\n\n    # create the new Caret\n    @caret = new CaretMorph(aStringMorphOrTextMorph)\n    aStringMorphOrTextMorph.parent.add @caret\n    # this is the only place where the @keyboardEventsReceiver is set\n    @keyboardEventsReceiver = @caret\n\n    if WorldMorph.preferencesAndSettings.isTouchDevice and WorldMorph.preferencesAndSettings.useVirtualKeyboard\n      @initVirtualKeyboard()\n      # For touch devices, giving focus on the textbox causes\n      # the keyboard to slide up, and since the page viewport\n      # shrinks, the page is scrolled to where the texbox is.\n      # So, it is important to position the textbox around\n      # where the caret is, so that the changed text is going to\n      # be visible rather than out of the viewport.\n      pos = getDocumentPositionOf(@worldCanvas)\n      @inputDOMElementForVirtualKeyboard.style.top = @caret.top() + pos.y + "px"\n      @inputDOMElementForVirtualKeyboard.style.left = @caret.left() + pos.x + "px"\n      @inputDOMElementForVirtualKeyboard.focus()\n    if WorldMorph.preferencesAndSettings.useSliderForInput\n      if !aStringMorphOrTextMorph.parentThatIsA(MenuMorph)\n        @slide aStringMorphOrTextMorph\n  \n  # Editing can stop because of three reasons:\n  #   cancel (user hits ESC)\n  #   accept (on stringmorph, user hits enter)\n  #   user clicks/floatDrags another morph\n  stopEditing: ->\n    if @caret\n      @lastEditedText = @caret.target\n      @lastEditedText.clearSelection()\n      @lastEditedText.escalateEvent "reactToEdit", @lastEditedText\n      @caret = @caret.destroy()\n    # the only place where the @keyboardEventsReceiver is unset\n    # (and the hidden input is removed)\n    @keyboardEventsReceiver = null\n    if @inputDOMElementForVirtualKeyboard\n      @inputDOMElementForVirtualKeyboard.blur()\n      document.body.removeChild @inputDOMElementForVirtualKeyboard\n      @inputDOMElementForVirtualKeyboard = null\n    @worldCanvas.focus()\n  \n  slide: (@aStringMorphOrTextMorph) ->\n    # display a slider for numeric text entries\n    val = parseFloat(@aStringMorphOrTextMorph.text)\n    val = 0  if isNaN(val)\n    menu = new MenuMorph(false)\n    slider = new SliderMorph(val - 25, val + 25, val, 10, "horizontal")\n    slider.alpha = 1\n    slider.color = new Color(225, 225, 225)\n    slider.button.color = new Color 60,60,60\n    slider.button.highlightColor = slider.button.color.copy()\n    slider.button.highlightColor.b += 100\n    slider.button.pressColor = slider.button.color.copy()\n    slider.button.pressColor.b += 150\n    slider.silentSetHeight WorldMorph.preferencesAndSettings.scrollBarSize\n    slider.silentSetWidth WorldMorph.preferencesAndSettings.menuFontSize * 10\n    slider.setLayoutBeforeUpdatingBackingStore()\n    slider.updateBackingStore()\n    slider.action = "reactToSlide"\n    menu.items.push slider\n    menu.popup @, @aStringMorphOrTextMorph.bottomLeft().add(new Point(0, 5))\n  \n  reactToSlide: (num) ->\n    @aStringMorphOrTextMorph.changed()\n    @aStringMorphOrTextMorph.text = Math.round(num).toString()\n    @aStringMorphOrTextMorph.setLayoutBeforeUpdatingBackingStore()\n    @aStringMorphOrTextMorph.updateBackingStore()\n    @aStringMorphOrTextMorph.changed()\n    @aStringMorphOrTextMorph.escalateEvent(\n        \'reactToSliderEdit\',\n        @aStringMorphOrTextMorph\n    )\n  ';

  return WorldMorph;

})(FrameMorph);

StringMorph = (function(_super) {
  __extends(StringMorph, _super);

  namedClasses[StringMorph.name] = StringMorph.prototype;

  StringMorph.augmentWith(BackingStoreMixin);

  StringMorph.prototype.text = "";

  StringMorph.prototype.fontSize = null;

  StringMorph.prototype.fontName = null;

  StringMorph.prototype.fontStyle = null;

  StringMorph.prototype.isBold = null;

  StringMorph.prototype.isItalic = null;

  StringMorph.prototype.isEditable = false;

  StringMorph.prototype.isNumeric = null;

  StringMorph.prototype.isPassword = false;

  StringMorph.prototype.isShowingBlanks = false;

  StringMorph.prototype.blanksColor = new Color(180, 140, 140);

  StringMorph.prototype.isScrollable = true;

  StringMorph.prototype.currentlySelecting = false;

  StringMorph.prototype.startMark = null;

  StringMorph.prototype.endMark = null;

  StringMorph.prototype.markedTextColor = new Color(255, 255, 255);

  StringMorph.prototype.markedBackgoundColor = new Color(60, 60, 120);

  function StringMorph(text, fontSize, fontStyle, isBold, isItalic, isNumeric, color, fontName) {
    if (text == null) {
      text = "";
    }
    this.fontSize = fontSize != null ? fontSize : 12;
    this.fontStyle = fontStyle != null ? fontStyle : "sans-serif";
    this.isBold = isBold != null ? isBold : false;
    this.isItalic = isItalic != null ? isItalic : false;
    this.isNumeric = isNumeric != null ? isNumeric : false;
    this.text = text || (text === "" ? "" : "StringMorph");
    this.fontName = fontName || WorldMorph.preferencesAndSettings.globalFontFamily;
    StringMorph.__super__.constructor.call(this);
    this.color = color || new Color(0, 0, 0);
    this.noticesTransparentClick = true;
  }

  StringMorph.prototype.toString = function() {
    var firstPart;
    firstPart = StringMorph.__super__.toString.call(this);
    if (AutomatorRecorderAndPlayer.state !== AutomatorRecorderAndPlayer.IDLE && AutomatorRecorderAndPlayer.hidingOfMorphsContentExtractInLabels) {
      return firstPart;
    } else {
      return firstPart + " (\"" + this.text.slice(0, 30) + "...\")";
    }
  };

  StringMorph.prototype.getTextDescription = function() {
    var textWithoutLocationOrInstanceNo;
    if (this.textDescription != null) {
      return this.textDescription + " (adhoc description of string)";
    }
    textWithoutLocationOrInstanceNo = this.text.replace(/\[\d*@\d*[ ]*\|[ ]*\d*@\d*\]/, "");
    textWithoutLocationOrInstanceNo = textWithoutLocationOrInstanceNo.replace(/#\d*/, "");
    return textWithoutLocationOrInstanceNo.slice(0, 30) + " (content of string)";
  };

  StringMorph.prototype.password = function(letter, length) {
    var ans, _i;
    ans = "";
    for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
      ans += letter;
    }
    return ans;
  };

  StringMorph.prototype.font = function() {
    var font;
    font = "";
    if (this.isBold) {
      font = font + "bold ";
    }
    if (this.isItalic) {
      font = font + "italic ";
    }
    return font + this.fontSize + "px " + (this.fontName ? this.fontName + ", " : "") + this.fontStyle;
  };

  StringMorph.prototype.calculateExtentBasedOnText = function() {
    var context, text;
    text = (this.isPassword ? this.password("*", this.text.length) : this.text);
    this.image = newCanvas();
    context = this.image.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    context.font = this.font();
    context.textAlign = "left";
    context.textBaseline = "bottom";
    return Math.ceil(Math.max(context.measureText(text).width, 1));
  };

  StringMorph.prototype.setLayoutBeforeUpdatingBackingStore = function() {
    var width;
    width = this.calculateExtentBasedOnText();
    return this.bounds.corner = this.bounds.origin.add(new Point(width, fontHeight(this.fontSize)));
  };

  StringMorph.prototype.updateBackingStore = function() {
    var c, context, p, start, stop, text, width, _i, _results;
    text = (this.isPassword ? this.password("*", this.text.length) : this.text);
    width = this.calculateExtentBasedOnText();
    this.image = newCanvas((new Point(width, this.height())).scaleBy(pixelRatio));
    context = this.image.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    context.font = this.font();
    context.textAlign = "left";
    context.textBaseline = "bottom";
    context.fillStyle = this.color.toString();
    if (this.isShowingBlanks) {
      this.renderWithBlanks(context, 0, fontHeight(this.fontSize));
    } else {
      context.fillText(text, 0, fontHeight(this.fontSize));
    }
    start = Math.min(this.startMark, this.endMark);
    stop = Math.max(this.startMark, this.endMark);
    _results = [];
    for (i = _i = start; start <= stop ? _i < stop : _i > stop; i = start <= stop ? ++_i : --_i) {
      p = this.slotCoordinates(i).subtract(this.position());
      c = text.charAt(i);
      context.fillStyle = this.markedBackgoundColor.toString();
      context.fillRect(p.x, p.y, Math.ceil(context.measureText(c).width) + 1, fontHeight(this.fontSize));
      context.fillStyle = this.markedTextColor.toString();
      _results.push(context.fillText(c, p.x, fontHeight(this.fontSize)));
    }
    return _results;
  };

  StringMorph.prototype.renderWithBlanks = function(context, startX, y) {
    var blank, ctx, drawBlank, isFirst, space, words, x;
    drawBlank = function() {
      context.drawImage(blank, Math.round(x), 0);
      return x += space;
    };
    space = Math.ceil(context.measureText(" ").width);
    blank = newCanvas(new Point(space, this.height()).scaleBy(pixelRatio));
    ctx = blank.getContext("2d");
    words = this.text.split(" ");
    x = startX || 0;
    isFirst = true;
    ctx.fillStyle = this.blanksColor.toString();
    ctx.arc(space / 2, blank.height / 2, space / 2, degreesToRadians(0), degreesToRadians(360));
    ctx.fill();
    return words.forEach(function(word) {
      if (!isFirst) {
        drawBlank();
      }
      isFirst = false;
      if (word !== "") {
        context.fillText(word, x, y);
        return x += Math.ceil(context.measureText(word).width);
      }
    });
  };

  StringMorph.prototype.slotCoordinates = function(slot) {
    var context, dest, text, x, xOffset, y;
    text = (this.isPassword ? this.password("*", this.text.length) : this.text);
    dest = Math.min(Math.max(slot, 0), text.length);
    context = this.image.getContext("2d");
    xOffset = Math.ceil(context.measureText(text.substring(0, dest)).width);
    this.pos = dest;
    x = this.left() + xOffset;
    y = this.top();
    return new Point(x, y);
  };

  StringMorph.prototype.slotAt = function(aPoint) {
    var charX, context, idx, text;
    text = (this.isPassword ? this.password("*", this.text.length) : this.text);
    idx = 0;
    charX = 0;
    context = this.image.getContext("2d");
    while (aPoint.x - this.left() > charX) {
      charX += Math.ceil(context.measureText(text[idx]).width);
      idx += 1;
      if (idx === text.length) {
        if ((Math.ceil(context.measureText(text).width) - (Math.ceil(context.measureText(text[idx - 1]).width) / 2)) < (aPoint.x - this.left())) {
          return idx;
        }
      }
    }
    return idx - 1;
  };

  StringMorph.prototype.upFrom = function(slot) {
    return slot;
  };

  StringMorph.prototype.downFrom = function(slot) {
    return slot;
  };

  StringMorph.prototype.startOfLine = function() {
    return 0;
  };

  StringMorph.prototype.endOfLine = function() {
    return this.text.length;
  };

  StringMorph.prototype.rawHeight = function() {
    return this.height() / 1.2;
  };

  StringMorph.prototype.fontSizePopup = function(menuItem) {
    return this.prompt(menuItem.parent.title + "\nfont\nsize:", this, "setFontSize", this.fontSize.toString(), null, 6, 500, true);
  };

  StringMorph.prototype.developersMenu = function() {
    var menu;
    menu = StringMorph.__super__.developersMenu.call(this);
    menu.addLine();
    menu.addItem("edit", true, this, "edit");
    menu.addItem("font size...", true, this, "fontSizePopup", "set this String's\nfont point size");
    if (this.fontStyle !== "serif") {
      menu.addItem("serif", true, this, "setSerif");
    }
    if (this.fontStyle !== "sans-serif") {
      menu.addItem("sans-serif", true, this, "setSansSerif");
    }
    if (this.isBold) {
      menu.addItem("normal weight", true, this, "toggleWeight");
    } else {
      menu.addItem("bold", true, this, "toggleWeight");
    }
    if (this.isItalic) {
      menu.addItem("normal style", true, this, "toggleItalic");
    } else {
      menu.addItem("italic", true, this, "toggleItalic");
    }
    if (this.isShowingBlanks) {
      menu.addItem("hide blanks", true, this, "toggleShowBlanks");
    } else {
      menu.addItem("show blanks", true, this, "toggleShowBlanks");
    }
    if (this.isPassword) {
      menu.addItem("show characters", true, this, "toggleIsPassword");
    } else {
      menu.addItem("hide characters", true, this, "toggleIsPassword");
    }
    return menu;
  };

  StringMorph.prototype.toggleIsfloatDraggable = function() {
    this.isfloatDraggable = !this.isfloatDraggable;
    if (this.isfloatDraggable) {
      return this.disableSelecting();
    } else {
      return this.enableSelecting();
    }
  };

  StringMorph.prototype.toggleShowBlanks = function() {
    this.isShowingBlanks = !this.isShowingBlanks;
    this.changed();
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    return this.changed();
  };

  StringMorph.prototype.toggleWeight = function() {
    this.isBold = !this.isBold;
    this.changed();
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    return this.changed();
  };

  StringMorph.prototype.toggleItalic = function() {
    this.isItalic = !this.isItalic;
    this.changed();
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    return this.changed();
  };

  StringMorph.prototype.toggleIsPassword = function() {
    this.isPassword = !this.isPassword;
    this.changed();
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    return this.changed();
  };

  StringMorph.prototype.setSerif = function() {
    this.fontStyle = "serif";
    this.changed();
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    return this.changed();
  };

  StringMorph.prototype.setSansSerif = function() {
    this.fontStyle = "sans-serif";
    this.changed();
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    return this.changed();
  };

  StringMorph.prototype.setFontSize = function(sizeOrMorphGivingSize, morphGivingSize) {
    var newSize, size;
    if ((morphGivingSize != null ? morphGivingSize.getValue : void 0) != null) {
      size = morphGivingSize.getValue();
    } else {
      size = sizeOrMorphGivingSize;
    }
    if (typeof size === "number") {
      this.fontSize = Math.round(Math.min(Math.max(size, 4), 500));
    } else {
      newSize = parseFloat(size);
      if (!isNaN(newSize)) {
        this.fontSize = Math.round(Math.min(Math.max(newSize, 4), 500));
      }
    }
    this.changed();
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    return this.changed();
  };

  StringMorph.prototype.setText = function(size) {
    this.text = Math.round(size).toString();
    this.changed();
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    return this.changed();
  };

  StringMorph.prototype.numericalSetters = function() {
    return ["setLeft", "setTop", "setAlphaScaled", "setFontSize", "setText"];
  };

  StringMorph.prototype.edit = function() {
    return this.root().edit(this);
  };

  StringMorph.prototype.selection = function() {
    var start, stop;
    start = Math.min(this.startMark, this.endMark);
    stop = Math.max(this.startMark, this.endMark);
    return this.text.slice(start, stop);
  };

  StringMorph.prototype.selectionStartSlot = function() {
    return Math.min(this.startMark, this.endMark);
  };

  StringMorph.prototype.clearSelection = function() {
    this.currentlySelecting = false;
    this.startMark = null;
    this.endMark = null;
    this.changed();
    this.updateBackingStore();
    return this.changed();
  };

  StringMorph.prototype.deleteSelection = function() {
    var start, stop, text;
    text = this.text;
    start = Math.min(this.startMark, this.endMark);
    stop = Math.max(this.startMark, this.endMark);
    this.text = text.slice(0, start) + text.slice(stop);
    this.changed();
    return this.clearSelection();
  };

  StringMorph.prototype.selectAll = function() {
    this.startMark = 0;
    this.endMark = this.text.length;
    this.updateBackingStore();
    return this.changed();
  };

  StringMorph.prototype.mouseDownLeft = function(pos) {
    if (this.isEditable) {
      return this.clearSelection();
    } else {
      return this.escalateEvent("mouseDownLeft", pos);
    }
  };

  StringMorph.prototype.mouseClickLeft = function(pos) {
    var caret;
    StringMorph.__super__.mouseClickLeft.call(this);
    caret = this.root().caret;
    if (this.isEditable) {
      if (!this.currentlySelecting) {
        this.edit();
      }
      if (caret) {
        caret.gotoPos(pos);
      }
      this.root().caret.gotoPos(pos);
      return this.currentlySelecting = true;
    } else {
      return this.escalateEvent("mouseClickLeft", pos);
    }
  };

  StringMorph.prototype.enableSelecting = function() {
    this.mouseDownLeft = function(pos) {
      this.clearSelection();
      if (this.isEditable && (!this.isfloatDraggable)) {
        this.edit();
        this.root().caret.gotoPos(pos);
        this.startMark = this.slotAt(pos);
        this.endMark = this.startMark;
        return this.currentlySelecting = true;
      }
    };
    return this.mouseMove = function(pos) {
      var newMark;
      if (this.isEditable && this.currentlySelecting && (!this.isfloatDraggable)) {
        newMark = this.slotAt(pos);
        if (newMark !== this.endMark) {
          this.endMark = newMark;
          this.updateBackingStore();
          return this.changed();
        }
      }
    };
  };

  StringMorph.prototype.disableSelecting = function() {
    this.mouseDownLeft = StringMorph.prototype.mouseDownLeft;
    return delete this.mouseMove;
  };

  StringMorph.coffeeScriptSourceOfThisClass = '# StringMorph /////////////////////////////////////////////////////////\n\n# A StringMorph is a single line of text. It can only be left-aligned.\n# REQUIRES WorldMorph\n# REQUIRES BackingStoreMixin\n\nclass StringMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith BackingStoreMixin\n\n  text: ""\n  fontSize: null\n  fontName: null\n  fontStyle: null\n  isBold: null\n  isItalic: null\n  isEditable: false\n  isNumeric: null\n  isPassword: false\n  isShowingBlanks: false\n  # careful: this Color object is shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  blanksColor: new Color(180, 140, 140)\n\n  # Properties for text-editing\n  isScrollable: true\n  currentlySelecting: false\n  startMark: null\n  endMark: null\n  # careful: this Color object is shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  markedTextColor: new Color(255, 255, 255)\n  # careful: this Color object is shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  markedBackgoundColor: new Color(60, 60, 120)\n\n  constructor: (\n      text = "",\n      @fontSize = 12,\n      @fontStyle = "sans-serif",\n      @isBold = false,\n      @isItalic = false,\n      @isNumeric = false,\n      color,\n      fontName\n      ) ->\n    # additional properties:\n    @text = text or ((if (text is "") then "" else "StringMorph"))\n    @fontName = fontName or WorldMorph.preferencesAndSettings.globalFontFamily\n\n    super()\n\n    # override inherited properties:\n    @color = color or new Color(0, 0, 0)\n    @noticesTransparentClick = true\n\n  \n  toString: ->\n    # e.g. \'a StringMorph("Hello World")\'\n    firstPart = super()\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.hidingOfMorphsContentExtractInLabels\n      return firstPart\n    else\n      return firstPart + " (\"" + @text.slice(0, 30) + "...\")"\n\n  getTextDescription: ->\n    if @textDescription?\n      return @textDescription + " (adhoc description of string)"\n    textWithoutLocationOrInstanceNo = @text.replace(/\[\d*@\d*[ ]*\|[ ]*\d*@\d*\]/,"")\n    textWithoutLocationOrInstanceNo = textWithoutLocationOrInstanceNo.replace(/#\d*/,"")\n    return textWithoutLocationOrInstanceNo.slice(0, 30) + " (content of string)"\n  \n  password: (letter, length) ->\n    ans = ""\n    for i in [0...length]\n      ans += letter\n    ans\n\n  font: ->\n    # answer a font string, e.g. \'bold italic 12px sans-serif\'\n    font = ""\n    font = font + "bold "  if @isBold\n    font = font + "italic "  if @isItalic\n    font + @fontSize + "px " + ((if @fontName then @fontName + ", " else "")) + @fontStyle\n\n  calculateExtentBasedOnText: ->\n    text = (if @isPassword then @password("*", @text.length) else @text)\n    # initialize my surface property\n    @image = newCanvas()\n    context = @image.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    context.font = @font()\n    context.textAlign = "left"\n    context.textBaseline = "bottom"\n\n    # set my extent based on the size of the text\n    return Math.ceil(Math.max(context.measureText(text).width, 1))\n\n  setLayoutBeforeUpdatingBackingStore: ->\n    width = @calculateExtentBasedOnText()\n    @bounds.corner = @bounds.origin.add(new Point(\n      width, fontHeight(@fontSize)))\n  \n  # no changes of position or extent\n  updateBackingStore: ->\n    text = (if @isPassword then @password("*", @text.length) else @text)\n    # initialize my surface property\n    width = @calculateExtentBasedOnText()\n    @image = newCanvas (new Point width, @height()).scaleBy pixelRatio\n    context = @image.getContext("2d")\n\n    # changing the canvas size resets many of\n    # the properties of the canvas, so we need to\n    # re-initialise the font and alignments here\n    context.scale pixelRatio, pixelRatio\n    context.font = @font()\n    context.textAlign = "left"\n    context.textBaseline = "bottom"\n\n    context.fillStyle = @color.toString()\n    if @isShowingBlanks\n      @renderWithBlanks context, 0, fontHeight(@fontSize)\n    else\n      context.fillText text, 0, fontHeight(@fontSize)\n\n    # draw the selection\n    start = Math.min(@startMark, @endMark)\n    stop = Math.max(@startMark, @endMark)\n    for i in [start...stop]\n      p = @slotCoordinates(i).subtract(@position())\n      c = text.charAt(i)\n      context.fillStyle = @markedBackgoundColor.toString()\n      context.fillRect p.x, p.y, Math.ceil(context.measureText(c).width) + 1,\n        fontHeight(@fontSize)\n      context.fillStyle = @markedTextColor.toString()\n      context.fillText c, p.x, fontHeight(@fontSize)\n\n    # notify my parent of layout change\n    # @parent.layoutSubmorphs()  if @parent.layoutSubmorphs  if @parent\n  \n  renderWithBlanks: (context, startX, y) ->\n    # create the blank form\n    drawBlank = ->\n      context.drawImage blank, Math.round(x), 0\n      x += space\n    space = Math.ceil(context.measureText(" ").width)\n    blank = newCanvas(new Point(space, @height()).scaleBy pixelRatio)\n    ctx = blank.getContext("2d")\n    words = @text.split(" ")\n    x = startX or 0\n    isFirst = true\n    ctx.fillStyle = @blanksColor.toString()\n    ctx.arc space / 2, blank.height / 2, space / 2, degreesToRadians(0), degreesToRadians(360)\n    ctx.fill()\n\n    # render my text inserting blanks\n    words.forEach (word) ->\n      drawBlank()  unless isFirst\n      isFirst = false\n      if word isnt ""\n        context.fillText word, x, y\n        x += Math.ceil(context.measureText(word).width)\n  \n  \n  # StringMorph measuring:\n  slotCoordinates: (slot) ->\n    # answer the position point of the given index ("slot")\n    # where the caret should be placed\n    text = (if @isPassword then @password("*", @text.length) else @text)\n    dest = Math.min(Math.max(slot, 0), text.length)\n    context = @image.getContext("2d")\n    xOffset = Math.ceil(context.measureText(text.substring(0,dest)).width)\n    @pos = dest\n    x = @left() + xOffset\n    y = @top()\n    new Point(x, y)\n  \n  slotAt: (aPoint) ->\n    # answer the slot (index) closest to the given point\n    # so the caret can be moved accordingly\n    text = (if @isPassword then @password("*", @text.length) else @text)\n    idx = 0\n    charX = 0\n    context = @image.getContext("2d")\n\n    while aPoint.x - @left() > charX\n      charX += Math.ceil(context.measureText(text[idx]).width)\n      idx += 1\n      if idx is text.length\n        if (Math.ceil(context.measureText(text).width) - (Math.ceil(context.measureText(text[idx - 1]).width) / 2)) < (aPoint.x - @left())  \n          return idx\n    idx - 1\n  \n  upFrom: (slot) ->\n    # answer the slot above the given one\n    slot\n  \n  downFrom: (slot) ->\n    # answer the slot below the given one\n    slot\n  \n  startOfLine: ->\n    # answer the first slot (index) of the line for the given slot\n    0\n  \n  endOfLine: ->\n    # answer the slot (index) indicating the EOL for the given slot\n    @text.length\n\n  rawHeight: ->\n    # answer my corrected fontSize\n    @height() / 1.2\n    \n  fontSizePopup: (menuItem)->\n    @prompt menuItem.parent.title + "\nfont\nsize:",\n      @,\n      "setFontSize",\n      @fontSize.toString(),\n      null, 6, 500, true\n\n  # StringMorph menus:\n  developersMenu: ->\n    menu = super()\n    menu.addLine()\n    menu.addItem "edit", true, @, "edit"\n    menu.addItem "font size...", true, @, "fontSizePopup", "set this String\'s\nfont point size"\n    menu.addItem "serif", true, @, "setSerif"  if @fontStyle isnt "serif"\n    menu.addItem "sans-serif", true, @, "setSansSerif"  if @fontStyle isnt "sans-serif"\n\n    if @isBold\n      menu.addItem "normal weight", true, @, "toggleWeight"\n    else\n      menu.addItem "bold", true, @, "toggleWeight"\n\n    if @isItalic\n      menu.addItem "normal style", true, @, "toggleItalic"\n    else\n      menu.addItem "italic", true, @, "toggleItalic"\n\n    if @isShowingBlanks\n      menu.addItem "hide blanks", true, @, "toggleShowBlanks"\n    else\n      menu.addItem "show blanks", true, @, "toggleShowBlanks"\n\n    if @isPassword\n      menu.addItem "show characters", true, @, "toggleIsPassword"\n    else\n      menu.addItem "hide characters", true, @, "toggleIsPassword"\n\n    menu\n  \n  toggleIsfloatDraggable: ->\n    # for context menu demo purposes\n    @isfloatDraggable = not @isfloatDraggable\n    if @isfloatDraggable\n      @disableSelecting()\n    else\n      @enableSelecting()\n  \n  toggleShowBlanks: ->\n    @isShowingBlanks = not @isShowingBlanks\n    @changed()\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    @changed()\n  \n  toggleWeight: ->\n    @isBold = not @isBold\n    @changed()\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    @changed()\n  \n  toggleItalic: ->\n    @isItalic = not @isItalic\n    @changed()\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    @changed()\n  \n  toggleIsPassword: ->\n    @isPassword = not @isPassword\n    @changed()\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    @changed()\n  \n  setSerif: ->\n    @fontStyle = "serif"\n    @changed()\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    @changed()\n  \n  setSansSerif: ->\n    @fontStyle = "sans-serif"\n    @changed()\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    @changed()\n  \n  setFontSize: (sizeOrMorphGivingSize, morphGivingSize) ->\n    if morphGivingSize?.getValue?\n      size = morphGivingSize.getValue()\n    else\n      size = sizeOrMorphGivingSize\n\n    # for context menu demo purposes\n    if typeof size is "number"\n      @fontSize = Math.round(Math.min(Math.max(size, 4), 500))\n    else\n      newSize = parseFloat(size)\n      @fontSize = Math.round(Math.min(Math.max(newSize, 4), 500))  unless isNaN(newSize)\n    @changed()\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    @changed()\n  \n  setText: (size) ->\n    # for context menu demo purposes\n    @text = Math.round(size).toString()\n    @changed()\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    @changed()\n  \n  numericalSetters: ->\n    # for context menu demo purposes\n    ["setLeft", "setTop", "setAlphaScaled", "setFontSize", "setText"]\n  \n  \n  # StringMorph editing:\n  edit: ->\n    @root().edit @\n\n  selection: ->\n    start = Math.min(@startMark, @endMark)\n    stop = Math.max(@startMark, @endMark)\n    @text.slice start, stop\n  \n  selectionStartSlot: ->\n    Math.min @startMark, @endMark\n  \n  clearSelection: ->\n    @currentlySelecting = false\n    @startMark = null\n    @endMark = null\n    @changed()\n    @updateBackingStore()\n    @changed()\n  \n  deleteSelection: ->\n    text = @text\n    start = Math.min(@startMark, @endMark)\n    stop = Math.max(@startMark, @endMark)\n    @text = text.slice(0, start) + text.slice(stop)\n    @changed()\n    @clearSelection()\n  \n  selectAll: ->\n    @startMark = 0\n    @endMark = @text.length\n    @updateBackingStore()\n    @changed()\n\n  mouseDownLeft: (pos) ->\n    if @isEditable\n      @clearSelection()\n    else\n      @escalateEvent "mouseDownLeft", pos\n\n  # Every time the user clicks on the text, a new edit()\n  # is triggered, which creates a new caret.\n  mouseClickLeft: (pos) ->\n    super()\n    caret = @root().caret;\n    if @isEditable\n      @edit()  unless @currentlySelecting\n      if caret then caret.gotoPos pos\n      @root().caret.gotoPos pos\n      @currentlySelecting = true\n    else\n      @escalateEvent "mouseClickLeft", pos\n  \n  #mouseDoubleClick: ->\n  #  alert "mouseDoubleClick!"\n\n  enableSelecting: ->\n    @mouseDownLeft = (pos) ->\n      @clearSelection()\n      if @isEditable and (not @isfloatDraggable)\n        @edit()\n        @root().caret.gotoPos pos\n        @startMark = @slotAt(pos)\n        @endMark = @startMark\n        @currentlySelecting = true\n    \n    @mouseMove = (pos) ->\n      if @isEditable and @currentlySelecting and (not @isfloatDraggable)\n        newMark = @slotAt(pos)\n        if newMark isnt @endMark\n          @endMark = newMark\n          @updateBackingStore()\n          @changed()\n  \n  disableSelecting: ->\n    # re-establish the original definition of the method\n    @mouseDownLeft = StringMorph::mouseDownLeft\n    delete @mouseMove\n\n';

  return StringMorph;

})(Morph);

TextMorph = (function(_super) {
  __extends(TextMorph, _super);

  namedClasses[TextMorph.name] = TextMorph.prototype;

  TextMorph.prototype.words = [];

  TextMorph.prototype.lines = [];

  TextMorph.prototype.lineSlots = [];

  TextMorph.prototype.alignment = null;

  TextMorph.prototype.maxWidth = null;

  TextMorph.prototype.maxLineWidth = 0;

  TextMorph.prototype.backgroundColor = null;

  TextMorph.prototype.receiver = null;

  function TextMorph(text, fontSize, fontStyle, isBold, isItalic, alignment, maxWidth, fontName, shadowOffset, shadowColor) {
    this.fontSize = fontSize != null ? fontSize : 12;
    this.fontStyle = fontStyle != null ? fontStyle : "sans-serif";
    this.isBold = isBold != null ? isBold : false;
    this.isItalic = isItalic != null ? isItalic : false;
    this.alignment = alignment != null ? alignment : "left";
    this.maxWidth = maxWidth != null ? maxWidth : 0;
    this.shadowColor = shadowColor != null ? shadowColor : null;
    TextMorph.__super__.constructor.call(this, text, this.fontSize, this.fontStyle, this.isBold, this.isItalic, null, shadowOffset, this.shadowColor, null, fontName);
    this.markedTextColor = new Color(255, 255, 255);
    this.markedBackgoundColor = new Color(60, 60, 120);
    this.text = text || (text === "" ? text : "TextMorph");
    this.fontName = fontName || WorldMorph.preferencesAndSettings.globalFontFamily;
    this.shadowOffset = shadowOffset || new Point(0, 0);
    this.color = new Color(0, 0, 0);
    this.noticesTransparentClick = true;
  }

  TextMorph.prototype.breakTextIntoLines = function() {
    var canvas, context, currentLine, paragraphs, slot;
    paragraphs = this.text.split("\n");
    canvas = newCanvas();
    context = canvas.getContext("2d");
    context.scale(pixelRatio, pixelRatio);
    currentLine = "";
    slot = 0;
    context.font = this.font();
    this.maxLineWidth = 0;
    this.lines = [];
    this.lineSlots = [0];
    this.words = [];
    paragraphs.forEach((function(_this) {
      return function(p) {
        _this.words = _this.words.concat(p.split(" "));
        return _this.words.push("\n");
      };
    })(this));
    return this.words.forEach((function(_this) {
      return function(word) {
        var lineForOverflowTest, w;
        if (word === "\n") {
          _this.lines.push(currentLine);
          _this.lineSlots.push(slot);
          _this.maxLineWidth = Math.max(_this.maxLineWidth, Math.ceil(context.measureText(currentLine).width));
          return currentLine = "";
        } else {
          if (_this.maxWidth > 0) {
            lineForOverflowTest = currentLine + word + " ";
            w = Math.ceil(context.measureText(lineForOverflowTest).width);
            if (w > _this.maxWidth) {
              _this.lines.push(currentLine);
              _this.lineSlots.push(slot);
              _this.maxLineWidth = Math.max(_this.maxLineWidth, Math.ceil(context.measureText(currentLine).width));
              currentLine = word + " ";
            } else {
              currentLine = lineForOverflowTest;
            }
          } else {
            currentLine = currentLine + word + " ";
          }
          return slot += word.length + 1;
        }
      };
    })(this));
  };

  TextMorph.prototype.setLayoutBeforeUpdatingBackingStore = function() {
    var ANimage, context, height, shadowHeight, shadowWidth;
    ANimage = newCanvas();
    context = ANimage.getContext("2d");
    context.font = this.font();
    this.breakTextIntoLines();
    shadowWidth = Math.abs(this.shadowOffset.x);
    shadowHeight = Math.abs(this.shadowOffset.y);
    height = this.lines.length * (Math.ceil(fontHeight(this.fontSize)) + shadowHeight);
    if (this.maxWidth === 0) {
      this.bounds = this.bounds.origin.extent(new Point(this.maxLineWidth + shadowWidth, height));
    } else {
      this.bounds = this.bounds.origin.extent(new Point(this.maxWidth + shadowWidth, height));
    }
    if (this.parent) {
      if (this.parent.layoutChanged) {
        return this.parent.layoutChanged();
      }
    }
  };

  TextMorph.prototype.updateBackingStore = function() {
    var c, context, line, offx, offy, p, shadowHeight, shadowWidth, start, stop, width, x, y, _i, _j, _k, _len, _len1, _ref, _ref1, _results;
    this.image = newCanvas();
    context = this.image.getContext("2d");
    context.font = this.font();
    shadowWidth = Math.abs(this.shadowOffset.x);
    shadowHeight = Math.abs(this.shadowOffset.y);
    this.image.width = this.width() * pixelRatio;
    this.image.height = this.height() * pixelRatio;
    context.scale(pixelRatio, pixelRatio);
    context.font = this.font();
    context.textAlign = "left";
    context.textBaseline = "bottom";
    if (this.backgroundColor) {
      context.fillStyle = this.backgroundColor.toString();
      context.fillRect(0, 0, this.width(), this.height());
    }
    if (this.shadowColor) {
      offx = Math.max(this.shadowOffset.x, 0);
      offy = Math.max(this.shadowOffset.y, 0);
      context.fillStyle = this.shadowColor.toString();
      i = 0;
      _ref = this.lines;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        width = Math.ceil(context.measureText(line).width) + shadowWidth;
        if (this.alignment === "right") {
          x = this.width() - width;
        } else if (this.alignment === "center") {
          x = (this.width() - width) / 2;
        } else {
          x = 0;
        }
        y = (i + 1) * (Math.ceil(fontHeight(this.fontSize)) + shadowHeight) - shadowHeight;
        i++;
        context.fillText(line, x + offx, y + offy);
      }
    }
    offx = Math.abs(Math.min(this.shadowOffset.x, 0));
    offy = Math.abs(Math.min(this.shadowOffset.y, 0));
    context.fillStyle = this.color.toString();
    i = 0;
    _ref1 = this.lines;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      line = _ref1[_j];
      width = Math.ceil(context.measureText(line).width) + shadowWidth;
      if (this.alignment === "right") {
        x = this.width() - width;
      } else if (this.alignment === "center") {
        x = (this.width() - width) / 2;
      } else {
        x = 0;
      }
      y = (i + 1) * (Math.ceil(fontHeight(this.fontSize)) + shadowHeight) - shadowHeight;
      i++;
      context.fillText(line, x + offx, y + offy);
    }
    start = Math.min(this.startMark, this.endMark);
    stop = Math.max(this.startMark, this.endMark);
    _results = [];
    for (i = _k = start; start <= stop ? _k < stop : _k > stop; i = start <= stop ? ++_k : --_k) {
      p = this.slotCoordinates(i).subtract(this.position());
      c = this.text.charAt(i);
      context.fillStyle = this.markedBackgoundColor.toString();
      context.fillRect(p.x, p.y, Math.ceil(context.measureText(c).width) + 1, Math.ceil(fontHeight(this.fontSize)));
      context.fillStyle = this.markedTextColor.toString();
      _results.push(context.fillText(c, p.x, p.y + Math.ceil(fontHeight(this.fontSize))));
    }
    return _results;
  };

  TextMorph.prototype.setExtent = function(aPoint) {
    this.maxWidth = Math.max(aPoint.x, 0);
    this.changed();
    this.setLayoutBeforeUpdatingBackingStore();
    return this.updateBackingStore();
  };

  TextMorph.prototype.slotRowAndColumn = function(slot) {
    var col, idx, row, _i, _j, _ref, _ref1;
    idx = 0;
    for (row = _i = 0, _ref = this.lines.length; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
      idx = this.lineSlots[row];
      for (col = _j = 0, _ref1 = this.lines[row].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
        if (idx === slot) {
          return [row, col];
        }
        idx += 1;
      }
    }
    return [this.lines.length - 1, this.lines[this.lines.length - 1].length - 1];
  };

  TextMorph.prototype.slotCoordinates = function(slot) {
    var context, shadowHeight, slotColumn, slotRow, x, xOffset, y, yOffset, _ref;
    _ref = this.slotRowAndColumn(slot), slotRow = _ref[0], slotColumn = _ref[1];
    context = this.image.getContext("2d");
    shadowHeight = Math.abs(this.shadowOffset.y);
    yOffset = slotRow * (Math.ceil(fontHeight(this.fontSize)) + shadowHeight);
    xOffset = Math.ceil(context.measureText(this.lines[slotRow].substring(0, slotColumn)).width);
    x = this.left() + xOffset;
    y = this.top() + yOffset;
    return new Point(x, y);
  };

  TextMorph.prototype.slotAt = function(aPoint) {
    var charX, col, context, row, shadowHeight;
    charX = 0;
    row = 0;
    col = 0;
    shadowHeight = Math.abs(this.shadowOffset.y);
    context = this.image.getContext("2d");
    while (aPoint.y - this.top() > ((Math.ceil(fontHeight(this.fontSize)) + shadowHeight) * row)) {
      row += 1;
    }
    row = Math.max(row, 1);
    while (aPoint.x - this.left() > charX) {
      charX += Math.ceil(context.measureText(this.lines[row - 1][col]).width);
      col += 1;
    }
    return this.lineSlots[Math.max(row - 1, 0)] + col - 1;
  };

  TextMorph.prototype.upFrom = function(slot) {
    var above, slotColumn, slotRow, _ref;
    _ref = this.slotRowAndColumn(slot), slotRow = _ref[0], slotColumn = _ref[1];
    if (slotRow < 1) {
      return slot;
    }
    above = this.lines[slotRow - 1];
    if (above.length < slotColumn - 1) {
      return this.lineSlots[slotRow - 1] + above.length;
    }
    return this.lineSlots[slotRow - 1] + slotColumn;
  };

  TextMorph.prototype.downFrom = function(slot) {
    var below, slotColumn, slotRow, _ref;
    _ref = this.slotRowAndColumn(slot), slotRow = _ref[0], slotColumn = _ref[1];
    if (slotRow > this.lines.length - 2) {
      return slot;
    }
    below = this.lines[slotRow + 1];
    if (below.length < slotColumn - 1) {
      return this.lineSlots[slotRow + 1] + below.length;
    }
    return this.lineSlots[slotRow + 1] + slotColumn;
  };

  TextMorph.prototype.startOfLine = function(slot) {
    return this.lineSlots[this.slotRowAndColumn(slot).y];
  };

  TextMorph.prototype.endOfLine = function(slot) {
    return this.startOfLine(slot) + this.lines[this.slotRowAndColumn(slot).y].length - 1;
  };

  TextMorph.prototype.developersMenu = function() {
    var menu;
    menu = TextMorph.__super__.developersMenu.call(this);
    menu.addLine();
    if (this.alignment !== "left") {
      menu.addItem("align left", true, this, "setAlignmentToLeft");
    }
    if (this.alignment !== "right") {
      menu.addItem("align right", true, this, "setAlignmentToRight");
    }
    if (this.alignment !== "center") {
      menu.addItem("align center", true, this, "setAlignmentToCenter");
    }
    menu.addItem("run contents", true, this, "doContents");
    return menu;
  };

  TextMorph.prototype.setAlignmentToLeft = function() {
    this.alignment = "left";
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    return this.changed();
  };

  TextMorph.prototype.setAlignmentToRight = function() {
    this.alignment = "right";
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    return this.changed();
  };

  TextMorph.prototype.setAlignmentToCenter = function() {
    this.alignment = "center";
    this.setLayoutBeforeUpdatingBackingStore();
    this.updateBackingStore();
    return this.changed();
  };

  TextMorph.prototype.evaluationMenu = function() {
    var menu;
    menu = this.hierarchyMenu();
    if (this.text.length > 0) {
      menu.prependLine();
      menu.prependItem("select all", true, this, "selectAllAndEdit");
      menu.prependItem("do all", true, this, "selectAllAndDoit");
    }
    if (this.selection().replace(/^\s\s*/, '').replace(/\s\s*$/, '') !== '') {
      menu.prependLine();
      menu.prependItem("inspect selection", true, this, "inspectSelection", "evaluate the\nselected expression\nand inspect the result");
      menu.prependItem("show selection", true, this, "showSelection", "evaluate the\nselected expression\nand show the result");
      menu.prependItem("do selection", true, this, "doSelection", "evaluate the\nselected expression");
    }
    return menu;
  };

  TextMorph.prototype.selectAllAndEdit = function() {
    this.edit();
    return this.selectAll();
  };

  TextMorph.prototype.selectAllAndDoit = function() {
    this.edit();
    this.selectAll();
    return this.doSelection();
  };

  TextMorph.prototype.setReceiver = function(obj) {
    this.receiver = obj;
    return this.customContextMenu = this.evaluationMenu;
  };

  TextMorph.prototype.doSelection = function() {
    this.receiver.evaluateString(this.selection());
    return this.edit();
  };

  TextMorph.prototype.doContents = function() {
    if (this.receiver != null) {
      return this.receiver.evaluateString(this.text);
    } else {
      return this.evaluateString(this.text);
    }
  };

  TextMorph.prototype.showSelection = function() {
    var result;
    result = this.receiver.evaluateString(this.selection());
    if (result != null) {
      return this.inform(result);
    }
  };

  TextMorph.prototype.inspectSelection = function() {
    var result;
    result = this.receiver.evaluateString(this.selection());
    if (result != null) {
      return this.spawnInspector(result);
    }
  };

  TextMorph.coffeeScriptSourceOfThisClass = '# TextMorph ///////////////////////////////////////////////////////////\n\n# I am a multi-line, word-wrapping String\n\n# Note that in the original Jens\' Morphic.js version he\n# has made this quasi-inheriting from StringMorph i.e. he is copying\n# over manually the following methods like so:\n#\n#  TextMorph::font = StringMorph::font\n#  TextMorph::edit = StringMorph::edit\n#  TextMorph::selection = StringMorph::selection\n#  TextMorph::selectionStartSlot = StringMorph::selectionStartSlot\n#  TextMorph::clearSelection = StringMorph::clearSelection\n#  TextMorph::deleteSelection = StringMorph::deleteSelection\n#  TextMorph::selectAll = StringMorph::selectAll\n#  TextMorph::mouseClickLeft = StringMorph::mouseClickLeft\n#  TextMorph::enableSelecting = StringMorph::enableSelecting \n#  TextMorph::disableSelecting = StringMorph::disableSelecting\n#  TextMorph::toggleIsfloatDraggable = StringMorph::toggleIsfloatDraggable\n#  TextMorph::toggleWeight = StringMorph::toggleWeight\n#  TextMorph::toggleItalic = StringMorph::toggleItalic\n#  TextMorph::setSerif = StringMorph::setSerif\n#  TextMorph::setSansSerif = StringMorph::setSansSerif\n#  TextMorph::setText = StringMorph::setText\n#  TextMorph::setFontSize = StringMorph::setFontSize\n#  TextMorph::numericalSetters = StringMorph::numericalSetters\n\n\nclass TextMorph extends StringMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  words: []\n  lines: []\n  lineSlots: []\n  alignment: null\n  maxWidth: null\n  maxLineWidth: 0\n  backgroundColor: null\n\n  #additional properties for ad-hoc evaluation:\n  receiver: null\n\n  constructor: (\n    text, @fontSize = 12, @fontStyle = "sans-serif", @isBold = false,\n    @isItalic = false, @alignment = "left", @maxWidth = 0, fontName, shadowOffset,\n    @shadowColor = null\n    ) ->\n\n      super(text, @fontSize, @fontStyle, @isBold, @isItalic, null, shadowOffset, @shadowColor,null,fontName)\n      # override inherited properties:\n      @markedTextColor = new Color(255, 255, 255)\n      @markedBackgoundColor = new Color(60, 60, 120)\n      @text = text or ((if text is "" then text else "TextMorph"))\n      @fontName = fontName or WorldMorph.preferencesAndSettings.globalFontFamily\n      @shadowOffset = shadowOffset or new Point(0, 0)\n      @color = new Color(0, 0, 0)\n      @noticesTransparentClick = true\n  \n  breakTextIntoLines: ->\n    paragraphs = @text.split("\n")\n    canvas = newCanvas()\n    context = canvas.getContext("2d")\n    context.scale pixelRatio, pixelRatio\n    currentLine = ""\n    slot = 0\n    context.font = @font()\n    @maxLineWidth = 0\n    @lines = []\n    @lineSlots = [0]\n    @words = []\n    \n    # put all the text in an array, word by word\n    paragraphs.forEach (p) =>\n      @words = @words.concat(p.split(" "))\n      @words.push "\n"\n\n    # takes the text, word by word, and re-flows\n    # it according to the available width for the\n    # text (if there is such limit).\n    # The end result is an array of lines\n    # called @lines, which contains the string for\n    # each line (excluding the end of lines).\n    # Also another array is created, called\n    # @lineSlots, which memorises how many characters\n    # of the text have been consumed up to each line\n    #  example: original text: "Hello\nWorld"\n    # then @lines[0] = "Hello" @lines[1] = "World"\n    # and @lineSlots[0] = 6, @lineSlots[1] = 11\n    # Note that this algorithm doesn\'t work in case\n    # of single non-spaced words that are longer than\n    # the allowed width.\n    @words.forEach (word) =>\n      if word is "\n"\n        # we reached the end of the line in the\n        # original text, so push the line and the\n        # slots count in the arrays\n        @lines.push currentLine\n        @lineSlots.push slot\n        @maxLineWidth = Math.max(@maxLineWidth, Math.ceil(context.measureText(currentLine).width))\n        currentLine = ""\n      else\n        if @maxWidth > 0\n          # there is a width limit, so we need\n          # to check whether we overflowed it. So create\n          # a prospective line and then check its width.\n          lineForOverflowTest = currentLine + word + " "\n          w = Math.ceil(context.measureText(lineForOverflowTest).width)\n          if w > @maxWidth\n            # ok we just overflowed the available space,\n            # so we need to push the old line and its\n            # "slot" number to the respective arrays.\n            # the new line is going to only contain the\n            # word that has caused the overflow.\n            @lines.push currentLine\n            @lineSlots.push slot\n            @maxLineWidth = Math.max(@maxLineWidth, Math.ceil(context.measureText(currentLine).width))\n            currentLine = word + " "\n          else\n            # no overflow happened, so just proceed as normal\n            currentLine = lineForOverflowTest\n        else\n          currentLine = currentLine + word + " "\n        slot += word.length + 1\n  \n\n  setLayoutBeforeUpdatingBackingStore: ->\n    ANimage = newCanvas()\n    context = ANimage.getContext("2d")\n    context.font = @font()\n    @breakTextIntoLines()\n\n    shadowWidth = Math.abs(@shadowOffset.x)\n    shadowHeight = Math.abs(@shadowOffset.y)\n    height = @lines.length * (Math.ceil(fontHeight(@fontSize)) + shadowHeight)\n    if @maxWidth is 0\n      @bounds = @bounds.origin.extent(new Point(@maxLineWidth + shadowWidth, height))\n    else\n      @bounds = @bounds.origin.extent(new Point(@maxWidth + shadowWidth, height))\n    @parent.layoutChanged()  if @parent.layoutChanged  if @parent\n  \n  # no changes of position or extent\n  updateBackingStore: ->\n    @image = newCanvas()\n    context = @image.getContext("2d")\n    context.font = @font()\n\n    shadowWidth = Math.abs(@shadowOffset.x)\n    shadowHeight = Math.abs(@shadowOffset.y)\n\n\n    @image.width = @width() * pixelRatio\n    @image.height = @height() * pixelRatio\n\n    # changing the canvas size resets many of\n    # the properties of the canvas, so we need to\n    # re-initialise the font and alignments here\n    context.scale pixelRatio, pixelRatio\n    context.font = @font()\n    context.textAlign = "left"\n    context.textBaseline = "bottom"\n\n    # fill the background, if desired\n    if @backgroundColor\n      context.fillStyle = @backgroundColor.toString()\n      context.fillRect 0, 0, @width(), @height()\n\n    # draw the shadow, if any\n    if @shadowColor\n      offx = Math.max(@shadowOffset.x, 0)\n      offy = Math.max(@shadowOffset.y, 0)\n      #console.log \'shadow x: \' + offx + " y: " + offy\n      context.fillStyle = @shadowColor.toString()\n      i = 0\n      for line in @lines\n        width = Math.ceil(context.measureText(line).width) + shadowWidth\n        if @alignment is "right"\n          x = @width() - width\n        else if @alignment is "center"\n          x = (@width() - width) / 2\n        else # \'left\'\n          x = 0\n        y = (i + 1) * (Math.ceil(fontHeight(@fontSize)) + shadowHeight) - shadowHeight\n        i++\n        context.fillText line, x + offx, y + offy\n\n    # now draw the actual text\n    offx = Math.abs(Math.min(@shadowOffset.x, 0))\n    offy = Math.abs(Math.min(@shadowOffset.y, 0))\n    #console.log \'maintext x: \' + offx + " y: " + offy\n    context.fillStyle = @color.toString()\n    i = 0\n    for line in @lines\n      width = Math.ceil(context.measureText(line).width) + shadowWidth\n      if @alignment is "right"\n        x = @width() - width\n      else if @alignment is "center"\n        x = (@width() - width) / 2\n      else # \'left\'\n        x = 0\n      y = (i + 1) * (Math.ceil(fontHeight(@fontSize)) + shadowHeight) - shadowHeight\n      i++\n      context.fillText line, x + offx, y + offy\n\n    # Draw the selection. This is done by re-drawing the\n    # selected text, one character at the time, just with\n    # a background rectangle.\n    start = Math.min(@startMark, @endMark)\n    stop = Math.max(@startMark, @endMark)\n    for i in [start...stop]\n      p = @slotCoordinates(i).subtract(@position())\n      c = @text.charAt(i)\n      context.fillStyle = @markedBackgoundColor.toString()\n      context.fillRect p.x, p.y, Math.ceil(context.measureText(c).width) + 1, Math.ceil(fontHeight(@fontSize))\n      context.fillStyle = @markedTextColor.toString()\n      context.fillText c, p.x, p.y + Math.ceil(fontHeight(@fontSize))\n\n  \n  setExtent: (aPoint) ->\n    @maxWidth = Math.max(aPoint.x, 0)\n    @changed()\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n  \n  # TextMorph measuring ////\n\n  # answer the logical position point of the given index ("slot")\n  # i.e. the row and the column where a particular character is.\n  slotRowAndColumn: (slot) ->\n    idx = 0\n    # Note that this solution scans all the characters\n    # in all the rows up to the slot. This could be\n    # done a lot quicker by stopping at the first row\n    # such that @lineSlots[theRow] <= slot\n    # You could even do a binary search if one really\n    # wanted to, because the contents of @lineSlots are\n    # in order, as they contain a cumulative count...\n    for row in [0...@lines.length]\n      idx = @lineSlots[row]\n      for col in [0...@lines[row].length]\n        return [row, col]  if idx is slot\n        idx += 1\n    [@lines.length - 1, @lines[@lines.length - 1].length - 1]\n  \n  # Answer the position (in pixels) of the given index ("slot")\n  # where the caret should be placed.\n  # This is in absolute world coordinates.\n  # This function assumes that the text is left-justified.\n  slotCoordinates: (slot) ->\n    [slotRow, slotColumn] = @slotRowAndColumn(slot)\n    context = @image.getContext("2d")\n    shadowHeight = Math.abs(@shadowOffset.y)\n    yOffset = slotRow * (Math.ceil(fontHeight(@fontSize)) + shadowHeight)\n    xOffset = Math.ceil(context.measureText((@lines[slotRow]).substring(0,slotColumn)).width)\n    x = @left() + xOffset\n    y = @top() + yOffset\n    new Point(x, y)\n  \n  # Returns the slot (index) closest to the given point\n  # so the caret can be moved accordingly\n  # This function assumes that the text is left-justified.\n  slotAt: (aPoint) ->\n    charX = 0\n    row = 0\n    col = 0\n    shadowHeight = Math.abs(@shadowOffset.y)\n    context = @image.getContext("2d")\n    row += 1  while aPoint.y - @top() > ((Math.ceil(fontHeight(@fontSize)) + shadowHeight) * row)\n    row = Math.max(row, 1)\n    while aPoint.x - @left() > charX\n      charX += Math.ceil(context.measureText(@lines[row - 1][col]).width)\n      col += 1\n    @lineSlots[Math.max(row - 1, 0)] + col - 1\n  \n  upFrom: (slot) ->\n    # answer the slot above the given one\n    [slotRow, slotColumn] = @slotRowAndColumn(slot)\n    return slot  if slotRow < 1\n    above = @lines[slotRow - 1]\n    return @lineSlots[slotRow - 1] + above.length  if above.length < slotColumn - 1\n    @lineSlots[slotRow - 1] + slotColumn\n  \n  downFrom: (slot) ->\n    # answer the slot below the given one\n    [slotRow, slotColumn] = @slotRowAndColumn(slot)\n    return slot  if slotRow > @lines.length - 2\n    below = @lines[slotRow + 1]\n    return @lineSlots[slotRow + 1] + below.length  if below.length < slotColumn - 1\n    @lineSlots[slotRow + 1] + slotColumn\n  \n  startOfLine: (slot) ->\n    # answer the first slot (index) of the line for the given slot\n    @lineSlots[@slotRowAndColumn(slot).y]\n  \n  endOfLine: (slot) ->\n    # answer the slot (index) indicating the EOL for the given slot\n    @startOfLine(slot) + @lines[@slotRowAndColumn(slot).y].length - 1\n  \n  # TextMorph menus:\n  developersMenu: ->\n    menu = super()\n    menu.addLine()\n    menu.addItem "align left", true, @, "setAlignmentToLeft"  if @alignment isnt "left"\n    menu.addItem "align right", true, @, "setAlignmentToRight"  if @alignment isnt "right"\n    menu.addItem "align center", true, @, "setAlignmentToCenter"  if @alignment isnt "center"\n    menu.addItem "run contents", true, @, "doContents"\n    menu\n  \n  setAlignmentToLeft: ->\n    @alignment = "left"\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    @changed()\n  \n  setAlignmentToRight: ->\n    @alignment = "right"\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    @changed()\n  \n  setAlignmentToCenter: ->\n    @alignment = "center"\n    @setLayoutBeforeUpdatingBackingStore()\n    @updateBackingStore()\n    @changed()  \n  \n  # TextMorph evaluation:\n  evaluationMenu: ->\n    menu = @hierarchyMenu()\n\n    if @text.length > 0\n      menu.prependLine()\n      menu.prependItem "select all", true, @, "selectAllAndEdit"\n      menu.prependItem "do all", true, @, "selectAllAndDoit"\n\n    # only show the do it / show it / inspect it entries\n    # if there is actually something selected.\n    if @selection().replace(/^\s\s*/, \'\').replace(/\s\s*$/, \'\') != \'\'\n      menu.prependLine()\n      menu.prependItem "inspect selection", true, @, "inspectSelection", "evaluate the\nselected expression\nand inspect the result"\n      menu.prependItem "show selection", true, @, "showSelection", "evaluate the\nselected expression\nand show the result"\n      menu.prependItem "do selection", true, @, "doSelection", "evaluate the\nselected expression"\n    menu\n\n  selectAllAndEdit: ->\n    @edit()\n    @selectAll()\n\n  # TODO this can be done more\n  # abstractly, bypassing the\n  # actual selection and doSelection...\n  selectAllAndDoit: ->\n    @edit()\n    @selectAll()\n    @doSelection()\n   \n  # this is set by the inspector. It tells the TextMorph\n  # that any following doSelection/showSelection/inspectSelection action needs to be\n  # done apropos a particular obj\n  setReceiver: (obj) ->\n    @receiver = obj\n    @customContextMenu = @evaluationMenu\n  \n  doSelection: ->\n    @receiver.evaluateString @selection()\n    @edit()\n\n  doContents: ->\n    if @receiver?\n      @receiver.evaluateString @text\n    else\n      @evaluateString @text\n\n  showSelection: ->\n    result = @receiver.evaluateString(@selection())\n    if result? then @inform result\n  \n  inspectSelection: ->\n    # evaluateString is a pimped-up eval in\n    # the Morph class.\n    result = @receiver.evaluateString(@selection())\n    if result? then @spawnInspector result';

  return TextMorph;

})(StringMorph);

WorkspaceMorph = (function(_super) {
  __extends(WorkspaceMorph, _super);

  namedClasses[WorkspaceMorph.name] = WorkspaceMorph.prototype;

  WorkspaceMorph.prototype.morphsList = null;

  WorkspaceMorph.prototype.buttonClose = null;

  WorkspaceMorph.prototype.resizer = null;

  function WorkspaceMorph(target) {
    WorkspaceMorph.__super__.constructor.call(this);
    this.silentSetExtent(new Point(WorldMorph.preferencesAndSettings.handleSize * 10, WorldMorph.preferencesAndSettings.handleSize * 20 * 2 / 3));
    this.isfloatDraggable = true;
    this.border = 1;
    this.edge = 5;
    this.color = new Color(60, 60, 60);
    this.buildAndConnectChildren();
  }

  WorkspaceMorph.prototype.setTarget = function(target) {
    this.target = target;
    this.currentProperty = null;
    return this.buildAndConnectChildren();
  };

  WorkspaceMorph.prototype.buildAndConnectChildren = function() {
    var ListOfMorphs, attribs, theWordMorph;
    attribs = [];
    this.destroyAll();
    this.label = new TextMorph("Morphs List");
    this.label.fontSize = WorldMorph.preferencesAndSettings.menuFontSize;
    this.label.isBold = true;
    this.label.color = new Color(255, 255, 255);
    this.add(this.label);
    theWordMorph = "Morph";
    ListOfMorphs = (Object.keys(window)).filter(function(i) {
      return i.indexOf(theWordMorph, i.length - theWordMorph.length) !== -1;
    });
    this.morphsList = new ListMorph(ListOfMorphs, null);
    this.morphsList.hBar.alpha = 0.6;
    this.morphsList.vBar.alpha = 0.6;
    this.add(this.morphsList);
    this.buttonClose = new TriggerMorph(true, this);
    this.buttonClose.setLabel("close");
    this.buttonClose.action = "destroy";
    this.add(this.buttonClose);
    this.resizer = new HandleMorph(this, 150, 100, this.edge, this.edge);
    return this.layoutSubmorphs();
  };

  WorkspaceMorph.prototype.layoutSubmorphs = function() {
    var b, h, handleSize, r, w, x, y;
    Morph.prototype.trackChanges = false;
    handleSize = WorldMorph.preferencesAndSettings.handleSize;
    x = this.left() + this.edge;
    y = this.top() + this.edge;
    r = this.right() - this.edge;
    w = r - x;
    this.label.setPosition(new Point(x + handleSize * 2 / 3 + this.edge, y - this.edge / 2));
    this.label.setWidth(w);
    if (this.label.height() > (this.height() - 50)) {
      this.setHeight(this.label.height() + 50);
      this.changed();
    }
    y = this.label.bottom() + this.edge / 2;
    w = this.width() - this.edge;
    w -= this.edge;
    b = this.bottom() - (2 * this.edge) - handleSize;
    h = b - y;
    this.morphsList.setPosition(new Point(x, y));
    this.morphsList.setExtent(new Point(w, h));
    x = this.morphsList.left();
    y = this.morphsList.bottom() + this.edge;
    h = handleSize;
    w = this.morphsList.width() - h - this.edge;
    this.buttonClose.setPosition(new Point(x, y));
    this.buttonClose.setExtent(new Point(w, h));
    Morph.prototype.trackChanges = true;
    return this.changed();
  };

  WorkspaceMorph.prototype.setExtent = function(aPoint) {
    WorkspaceMorph.__super__.setExtent.call(this, aPoint);
    return this.layoutSubmorphs();
  };

  WorkspaceMorph.coffeeScriptSourceOfThisClass = '# WorkspaceMorph //////////////////////////////////////////////////////\n\n# just an experiment to see how a "close" button at the top left of\n# any window would look like. Unclear why I called it something\n# so important given that this looks like a temporary experiment.\n\nclass WorkspaceMorph extends BoxMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  # panes:\n  morphsList: null\n  buttonClose: null\n  resizer: null\n\n  constructor: (target) ->\n    super()\n\n    @silentSetExtent new Point(\n      WorldMorph.preferencesAndSettings.handleSize * 10,\n      WorldMorph.preferencesAndSettings.handleSize * 20 * 2 / 3)\n    @isfloatDraggable = true\n    @border = 1\n    @edge = 5\n    @color = new Color(60, 60, 60)\n    @buildAndConnectChildren()\n  \n  setTarget: (target) ->\n    @target = target\n    @currentProperty = null\n    @buildAndConnectChildren()\n  \n  buildAndConnectChildren: ->\n    attribs = []\n\n    # remove existing panes\n    @destroyAll()\n\n    # label\n    @label = new TextMorph("Morphs List")\n    @label.fontSize = WorldMorph.preferencesAndSettings.menuFontSize\n    @label.isBold = true\n    @label.color = new Color(255, 255, 255)\n    @add @label\n\n    # Check which objects end with the word Morph\n    theWordMorph = "Morph"\n    ListOfMorphs = (Object.keys(window)).filter (i) ->\n      i.indexOf(theWordMorph, i.length - theWordMorph.length) isnt -1\n    @morphsList = new ListMorph(ListOfMorphs, null)\n\n    # so far nothing happens when items are selected\n    #@morphsList.action = (selected) ->\n    #  val = myself.target[selected]\n    #  myself.currentProperty = val\n    #  if val is null\n    #    txt = "NULL"\n    #  else if isString(val)\n    #    txt = val\n    #  else\n    #    txt = val.toString()\n    #  cnts = new TextMorph(txt)\n    #  cnts.isEditable = true\n    #  cnts.enableSelecting()\n    #  cnts.setReceiver myself.target\n    #  myself.detail.setContents cnts\n\n    @morphsList.hBar.alpha = 0.6\n    @morphsList.vBar.alpha = 0.6\n    @add @morphsList\n\n    # close button\n    @buttonClose = new TriggerMorph(true, @)\n    @buttonClose.setLabel "close"\n    @buttonClose.action = "destroy"\n\n    @add @buttonClose\n\n    # resizer\n    @resizer = new HandleMorph(@, 150, 100, @edge, @edge)\n\n    # update layout\n    @layoutSubmorphs()\n  \n  layoutSubmorphs: ->\n    Morph::trackChanges = false\n\n    handleSize = WorldMorph.preferencesAndSettings.handleSize;\n\n    x = @left() + @edge\n    y = @top() + @edge\n    r = @right() - @edge\n    w = r - x\n\n    # label\n    @label.setPosition new Point(x + handleSize * 2/3 + @edge, y - @edge/2)\n    @label.setWidth w\n    if @label.height() > (@height() - 50)\n      @setHeight @label.height() + 50\n      @changed()\n      #@resizer.updateBackingStore()\n\n    # morphsList\n    y = @label.bottom() + @edge/2\n    w = @width() - @edge\n    w -= @edge\n    b = @bottom() - (2 * @edge) - handleSize\n    h = b - y\n    @morphsList.setPosition new Point(x, y)\n    @morphsList.setExtent new Point(w, h)\n\n    # close button\n    x = @morphsList.left()\n    y = @morphsList.bottom() + @edge\n    h = handleSize\n    w = @morphsList.width() - h - @edge\n    @buttonClose.setPosition new Point(x, y)\n    @buttonClose.setExtent new Point(w, h)\n    Morph::trackChanges = true\n    @changed()\n  \n  setExtent: (aPoint) ->\n    super aPoint\n    @layoutSubmorphs()';

  return WorkspaceMorph;

})(BoxMorph);

morphicVersion = 'version of 2015-04-23 21:46:53';
